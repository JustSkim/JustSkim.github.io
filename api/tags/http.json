{"name":"http","slug":"http","count":2,"postlist":[{"title":"nodejs中http相关方法","slug":"nodejs中http相关方法","date":"2021-08-31T06:25:35.662Z","updated":"2021-08-31T07:54:54.543Z","comments":true,"path":"api/articles/nodejs中http相关方法.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"nodejs中http相关方法\"><a href=\"#nodejs中http相关方法\" class=\"headerlink\" title=\"nodejs中http相关方法\"></a>nodejs中http相关方法</h1><h2 id=\"response相关\"><a href=\"#response相关\" class=\"headerlink\" title=\"response相关\"></a>response相关</h2><h3 id=\"http-response-end\"><a href=\"#http-response-end\" class=\"headerlink\" title=\"http.response.end\"></a>http.response.end</h3><p>原文链接<a href=\"https://www.jb51.net/article/58468.htm\">https://www.jb51.net/article/58468.htm</a></p>\n<blockquote>\n<p>http.response.end结束响应，告诉客户端所有消息已经发送。当所有要返回的内容发送完毕时，该函数必须被调用一次。<br>如果不调用该函数，客户端将永远处于等待状态。<br>语法：<br>response.end([data], [encoding])<br>接收参数：<br>data ： end()执行完毕后要输出的字符，如果指定了 data 的值，那就意味着在执行完 response.end() 之后，会接着执行一条 response.write(data , encoding);<br>encoding： 对应data的字符编码 </p>\n</blockquote>\n<h3 id=\"http-response-write\"><a href=\"#http-response-write\" class=\"headerlink\" title=\"http.response.write\"></a>http.response.write</h3><p>原文链接：<a href=\"https://www.jianshu.com/p/ab0889a387e6\">https://www.jianshu.com/p/ab0889a387e6</a><br>response.write(chunk, [encoding])<br>参数：chunk 是一个buffer 或 字符串，表示发送的内容encoding 如果chunk是字符串，就需要指定encoding来说明它的编码方式，默认utf-8<br>该函数用于向请求的客户端发送响应内容。在 response.end() 之前，response.write() 可以被执行多次。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.get(<span class=\"string\">&#x27;/to&#x27;</span>,<span class=\"function\">(<span class=\"params\">req,resp</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    resp.write(<span class=\"string\">&quot;JQK&quot;</span>);</span><br><span class=\"line\">    resp.end(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>后续的response.end(data)并不会覆盖之前response.write(data)的值</p>\n","text":"nodejs中http相关方法response相关http.response.end原文链接https://www.jb51.net/article/58468.htmhttp.response.end结束响应，告诉客户端所有消息已经发送。当所有要返回的内容发送完毕时，该函数必须","link":"","raw":null,"photos":[],"categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","count":11,"path":"api/categories/Programming-languages-and-projects.json"},{"name":"JavaScript","slug":"Programming-languages-and-projects/JavaScript","count":2,"path":"api/categories/Programming-languages-and-projects/JavaScript.json"},{"name":"Nodejs","slug":"Programming-languages-and-projects/JavaScript/Nodejs","count":2,"path":"api/categories/Programming-languages-and-projects/JavaScript/Nodejs.json"}],"tags":[{"name":"http","slug":"http","count":2,"path":"api/tags/http.json"},{"name":"nodejs","slug":"nodejs","count":2,"path":"api/tags/nodejs.json"}]},{"title":"new Promise构造函数详解","slug":"new-Promise构造函数详解","date":"2021-08-31T07:27:48.096Z","updated":"2021-08-31T07:49:12.413Z","comments":true,"path":"api/articles/new-Promise构造函数详解.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"new-Promise构造函数详解\"><a href=\"#new-Promise构造函数详解\" class=\"headerlink\" title=\"new Promise构造函数详解\"></a>new Promise构造函数详解</h1><p>Promise 对象是 JavaScript 的异步操作解决方案，为异步操作提供统一接口[^1]。它起到代理作用（proxy），充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口。Promise 可以让异步操作写起来，就像在写同步操作的流程（链式操作），而不必一层层地嵌套回调函数。</p>\n<p>Promise是一个对象，也是一个构造函数，在ES6中，加入了Promise，其设计思想是：所有异步任务都返回一个 Promise 实例。而每个Promise 实例又都有一个<code>then</code>方法，用来指定下一步的回调函数。<br>如果不使用Promise，我们往往要使用很多层回调的写法，下面做一个对比：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 传统写法</span></span><br><span class=\"line\">step1(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value1</span>) </span>&#123;</span><br><span class=\"line\">  step2(value1, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value2</span>) </span>&#123;</span><br><span class=\"line\">    step3(value2, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value3</span>) </span>&#123;</span><br><span class=\"line\">      step4(value3, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value4</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Promise 的写法</span></span><br><span class=\"line\">(<span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(step1))</span><br><span class=\"line\">  .then(step2)</span><br><span class=\"line\">  .then(step3)</span><br><span class=\"line\">  .then(step4);</span><br></pre></td></tr></table></figure>\n\n<p>Promise的构造函数接收一个参数，是函数，并且传入两个参数：resolve，reject，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。按照标准来讲，resolve是将Promise的状态置为fullfiled，reject是将Promise的状态置为rejected。<strong>注意，Promise对象通过自身的状态来控制异步操作！</strong></p>\n<p>根据mdn官方网站上的讲解：</p>\n<blockquote>\n<p>一个 <code>Promise</code> 对象代表一个在这个 promise 被创建出来时不一定已知的值。它让您能够把异步操作最终的成功返回值或者失败原因和相应的处理程序关联起来。 这样使得异步方法可以像同步方法那样返回值：异步方法并不会立即返回最终的值，而是会返回一个 <em>promise</em>，以便在未来某个时候把值交给使用者。<br>一个 <code>Promise</code> 必然处于以下几种状态之一：</p>\n<ul>\n<li><p><em>待定（pending）</em>: 初始状态，既没有被兑现，也没有被拒绝。</p>\n</li>\n<li><p><em>已兑现（fulfilled）</em>: 意味着操作成功完成。</p>\n</li>\n<li><p><em>已拒绝（rejected）</em>: 意味着操作失败。</p>\n</li>\n</ul>\n<p> 其中，状态fulfilled和rejected合在一起称为resolved（已定型），这三种的状态的变化途径只有两种：</p>\n<ul>\n<li><p>从“未完成”到“成功”——异步操作成功，Promise 实例传回一个值（value），状态变为fulfilled。</p>\n</li>\n<li><p>从“未完成”到“失败”——异步操作失败，Promise 实例抛出一个错误（error），状态变为rejected。</p>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>注意！一个Promise对象的状态发生一次变化，就凝固了，不会再有新的状态变化！这也是 Promise 这个名字的由来，它的英语意思是“承诺”，一旦承诺成效，就不得再改变了。这也意味着，<strong>Promise 实例的状态变化只可能发生一次</strong>。</p>\n<p>当两个途径之一发生时，我们用 promise 的 then 方法排列起来的相关处理程序就会被调用。如果 promise 在一个相应的处理程序被绑定时就已经被兑现或被拒绝了，那么这个处理程序就会被调用，因此在完成异步操作和绑定处理方法之间不会存在竞争状态。</p>\n</blockquote>\n<h2 id=\"构造一个Promise实例\"><a href=\"#构造一个Promise实例\" class=\"headerlink\" title=\"构造一个Promise实例\"></a>构造一个Promise实例</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"comment\">/* 异步操作成功 */</span>)&#123;</span><br><span class=\"line\">    resolve(value);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">/* 异步操作失败 */</span></span><br><span class=\"line\">    reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><code>resolve</code>函数的作用是，将<code>Promise</code>实例的状态从“未完成”变为“成功”（即从<code>pending</code>变为<code>fulfilled</code>），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去。<code>reject</code>函数的作用是，将<code>Promise</code>实例的状态从“未完成”变为“失败”（即从<code>pending</code>变为<code>rejected</code>），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p>[^1]: <a href=\"https://javascript.ruanyifeng.com/advanced/promise.html\">Promise 对象</a></p>\n","text":"new Promise构造函数详解Promise 对象是 JavaScript 的异步操作解决方案，为异步操作提供统一接口[^1]。它起到代理作用（proxy），充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口。Promise 可以让异步操作写起来，就像在写同步操","link":"","raw":null,"photos":[],"categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","count":11,"path":"api/categories/Programming-languages-and-projects.json"},{"name":"JavaScript","slug":"Programming-languages-and-projects/JavaScript","count":2,"path":"api/categories/Programming-languages-and-projects/JavaScript.json"},{"name":"Nodejs","slug":"Programming-languages-and-projects/JavaScript/Nodejs","count":2,"path":"api/categories/Programming-languages-and-projects/JavaScript/Nodejs.json"}],"tags":[{"name":"http","slug":"http","count":2,"path":"api/tags/http.json"},{"name":"nodejs","slug":"nodejs","count":2,"path":"api/tags/nodejs.json"}]}]}