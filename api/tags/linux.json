{"name":"linux","slug":"linux","count":2,"postlist":[{"title":"在linux系统中编写并执行C语言程序","slug":"在linux系统中编写并执行C语言程序","date":"2021-09-24T12:07:36.765Z","updated":"2021-09-24T13:05:10.491Z","comments":true,"path":"api/articles/在linux系统中编写并执行C语言程序.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"在linux系统中编写并执行C语言程序\"><a href=\"#在linux系统中编写并执行C语言程序\" class=\"headerlink\" title=\"在linux系统中编写并执行C语言程序\"></a>在linux系统中编写并执行C语言程序</h1><h2 id=\"1-按照教程使用Vmware创建虚拟机\"><a href=\"#1-按照教程使用Vmware创建虚拟机\" class=\"headerlink\" title=\"1. 按照教程使用Vmware创建虚拟机\"></a>1. 按照<a href=\"https://blog.csdn.net/weixin_44232795/article/details/104556174\">教程</a>使用Vmware创建虚拟机</h2><p>值得注意的两点是，vmware15的激活码无法适用于vmware16的虚拟机，ubuntu的iso映像文件可以在官方网站中下载，使用最新（20版本）的即可。版本名称中带有desktop字段的意味着自带图形界面系统。</p>\n<h2 id=\"2-linux系统下的C语言编译执行\"><a href=\"#2-linux系统下的C语言编译执行\" class=\"headerlink\" title=\"2. linux系统下的C语言编译执行\"></a>2. linux系统下的C语言编译执行</h2><p>我们按照教程的步骤配置编译程序环境：</p>\n<blockquote>\n<p>找到命令行窗口输入：<br>（1）、sudo apt-get install gcc<br>（2）、sudo apt-get install build-essential //编写c所用到的库<br>（3）、gedit [文件名].c //创建一个c文件，并且会自动打开，即可开始编写<br>（4）、gcc [文件名].c -o [自定义程序名] //创建可执行文件<br>（5）、./ [自定义程序名] //即可运行</p>\n</blockquote>\n<p>然后写了第一个简单的程序：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;hello world\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行，报错：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user@ubuntu:~$ <span class=\"built_in\">cd</span> Desktop</span><br><span class=\"line\"><span class=\"comment\">#因为是在桌面上直接创建的cpp程序，因此要从home/user文件夹中跳到子文件夹Desktop中</span></span><br><span class=\"line\"></span><br><span class=\"line\">user@ubuntu:~/Desktop$ ./hello.cpp</span><br><span class=\"line\">bash: ./hello.cpp: Permission denied</span><br></pre></td></tr></table></figure>\n\n<p>根据<a href=\"https://blog.csdn.net/mch2869253130/article/details/89403626\">博客</a>的讲解：</p>\n<blockquote>\n<p>出现这个问题的原因是由于权限不够。解决办法就是改变可执行文件的权限。</p>\n<p>对于单个的可执行文件使用命令：<code>chmod 777 file-name</code><br>若需要将一个目录下的所有可执行文件的权限都升级，可使用命令：<code>chmod -R 777 directory-name</code></p>\n<p>其中：<br>-R 是指级联应用到目录里的所有子目录和文件<br>777 是所有用户都拥有最高权限</p>\n</blockquote>\n<p>如果我们不对cpp文件创建可执行文件，而是直接运行cpp文件，会导致报错如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user@ubuntu:~/Desktop$ ./hello.cpp</span><br><span class=\"line\">./hello.cpp: line 2: syntax error near unexpected token `(<span class=\"string\">&#x27;</span></span><br><span class=\"line\"><span class=\"string\">./hello.cpp: line 2: `int main()&#123;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>只有执行gcc编译命令后，再执行相关可执行文件，才可正确输出：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user@ubuntu:~/Desktop$ gcc hello.cpp -o hello</span><br><span class=\"line\">user@ubuntu:~/Desktop$ ./hello</span><br><span class=\"line\">hello world</span><br></pre></td></tr></table></figure>\n\n<p>除此之外，我们还可以在ubuntu的页面上看到一个hello可执行文件：</p>\n<h2 id=\"3-GCC编译\"><a href=\"#3-GCC编译\" class=\"headerlink\" title=\"3. GCC编译\"></a>3. GCC编译</h2><p>在配置好的windows系统中，C程序执行步骤如下所示：</p>\n<blockquote>\n<ol>\n<li>打开一个文本编辑器，添加上述代码。</li>\n<li>保存文件为 <em>hello.c</em>。</li>\n<li>打开命令提示符，进入到保存文件所在的目录。</li>\n<li>键入 <em>gcc hello.c</em>，输入回车，编译代码。</li>\n<li>如果代码中没有错误，命令提示符会跳到下一行，并生成 <em>a.out</em> 可执行文件。</li>\n<li>现在，键入 <em>a.out</em> 来执行程序。</li>\n<li>您可以看到屏幕上显示 *”Hello World”*。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ gcc hello.c</span><br><span class=\"line\">$ ./a.out</span><br><span class=\"line\">Hello, World!</span><br></pre></td></tr></table></figure></blockquote>\n","text":"在linux系统中编写并执行C语言程序1. 按照教程使用Vmware创建虚拟机值得注意的两点是，vmware15的激活码无法适用于vmware16的虚拟机，ubuntu的iso映像文件可以在官方网站中下载，使用最新（20版本）的即可。版本名称中带有desktop字段的意味着自带图","link":"","raw":null,"photos":[],"categories":[{"name":"Linux","slug":"Linux","count":2,"path":"api/categories/Linux.json"}],"tags":[{"name":"虚拟机","slug":"虚拟机","count":2,"path":"api/tags/虚拟机.json"},{"name":"linux","slug":"linux","count":2,"path":"api/tags/linux.json"},{"name":"ubuntu","slug":"ubuntu","count":2,"path":"api/tags/ubuntu.json"},{"name":"c语言","slug":"c语言","count":2,"path":"api/tags/c语言.json"}]},{"title":"在linux系统创建父子进程及相关操作","slug":"在linux系统创建父子进程及相关操作","date":"2021-09-26T02:16:56.153Z","updated":"2021-09-26T08:47:08.000Z","comments":true,"path":"api/articles/在linux系统创建父子进程及相关操作.json","excerpt":"","keywords":null,"cover":"E:\\JS练习\\blog\\Myblog\\source\\images\\fork中的父子进程.jpg","content":"<h1 id=\"在linux系统创建父子进程及相关操作\"><a href=\"#在linux系统创建父子进程及相关操作\" class=\"headerlink\" title=\"在linux系统创建父子进程及相关操作\"></a>在linux系统创建父子进程及相关操作</h1><h2 id=\"fork函数\"><a href=\"#fork函数\" class=\"headerlink\" title=\"fork函数\"></a>fork函数</h2><p><code>fork</code>这一词，在英文中有两个意思：</p>\n<ul>\n<li>n. 叉(挖掘用的园艺工具); 餐叉; (道路、河流等的)分岔处; 岔路;</li>\n<li>v. 分岔出分支，走岔路中的一条。</li>\n</ul>\n<p><em>fork</em>函数是基本上只在Linux环境中会使用到的C语言函数，在使用时需要调用<code>unistd.h</code>这个头文件，我们在Linux环境下举例讲解<a href=\"https://www.jianshu.com/p/586300fdb1ce\">C语言的fork()函数</a>用法：</p>\n<blockquote>\n<p>一个进程，包括代码、数据和分配给进程的资源。fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。</p>\n<p><strong>一个进程调用fork（）函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。</strong></p>\n<p>由<strong>fork函数创建的新进程</strong>被称为<strong>子进程</strong>。fork函数<strong>被调用一次</strong>，但是<strong>返回两次</strong>。父进程返回的值是<strong>新进程的进程ID</strong>，而子进程返回的值是0。</p>\n<h4 id=\"fork函数返回值的三种情况\"><a href=\"#fork函数返回值的三种情况\" class=\"headerlink\" title=\"fork函数返回值的三种情况\"></a>fork函数返回值的三种情况</h4><ul>\n<li>返回<strong>子进程标识符，即PID</strong>给父进程（在父进程中，fork返回新创建子进程的进程ID）<ul>\n<li>因为一个进程的子进程可能有多个，并且<strong>没有一个函数可以获得一个进程的所有子进程ID</strong>。</li>\n</ul>\n</li>\n<li>返回0给子进程（在子进程中，fork返回值为0）<ul>\n<li>一个进程只会有一个父进程，所以子进程总是可以调用<strong>getpid</strong>以获得<strong>当前进程Id</strong>以及调用<strong>getppid</strong>获得<strong>父进程Id</strong>.</li>\n</ul>\n</li>\n<li>出现错误，返回负值<ul>\n<li>当前进程数已经达到系统规定的上限，这时errno的值被设置为EAGAIN</li>\n<li>系统内存不足，这时errno的值被设置为ENOMEM</li>\n</ul>\n</li>\n</ul>\n<p>创建新进程成功后，系统中出现两个基本完全相同的进程，这两个进程执行没有固定的先后顺序，哪个进程先执行要看系统的进程调度策略</p>\n</blockquote>\n<p><a href=\"https://blog.csdn.net/wangww631/article/details/78413815\">更加形象的解释</a>：</p>\n<blockquote>\n<p>“ 其实就相当于<strong>链表</strong>，进程形成了链表，<strong>父进程的fork函数返回的值指向子进程的进程id</strong>, 因为<strong>子进程没有子进程</strong>，所以其<strong>fork函数返回的值为0</strong> .</p>\n<pre><code>调用fork之后，数据、堆、栈有两份，代码仍然为一份但是这个代码段成为两个进程的共享代码段都从fork函数中返回。当父子进程有一个想要修改数据或者堆栈时，两个进程真正分裂。\n</code></pre>\n</blockquote>\n<p>注意！子进程代码是<strong>从fork处开始执行</strong>的， 为什么不是从<code>#include</code>处开始复制代码的？这是因为fork是把 <strong>进程当前的情况拷贝一份</strong> ，执行fork时，进程已经执行完了int count=0;fork只拷贝下一个要执行的代码到新的进程。</p>\n<h2 id=\"fork函数被调用一次，返回两次，详解\"><a href=\"#fork函数被调用一次，返回两次，详解\" class=\"headerlink\" title=\"fork函数被调用一次，返回两次，详解\"></a>fork函数被调用一次，返回两次，详解</h2><p>来自<a href=\"https://blog.csdn.net/jason314/article/details/5640969\">这篇博客的例子</a>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span>\t<span class=\"comment\">//引入pid_t类型的头文件</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span> </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; </span><br><span class=\"line\">\t<span class=\"keyword\">pid_t</span> fpid; <span class=\"comment\">//fpid表示fork函数返回的值</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> count=<span class=\"number\">0</span>;</span><br><span class=\"line\">\tfpid=fork(); </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (fpid &lt; <span class=\"number\">0</span>) </span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;error in fork!&quot;</span>); <span class=\"comment\">//fork函数返回的第一种情况，为负数，错误处理</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (fpid == <span class=\"number\">0</span>) &#123;\t\t<span class=\"comment\">//fork函数返回的第二种情况，在子进程中返回0</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;i am the child process, my process id is %d/n&quot;</span>,getpid()); </span><br><span class=\"line\">\t\tcount++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;\t\t\t\t\t<span class=\"comment\">//fork函数返回的第三种情况，在父进程中，fork返回新创建子进程的进程ID</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;i am the parent process, my process id is %d/n&quot;</span>,getpid());</span><br><span class=\"line\">        <span class=\"comment\">//这里因为已经在父进程中了，getpid()函数返回的是当前进程（elseif语句中进程的父进程）的进程ID</span></span><br><span class=\"line\">\t\tcount++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;统计结果是: %d/n&quot;</span>,count);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译后运行的结果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i am the child process, my process id is 5574</span><br><span class=\"line\">统计结果是: 1</span><br><span class=\"line\">i am the parent process, my process id is 5573</span><br><span class=\"line\">统计结果是: 1</span><br></pre></td></tr></table></figure>\n\n<p>借用一张图解释一下<strong>为什么同一个if else语句会执行两次，并且count的值为1而不是2</strong>：</p>\n<p><img src=\"E:\\JS练习\\blog\\Myblog\\source\\images\\fork中的父子进程.jpg\"></p>\n<p>上面的代码都是位于语句<code>fpid=fork()</code>之后，进程1的变量为<code>count=0，fpid！=0（父进程）</code>。进程2的变量为<code>count=0，fpid=0（子进程）</code>，这两个进程的变量都是独立的，存在不同的地址中，不是共用的，这点要注意。可以说，我们就是通过<code>fpid</code>来识别和操作父子进程的。<br> 如果疑惑为什么不是从<code>#include</code>处开始复制代码的，这是因为fork是把进程当前的情况拷贝一份，执行fork时，进程已经执行完了<code>int count=0;</code>，正如我们上面所说的，<strong>子进程代码</strong>是<strong>从fork处开始执行</strong>的，fork只拷贝下一个要执行的代码到新的进程。</p>\n<p>所以，其实执行的是两个if…else语句，输出的两个count也不是同一个。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;i son/pa ppid pid  fpid/n&quot;</span>);<span class=\"comment\">//打印表头</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">2</span>;i++)&#123;</span><br><span class=\"line\">       <span class=\"keyword\">pid_t</span> fpid=fork();</span><br><span class=\"line\">       <span class=\"keyword\">if</span>(fpid==<span class=\"number\">0</span>)</span><br><span class=\"line\">    \t   <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d child  %4d %4d %4d/n&quot;</span>,i,getppid(),getpid(),fpid);</span><br><span class=\"line\">       <span class=\"keyword\">else</span></span><br><span class=\"line\">    \t   <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d parent %4d %4d %4d/n&quot;</span>,i,getppid(),getpid(),fpid);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">运行结果：</span></span><br><span class=\"line\"><span class=\"comment\">    i son/pa ppid pid  fpid</span></span><br><span class=\"line\"><span class=\"comment\">    0 parent 2043 3224 3225     这里是最开始的那个父进程id3224，它的ppid2043我们不用管</span></span><br><span class=\"line\"><span class=\"comment\">    0 child  3224 3225    0\t\t子进程3225的ppid是父进程的pid</span></span><br><span class=\"line\"><span class=\"comment\">    1 parent 2043 3224 3226\t\t仍然是父进程id3224，又用fork创建了一个子进程3226</span></span><br><span class=\"line\"><span class=\"comment\">    1 parent 3224 3225 3227\t\t在这里fork返回了子进程3225创建的孙子进程3227</span></span><br><span class=\"line\"><span class=\"comment\">    1 child     1 3227    0</span></span><br><span class=\"line\"><span class=\"comment\">    1 child     1 3226    0</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>从上面，我们可以看到，每次都是先执行父进程中的语句，再执行子进程中拷贝的代码语句，正如博主所说：</p>\n<blockquote>\n<ol>\n<li>第一步：在父进程中，指令执行到for循环中，i=0，接着执行fork，fork执行完后，系统中出现两个进程，分别是p3224和p3225（后面我都用pxxxx表示进程id为xxxx的进程）。可以看到父进程p3224的父进程是p2043，子进程p3225的父进程正好是p3224。我们用一个链表来表示这个关系：<br> <code>p2043-&gt;p3224-&gt;p3225</code><br> 第一次fork后，p3224（父进程）的变量为i=0，fpid=3225（fork函数在父进程中返向子进程id）<br> p3225（子进程）的变量为i=0，fpid=0（fork函数在子进程中返回0），打印出结果：<br> 0 parent 2043 3224 3225<br> 0 child  3224 3225    0</li>\n<li>第二步：假设父进程p3224先执行，当进入下一个循环时，i=1，接着执行fork，系统中又新增一个进程p3226，对于此时的父进程，p2043-&gt;p3224（当前进程）-&gt;p3226（被创建的子进程）。<br> 对于子进程p3225，执行完第一次循环后，i=1，接着执行fork，系统中新增一个进程p3227，对于此进程，p3224-&gt;p3225（当前进程）-&gt;p3227（被创建的子进程）。从输出可以看到p3225原来是p3224的子进程，现在变成p3227的父进程。父子是相对的，这个大家应该容易理解。只要当前进程执行了fork，该进程就变成了父进程了，就打印出了parent。<br> 所以打印出结果是：<br> 1 parent 2043 3224 3226<br> 1 parent 3224 3225 3227 </li>\n<li>第三步：第二步创建了两个进程p3226，p3227，这两个进程执行完printf函数后就结束了，因为这两个进程无法进入第三次循环，无法fork，该执行return 0;了，其他进程也是如此。<br> 以下是p3226，p3227打印出的结果：<br> 1 child     1 3227    0<br> 1 child     1 3226    0</li>\n<li> 细心的读者可能注意到p3226，p3227的父进程难道不该是p3224和p3225吗，怎么会是1呢？这里得讲到进程的创建和死亡的过程，在p3224和p3225执行完第二个循环后，main函数就该退出了，也即进程该死亡了，因为它已经做完所有事情了。p3224和p3225死亡后，p3226，p3227就没有父进程了，这在操作系统是不被允许的，所以p3226，p3227的父进程就被置为p1了，p1是永远不会死亡的，至于为什么，这里先不介绍。</li>\n</ol>\n</blockquote>\n<p><img src=\"E:\\JS练习\\blog\\Myblog\\source\\images\\fork中的父子进程2.jpg\" alt=\"fork中的父子进程进阶\"></p>\n<p>最后，用博主的这段打印祖孙三代关系的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">3</span>;i++)&#123;</span><br><span class=\"line\">       <span class=\"keyword\">pid_t</span> fpid=fork();</span><br><span class=\"line\">       <span class=\"keyword\">if</span>(fpid==<span class=\"number\">0</span>)</span><br><span class=\"line\">    \t   <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;son/n&quot;</span>);</span><br><span class=\"line\">       <span class=\"keyword\">else</span></span><br><span class=\"line\">    \t   <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;father/n&quot;</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    for        i=0         1           2</span></span><br><span class=\"line\"><span class=\"comment\">              father     father     father</span></span><br><span class=\"line\"><span class=\"comment\">                                        son</span></span><br><span class=\"line\"><span class=\"comment\">                            son       father</span></span><br><span class=\"line\"><span class=\"comment\">                                        son</span></span><br><span class=\"line\"><span class=\"comment\">               son       father     father</span></span><br><span class=\"line\"><span class=\"comment\">                                        son</span></span><br><span class=\"line\"><span class=\"comment\">                            son       father</span></span><br><span class=\"line\"><span class=\"comment\">                                        son</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"pid-t类型\"><a href=\"#pid-t类型\" class=\"headerlink\" title=\"pid_t类型\"></a>pid_t类型</h2><p>pid_t类型是Linux下的<strong>进程号类型</strong>，在Linux环境编程中用于定义进程ID，需要引入头文件<code>&lt;sys/types.h&gt;</code>，否则会报错：<code>error:&#39;pid_t&#39; was not declared in this  scope</code>。</p>\n<p><a href=\"https://blog.csdn.net/shanshu12/article/details/7896331\">使用fork函数时，为什么使用pid_t而不用int</a>:</p>\n<blockquote>\n<p>pid_t是一个typedef定义类型，<br>sys/types.h中的定义:<br>typedef short       pid_t;     /* used for process ids */</p>\n<p>pid_t就是一个short类型变量，实际表示的是内核中的进程表的索引</p>\n<p>可以看到，头文件里也不过是个typedef而已.<br>使用pid_t而不使用int只是为了可移植性好一些.<br>因为在不同的平台上有可能这么定义：<br><code>typedef int pid_t</code><br>也有可能：<br><code>typedef long pid_t</code></p>\n</blockquote>\n<p>但是，在和fork函数配合使用时，由于进程很多时，fork函数返回的pid_t类型的子进程id，可能长度超过了int类型，需要用long int类型来存储，这时候就使用pid_t来存储子进程PID比较便于使用和移植。</p>\n<h2 id=\"PID-PPID-PGID与SID\"><a href=\"#PID-PPID-PGID与SID\" class=\"headerlink\" title=\"PID PPID PGID与SID\"></a>PID PPID PGID与SID</h2><p>详见<a href=\"https://blog.csdn.net/Justdoit123_/article/details/101347971\">博客</a>，在Linux中，进程都拥有以下的ID</p>\n<ul>\n<li><strong>Process ID</strong>(<strong>PID</strong>，也称之为<strong>进程标识</strong>)<br>Linux中标识进程的一个数字，它的值是不确定的，是由系统分配的（但是有一个例外，启动阶段,kernel运行的第一个进程是init，它的PID是1，是所有进程的最原始的父进程），每个进程都有唯一PID，当进程退出运行之后，PID就会回收，可能之后创建的进程会分配这个PID</li>\n<li><strong>Parent</strong> Process ID(<strong>P</strong>PID)<br>字面意思，父进程的PID</li>\n<li>Process <strong>Group</strong> ID(P<strong>G</strong>ID)<br>PGID就是进程所属的Group的Leader的PID，如果PGID=PID，那么该进程是Group Leader</li>\n<li><strong>Session</strong> ID(<strong>S</strong>ID)<br>和PGID非常相似，SID就是进程所属的Session Leader的PID，如果SID==PID，那么该进程是session leader</li>\n</ul>\n<blockquote>\n<p>Session和Group都是管理多个进程的方式，同一个Group的进程属于同一个Session，一个Session里可以包含多个Group</p>\n</blockquote>\n<p>注意，父进程也有<code>ppid</code>（爸爸的爸爸叫爷爷(～￣▽￣)～ ），<code>ppid</code>为<code>1</code>的进程被称之为<strong>僵尸进程</strong>，这是因为<code>linux</code>下有3个特殊的进程，<code>idle</code>进程(<code>PID = 0</code>), <code>init</code>进程(<code>PID = 1</code>)和<code>kthreadd(PID = 2</code>)。</p>\n<p>在<code>terminal</code>中使用默认的ps命令输出的信息值包括和当前终端会话相关的进程信息，自然看不到<code>id</code>很短的进程：</p>\n<p><img src=\"E:\\JS练习\\blog\\Myblog\\source\\images\\默认ps命令.png\" alt=\"使用ps命令\"></p>\n<p>我们可以使用命令<code>ps --help</code>获取帮助，然后使用命令<code>ps -A</code>或<code>ps -e</code>来获取全部进程（all process）<br>![查看全部进程](E:\\JS练习\\blog\\Myblog\\source\\images\\ps -A命令.png)</p>\n<h2 id=\"getpid和getppid函数\"><a href=\"#getpid和getppid函数\" class=\"headerlink\" title=\"getpid和getppid函数\"></a>getpid和getppid函数</h2><p>getpid返回当前进程标识（也就是PID），getppid返回当前进程的父进程标识，使用这两个函数需要引入头文件<code>&lt;unistd.h&gt;</code>。</p>\n<blockquote>\n<p>每个进程都有一个独特（互不相同）的进程标识符（process ID），可以通过getpid（）函数获得，还有一个记录父进程pid的变量，可以通过getppid（）函数获得变量的值。</p>\n</blockquote>\n<p>这两个函数<strong>在调用中都不能返回错误</strong>，注意，返回值的pid_t类型 能够放进 int类型中去，返回值被转为long 整型输出。</p>\n","text":"在linux系统创建父子进程及相关操作fork函数fork这一词，在英文中有两个意思：n. 叉(挖掘用的园艺工具); 餐叉; (道路、河流等的)分岔处; 岔路;v. 分岔出分支，走岔路中的一条。fork函数是基本上只在Linux环境中会使用到的C语言函数，在使用时需要调用unis","link":"","raw":null,"photos":[],"categories":[{"name":"Linux","slug":"Linux","count":2,"path":"api/categories/Linux.json"}],"tags":[{"name":"虚拟机","slug":"虚拟机","count":2,"path":"api/tags/虚拟机.json"},{"name":"linux","slug":"linux","count":2,"path":"api/tags/linux.json"},{"name":"ubuntu","slug":"ubuntu","count":2,"path":"api/tags/ubuntu.json"},{"name":"c语言","slug":"c语言","count":2,"path":"api/tags/c语言.json"},{"name":"进程","slug":"进程","count":1,"path":"api/tags/进程.json"}]}]}