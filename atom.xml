<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://justskim.github.io/atom.xml" rel="self"/>
  
  <link href="http://justskim.github.io/"/>
  <updated>2022-05-06T03:22:21.506Z</updated>
  <id>http://justskim.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux系统下的make编译和CMake</title>
    <link href="http://justskim.github.io/2022/04/29/Linux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%9A%84make%E7%BC%96%E8%AF%91%E5%92%8CCMake/"/>
    <id>http://justskim.github.io/2022/04/29/Linux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%9A%84make%E7%BC%96%E8%AF%91%E5%92%8CCMake/</id>
    <published>2022-04-29T10:14:31.675Z</published>
    <updated>2022-05-06T03:22:21.506Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>博主在读<a href="https://ieeexplore.ieee.org/document/7539326">论文”Hashedcubes: Simple, Low Memory, Real-Time Visual Exploration of Big Data”</a>的时候，在末尾找到作者的源代码公开链接<code>https://github.com/cicerolp/hashedcubes</code>，在Centos 7系统上<code>git clone</code>代码后，按照作者README.md中的教程，无法正确地部署，产生报错。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>Centos 7 系统中预装的gcc和g++版本都为较低的4.8，在编译时需要换用更高版本以上的gcc，</p><p>具体可以参见网上相关gcc版本升级的文章。</p><p>在升级之后，可以使用命令<code>gcc --version</code>来查看gcc编译器的版本。</p><p>如果在编译过程中，仍然提示<code>-c++:std=14</code>的报错，那么可能是编译时候使用的gcc-c++还是预装的4.8版本，可以在CMakeLists.txt文件的开头加上这么两句，来使用指定位置的gcc编译器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_C_COMPLIER&quot;/usr/bin/gcc&quot;)</span><br><span class="line">set(CMAKE_CXX_COMPLIER&quot;/usr/bin/g++&quot;)</span><br></pre></td></tr></table></figure><h2 id="boost的下载与安装"><a href="#boost的下载与安装" class="headerlink" title="boost的下载与安装"></a>boost的下载与安装</h2><h2 id="cmake与CMakeList-txt文件"><a href="#cmake与CMakeList-txt文件" class="headerlink" title="cmake与CMakeList.txt文件"></a>cmake与CMakeList.txt文件</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;博主在读&lt;a href=&quot;https://ieeexplore.ieee.org/document/7539326&quot;&gt;论文”Hashedcu</summary>
      
    
    
    
    <category term="Linux" scheme="http://justskim.github.io/categories/Linux/"/>
    
    
    <category term="linux" scheme="http://justskim.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Maven项目中JSP文件引用的静态资源无法加载问题</title>
    <link href="http://justskim.github.io/2022/04/13/Maven%E9%A1%B9%E7%9B%AE%E4%B8%ADJSP%E6%96%87%E4%BB%B6%E5%BC%95%E7%94%A8%E7%9A%84%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E9%97%AE%E9%A2%98/"/>
    <id>http://justskim.github.io/2022/04/13/Maven%E9%A1%B9%E7%9B%AE%E4%B8%ADJSP%E6%96%87%E4%BB%B6%E5%BC%95%E7%94%A8%E7%9A%84%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E9%97%AE%E9%A2%98/</id>
    <published>2022-04-13T15:17:24.517Z</published>
    <updated>2022-04-13T15:56:40.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>不使用框架，直接建造一个maven项目，并新建error和img等文件目录用于存放特定的jsp文件和图片。在500.jsp文件中引入一张图片，代码：<code>&lt;img src=&quot;../img/500.jpg&quot;/&gt;</code>，项目的文件结构为：</p><p><img src="/images/javaweb-jsp%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.PNG" alt="javaweb-jsp项目文件结构.PNG"></p><p>打开浏览器，在相关页面中可以看到图片未能正常显示，报错404：</p><p><img src="/images/%E6%89%BE%E4%B8%8D%E5%88%B0%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90.PNG" alt="找不到静态资源.PNG"></p><h2 id="排查问题步骤"><a href="#排查问题步骤" class="headerlink" title="排查问题步骤"></a>排查问题步骤</h2><ol><li><p>将静态资源所在的文件夹标记为资源文件；</p></li><li><p>检查target文件夹和out文件夹中是否存在相关文件，如果无则更新资源或者重新部署；</p></li><li><p>重新部署或者重新更新服务器。</p></li></ol><p>以上步骤都没有用，博主返回到软件中查看tomcat服务器设置，发现自己在<strong>tomcat服务器配置中的应用程序上下文 Application context</strong>，被默认设置为<code>http://localhost:8080/javaweb_jsp_war_exploded/</code>，因此，在导入静态资源的时候，也应当把项目路径加上，正确的写法为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/javaweb_jsp_war_exploded/img/500.jpg&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>注意我们修改了tomcat的配置，因此需要选择重启服务器来使新的配置生效。<br>如果我们想要使用原来默认的jsp文件相对路径引入静态资源写法：<code>&lt;img src=&quot;../img/500.jpg&quot;/&gt;</code>，则在tomcat中修改应用程序上下文为：<code>http://localhost:8080/</code>即可，但不推荐这种方式，特别是在同时部署多个模块的时候。<br>注意，要修改tomcat配置中 “deployment”下的“Application context”选项而不是URL项，URL项只是打开浏览器时使用的路径：<br>![tomcat服务器中的Application context](&#x2F;images&#x2F;tomcat服务器中的Application context.PNG)</p><p>我们也可以使用绝对路径的方式引入静态资源：<code>&lt;img src=&quot;$&#123;pageContext.request.contextPath&#125;/img/500.jpg&quot;/&gt;</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;不使用框架，直接建造一个maven项目，并新建error和img等文件目录用于存放特定的jsp文件和图片。在500.jsp文件中引入一张图片</summary>
      
    
    
    
    <category term="Java" scheme="http://justskim.github.io/categories/Java/"/>
    
    <category term="Maven" scheme="http://justskim.github.io/categories/Java/Maven/"/>
    
    
    <category term="java" scheme="http://justskim.github.io/tags/java/"/>
    
    <category term="tomcat" scheme="http://justskim.github.io/tags/tomcat/"/>
    
    <category term="servlet" scheme="http://justskim.github.io/tags/servlet/"/>
    
    <category term="maven" scheme="http://justskim.github.io/tags/maven/"/>
    
    <category term="IDEA" scheme="http://justskim.github.io/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>IDEA中Maven项目的打包与tomcat服务器运行</title>
    <link href="http://justskim.github.io/2022/04/12/IDEA%E4%B8%ADMaven%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%89%93%E5%8C%85%E4%B8%8Etomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E8%A1%8C/"/>
    <id>http://justskim.github.io/2022/04/12/IDEA%E4%B8%ADMaven%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%89%93%E5%8C%85%E4%B8%8Etomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E8%A1%8C/</id>
    <published>2022-04-12T11:06:52.334Z</published>
    <updated>2022-04-13T16:14:45.665Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因以及解决方案"><a href="#起因以及解决方案" class="headerlink" title="起因以及解决方案"></a>起因以及解决方案</h2><p>在学习狂神说 Java web中的servlet项目时，学到<a href="https://www.bilibili.com/video/BV12J411M7Sj?p=15">第15课 javaweb的应用</a>时，想跳转到的项目的发布路径一直显示404，页面的报错信息为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP Status 404 – Not Found</span><br><span class="line">Type Status Report</span><br><span class="line">Message 文.件[/request_war_exploded/success.jsp] 未找到</span><br><span class="line">Description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists.</span><br><span class="line">Apache Tomcat/9.0.62</span><br></pre></td></tr></table></figure><p>经过多次检查代码，并没有发现错误的地方，最后发现是模块打包的target文件夹下，并没有success.jsp文件，即使多次重启或者重新部署tomcat服务器后依然未能解决该问题：</p><p><img src="/images/%E6%89%93%E5%8C%85%E7%9A%84target%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E6%B2%A1%E6%9C%89success.jsp%E6%96%87%E4%BB%B6.PNG" alt="打包的target文件夹下没有success.jsp文件"> </p><p>手动将success.jsp文件复制粘贴到打包的request文件夹下，问题解决！</p><h2 id="maven项目打包机制与target文件夹"><a href="#maven项目打包机制与target文件夹" class="headerlink" title="maven项目打包机制与target文件夹"></a>maven项目打包机制与target文件夹</h2><p>maven项目创建完后，要打包并部署到服务器上。</p><h3 id="Java打包"><a href="#Java打包" class="headerlink" title="Java打包"></a>Java打包</h3><p>Java中两种项目打包的格式：jar 包和 war包。</p><ul><li><p>jar包，将项目看成一整个拼图，引入的每个jar包就是一个拼块，在依赖中经常使用，向项目中添加某些依赖就是下载相应的 jar 包添加到项目中。jar包中只是用java来写的项目打包来的，里面只有编译后的class和一些部署文件。</p></li><li><p>war包，在 <strong>Java web</strong>中通常都是将项目打包成<strong>war包</strong>再进行部署——这是因为war包不仅包含代码编译成的class文件，还有依赖的包、配置文件，以及包括html，jsp等等在内的资源文件。一个war包可以理解为一个web项目，里面有项目的所有东西。<br>pom.xml文件中可以规定打包的相关要求，比如<code>&lt;packaging&gt;war&lt;/packaging&gt;</code>会要求打包成war格式包。</p></li></ul><p><a href="https://blog.csdn.net/qq_41394352/article/details/119192755">maven常用打包命令</a>：</p><blockquote><ol><li><code>mvn compile</code> 编译,将Java 源程序编译成 class 字节码文件。</li><li><code>mvn test</code> 测试，并生成测试报告</li><li><code>mvn clean</code> 将以前编译得到的旧的 class 字节码文件删除</li><li><code>mvn pakage</code> 打包,动态 web工程打 war包，Java工程打 jar 包。</li><li><code>mvn install</code> 将项目生成 jar 包放在仓库中，以便别的模块调用</li><li><code>mvn clean install -Dmaven.test.skip=true</code> 打成jar包，并且抛弃测试用例打包</li><li><code>mvn clean pakage -Dmaven.test.skip=true </code>动态 web工程打 war包，Java工程打 jar 包 ，并且抛弃测试用例打包</li></ol></blockquote><p>target文件夹是用来存放maven项目构建时生成的文件和目录、jar包、war包、编译的class文件</p><h2 id="热加载和热部署"><a href="#热加载和热部署" class="headerlink" title="热加载和热部署"></a><a href="https://blog.csdn.net/Wangdiankun/article/details/105753755">热加载和热部署</a></h2><p><strong>热加载(Hot Reload)<strong>：实现方式是 Web 容器（Context组件）启动一个后台线程，定期检测类文件的变化，如果有变化，就重新加载类，即在运行时重新加载class。在这个过程中不会清空 Session，不安全，一般用在开发环境。</strong>Tomcat默认情况下不开启热加载功能</strong>，包括博主所用的tomcat 9 版本。如果需要用到热加载功能，则要在Tomcat安装路径下的 Context.xml文件中配置 reloadable 参数来开启。</p><p>**热部署(Hot Swap)**：原理类似，也由后台线程定时检测 Web 应用的变化，但会重新加载整个 Web 应用。这种方式会清空Session，比热加载更加干净、彻底，一般用在生产环境。<br>本质区别：热加载的粒度比较小，主要是针对类文件的更新，通过创建新的类加载器来实现重新加载。而热部署是针对整个 Web应用的，重新部署 Web 应用，服务器如Tomcat，会将原来的 Context 对象（包括其所关联的一切资源，比如Session）整个销毁掉，再重新创建 Context 容器对象。<br>相同的目的：在不重启 Tomcat 的情况下实现 Web 应用的更新。</p><h2 id="tomcat服务器上的重启与热加载、重新部署"><a href="#tomcat服务器上的重启与热加载、重新部署" class="headerlink" title="tomcat服务器上的重启与热加载、重新部署"></a>tomcat服务器上的重启与热加载、重新部署</h2><p><a href="https://www.jetbrains.com/help/idea/updating-applications-on-application-servers.html">IDEA的官方文档中介绍了tomcat服务器更新的四个选项区别所在</a>：</p><p><img src="/images/IDEA%E4%B8%ADtomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9B%B4%E6%96%B0%E7%9A%84%E5%9B%9B%E4%B8%AA%E9%80%89%E9%A1%B9.PNG" alt="IDEA中tomcat服务器更新的四个选项"></p><ol><li><p>更新资源 Update resources：更新所有更改的资源，例如 HTML、JSP、JavaScript、CSS 和图像；</p></li><li><p>更新类和资源 Update classes and resources：更新所有更改的资源并重新编译所有更改的 Java 类（EJB、servlet） 等；</p></li></ol><p>以上两者都是热部署——在不重启tomcat服务器的前提下，将自己的项目部署到tomcat服务器中。</p><ol start="3"><li><p>重新部署 redeploy：把当前的一个项目重新部署到Tomcat服务器上；</p></li><li><p>重启服务器 restart：在重新部署的基础上，对Tomcat的相关配置文件进行刷新。在tomcat为debug 模式下，修改当前正在用的类的定义（包括：类名，方法，方法名称，参数等等……），需要重启tomcat</p></li></ol><p>因此，如果我们项目处于开发模式（即我们在之前的博客中讲到的 war exploded部署方式）下，如果只是修改了已有的JSP文件或者其他资源文件，采用第一个选项即可（无论tomcat处于运行模式还是调试模式）；如果<strong>修改了java代码，需要更新class类文件</strong>，且<strong>tomcat处于调试模式下</strong>，那么我们**可以选择第二个选项<code>Update classes and resources</code>**，处于运行模式下的tomcat服务器无法更新java程序，只能更新已有的被修改的资源文件。</p><p>但是注意以上两个方式，只能用于更新已经被部署到tomcat服务器上的资源和类文件，无论tomcat处于运行状态还是debug状态，对于我们新建的资源&#x2F;类文件都必须重新打包部署！使用“更新类和资源”操作，虽然可以在target文件夹中看到新建的资源文件和class类，但因为没有被部署到tomcat服务器上，会报告404的http转换码。同时，上述两个操作也无法应用于删除类文件或资源的情形，在项目中删除相关文件后，必须使用重新部署的方式，才能删除target包中的对应文件。</p><p>对于我们新建的文件，又或者是处于生产模式下，就需要采用 redeploy 方式重新部署了；若我们修改了tomcat服务器的相关配置，则应选择最后一个选项将服务器重启。</p><p>在前面我们说道，web.xml文件并非每个java web工程都必须的，但web.xml文件会被用于servlet程序等一系列配置，因此如果我们<strong>更新了web.xml文件</strong>，无论tomcat处于运行还是调试模式，更新类和资源操作都无法使web.xml中修改的配置生效，<strong>必须重新部署才行</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;起因以及解决方案&quot;&gt;&lt;a href=&quot;#起因以及解决方案&quot; class=&quot;headerlink&quot; title=&quot;起因以及解决方案&quot;&gt;&lt;/a&gt;起因以及解决方案&lt;/h2&gt;&lt;p&gt;在学习狂神说 Java web中的servlet项目时，学到&lt;a href=&quot;https:/</summary>
      
    
    
    
    <category term="Java" scheme="http://justskim.github.io/categories/Java/"/>
    
    <category term="Maven" scheme="http://justskim.github.io/categories/Java/Maven/"/>
    
    
    <category term="java" scheme="http://justskim.github.io/tags/java/"/>
    
    <category term="tomcat" scheme="http://justskim.github.io/tags/tomcat/"/>
    
    <category term="servlet" scheme="http://justskim.github.io/tags/servlet/"/>
    
    <category term="maven" scheme="http://justskim.github.io/tags/maven/"/>
    
    <category term="IDEA" scheme="http://justskim.github.io/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>Python中graphviz包的安装与bug解决</title>
    <link href="http://justskim.github.io/2022/04/12/Python%E4%B8%ADgraphviz%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8Ebug%E8%A7%A3%E5%86%B3/"/>
    <id>http://justskim.github.io/2022/04/12/Python%E4%B8%ADgraphviz%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8Ebug%E8%A7%A3%E5%86%B3/</id>
    <published>2022-04-12T03:33:44.869Z</published>
    <updated>2022-04-12T07:07:14.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>按照学校课程要求，配合scikit-learn官方文档，学习机器学习的过程中，在<a href="https://scikit-learn.org/stable/modules/tree.html">决策树</a>这一章，安装graphviz模块后运行程序产生报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AttributeError: module <span class="string">&#x27;graphviz.backend&#x27;</span> has no attribute <span class="string">&#x27;ENCODING&#x27;</span></span><br></pre></td></tr></table></figure><p>Graphviz是一款自动排版的绘图软件，而python graphviz则是该软件在python的实现，graphviz模块提供了Graph和Digraph两个类，分别以DOT语言为无向图和有向图创建图描述。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>搜索该问题解决方案，相关中文博客中给出的以下两个解决方案：</p><ol><li><p>下载模块python-graphviz；</p></li><li><p>本地下载安装graphviz软件，在系统变量中配置环境变量<code>GRAPHVIZ_INSTALL_DIR</code>（路径为bin文件夹）和<code>GRAPHVIZ_DOT</code>（路径为bin文件夹下的dot.exe程序），在用户变量中也要配置<code>GRAPHVIZ_INSTALL_DIR</code>，然后重启计算机；</p></li></ol><p>但是经过以上尝试过后，该问题依旧没有解决，最后在<a href="https://stackoverflow.com/questions/69989691/how-to-resolve-attributeerror-module-graphviz-backend-has-no-attribute-encod">stackoverflow上的相关问题</a>中，发现问题的根源在于graphviz的版本，并摸索出了相关的解决方案：</p><ol><li><p>使用命令<code>conda uninstall graphviz</code>后，还要将本地环境下的两个文件夹<code>graphviz</code>和<code>graphviz-0.19.2.dist-info</code>删除，否则使用第二步的命令时会被提示已安装；</p></li><li><p>使用命令<code>pip install graphviz=0.19.2 </code>下载符合要求的包；</p></li><li><p>在程序中，加入这么两句代码，添加路径：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">&quot;PATH&quot;</span>]+=os.pathsep+<span class="string">&quot;E:/download/Graphviz/bin&quot;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;按照学校课程要求，配合scikit-learn官方文档，学习机器学习的过程中，在&lt;a href=&quot;https://sciki</summary>
      
    
    
    
    <category term="机器学习" scheme="http://justskim.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="python" scheme="http://justskim.github.io/tags/python/"/>
    
    <category term="machine learning" scheme="http://justskim.github.io/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>IDEA中maven项目无法自动导入包的问题解决</title>
    <link href="http://justskim.github.io/2022/04/09/IDEA%E4%B8%ADmaven%E9%A1%B9%E7%9B%AE%E6%97%A0%E6%B3%95%E8%87%AA%E5%8A%A8%E5%AF%BC%E5%85%A5%E5%8C%85%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>http://justskim.github.io/2022/04/09/IDEA%E4%B8%ADmaven%E9%A1%B9%E7%9B%AE%E6%97%A0%E6%B3%95%E8%87%AA%E5%8A%A8%E5%AF%BC%E5%85%A5%E5%8C%85%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</id>
    <published>2022-04-09T08:50:55.411Z</published>
    <updated>2022-04-13T11:06:09.830Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在IDEA中创建项目工程后（父工程的src文件夹可以在创建后删除），再选择“module”创建子工程，发现无法自动导入依赖，具体表现为“HttpServlet”等不是java jdk自带的包会在代码中爆红，即使在pom.xml文件中按要求添加了相关依赖，也无法解决问题。按照网上教程所说的有以下方法：</p><ol><li>在settings中设置maven相关项</li><li>点击“文件”-&gt; “清除缓存”；</li><li>点击界面最右边一侧的“maven”设置，clean后install，或者点击项目菜单中的“reimport”选项</li></ol><p>以上做法均失效（对于引入jdk自带的包，比如java.lang中的包，可以采用上边的方式让其自动引入）。</p><h2 id="排查问题"><a href="#排查问题" class="headerlink" title="排查问题"></a>排查问题</h2><p>查看父工程的外部库External libaries可以发现，其中只有jdk11自带的包，而没有出现我们需要引入的依赖包，成功引入的界面应该是长下面这样：</p><p><img src="/images/%E6%88%90%E5%8A%9F%E4%BB%8E%E5%A4%96%E9%83%A8%E5%BA%93%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96%E5%8C%85.PNG" alt="成功从外部库引入依赖包"></p><p>重新新建一个项目来探究问题所在，发现在选择骨架创建子工程后，下方maven控制台的运行中，会出现一项<code>org.apache.maven.plugins:maven-archetype-plugin:RELEASE:generate</code>一直处于加载的状态！有时候甚至加载了十分钟依然未能成功！</p><p>这是因为子项目使用骨架创建时，需要从外部联网下载，<strong>因此由于网络的缘故导致工程骨架未能完全下载</strong>，进而导致功能不全的报错。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><strong>调整一下网络</strong>就可以成功创建项目。</p><h3 id="将负责配置的xml文件下载到本地"><a href="#将负责配置的xml文件下载到本地" class="headerlink" title="将负责配置的xml文件下载到本地"></a>将负责配置的xml文件下载到本地</h3><p>如果不想每次都让IDEA去联网下载archetype-catalog.xml文件（IDEA每次新建maven项目都会下载一次这个文件），可以将其下载到本地用户的<code>.m2</code>文件夹下，在新建maven项目时使用本地文件，并在IDEA的maven runner设置中的<code>VM Options</code>一栏输入：<code>-DarchetypeCatalog=local</code></p><h3 id="改变依赖的jar包的下载地址——采用国内镜像"><a href="#改变依赖的jar包的下载地址——采用国内镜像" class="headerlink" title="改变依赖的jar包的下载地址——采用国内镜像"></a>改变依赖的jar包的下载地址——采用国内镜像</h3><p>同样，IDEA的maven项目可以设置自动添加依赖功能，当我们的仓库中没有该jar包的时候可以设置让其自动下载。但是这样添加jar包时要连接网络仓库，为了更快的下载速度，需要更改maven的仓库地址——采用国内阿里云的镜像：在IDEA安装路径下，搜素“settings.xml”（不同版本该文件位置不同），然后在“mirrors”标签中添加我们的mirror标签，如下面的代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重新创建项目，可以发现，使用镜像地址和本地文件后，下载骨架的速度很快，子模块中的文件夹和配置文件的加载也是很快就出来。同时，外部库中也自动地将maven所需的依赖如”maven:junit”引入。在父工程的pom.xml文件中设置servlet的相关依赖后，点击“maven”小图标加载maven变更，外部库中也成功地出现相关依赖jar包。</p><p>实际上，在maven的仓库配置这一块，IDEA软件是自带maven的，如果我们要使用本地计算机原有安装的不同版本的maven，只需要在设置中进行修改，然后在本地计算机的maven安装路径的xml配置文件中，同样设置镜像就可以了。</p><h2 id="Maven-父子项目的依赖继承"><a href="#Maven-父子项目的依赖继承" class="headerlink" title="Maven 父子项目的依赖继承"></a>Maven 父子项目的依赖继承</h2><p>在父项目的pom.xml文件中，在depencyManagement结构体中添加相关依赖dependencies，然后在子项目的依赖文件中，只需要添加groupId和artifactId即可，版本号在父项目的pom.xml中已经定义好了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--子项目的依赖--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet.jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果maven同步后显示子项目代码中引入相关包的报错，可以先在子项目中把version一项加上，同步一次之后再删除这一项。</p><h2 id="Tomcat对IDEA开发项目的部署"><a href="#Tomcat对IDEA开发项目的部署" class="headerlink" title="Tomcat对IDEA开发项目的部署"></a>Tomcat对IDEA开发项目的部署</h2><p><strong>工件和外部源</strong><br>工件 Artifact：Artifact 是maven中的一个概念，表示某个module要如何打包，包括一个项目将要产生的文件，可以是jar文件，源文件，二进制文件，war文件，甚至是pom文件。每个artifact都由groupId:artifactId:version组成的标识符唯一识别。需要被使用(依赖)的artifact都要放在仓库(Repository)中。一个module有了 Artifacts 就可以部署到应用服务器中了。<br>注意，当我们不使用任何框架来创建maven项目时，如果直接添加tomcat配置，会发现只有外部源，而没有工件这一个选项。我们需要右键单击项目，选择添加框架支持，并选择其中的web程序，这样，在配置中就可以看到工件并在其中选择我们的一个或者多个项目模块了。如果还是不行，<a href="https://blog.csdn.net/qq_26963495/article/details/105169789">可能问题出现在IDEA的配置问题中</a>，<a href="https://www.trinea.cn/android/maven/">更多maven概念名词可参见博客</a>。</p><p><strong>发布模式（生产环境）和开发模式（开发环境）</strong></p><p>在IDEA中配置Tomcat服务器时，需要在部署deployment中手动二选一设置：</p><ol><li>servlet-01:war</li><li>servlet-01:war exploded</li></ol><p>这里的servlet-01是web工程的模块名称，两个部署方式在区别在于：</p><ol><li><p>war模式（发布模式）：将web工程以包的形式上传到服务器；</p></li><li><p>war exploded模式（开发模式）：将web工程以当前文件夹的位置关系上传到服务器</p></li></ol><p>很显然，在我们需要不断调试程序的开发过程中，更应使用war exploded模式，这种方式也支持热部署。</p><p>使用war exploded部署方式，还需要在tomcat配置中的Server选项中进行如下改动：</p><ol><li>执行更新操作——<code>On &#39;Update&#39; action</code>项选择<code>Update resources</code>；</li><li>框架停用时——<code>On frame deactivation</code>项选择<code>Update resources</code>；</li></ol><h2 id="maven工程框架的目录-x2F-文件缺失问题"><a href="#maven工程框架的目录-x2F-文件缺失问题" class="headerlink" title="maven工程框架的目录&#x2F;文件缺失问题"></a>maven工程框架的目录&#x2F;文件缺失问题</h2><p>即使我们使用了本地文件+国内镜像的相关配置，有时候使用框架创建maven项目依然可能出现目录&#x2F;文件缺失的情况，这里以webapp文件夹为例，如果我们使用框架搭建的maven项目缺失了该文件夹：</p><ol><li>点击IDEA的第一个”File”选项，点击项目结构”Project Structure”；</li><li>修改Web资源目录和Web模块部署描述符</li></ol><p><img src="/images/%E4%BF%AE%E6%94%B9Web%E8%B5%84%E6%BA%90%E7%9B%AE%E5%BD%95%E5%92%8CWeb%E6%A8%A1%E5%9D%97%E9%83%A8%E7%BD%B2%E6%8F%8F%E8%BF%B0%E7%AC%A6.PNG" alt="修改Web资源目录和Web模块部署描述符"></p><p>如果缺失了其他的文件，我们也可以手动增加。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;在IDEA中创建项目工程后（父工程的src文件夹可以在创建后删除），再选择“module”创建子工程，发现无法自动导入依赖，</summary>
      
    
    
    
    <category term="Java" scheme="http://justskim.github.io/categories/Java/"/>
    
    
    <category term="服务器" scheme="http://justskim.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="java" scheme="http://justskim.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat服务器与Servlet程序</title>
    <link href="http://justskim.github.io/2022/04/08/Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8EServlet%E7%A8%8B%E5%BA%8F/"/>
    <id>http://justskim.github.io/2022/04/08/Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8EServlet%E7%A8%8B%E5%BA%8F/</id>
    <published>2022-04-08T09:50:37.820Z</published>
    <updated>2022-04-08T16:05:53.645Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>按照<a href="https://www.bilibili.com/video/BV12J411M7Sj">狂神的JavaWeb教程</a>，在为Maven项目配置Servlet的映射时，出现了访问地址404的问题，检查文件<code>web.xml</code>的代码，发现在路径映射这一块并没有写错</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--注册Servlet--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.kuang.servlet.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--servlet的请求路径--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="web-xml文件详解"><a href="#web-xml文件详解" class="headerlink" title="web.xml文件详解"></a>web.xml文件详解</h3><p>web.xml的模式文件是由Sun公司定义的，但不是必须的。<strong>web.xml文件是用来配置：欢迎页、servlet、filter等的。当创建的java web工程没用到这些功能时，可以不用web.xml文件来配置你的web工程。</strong>web.xml的模式(Schema)文件中定义了多少种标签元素，web.xml中就可以出现它的模式文件所定义的标签元素，它就能拥有定义出来的那些功能。</p><h3 id="web项目启动的第一步-——web-xml加载过程"><a href="#web项目启动的第一步-——web-xml加载过程" class="headerlink" title="web项目启动的第一步 ——web.xml加载过程"></a>web项目启动的第一步 ——web.xml加载过程</h3><p>启动一个WEB项目时，容器包括（JBoss、Tomcat等）首先会读取项目web.xml配置文件里的配置，当这一步骤成功完成之后，项目才正常启动。更详细的加载过程和文件作用详见<a href="https://www.cnblogs.com/linhuaming/p/9464356.html%E3%80%82">https://www.cnblogs.com/linhuaming/p/9464356.html。</a></p><h2 id="排查问题"><a href="#排查问题" class="headerlink" title="排查问题"></a>排查问题</h2><p>首先在<code>Intellj IDEA</code>界面中查看程序逻辑，并没有运行报错的地方，然后查看tomcat服务器，可以看到Web应用被正常部署并启动：</p><p><img src="/images/tomcat10%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E8%A1%8C%E4%BF%A1%E6%81%AF.PNG" alt="tomcat10中的服务器运行信息"></p><p>在我们设置的 项目部署地址<code>http://localhost:8080/kuang</code>中，可以成功看到<code>hello wordl</code>的返回页面。但是在<code>web.xml</code>文件中<code>Servlet</code>的映射路径<code>http://localhost:8080/kuang/hello</code>中，我们<strong>第一次刷新到此页面</strong>时，可以看得到HTTP状态码500的报错页面：</p><p><img src="/images/%E7%8A%B6%E6%80%81%E7%A0%81500.PNG" alt="状态码500"></p><p>如果再次刷新或者选择其他前缀相同的地址输入，则返回的只是404页面：</p><p><img src="/images/%E7%8A%B6%E6%80%81%E7%A0%81404.PNG" alt="状态码404.PNG"></p><h2 id="排查问题-1"><a href="#排查问题-1" class="headerlink" title="排查问题"></a>排查问题</h2><p>注意我们一开报错的状态码500界面，里面提示<code>jakarta.servlet.ServletException:实例化[com.kuang.servlet.HelloServlet]异常</code>，后面的类是我们自己编写的程序，那么前面的<code>jakarta.servlet</code>包又是怎么回事呢？</p><h3 id="Tomcat与Servlet的关系"><a href="#Tomcat与Servlet的关系" class="headerlink" title="Tomcat与Servlet的关系"></a>Tomcat与Servlet的关系</h3><p>Tomcat是Web应用服务器Server，也是一个Servlet&#x2F;JSP容器，处理Client发来的请求，将请求传递给Servlet，并将Servlet的响应Response传递给Client。</p><p>Servlet 是Java编写的服务端程序，<strong>与协议、平台均无关</strong>，可以动态地扩展Server的能力，像上边说的用请求-响应模式提供Web服务。<strong>编写一个Servlet</strong>，<strong>实际就是按照Servlet规范编写一个Java类</strong>。由于Servlet没有main方法，不能独立运行，因此其必须被部署到Servlet容器中，由容器来实例化并调用Servlet的方法（例如doGet()和doPost()）。</p><p><strong>Servlet容器又称为Servlet引擎</strong>，在Servlet的生命周期内包容和管理Servlet——JSP技术推出后，管理和运行Servlet&#x2F;JSP的容器也称作Web容器。Tomcat就是一个免费开源的Servlet容器。</p><h3 id="Tomcat-10的版本问题"><a href="#Tomcat-10的版本问题" class="headerlink" title="Tomcat 10的版本问题"></a>Tomcat 10的版本问题</h3><p>在IDEA的服务界面中，打开<strong>Tomcat Localhost log</strong>可以看到这么一句报错信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.apache.catalina.core.StandardWrapperValve.invoke 分配异常的servlet [hello]</span><br><span class="line">java.lang.ClassNotFoundException: javax.servlet.http.HttpServlet</span><br></pre></td></tr></table></figure><p>经过查询，发现问题的原因在于<a href="https://blog.csdn.net/qq_55069056/article/details/118105044">Tomcat 10中Servlet无法正常使用</a>，教学视频中演示所用的是tomcat 9，出在了服务器版本问题：</p><blockquote><p>在<code>Tomcat 10</code>中把包名从以往版本的<code>javax</code>改成了<code>jakarta</code>，而<code>maven</code>导包的时候依旧使用原来的<code>javax</code>，导致<code>Tomcat 10</code>服务器的<code>Servlet</code>接口和我写的<code>servlet</code>文件不匹配，从而无法正常运行。</p></blockquote><p>截止至2022年，tomcat 10是最新的版本，这里要提醒踩坑，因为(<strong>Jakarta EE</strong>)[<a href="https://www.cnblogs.com/amon2021/p/15622511.html]%E7%9A%84%E7%BC%98%E6%95%85%E3%80%82%E5%9C%A8Tomcat10.0%E7%89%88%E6%9C%AC%E4%B8%AD%EF%BC%8C%E9%87%8C%E9%9D%A2%E7%9A%84javax.servlet%E4%B8%AD%E7%9A%84%E5%8C%85%E5%90%8D%E5%B7%B2%E7%BB%8F%E6%94%B9%E4%B8%BAjakarta.servlet%E6%9C%80%E5%A5%BD%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E6%9C%80%E6%96%B0%E7%89%88%E7%9A%84tomcat">https://www.cnblogs.com/amon2021/p/15622511.html]的缘故。在Tomcat10.0版本中，里面的javax.servlet中的包名已经改为jakarta.servlet最好不要使用最新版的tomcat</a> 10。对于一切 Java EE，无论是哪个JDK版本，只推荐使用tomcat 9。</p><p>换用tomcat 9之后，重新配置，成功启动！</p><p>这里注意<a href="https://tomcat.apache.org/download-90.cgi">tomcat 9的安装</a>尽可能选择安装版而非压缩包，可以省去环境变量手动配置的麻烦——可能start.bat文件打开后会闪退，但不影响在电脑中的运行。</p><h3 id="端口号8080被占用导致无法启动tomcat服务器"><a href="#端口号8080被占用导致无法启动tomcat服务器" class="headerlink" title="端口号8080被占用导致无法启动tomcat服务器"></a>端口号8080被占用导致无法启动tomcat服务器</h3><p>使用命令 <code>netstat -ano|findstr 端口号</code> 查看占用端口号8080的进程，最右边一列为进程PID，使用命令<code>taskkill /T /F /PID 进程pid</code>终止进程，如果无法终止则在IDEA中改用其他端口。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;按照&lt;a href=&quot;https://www.bilibili.com/video/BV12J411M7Sj&quot;&gt;狂神的JavaWeb教程&lt;/</summary>
      
    
    
    
    <category term="Java" scheme="http://justskim.github.io/categories/Java/"/>
    
    <category term="Servlet" scheme="http://justskim.github.io/categories/Java/Servlet/"/>
    
    
    <category term="java" scheme="http://justskim.github.io/tags/java/"/>
    
    <category term="tomcat" scheme="http://justskim.github.io/tags/tomcat/"/>
    
    <category term="servlet" scheme="http://justskim.github.io/tags/servlet/"/>
    
  </entry>
  
  <entry>
    <title>计算机的各类期刊分级与介绍</title>
    <link href="http://justskim.github.io/2022/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%90%84%E7%B1%BB%E6%9C%9F%E5%88%8A%E5%88%86%E7%BA%A7%E4%B8%8E%E4%BB%8B%E7%BB%8D/"/>
    <id>http://justskim.github.io/2022/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%90%84%E7%B1%BB%E6%9C%9F%E5%88%8A%E5%88%86%E7%BA%A7%E4%B8%8E%E4%BB%8B%E7%BB%8D/</id>
    <published>2022-03-31T10:34:55.244Z</published>
    <updated>2022-05-07T13:25:05.394Z</updated>
    
    <content type="html"><![CDATA[<h2 id="会议论文和期刊论文"><a href="#会议论文和期刊论文" class="headerlink" title="会议论文和期刊论文"></a>会议论文和期刊论文</h2><p>会议论文和期刊论文是两种主要的论文形式：</p><ul><li>会议论文：针对某个学术会议投稿，由学术会议的会务组决定是否录用；</li><li>期刊论文：针对某学术期刊投稿，由期刊编辑部决定是否录用，审稿专家只负责审稿并返回意见，真正决定录用权在期刊编辑手上。</li></ul><p>二者的不同还有以下几点：</p><ol><li>审稿周期上：会议论文一般都比较短，在2周左右，甚至快的只需1周；期刊论文相对慢，国内中文核心期刊一般2个月，普刊在1到3周左右，部分水刊录用速度很快。</li><li>权威性上：会议论文现在很多都比较水，期刊的话也有水刊，这些都难以被单位认可。有论文集出版的会议论文，在国内的认可度相对较好。<a href="https://zhuanlan.zhihu.com/p/49521821">要学会如何判断EI会议权威性</a>。</li></ol><p>尚未被会议论文集出版的会议论文可以发期刊（出版了就有版权），但是需要在会议论文的基础上进行再次加工——这是因为<strong>会议论文基本上没有完成</strong>，在会议上发表论文的用意是为了让其他人知道自己的研究并取得反馈。扩充的比例依期刊审稿严格程度而定，多数要求扩充30%以上。</p><h2 id="A类、B类、C类期刊"><a href="#A类、B类、C类期刊" class="headerlink" title="A类、B类、C类期刊"></a>A类、B类、C类期刊</h2><p>A、B、C类期刊是<strong>科研单位自主对学术期刊的简单认定，标准由单位自定</strong>。A类最好，B类其次，C类刊物有时会称之为C刊（注意，和人文社科期刊中的C刊——CSSCI期刊要划分开来，同名不同意）。以上三类在一些单位也会被分为一二三类期刊。D刊较为少见，一些有刊号非核心的期刊会被称为省级期刊，不会被科研单位算入成绩。<br>计算机领域通常的A、B、C类期刊，是CCF（中国计算机学会）推荐的高水平期刊，也就是CCF 1，CCF B，CCF C——CCF A非常难，一篇足以博士毕业了——其划分可参考<a href="https://blog.csdn.net/ztf312/article/details/102918185">该文章</a>。</p><h2 id="SCI，SSCI，EI"><a href="#SCI，SSCI，EI" class="headerlink" title="SCI，SSCI，EI"></a>SCI，SSCI，EI</h2><p>国际三大科技文献检索分别是 SCI（科学引文索引）、EI（工程索引）和ISTP（科技会议录索引）。</p><h3 id="SCI"><a href="#SCI" class="headerlink" title="SCI"></a>SCI</h3><p>SCI即《科学引文索引》（Science Citation Index），从来源期刊数量分为：</p><ul><li>SCI：来源期刊为3500多种的SCI印刷版和SCI光盘版（SCI Compact Disc Edition，简称SCI CDE）</li><li>SCI-E：即SCI Expanded，是SCI的扩展库，收录更多，接近6000种来源期刊，可通过联网进行检索。</li></ul><h3 id="SSCI"><a href="#SSCI" class="headerlink" title="SSCI"></a>SSCI</h3><p>SSCI即社会科学引文索引（Social Sciences Citation Index），收录社会科学类期刊。</p><h3 id="CSSCI"><a href="#CSSCI" class="headerlink" title="CSSCI"></a>CSSCI</h3><p>CSSCI是南京大学的“中文社会科学引文索引”，也被称为C刊（注意和C类刊物分开），又称为南大核心。工科学生了解这个名词就行。</p><h3 id="EI"><a href="#EI" class="headerlink" title="EI"></a>EI</h3><p>EI 即《工程索引》（The Engineering Index）。国内的EI期刊有自动化学报、软件学报、通信学报、计算机辅助设计与图形学学报等，EI检索到的通常是这些刊物的英文版。<strong>EI期刊的发表要求和学术价值都高于EI会议</strong>。</p><h3 id="能被上述索引检索到的中文期刊"><a href="#能被上述索引检索到的中文期刊" class="headerlink" title="能被上述索引检索到的中文期刊"></a>能被上述索引检索到的中文期刊</h3><p>能够被以上这些国际学术检索系统检索到的中文刊物，其发表难度要求与其他英文期刊也是一视同仁的！由于中文稿投稿SCI也要翻译成英文，因此有些作者一开始就用英文写作可以提高效率。<br>国内的EI期刊：自动化学报、软件学报、通信学报、计算机辅助设计与图形学学报等。<br>中文SCI期刊：</p><h2 id="一区，二区"><a href="#一区，二区" class="headerlink" title="一区，二区"></a>一区，二区</h2><p>一区、二区等指中科院对SCI的分区（不同地方可能有所不同，但大部分常用中科院的标准），按照各类期刊影响因子划分，前5%为该类一区，前6%<del>20%为二区，21%</del>50%为三区，其余为四区，越靠前自然质量越高。</p><h3 id="CCF-ABC与SCI的分区关系"><a href="#CCF-ABC与SCI的分区关系" class="headerlink" title="CCF ABC与SCI的分区关系"></a>CCF ABC与SCI的分区关系</h3><p><strong>二者之间没有必然练习，CCF是计算机行业权威人士排行，因此计算机学科比较注重CCF的分类</strong>。</p><h2 id="可视化方向的期刊"><a href="#可视化方向的期刊" class="headerlink" title="可视化方向的期刊"></a>可视化方向的期刊</h2><p>IEEE Transactions on Visualization and Computer Graphics，可视化领域最权威的期刊</p><p>谷歌学术中搜索：<code>visualization source:(&quot;IEEE Transactions source:on source:Visualization source:and source:Computer source:Graphics&quot;)</code></p><p><code>source:</code>前面的是要搜索的关键字</p><p>注意！不能搜<code>hadoop source:(&quot;IEEE Transactions Visualization and Computer Graphics&quot;)</code>，会得到错误或者空白的结果。</p><p>VIS顶会——全称 IEEE Visualization and Visual Analytics</p><p>注意，上面两个名词，一个是期刊，一个是会议，有<a href="https://zhuanlan.zhihu.com/p/259298679?utm_source=wechat_session">厉害的文章</a>可以两个都进。</p><p>info和vast都是年会的重要组成部分，收录的文章相似，但还是有些区别。具体细节可参考VIS会议的官方网站: InfoVis和VAST。<br><a href="https://www.jianshu.com/p/a6aebce572bd?t=123">具体的二者差别</a>：<br>VAST(IEEE Visual Analytics Science and Technology)—— IEEE <strong>视觉分析</strong>科学与技术会议 ( VAST 2017) 是领先的国际会议，致力于 视觉分析的进步。 会议范围，同地 在 VIS 与年度 IEEE 科学可视化会议和 IEEE 信息可视化会议，包括 可视化分析中的基础研究贡献以及 视觉分析在科学、工程、医学中的应用， 健康、媒体、商业、社交互动、安全和 调查分析等学科。<br>INFO(IEEE Information Visualization)——IEEE <strong>信息可视化</strong> (InfoVis) 原创研究论文。 论文可能会贡献新的或改进的视觉编码或交互技术； 评估技术和工具； 与可视化相关的模型或理论； 支持可视化数据分析的系统； 以及将可视化应用于广泛的现实世界环境和领域。 </p><p><a href="http://chinavis.org/2022/index.html">ChinaVis</a>——中国可视化与可视分析大会，宗旨是促进中国及周边地区的可视化与可视分析研究与应用的交流，探讨在大数据时代可视化与可视分析发展的方向与机遇，每年均有论文征稿，可见<a href="http://chinavis.org/2022/callforpaper.html">官网详细征稿信息</a>。2022年大会录取的英文研究论文将发表到 SCI期刊《Journal of Visualization》，中文论文将发表到CCF中文A类期刊《计算机辅助设计与图形学学报》。大会录取的英文综述论文将在SCI期刊《Visual Informatics》上发表，中文综述论文将在CCF中文A类期刊《计算机辅助设计与图形学学报》上发表。该会议每年还会举办<a href="http://chinavis.org/2021/challenge.html">数据可视化竞赛</a> 。            </p><p><a href="https://blog.csdn.net/amych_/article/details/108616961">如何使用IEEE搜索指定期刊&#x2F;会议</a>？</p><p>在2022年的新版页面设计中，”calls a paper”这个选项要到页面底部去查找，我们点击该选项后，可以在<a href="https://publication-recommender.ieee.org/home">“Search for upcoming call for paper deadlines in your field of interest”</a>中选择会议（Conferences）或者期刊（Periodicals），中间白色输入框内输入检索关键字，然后点击“Get Recommendation”。</p><p>如果我们搜的是期刊“IEEE Transactions Visualization and Computer Graphics”（注意，呈现的结果是“Visualization and Computer Graphics, IEEE Transactions on”），点击进入页面中，可以看到IEEE TVCG 的影响因子（Impact factor）为4.579，相当高了。页面中会提示期刊主页(IEEE Periodical home page)——<a href="https://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=2945">IEEE Transactions on Visualization and Computer Graphics</a>，但是在”current issue”中可以采用左边的搜索框只能搜索到该年的文献，在”all issue”中则无法进行检索。</p><p><strong>IEEE检索某个期刊下全部符合条件的文章</strong></p><p>在搜索框中输入关键词后，在左侧过滤选项的“<strong>Publication Title</strong>”中选择期刊，我们可以看到最顶上的就是TVCG。</p><p>如果我们搜的是会议“IEEE Visualization and Visual Analytics”，会发现会议是没有影响因子的，就如我们之前说的，<strong>会议论文往往尚未完成</strong>。在导向的网站中没有可以看论文的地方，详见如下：</p><p><a href="https://blog.csdn.net/Strive_For_Future/article/details/118361928">如何使用谷歌学术搜索指定期刊</a>？在谷歌学术中找不到VIS的论文——因为大部分论文完成后，都会被推荐到期刊发表（比如顶级的TVCG）。</p><p><strong>检索综述某个类型的文献</strong></p><p>以知识图谱的综述为例，在<a href="http://www.scopus.com中搜索&quot;knowledge/">www.scopus.com中搜索&quot;Knowledge</a> Graph”后，可以在左侧栏目中，找到文献类型一栏，点击其中的“review”，限制范围后得到关于知识图谱的综述类论文。</p><p>或者在搜索中添加相关字段，如“overview”“survey”“review”</p><p><img src="/images/%E6%9F%A5%E6%89%BE%E7%BB%BC%E8%BF%B0%E7%B1%BB%E8%AE%BA%E6%96%87.png" alt="查找综述类论文.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;会议论文和期刊论文&quot;&gt;&lt;a href=&quot;#会议论文和期刊论文&quot; class=&quot;headerlink&quot; title=&quot;会议论文和期刊论文&quot;&gt;&lt;/a&gt;会议论文和期刊论文&lt;/h2&gt;&lt;p&gt;会议论文和期刊论文是两种主要的论文形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;会议论文：针对某</summary>
      
    
    
    
    <category term="Diary" scheme="http://justskim.github.io/categories/Diary/"/>
    
    
    <category term="life" scheme="http://justskim.github.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Java Reflection反射机制</title>
    <link href="http://justskim.github.io/2022/03/30/Java-Reflection%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>http://justskim.github.io/2022/03/30/Java-Reflection%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</id>
    <published>2022-03-30T10:20:57.484Z</published>
    <updated>2022-03-30T15:11:17.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>Java 反射机制</strong>可以让我们在编译期（Compile Time）之外的运行期（Runtime）获得任何一个类的字节码。 包括接口、变量、方法等信息。</p><p>编译期：把源码交给编译器编译成计算机可以执行的文件的过程。在 Java 中也就是把 Java 代码编成 class 文件的过程。编译期只是做了一些翻译功能，并没有把代码放在内存中运行起来，而只是把代码当成文本进行操作，比如检查错误；</p><p>运行期：把编译后的文件交给计算机执行，直到程序运行结束。运行期中会把在磁盘中的代码放到内存中执行起来。</p><h3 id="使用背景"><a href="#使用背景" class="headerlink" title="使用背景"></a>使用背景</h3><p><a href="https://blog.csdn.net/weixin_42041027/article/details/101451331">为什么需要Java反射</a>？我们先看一下Java的内存模型</p><p><img src="/images/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="Java内存模型"></p><p><strong>class对象</strong>：不是new出来的对象o，而是<strong>类的类型对象，每个类只有一个class对象，作为方法区类的数据结构的接口</strong>。<a href="https://so.csdn.net/so/search?q=jvm&spm=1001.2101.3001.7020"><code>jvm</code></a>创建对象前，会先检查类是否加载，寻找类对应的class对象，若加载好，则为你的对象分配内存，初始化也就是代码:new Object()。</p><p><strong>方法区</strong>存的是类的信息，不是存类对象的。</p><p><strong>类加载器</strong>加载类是通过方法区上类的信息在堆上创建一个类的Class对象，这个Class对象是唯一的，由<code>JVM</code>保证唯一，之后对这个类的创建都是根据这个Class对象来操作的</p><p>程序对象是自己new的，程序相当于写死了给jvm去跑。假如一个服务器上突然遇到某个请求要用到某个类但没加载进<code>jvm</code>，还要停下来自己写段代码，new一下，重新启动一下服务器</p><p>因此需要使用到反射：当我们的程序在运行时，需要动态的加载一些类，这些类可能之前用不到所以不用加载到<code>jvm</code>，而是在运行时根据需要才加载，这样的好处对于服务器来说不言而喻。</p><blockquote><p>动态语言（弱类型语言）：在运行时可以改变数据类型，变量在使用之前无需声明类型，通常变量的值是被赋值的那个值的类型。包括：PHP，JavaScript，Python。</p><p>静态语言（强类型语言）：编译时变量的数据类型即可确定，其中大多数会要求在使用变量之前声明其数据类型，包括：C&#x2F;C++，Java。</p></blockquote><p>尽管Java是静态语言，但反射机制的存在使Java被称为“准动态语言”，可以利用反射机制获得类似动态语言的特性。反射机制允许程序在运行期借助于 <strong>Reflection API</strong> 取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。<br>加载完类之后，在堆内存的方法区中产生一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。<strong>这个对象就像一面镜子一样，我们可以通过这个对象看到类的结构，因此，称之为：反射</strong>。<br>正常方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[引入需要的包类名称] --&gt; B[通过new实例化]</span><br><span class="line">B--&gt;C[取得实例化对象]</span><br></pre></td></tr></table></figure><p>反射方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[实例化对象] --&gt;B[&quot;getClass()&quot;方法]</span><br><span class="line">B--&gt;C[得到完整的包类名称]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Java 反射机制&lt;/strong&gt;可以让我们在编译期（Compile Time）之外的运行期（Runtime）获得任何一个</summary>
      
    
    
    
    <category term="Java" scheme="http://justskim.github.io/categories/Java/"/>
    
    
    <category term="java" scheme="http://justskim.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>LaTex,mikTex与word中auora插入</title>
    <link href="http://justskim.github.io/2022/03/27/LaTex,mikTex%E4%B8%8Eword%E4%B8%ADauora%E6%8F%92%E5%85%A5/"/>
    <id>http://justskim.github.io/2022/03/27/LaTex,mikTex%E4%B8%8Eword%E4%B8%ADauora%E6%8F%92%E5%85%A5/</id>
    <published>2022-03-27T02:48:02.292Z</published>
    <updated>2022-03-27T02:48:02.296Z</updated>
    
    <content type="html"><![CDATA[<p>latex和tex及相关软件都是<strong>跨平台、免费、开源</strong>的。LaTeX是基于TeX的一组宏集，相当于对TeX进行了一次封装。我相信使用LaTeX的用户一定对编程语言有一定了解，可以对某些功能进行封装，屏蔽一些细节，LaTeX是在TeX基础上，规范化出了一种格式，一种编写风格。</p><p><a href="https://blog.csdn.net/jucksu/article/details/116307244">在word中插入算法伪代码需要安装miktex和aurora</a>。注意路径<code>\miktex\bin\x64</code>下有<code>mitkex-console.exe</code>的控制台启动文件。</p><p>在windows系统中编写latex文件有多种方式，基于我们上边已经安装了mikTex，可以选择<a href="https://www.jianshu.com/p/5d59f2929d06">下载并安装texStudio工具</a>来作为latex文件的编辑器。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;latex和tex及相关软件都是&lt;strong&gt;跨平台、免费、开源&lt;/strong&gt;的。LaTeX是基于TeX的一组宏集，相当于对TeX进行了一次封装。我相信使用LaTeX的用户一定对编程语言有一定了解，可以对某些功能进行封装，屏蔽一些细节，LaTeX是在TeX基础上，规范</summary>
      
    
    
    
    <category term="Latex" scheme="http://justskim.github.io/categories/Latex/"/>
    
    
    <category term="latex" scheme="http://justskim.github.io/tags/latex/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程编程</title>
    <link href="http://justskim.github.io/2022/03/26/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    <id>http://justskim.github.io/2022/03/26/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</id>
    <published>2022-03-26T08:42:38.194Z</published>
    <updated>2022-03-30T10:03:10.437Z</updated>
    
    <content type="html"><![CDATA[<p>jdk11API中文文档中对java.lang.Thread类的介绍：</p><blockquote><ul><li><p><a href="Object.html">java.lang.Object</a> </p></li><li><ul><li>java.lang.Thread</li></ul></li><li><ul><li><p>实现的所有接口 </p><p><code>Runnable</code> </p></li><li><p>已知直接子类： </p><p><code>ForkJoinWorkerThread</code></p></li></ul><p> public class Thread</p></li></ul><p>extends Object<br>implements Runnable线程是程序中执行的线程。 Java虚拟机允许应用程序同时运行多个执行线程。     </p></blockquote><p>操作系统中，我们了解到当CPU的核数&lt;当前任务运行数量的时候，多任务的执行其实是轮流交替的。一个任务&#x3D;一个进程，而进程内至少有一个线程，即子任务。<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1304521607217185">多线程模型是Java程序最基本的并发模型，数据库处理和Web操作等都要依赖它</a>：</p><blockquote><p>Java语言内置了多线程支持：一个Java程序实际上是一个JVM进程，JVM进程用一个主线程来执行<code>main()</code>方法，在<code>main()</code>方法内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。</p><p>进程和线程是包含关系，但是多任务既可以由多进程实现，也可以由单进程内的多线程实现，还可以混合多进程＋多线程。</p><p>具体采用哪种方式，要考虑到进程和线程的特点。</p><p>和多线程相比，多进程的缺点在于：</p><ul><li>创建进程比创建线程开销大，尤其是在Windows系统上；</li><li>进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。</li></ul><p>而多进程的优点在于：</p><p>多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。</p></blockquote><p>我们创建一个程序来新建一个线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"><span class="comment">//可以重写父类的run()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;System.out.println(<span class="string">&quot;run()方法中执行&quot;</span>+i);&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String []args)</span>&#123;</span><br><span class="line">        <span class="type">TestThread1</span> <span class="variable">testThread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestThread1</span>();</span><br><span class="line">        <span class="comment">//建一个新线程非常容易，我们需要实例化一个Thread实例，然后调用它的start()方法，start()方法会在内部自动调用实例的run()方法</span></span><br><span class="line">        testThread1.start();</span><br><span class="line">        <span class="comment">//start()方法被调用时，JVM就创建了一个新线程，线程开启不一定立即执行，由CPU调度执行，所以我们可以看到控制台交替打印“run()...”“main()...”</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        testThread1.run();</span></span><br><span class="line"><span class="comment">        注意，如果我们把上面的start语句注释掉，直接调用run方法，相当于调用了一个普通的Java方法，当前线程并没有任何改变，也不会启动新线程。</span></span><br><span class="line"><span class="comment">        必须调用Thread实例的start()方法才能启动新线程，如果我们查看Thread类的源代码，会看到start()方法内部调用了一个private native void start0()方法，</span></span><br><span class="line"><span class="comment">        native修饰符表示这个方法是由JVM虚拟机内部的C代码实现的，不是由Java代码实现的。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">222</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main()方法中执行&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用<code>Thread.setPriority(int n)</code>来设置<strong>线程</strong>优先级，但注意！优先级高的线程被操作系统调度的优先级较高，操作系统对高优先级线程可能调度更频繁，但我们决不能通过设置优先级来确保高优先级的线程一定会先执行。</p><p>注意，Java用一个<code>Thread</code>对象表示一个线程，通过调用<code>start()</code>启动一个新线程，像进程的创建状态一样一个线程对象只能调用一次<code>start()</code>方法。无论采用何种方法创建线程，都要将线程的执行代码写在重写的<code>run()</code>方法中：</p><blockquote><p>如果此线程是使用单独的<code>Runnable</code>运行对象构造的，则调用该<code>Runnable</code>对象的<code>run</code>方法;  否则，此方法不执行任何操作并返回。</p><p>这很好理解，创建线程必然是要赋予其功能的，采用Thread类创建的线程默认没有任务功能，自然不进行任何操作，相当于无效占用资源。</p></blockquote><p>线程调度由操作系统决定，程序本身无法决定调度顺序；</p><p><code>Thread.sleep()</code>可以把当前线程暂停一段时间。</p><p>使用<code>getState()</code>可以返回线程的状态，返回值是一个<code>java.lang.Thread.State </code>的枚举类型（注意<strong>java.lang.Enum</strong> 类是所有<strong>Java</strong>语言枚举类型的公共基类）</p><p>线程的各种状态变化如下图：</p><p><img src="/images/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%84%E7%A7%8D%E7%8A%B6%E6%80%81.jpg" alt="线程的各种状态"></p><p>这里注意一下<a href="https://blog.csdn.net/muzhixi/article/details/105197446">WAITING、TIMED_WAITING与BLOCKED的区别</a>：</p><blockquote><ul><li>WAITING：进入等待状态，方式：wait&#x2F;join&#x2F;park方法进入无限等待，通过notify&#x2F;notifyAll&#x2F;unpark唤醒；</li><li>TIMED_WAITING：与WAITING类似，方式：a. 给定等待时间的wait&#x2F;join&#x2F;park方法；b. sleep方法；</li><li>BLOCKED：被动进入等待状态，方式：进入Synchronized块。</li></ul></blockquote><h3 id="进程的结束"><a href="#进程的结束" class="headerlink" title="进程的结束"></a>进程的结束</h3><p>Java程序入口就是由JVM启动<code>main</code>线程，<code>main</code>线程又可以启动其他线程。当所有线程都运行结束时，JVM退出，进程结束。</p><p>如果有一个线程没有退出，JVM进程就不会退出。所以，必须保证所有线程都能及时结束。</p><p>但是这样引发一个问题，比如有一些线程是定时执行或者随时都在执行的，不结束就无法结束<code>JVM</code>进程，同时也没有专门的线程用来负责结束这一类线程。这时候就要使用<strong>守护线程（Daemon Thread）</strong>——为其他线程服务的线程。在<code>JVM</code>中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。创建守护线程，只需在<code>start()</code>函数前调用<code>setDaemon(true)</code>把该线程标记为守护线程即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure><h3 id="使用接口创建线程"><a href="#使用接口创建线程" class="headerlink" title="使用接口创建线程"></a>使用接口创建线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;<span class="comment">//线程的主体类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;System.out.println(<span class="string">&quot;start new thread!&quot;</span>);&#125;</span><br><span class="line">    <span class="comment">//线程的主体方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在文章开头我们给出了<code>jdk11</code>文档中<code>Thread</code>类的说明，反应到代码中就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>可知，继承Thread类时覆写的还是Runnable接口的run()方法。</p><p>如果一个类<strong>继承Thread，则不适合资源共享</strong>（注意并不是不能，当以Thread方式去实现资源共享时，实际上源码内部是将thread向下转型为了Runnable，实际上内部依然是以Runnable形式去实现的资源共享），但若实现了Runable接口的话，则很容易的实现资源共享。</p><ul><li>继承Thread类：<ul><li>子类继承Thread类具备多线程能力</li><li>启动线程：子类对象.start()</li><li>不建议使用：避免OOP单继承局限性</li></ul></li><li>实现Runnable接口：<ul><li>实现Runnable接口具有多线程能力</li><li>启动线程：传入目标对象+Thread对象.start()</li><li>推荐使用：避免单继承局限性，<strong>方便同一个对象被多个线程使用</strong></li></ul></li></ul><blockquote><p>java中的单继承是指<strong>一个子类最多只能有一个父类</strong>，不支持多继承。单继承使JAVA的继承关系很简单，一个类只能有一个父类，易于管理程序。但一个类可以实现多个接口，从而克服单继承的缺点。</p></blockquote><p>还有一种比较少用的，Java1.5之后才出现的Callable接口方式，Callable接口和Runnable接口的异同：</p><ul><li>都是 Functional 接口（函数式接口），因此可以直接使用Lamba表达式来实现线程函数，而不一定非得实现一个类来实现接口。</li><li>Runnable 可以直接传给 Thread 构造方法，Callable 不可以;</li><li>Callable 只能使用 ExecutorService，但是Callable可以返回线程的运行结果，Runnable 不可以。</li></ul><blockquote><p>附注：函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口，函数式接口可以被隐式转换为 lambda 表达式。</p></blockquote><h3 id="Thread类中的静态方法"><a href="#Thread类中的静态方法" class="headerlink" title="Thread类中的静态方法"></a>Thread类中的静态方法</h3><p>Thread类中的静态方法表示操作的线程是”<strong>正在执行静态方法所在的代码块的线程</strong>“。用处：能对CPU<strong>当前正在运行的线程</strong>进行操作。下面来看一下Thread类中的静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Race</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">//winner</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String winner;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获取现在正在运行的进程，currentThread会返回一个Thread对象的引用，getName是实例（非静态）方法，会返回一个String类型的线程对象的名称</span></span><br><span class="line">        <span class="keyword">if</span>(Thread.currentThread().getName().equals(<span class="string">&quot;rabbit&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2</span>);</span><br><span class="line">                <span class="comment">//sleep是一个静态方法，让线程休眠2毫秒</span></span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Race</span> <span class="variable">race</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Race</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(race,<span class="string">&quot;rabbit&quot;</span>).start();<span class="comment">//新建一个线程并随之启动</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(race,<span class="string">&quot;tortoise&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在Java5之后，并发线程这块发生了根本的变化，最重要的莫过于新的启动、调度、管理线程的一大堆API了。在Java5以后，通过Executor来启动线程比用Thread的start()更好。在新特征中，可以很容易控制线程的启动、执行和关闭过程，还可以很容易使用线程池的特性。</p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>背景：经常创建、销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大</p><p>思路：提前创建好多个线程，放入线程池<code>ThreadPool</code>中，使用时直接获取，使用完放回池中，避免频繁创建销毁，实现重复利用，类似路上的公共交通工具。从JDK5.0开始提供了线程池的两个相关API：<code>ExecutorService</code>和<code>Executors</code></p><p><code>ExecutorService</code>：真正的线程池接口，实现该接口的最常见子类**<code>ThreadPoolExecutor</code>**，有以下三个常用方法：</p><ol><li><code>void execute(Runnable command)</code>：执行任务&#x2F;命令，没有返回值，一般用来执行<code>Runnable</code></li><li><code>&lt;T&gt; Fulture&lt;T&gt;submit(Callable&lt;T&gt; task)</code>：执行任务，且有返回值</li><li><code>void shutdown()</code>：关闭连接池</li></ol><p><code>Executors</code>：工具类、线程池的工厂类，作用：创建并返回不同类型的线程池。</p><p><code>ThreadPoolExecutor()</code>类构造方法中有以下三个重要参数：</p><ul><li><p>corePoolSize：池中保留的线程数，即核心池的大小</p></li><li><p>maximumPoolSize：最大线程数</p></li><li><p>keepAliveTime：线程没有任务时最多保持多长时间后会终止</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建服务，创建线程池，参数为：线程池大小</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">System.out.println(service.getClass());</span><br><span class="line">        <span class="comment">//输出结果为：class java.util.concurrent.ThreadPoolExecutor 是ExecutorService接口下的一个实现类</span></span><br><span class="line">        <span class="comment">//执行</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">MyThread</span>());</span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">MyThread</span>());</span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">MyThread</span>());</span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">MyThread</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭链接</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;System.out.println(Thread.currentThread().getName());&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在前面讲到了通过接口Runnable创建线程的方式，这里使用Executors类的静态方法<code>newFixedThreadPool(int nThreads)</code>来创建一个线程池，该方法会返回一个接口类型——实际是返回值付给一个实现了此接口的实现类的实例。</p><p>Executors类中定义的newFixedThreadPool方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());&#125;</span><br></pre></td></tr></table></figure><p>我们查看newFixedThreadPool方法的源代码，可以发现，返回值是一个ExecutorService接口下的ThreadPoolExecutor类对象</p><p><img src="/images/ExecutorSercice%E6%8E%A5%E5%8F%A3.PNG" alt="ExecutorSercice接口"></p><p>该类中有一方法<code>void execute(Runnable command)</code>，用于在将来某个时期执行给定的任务。</p><h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p>private 关键字可以保证数据对象智能被方法访问。synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符(public、protected、default、private)。<code>synchronized</code>关键字包括两种用法：<code>synchronized</code>方法和<code>synchronized</code>块</p><p>同步方法：<code>public synchronized void method(int args[])&#123;&#125;</code></p><p><code>synchronized</code>方法控制对“对象”的访问，每个对象对应一把锁，每个<code>synchronized</code>方法都必须获得调用该方法的对象的锁才能执行，否则线程阻塞。而方法一旦执行，就独占该锁，知道该方法返回才将该锁释放，后面被阻塞的线程才能获得这个锁，继续执行。<strong>由<code>synchronized</code>关键字声明的方法同一时间只能被一个线程访问</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">showDetails</span><span class="params">()</span>&#123;</span><br><span class="line">.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注： synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类</strong></p><h2 id="Java并发包"><a href="#Java并发包" class="headerlink" title="Java并发包"></a>Java并发包</h2><p>“并发包”指的是 JDK 1.5 版本引入的<code>java.util.concurrent</code>包，简称 J.U.C，其中包含大量多线程和并发编程的工具，其中有以下几个常用类：</p><blockquote><p>CopyOnWriteArrayList是ArrayList的线程安全版本，在有写操作的时候会copy一份数据，然后写完再设置成新的数据，适用于读多写少的并发场景。CopyOnWriteArraySet是线程安全版本的Set实现，它的内部通过一个CopyOnWriteArrayList来代理读写等操作，使得CopyOnWriteArraySet表现出了和CopyOnWriteArrayList一致的并发行为，他们的区别在于数据结构模型的不同，set不允许多个相同的元素插入容器中。</p><p>Seamphore（信号量），在多线程环境下使用的一种设施。类似于控制并发的时候用到的“令牌桶”算法，负责协调各个线程，通过控制信号总数，不断释放和回收信号来控制并发数量，以保证它们能够正确、合理的使用公共资源。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;jdk11API中文文档中对java.lang.Thread类的介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;Object.html&quot;&gt;java.lang.Object&lt;/a&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;java.</summary>
      
    
    
    
    <category term="Java" scheme="http://justskim.github.io/categories/Java/"/>
    
    
    <category term="java" scheme="http://justskim.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>编程语言的文档注释</title>
    <link href="http://justskim.github.io/2022/03/18/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A/"/>
    <id>http://justskim.github.io/2022/03/18/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A/</id>
    <published>2022-03-18T13:51:04.790Z</published>
    <updated>2022-03-19T03:03:14.052Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-文档注释"><a href="#Java-文档注释" class="headerlink" title="Java 文档注释"></a>Java 文档注释</h2><p>Java 支持三种注释方式。前两种和<code>C++</code>的注释一样，分别是 <code>//</code> 和 <code>/* */</code>。<strong>第三种</strong>被称作<strong>说明注释</strong>，它以 <code>/**</code>开始，以 <code>*/</code>结束。</p><blockquote><p>说明注释允许我们在程序中嵌入关于程序的信息，也可以使用 javadoc 工具软件来生成信息，并输出到HTML文件中。</p></blockquote><p>菜鸟教程给出了以下的<a href="https://www.runoob.com/java/java-documentation.html"><code>javadoc</code>标签</a>：</p><table><thead><tr><th align="left"><strong>标签</strong></th><th align="center"><strong>描述</strong></th><th align="center"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left">@author</td><td align="center">标识一个类的作者</td><td align="center">@author description</td></tr><tr><td align="left">@deprecated</td><td align="center">指名一个过期的类或成员</td><td align="center">@deprecated description</td></tr><tr><td align="left">{@docRoot}</td><td align="center">指明当前文档根目录的路径</td><td align="center">Directory Path</td></tr><tr><td align="left">@exception</td><td align="center">标志一个类抛出的异常</td><td align="center">@exception exception-name explanation</td></tr><tr><td align="left">{@inheritDoc}</td><td align="center">从直接父类继承的注释</td><td align="center">Inherits a comment from the immediate surperclass.</td></tr><tr><td align="left">{@link}</td><td align="center">插入一个到另一个主题的链接</td><td align="center">{@link name text}</td></tr><tr><td align="left">{@linkplain}</td><td align="center">插入一个到另一个主题的链接，但是该链接显示纯文本字体</td><td align="center">Inserts an in-line link to another topic.</td></tr><tr><td align="left">@param</td><td align="center">说明一个方法的参数</td><td align="center">@param parameter-name explanation</td></tr><tr><td align="left">@return</td><td align="center">说明返回值类型</td><td align="center">@return explanation</td></tr><tr><td align="left">@see</td><td align="center">指定一个到另一个主题的链接</td><td align="center">@see anchor</td></tr><tr><td align="left">@serial</td><td align="center">说明一个序列化属性</td><td align="center">@serial description</td></tr><tr><td align="left">@serialData</td><td align="center">说明通过writeObject( ) 和 writeExternal( )方法写的数据</td><td align="center">@serialData description</td></tr><tr><td align="left">@serialField</td><td align="center">说明一个ObjectStreamField组件</td><td align="center">@serialField name type description</td></tr><tr><td align="left">@since</td><td align="center">标记当引入一个特定的变化时</td><td align="center">@since release</td></tr><tr><td align="left">@throws</td><td align="center">和 @exception标签一样.</td><td align="center">The @throws tag has the same meaning as the @exception tag.</td></tr><tr><td align="left">{@value}</td><td align="center">显示常量的值，该常量必须是static属性。</td><td align="center">Displays the value of a constant, which must be a static field.</td></tr><tr><td align="left">@version</td><td align="center">指定类的版本</td><td align="center">@version info</td></tr></tbody></table><p><a href="http://c.biancheng.net/view/6262.html">C语言中文网</a>中有着更详细的<code>Javadoc</code>介绍：</p><p>对两种标签格式的说明：</p><ul><li>@tag 格式的标签（不被<code>&#123; &#125;</code>包围的标签）为块标签，只能在主要描述（类注释中对该类的详细说明为主要描述）后面的标签部分（如果块标签放在主要描述的前面，则生成 API 帮助文档时会检测不到主要描述）。</li><li>{@tag} 格式的标签（由<code>&#123; &#125;</code>包围的标签）为内联标签，可以放在主要描述中的任何位置或块标签的注释中。</li></ul><p><code>Javadoc</code>标签注意事项：</p><ul><li>Javadoc 标签必须从一行的开头开始，否则将被视为普通文本。</li><li>一般具有相同名称的标签放在一起。</li><li>Javadoc 标签区分大小写，代码中对于大小写错误的标签不会发生编译错误，但是在生成 API 帮助文档时会检测不到该注释内容。</li></ul><h3 id="Javadoc命令"><a href="#Javadoc命令" class="headerlink" title="Javadoc命令"></a>Javadoc命令</h3><p><code>Javadoc</code> 用法格式如下：</p><p><code>javadoc [options] [packagenames] [sourcefiles]</code></p><p>其中options 表示<code>Javadoc</code> 命令的选项，<code>packagenames</code>表示包名，这两个是可选项。</p><p>如果我们的代码中有中文的注释，可以使用命令<code>javadoc -encoding UTF-8 -charset UTF-8 Javadoc_demo.java</code>编译出相应的Html文档让我们阅读。</p><h3 id="java说明注释——javadoc标签的使用"><a href="#java说明注释——javadoc标签的使用" class="headerlink" title="java说明注释——javadoc标签的使用"></a><code>java</code>说明注释——<code>javadoc</code>标签的使用</h3><p>以<code>IDEA</code>软件为例，由于其自动补全的功能，我们只需要输入<code>/**</code>然后回车即可，每一行都会智能地为我们的注释文字在开头补上<code>*</code>符号。我们不仅可以在主类外写说明注释，还可以先写上类中的成员函数，然后在成员函数上头输入<code>/**</code>，<code>IDEA</code>将会自动为我们补全相关信息，比如参数 <code>param</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mike</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Javadoc_test</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JSDoc——JavaScript之注释规范化"><a href="#JSDoc——JavaScript之注释规范化" class="headerlink" title="JSDoc——JavaScript之注释规范化"></a>JSDoc——JavaScript之注释规范化</h2><p>原生的JavaScript语法中并没有像Java那样的说明注释，<code>JSDoc</code> 是一个针对 JavaScript 的 <code>API</code> 文档生成器，可以在其<a href="https://jsdoc.app/index.html">官网</a>查看介绍，类似于 Java 中的 <code>Javadoc</code> 或者 <code>PHP</code> 中的 <code>phpDocumentor</code>。我们在<code>js</code>格式代码中添加像<code>javadoc</code>标签般的注释，即可被<code>JSDoc</code>工具自动扫描并生成<code>API</code>文档。<a href="https://knightyun.github.io/2020/03/13/js-comment-format">这位博主的博客文章中介绍了该工具的使用</a>：</p><blockquote><p>首先要使用<code>npm</code>进行安装，我们选择全局安装较为方便：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g jsdoc</span><br></pre></td></tr></table></figure><p>书写符合形式的代码及说明注释，在<code>js</code>文件的当前目录下执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jsdoc doc.js</span><br></pre></td></tr></table></figure><p>就会在当前目录下生成一个名为 <code>out</code> 的目录（也可以另外指定目录），然后我们就可以通过浏览器访问这个 <code>out</code> 目录中的相关网页。</p></blockquote><p>对于JavaScript的业务开发，我们可以参考<a href="https://juejin.cn/post/6995464881205936164">这一篇掘金的文章</a>。尤其是<strong>针对参数的描述，要注意格式为：</strong></p><p><strong><code>@param &#123;paramDataType&#125; p1 descriptionStatements</code></strong></p><p>其中：</p><ul><li><code>p1</code>代表<strong>必选参数</strong></li><li><code>[p1]</code>代表<strong>可选参数</strong></li><li><code>[p1=xxx]</code>代表<strong>带默认值的参数</strong></li></ul><p>对于<code>typescript</code>，<code>JSDoc</code> 的提供的注释标记类型可以参考Block Tags, 但是到现在为止，<code>TypeScript</code> <strong>只支持了部分标记。</strong> 在语法方面，由于<code>JSDoc</code> 主要借鉴于 closure-compiler, 而 <strong><code>TypeScript</code></strong> 则有自己的一套类型语法，因此存在部分的差异。</p><h2 id="Python中的注释和文档"><a href="#Python中的注释和文档" class="headerlink" title="Python中的注释和文档"></a>Python中的注释和文档</h2><p>单行注释和多行注释都是基本语法知识，需要注意的是由于Python按缩进来划分代码块的语法特性，编写多行注释的时候要注意首尾<code>&#39;&#39;&#39;</code>符号的对齐和缩进，多行注释可以用三个单引号 <strong>‘’’</strong> 或者三个双引号 <strong>“””</strong> 将注释括起来。</p><h3 id="Docstring——Python的文档注释"><a href="#Docstring——Python的文档注释" class="headerlink" title="Docstring——Python的文档注释"></a>Docstring——Python的文档注释</h3><p>按照<a href="https://python-guide.gitbooks.io/python-style-guide/content/style-guide/comment_and_docs.html">gitbook上Python的指导文档</a>可以看到：</p><blockquote><p>作为文档的Docstring一般出现在模块头部、函数和类的头部，这样在python中可以通过对象的__doc__对象获取文档，编辑器和IDE也可以根据Docstring给出自动提示。文档注释中对函数参数、返回值等的说明采用<code>numpy</code>标准。文档注释以 <code>&quot;&quot;&quot;</code> 开头和结尾，<strong>首行不换行，如有多行，末行必需换行</strong></p></blockquote><p>注意！为了代码的效率和信息不冗余，不要在文档注释复制函数定义原型，而要具体地描述其具体内容，解释具体参数和返回值等，如下面的示例写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  不推荐的写法(不要写函数原型等废话)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">function</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;function(a, b) -&gt; list&quot;&quot;&quot;</span></span><br><span class="line">    ... ...</span><br><span class="line"><span class="comment">#  正确的写法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">function</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算并返回a到b范围内数据的平均值&quot;&quot;&quot;</span></span><br><span class="line">    ... ...</span><br></pre></td></tr></table></figure><p><code>pydoc</code>是python自带的一个文档生成工具，可以提取注释。在控制台中，我们可以使用命令<code>pydoc pydoc_demo &gt; doc.md</code>来生成文档。之后使用<code>python pydoc_demo.py</code>命令启动<code>pydoc_demo.py</code>文件，就可以看得到相关的文档注释。</p><p>使用命令<code>pydoc -w pydoc_demo</code>可以生成<code>html</code>格式文件<code>pydoc_demo.html</code>，更具体的使用可以参考<a href="https://www.cnblogs.com/meitian/p/6704488.html">pydoc用法</a>。</p><h3 id="Python文件头注释"><a href="#Python文件头注释" class="headerlink" title="Python文件头注释"></a>Python文件头注释</h3><p>我们以一个常见的Python开头注释为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author:XXX</span></span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/shizilunya/p/8081285.html">第一行<code>#!/usr/bin/env python</code>的意义</a>：</p><blockquote><p><strong>这些注释并不仅仅是写给读者看的注释，它也写给操作系统看的，这些注释决定了系统将如何运行这些文件。</strong></p><p>Linux系统自带python解释器（通常是Python 2的版本，比如Centos 7中就是如此）。在编写.py文件时，只要写上了#!&#x2F;usr&#x2F;bin&#x2F;python这行注释，用户就可以直接在命令行用文件名来执行py文件，例如：  testmode.py </p><p>意义：<strong>指定系统环境变量设定的解释器路径</strong>。类似于在window命令行中，你必须得写 python testmode.py 或 javac testmode.java 或 java testmode.class 来运行文件，你要通过文件名前面的<strong>关键字</strong>才能去启动对应的解释器。而有了这行注释，Linux系统就知道了你要用什么来执行这个文件，你就可以直接用文件名去跑它了。</p><p><code>#!/usr/bin/python</code>注释的问题：Linux只会使用系统默认的py解释器（也就是自带的那个）来运行文件。这样用户就无法使用自己的python版本了，不同的py版本之间语法有些差异，尤其是变动比较大的py2和py3，这些差异会使得整个程序无法正常运行。而#!&#x2F;usr&#x2F;bin&#x2F;env python 的出现可则让用户可以自行选择python版本，用户可以在<strong>环境变量</strong>中配置自己的py解释器（ps：用户安装的版本默认定位在Linux的local文件夹中）。<code>#!/usr/bin/env python</code>这行注释，会使linux在解析文件时，知道要去使用环境变量中的py解释器而非系统自带的那个。</p><p>所以如果你要使用该注释，推荐使用<code>#!/usr/bin/env python</code>的注释，而非<code>#!/usr/bin/python</code>。</p></blockquote><p>第二行<code># -*- coding:utf-8 -*-</code>作用是<strong>在Linux下指定文件的编码方式，用于支持中文</strong>。由于Python 3 默认支持中文，因此该行注释可以省略。</p><p>在<code>windows</code>系统的Python 3环境下运行我们的程序，可以不写上面的两行注释，但为了跨平台以及兼容，还是应该写上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java-文档注释&quot;&gt;&lt;a href=&quot;#Java-文档注释&quot; class=&quot;headerlink&quot; title=&quot;Java 文档注释&quot;&gt;&lt;/a&gt;Java 文档注释&lt;/h2&gt;&lt;p&gt;Java 支持三种注释方式。前两种和&lt;code&gt;C++&lt;/code&gt;的注释一样，分别</summary>
      
    
    
    
    <category term="Programming languages and projects" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/"/>
    
    
    <category term="python" scheme="http://justskim.github.io/tags/python/"/>
    
    <category term="java" scheme="http://justskim.github.io/tags/java/"/>
    
    <category term="javascript" scheme="http://justskim.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>知识图谱专业术语与基本知识</title>
    <link href="http://justskim.github.io/2022/03/16/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    <id>http://justskim.github.io/2022/03/16/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</id>
    <published>2022-03-16T07:04:43.745Z</published>
    <updated>2022-05-08T19:04:47.355Z</updated>
    
    <content type="html"><![CDATA[<h2 id="知识图谱的应用：我们为什么要做知识图谱"><a href="#知识图谱的应用：我们为什么要做知识图谱" class="headerlink" title="知识图谱的应用：我们为什么要做知识图谱"></a>知识图谱的应用：我们为什么要做知识图谱</h2><ol><li><p>语义搜索</p></li><li><p>智能问答</p></li><li><p>个性化推荐</p></li><li><p>辅助决策</p></li></ol><h2 id="起源和基本概念"><a href="#起源和基本概念" class="headerlink" title="起源和基本概念"></a>起源和基本概念</h2><p>在这篇<a href="https://zhuanlan.zhihu.com/p/148785892">知识图谱的介绍专栏</a>中，可以知道，<strong>知识图谱起源于语义网络（semantic nets or semantic networks）</strong>，语义网络一种用互联的的节点和弧来表示知识的一个结构，节点可以代表一个概念(concept)、一个属性(attribute)、一个事件(event)或者一个实体(entity)，而弧则用来表示节点之间的关系，弧的标签指明了关系的类型。<br>知识图谱不能仅理解为一个图，应该说：知识图谱是一种采用图模型（即由点和线组成的图形）来对人类知识进行表示的知识库或者知识的集合，并且符合某种语法和语义。</p><blockquote><p>知识图谱的图模型是一个有向图G&#x3D;&lt;O,E&gt;，这里O是一个实体或者字面量（literal）的集合，一般有以下几种：</p><ol><li>实例，即一个现实世界中具体的实物，比如说图1中的resource&#x2F;2019新型冠状病毒感染肺炎；</li><li>概念，可以看成是实例的集合，比如说图1中的class&#x2F;疾病；</li><li>字面量（literal），主要分为字符串和数据类型，这里数据类型包括日期值、高度等。</li></ol><p>知识图谱中<strong>一条知识</strong>称为<strong>三元组</strong>，即**<code>&lt;o1, e, o2&gt;</code><strong>的格式，这里<code>o1</code>和<code>o2</code>是实体或者字面量，而e则是带标签的边（类似图结构中我们要用两个点，一条边来表示）。</strong>一个三元组可以等价于一条主谓宾的知识，即<code>o1</code>和<code>o2</code>分别对应主语和宾语，e对应谓语**。</p></blockquote><p><a href="https://www.jianshu.com/p/941dc6d7e760">三元组的基本组成部分</a>：</p><blockquote><ul><li>实体（Entity）：实体是对客观个体的抽象，一个人、一部电影、一句话都可以看作是一个实体。例如：姚明，李安，我不是潘金莲</li><li>类型（type）：类型是对具有相同特点或属性的实体集合的抽象。举例：中国是一个实体，美国是一个实体，法国是一个实体。这些实体都有首都、人口、面积等共同特征，因此例如像中国、美国、法国等都有首都、人口、面积等特征的实体可以抽象为“国家”类型</li><li>属性（property）：属性是对实体与实体之间关系的抽象，例如李安是一个实体，李安是一个人物（type），少年派的奇幻漂流是一个实体，少年派的奇幻漂流是一个电影（type），很明显两个实体之间存在着关系即为：李安→导演→少年派的奇幻漂流因此李安与少年派的奇幻漂流之间的关系可以用属性“导演”刻画。那么可以根据属性构建一层关系，人物（type）→导演（property）→电影（type）。</li><li>关系（relation）：关系是<strong>实体与实体之间</strong>关系的抽象，李安（entity）→导演（relation）→少年派的奇幻漂流（entity），导演这个relation则是描述李安和少年派的奇幻漂流的关系。</li><li>域（domain）：域是类型的集合，凌驾于类型之上，是对某一领域所有类型的抽象，例如：国家是对中国、美国这样实体的一种抽象，是一种类型，而一个地理位置除了国家类型之外，还包括其他类型：城市、区域、洲等等，而把这些所有类型：洲、国家、城市、区域等类型抽象起来，就形成了地理位置域。</li><li>值（value）：值是用来描述实体的，可以分为文本型和数值型，EG：姚明（entity）→身高（relation）→ 226 cm（value）。</li></ul></blockquote><p>想要系统学习知识图谱，基础阶段可以看一下知乎上这一位博主的<a href="https://zhuanlan.zhihu.com/p/396516565">知识图谱专栏学习笔记</a>，比如他这里介绍的知识图谱构建方法：</p><p><img src="https://pic3.zhimg.com/80/v2-367fae46217b2666f15e20255a803eb2_720w.jpg" alt="知识图谱的构建"></p><p>建立知识图谱的第一步是获得数据，根据数据的类型可以分为：</p><ol><li><p>结构化的数据：表格、数据库等按照一定格式表示的数据，通常可以直接用来构建知识图谱；</p></li><li><p>非结构化的数据：文本、音频、视频、图片等，需要对它们进行信息抽取才能进一步建立知识图谱；</p></li><li><p>半结构化数据是介于结构化和非结构化之间的一种数据，也需要进行信息抽取才能建立知识图谱。</p></li></ol><p><a href="https://blog.csdn.net/taon1607/article/details/107087408">连续型数据和非连续型数据</a>：</p><blockquote><p>离散型数据都是类别值，如：男生，女生，商务座，一等座，二等座等等。连续型数据基本上都是数值型数据，如年龄（10岁，11岁…），身高（110cm, 175cm…），海拔，薪资等等。<br>既然连续型数据都是数值，是可以直接拿来供计算机使用的，那么连续型数据该如何处理？这里我们提出一个处理思想：连续型数据离散化。连续型数据离散化以后的建模效果一定会比原来的好吗？这个答案是不一定的</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200106162929139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MzA0ODUx,size_16,color_FFFFFF,t_70" alt="对不同类型数据的处理"></p><p><strong>信息抽取（知识抽取）</strong></p><blockquote><p>可以分为实体识别、关系抽取、属性抽取等。目前结构化的数据时最主要的知识来源。针对结构化的数据，知识图谱通常可以直接利用和转化，形成基础数据集，再利用知识图谱补全技术进一步扩展知识图谱。</p><p>针对文本型数据这种非结构化数据，知识获取的方式主要包括实体识别、关系抽取、属性抽取等。具体的方法又包括基于特征模版的方法、基于核函数的监督学习方法、基于深度学习的方法等</p><p>实体识别：指在一段文本中识别哪些词代表实体，并打上标签（进行分类）。例如“演员于和伟出演了电视剧《觉醒年代》”这句话中，“于和伟”和“《觉醒年代》”就是两个实体</p><p>关系抽取：识别文本（或其他数据）中实体之间的关系。例如“演员于和伟出演了电视剧《觉醒年代》”这句话中，“出演”为“演员于和伟”与“电视剧《觉醒年代》”之间的关系</p></blockquote><h3 id="知识表示与建模"><a href="#知识表示与建模" class="headerlink" title="知识表示与建模"></a>知识表示与建模</h3><p><strong>知识表示</strong></p><p>用一定的结构和符号语言来描述知识，并且能够用计算机进行推理、计算等操作的技术。知识表示的方法：谓词逻辑表示法、框架表示法、基于语意网路的表示法等。</p><p><strong>知识融合</strong> <strong>Knowledge fusion</strong></p><p>由于得到的数据可能会存在交叉和重叠，因此同一个概念、实体可能会反复出现，知识融合的目的就是把表示相同概念的实体进行合并。根据专栏作者的解释：</p><blockquote><p>主要任务包括实体消歧和指代消解，它们都用来判断知识库中的同名实体是代表同一含义、是否有其他实体也表示相同含义。实体消歧专门用于解决同名实体产生歧义的问题，通常采用聚类法、空间向量模型、语义模型等。指代消解则为了避免代词指代不清的情况。</p></blockquote><h3 id="知识推理-Knowledge-Reasoning"><a href="#知识推理-Knowledge-Reasoning" class="headerlink" title="知识推理 Knowledge Reasoning"></a>知识推理 Knowledge Reasoning</h3><blockquote><p>知识推理是根据已有的数据模型和数据，依据推理规则，获取新的知识或者结论，新的知识或结论应该是满足语义的。知识推理，依据描述逻辑系统实现。描述逻辑(Description Logic)是基于对象的知识表示的形式化，也叫概念表示语言或术语逻辑，是一阶谓词逻辑的一个可判定子集。</p><p>一个描述逻辑系统由四个基本部分组成： 最基本的元素：概念、关系、个体；TBox术语集：概念术语的公理集合； Abox断言集：个体的断言集合；TBox 和 ABox上的推理机制。</p><p>描述逻辑涉及到的内容也比较多，此处举几个例子，比如实体的分类包含关系，一个电脑椅是椅子，椅子是家具，可以说，一个电脑椅是家具。常识规则的推理，一个男人的孩子是A，一个女人的孩子是A，可以知道，这个男人和女人是配偶。</p></blockquote><p><img src="https://pic4.zhimg.com/80/v2-86c66ac77e2b89d0f39b31b230bfdf7f_720w.jpg" alt="知识推理的三大方式"></p><p>简单地说，推理任务主要有：通过<strong>规则挖掘</strong>对知识图谱进行<strong>补全（Knowledge Base Completion,KBC）与质量校验</strong>、<strong>链接预测、关联关系推理</strong>与<strong>冲突检测</strong>等。</p><p>基于规则的推理通过定义或学习知识中存在的规则进行挖掘与推理，从早期的ILP(Inductive Logic Programming)系统中衍生的AMIE、AMIE+算法， 强调通过自动化的规则学习方法，快速有效的从大规模知识图谱中学习出置信度较高的规则，并且应用于推理任务。</p><p><img src="https://pic2.zhimg.com/80/v2-ced25261ed496e505147fc23aa9cb95d_720w.jpg" alt="各种推理方法极其优缺点总结"></p><h3 id="Trans-E-算法细说"><a href="#Trans-E-算法细说" class="headerlink" title="Trans E 算法细说"></a>Trans E 算法细说</h3><p>transE算法就是一个非常经典的知识表示学习，用<a href="https://so.csdn.net/so/search?q=%E5%88%86%E5%B8%83%E5%BC%8F&spm=1001.2101.3001.7020">分布式</a>表示（distributed representation）来描述知识库中的三元组，<a href="https://blog.csdn.net/shunaoxi2313/article/details/89766467">这里可以看下其简单的算法思想</a>：</p><blockquote><p>知识图谱中的事实是用三元组 ( h , l , t ) (h,l,t)(h,l,t) 表示的，那么如何用低维稠密向量来表示它们，才能得到这种依赖关系呢？transE算法的思想非常简单，它受word2vec平移不变性的启发，希望h + l ≈ t h+l≈th+l≈t（此为归纳偏差？）。</p><p>光有这一个约束可不够。想让h + l ≈ t h+l≈th+l≈t，如何设置损失函数是个关键。我们发现表示学习都没有明显的监督信号，也就是不会明确告诉模型你学到的表示正不正确，那么想要快速收敛就得引入“相对”概念，即相对负例来说，正例的打分要更高，方法学名：<strong>“negative sampling”</strong>，也就是<strong>负采样</strong>。</p></blockquote><p>转移距离模型（Translational Distance Model）的主要思想是将衡量向量化后的知识图谱中三元组的合理性问题，转化成衡量头实体和尾实体的距离问题。这一方法的重点是如何设计得分函数，得分函数常常被设计成利用关系把头实体转移到尾实体的合理性的函数。 受词向量的启发，由词与词在向量空间的语义层面关系，可以拓展到知识图谱中头实体和尾实体在向量空间的关系。也就是说，同样可以 考虑把知识图谱中的头实体和尾实体映射到向量空间中，且它们之间的 联系也可以考虑成三元组中的关系。</p><p>TransE便是受到了词向量中平移不变性的启发，在 TransE 中，把实体和关系都表示为向量，对于某一个具体的关系（head, relation, tail），把关系的向量表示解释成头实体的向量到尾实体的向量的转移向量（Translation vector）。也就是说， 如果在一个知识图谱中，某一个三元组成立，则它的实体和关系需要满 足关系head+relation≈tail。</p><h3 id="知识图谱的嵌入"><a href="#知识图谱的嵌入" class="headerlink" title="知识图谱的嵌入"></a>知识图谱的嵌入</h3><p>知识图谱通常存在链接缺失问题，这限制了知识图谱在相关下游任务中的应用。为解决该问题，知识图谱补全任务应运而生。知识图谱补全旨在根据知识图谱中已有事实推断出新的事实，从而使得知识图谱更完整。</p><p>知识图谱嵌入 (Knowledge Graph Embedding) 是解决知识图谱补全问题的重要方法之一，它通过将知识图谱中的实体 (Entity) 和关系 (Relation) 嵌入到连续向量空间，从而在方便计算的同时保留知识图谱中的结构信息。知识图谱嵌入模型大致可以分为三类：</p><blockquote><h2 id="知识图谱补全任务"><a href="#知识图谱补全任务" class="headerlink" title="知识图谱补全任务"></a>知识图谱补全任务</h2><h3 id="符号定义"><a href="#符号定义" class="headerlink" title="符号定义"></a>符号定义</h3><p>知识图谱通常以三<a href="https://so.csdn.net/so/search?q=%E5%85%83%E7%BB%84&spm=1001.2101.3001.7020">元组</a> (Triple) 来表示知识，三元组的一般格式为 (<em>头实体</em>，<em>关系</em>，<em>尾实体</em>)，如“金庸的表兄是徐志摩”表示成三元组为 (<em>金庸</em>，<em>表兄</em>，<em>徐志摩</em>)，其中<em>金庸</em>为头实体，<em>徐志摩</em>为尾实体，<em>表兄</em>是这两个实体之间的关系。我们使用小写的字母 来分别表示头实体、关系和尾实体， 表示知识图谱中的一个三元组。相应地，小写加粗字母 分别表示头实体、关系和尾实体对应的嵌入向量。向量 的第 个元素记作 。 表示嵌入向量的维度。  表示两个向量间的 Hadamard (element-wise) product。另外，我们使用 来分别表示 和 范数。</p><h3 id="补全任务与性能指标"><a href="#补全任务与性能指标" class="headerlink" title="补全任务与性能指标"></a>补全任务与性能指标</h3><p>知识图谱补全 (Knowledge Graph Completion)，是根据知识图谱中已有的三元组去对未知三元组进行预测。我们使用 表示已知头实体和关系来预测尾实体， 表示已知关系和尾实体来预测头实体，其中 和 被称为查询 (Query)。实际上，知识图谱补全任务，本质上给定查询下的排序问题。比如，对于图2所示的查询 (<em>陆小曼</em>，<em>丈夫</em>，<em>？</em>)，返回的是预测答案的排序列表，正确答案排名越高，预测的效果就越好。</p></blockquote><h3 id="质量评估"><a href="#质量评估" class="headerlink" title="质量评估"></a>质量评估</h3><p>在知识推理完了之后，我们也不能忘记质量评估这一个最后的步骤：</p><blockquote><p>质量评估就是对最后的结果数据进行评估，将合格的数据放入知识图谱中。质量评估的方法，根据所构建的知识图谱的不同，对数据要求的差异而有所差别。总的目的是要获得合乎要求的知识图谱数据，要求的标准根据具体情况确定。 比如对于公共领域的知识图谱，知识的获取采用了众包的方法，对于同一个知识点，可能会有很多人来完成，如果这个知识点只有一个答案，可以采用的一种策略是，将多人的标注结果进行比较，取投票多的结果作为最终的结果。当然，这是不严谨的，因为真理往往掌握在少数人的手里，特别是针对一些行业的知识图谱，表现尤为突出。行业内的一条知识，可能只有行业专家能够给出权威正确的答案，如果让大众投票来决定，可能会得到一条错误的知识。所以，针对行业知识图谱，可能会采用不同于公共知识图谱的策略，来进行知识的质量评估。</p></blockquote><h3 id="NLP中的负采样（Negative-Sampling）"><a href="#NLP中的负采样（Negative-Sampling）" class="headerlink" title="NLP中的负采样（Negative Sampling）"></a>NLP中的负采样（Negative Sampling）</h3><p>负采样是NLP领域一个出现频次极高的词，负抽样的目的是为了最终输出的上下文单词（正样本），在采样过程中应该保留下来并更新，同时也需要采集部分负样本（非上下文单词）。通过负采样，在更新隐层到输出层的权重时，只需更负采样的单词，而不用更新词汇表所有单词，<br><a href="https://blog.csdn.net/ningyanggege/article/details/87869393">对负采样理解</a>来自于word2vec算法：</p><blockquote><p>比如说  love 和me两个单词；<br>使用特殊思维模式；假设整个词汇表只有100个单词；love 表示成one-hot向量； me表示成one-hot向量；<br>模型输入为love的one-hot向量；模型输出为me的one-hot向量；<br>假设模型的神经网络结构为100<em>10</em>100；输出层100个；<br>输出层中除了me对应位置的1外，其他全是0；称这为负样本；参数数量为10<em>100<br>采样就是从这样负样本中抽样；比如说抽取5个；那么在此次梯度更新中就只更新10</em>5；更新数量为原来的1&#x2F;20</p><p>因此，可以看到负采样的本质：每次让一个训练样本<strong>只更新部分权重</strong>，<strong>其他权重全部固定</strong>；<strong>减少计算量</strong>；（一定程度上还可以增加随机性）</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;知识图谱的应用：我们为什么要做知识图谱&quot;&gt;&lt;a href=&quot;#知识图谱的应用：我们为什么要做知识图谱&quot; class=&quot;headerlink&quot; title=&quot;知识图谱的应用：我们为什么要做知识图谱&quot;&gt;&lt;/a&gt;知识图谱的应用：我们为什么要做知识图谱&lt;/h2&gt;&lt;ol&gt;
</summary>
      
    
    
    
    <category term="知识图谱" scheme="http://justskim.github.io/categories/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
    
    <category term="知识图谱" scheme="http://justskim.github.io/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
  </entry>
  
  <entry>
    <title>visual studio code中无法切换Python版本的解决</title>
    <link href="http://justskim.github.io/2022/03/07/visual-studio-code%E4%B8%AD%E6%97%A0%E6%B3%95%E5%88%87%E6%8D%A2Python%E7%89%88%E6%9C%AC%E7%9A%84%E8%A7%A3%E5%86%B3/"/>
    <id>http://justskim.github.io/2022/03/07/visual-studio-code%E4%B8%AD%E6%97%A0%E6%B3%95%E5%88%87%E6%8D%A2Python%E7%89%88%E6%9C%AC%E7%9A%84%E8%A7%A3%E5%86%B3/</id>
    <published>2022-03-07T01:50:49.323Z</published>
    <updated>2022-03-07T02:05:47.908Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>使用Python进行机器学习，需要引入<code>sklearn</code>模块，因此在我们建立的<code>anaconda</code>环境（名称<code>py378</code>，用的Python 3.7.8的版本）中activate该环境，并安装<code>scikit-learn</code>库（安装的模块名和导入的库名称不一样，这个见网上详细解释，<code>scikit-learn</code>其实就是其工具包）。但来到软件<code>visual studio code</code>界面中却发现无法正常切换Python版本，工作区也未能生成<code>.vscode</code>文件夹：</p><p>![visual studio code无法切换python环境](&#x2F;images&#x2F;visual studio code无法切换python环境.PNG)</p><p>我们可以看到，在左下角并没有加载出Python Interpreter，终端中手动输入命令切换环境也依然无法奏效。</p><h2 id="尝试步骤"><a href="#尝试步骤" class="headerlink" title="尝试步骤"></a>尝试步骤</h2><ol><li><p>按住<code>ctrl+shift+p</code>，输入<code>Python Interpreter</code>切换环境，发现已经被切换到<code>py378</code></p></li><li><p>打开<code>Preferences</code>中的设置，在<code>settings.json</code>中找到<code>python.defaultInterpreterPath</code>，由于之前博主为了能像<code>anaconda</code>那般切换环境，在<code>visual studio code</code>进行配置，此项为<code>anaconda</code>下的<code>python.exe</code>文件，博主手动将其修改为<code>C:\\Users\\YourUserName\\Anaconda3\\envs\\py378\\python.exe</code></p></li><li><p>在上边的设置中，搜索<code>cmd</code>，查看终端<code>terminal</code>是否为<code>cmd</code>而不是<code>powershell</code>（据网上说法<code>powershell较不稳定</code>），但博主这里的设置无误：</p><p><img src="/images/visual-studio-code%E4%B8%ADterminal%E8%AE%BE%E7%BD%AE.PNG" alt="visual-studio-code中terminal设置"></p></li></ol><p>经过以上步骤依然无效</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;使用Python进行机器学习，需要引入&lt;code&gt;sklearn&lt;/code&gt;模块，因此在我们建立的&lt;code&gt;anaconda&lt;/code</summary>
      
    
    
    
    <category term="Programming languages and projects" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/"/>
    
    <category term="Python3" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"/>
    
    
    <category term="python" scheme="http://justskim.github.io/tags/python/"/>
    
    <category term="visual studio code" scheme="http://justskim.github.io/tags/visual-studio-code/"/>
    
  </entry>
  
  <entry>
    <title>Eclipse web 工程的项目目录结构</title>
    <link href="http://justskim.github.io/2022/03/06/Eclipse-web-%E5%B7%A5%E7%A8%8B%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
    <id>http://justskim.github.io/2022/03/06/Eclipse-web-%E5%B7%A5%E7%A8%8B%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</id>
    <published>2022-03-06T10:10:07.896Z</published>
    <updated>2022-03-19T03:14:27.784Z</updated>
    
    <content type="html"><![CDATA[<p>在使用Eclipse学习Java开发的过程中，发现我自己新建<code>dynamic web project</code>的项目目录结构和视频中演示的不同，最明显的区别是没有Java Resources和JavaScript Resources这两个文件夹：</p><p><img src="/images/%E6%96%B0%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.PNG" alt="新建web项目目录结构"></p><p>查阅多方资料显示，这种项目结构的不同对于程序执行并没有大问题，要参考项目中各个文件和目录的功能，可以见以下三篇博客：</p><ol><li><a href="https://blog.csdn.net/yyuanxiwen/article/details/94600630">https://blog.csdn.net/yyuanxiwen/article/details/94600630</a></li><li><a href="https://blog.csdn.net/Alan_Wdd/article/details/90514928">https://blog.csdn.net/Alan_Wdd/article/details/90514928</a></li><li><a href="https://www.cnblogs.com/jetdl/p/9724651.html">https://www.cnblogs.com/jetdl/p/9724651.html</a></li></ol><p>在webapp下有一个WEB-INF文件夹。该目录是一个专用区域， 容器不能把此目录中的内容提供给用户。这个目录下的文件只供容器使用，里面包含不应该由客户直接下载的资源。<strong>Web 容器要求在你的应用程序中必须有 WEB-INF 目录。WEB-INF 中包含着发布描述符（也就是 web.xml 文件）, 一个 classes 目录和一个 lib目录, 以及其它内容。注意： 如果你的 Web 应用程序中没有包含这个目录, 它可能将无法工作 。</strong></p><p>web.xml文件在 J2EE Web 应用程序发布之后帮助管理 Web 应用程序的配置。在web.xml文件中会设置welcome-file标签，这是因为&#x2F;WEB-INF目录下的文件本来是不允许直接访问的，但如果在web.xml中配置了如上欢迎页面，并且在&#x2F;WEB-INF目录下放置了index.html，那么在浏览器地址栏输入<a href="http://127.0.0.1:8080/myWeb%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AEindex.html%E9%A1%B5%E9%9D%A2%EF%BC%8C%E8%B7%AF%E5%BE%84%E4%B8%AD%E7%9A%84myWeb%E6%98%AF%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E5%90%8D%E3%80%82">http://127.0.0.1:8080/myWeb可以访问index.html页面，路径中的myWeb是项目文件名。</a></p><p>在web.xml文件下需要添加约束，约束文件可以在我们tomcat安装目录下的<code>/conf</code>子文件夹中的web.xml文件中拷贝。</p><p>我们打开eclipse时，会要求我们设定workspace。在我们设定workspace的那个文件夹下，我们可以发现一个**隐藏文件夹<code>.metadata</code>**，它存在于eclipse第一次启动时指定的workspace目录下， project name 和 workspace 分别对应的目录不能是同一个目录，否则无法建立project name。</p><p>当我们通过<a href="https://so.csdn.net/so/search?q=eclipse&spm=1001.2101.3001.7020">eclipse</a>启动tomcat运行工程时，eclipse会将工程发布到org.eclipse.wst.server.core中，就像发布到tomcat中一样。使用tomcat服务器的话，默认的部署路径为<code>.metadata/.plugins/org.eclipse.wst.server.core/tmp0</code>，可以看到有一个server.xml，可以看到<code>deployDir=&quot;wtpwebapps&quot;</code>。</p><p>因此在该路径下的wtpwebapps文件夹（注意最后不是webapps）下可以看到发布的项目。</p><p>当我们为Eclipse配置默认使用的本机tomcat服务器后，我们可以在Project Explorer窗口中找到一个Servers目录，其中有一个server.xml。Service标签代表包含着一个服务（默认情况下name&#x3D;”Catalina”)，一个服务器可以包含多个服务，就对应着多个Service标签。因为是web项目，我们这里的服务要给浏览器使用，因此需要用到连接器Connector，并在其中配置端口号（默认为port&#x3D;”8080”）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在使用Eclipse学习Java开发的过程中，发现我自己新建&lt;code&gt;dynamic web project&lt;/code&gt;的项目目录结构和视频中演示的不同，最明显的区别是没有Java Resources和JavaScript Resources这两个文件夹：&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="Java" scheme="http://justskim.github.io/categories/Java/"/>
    
    <category term="Eclipse" scheme="http://justskim.github.io/categories/Java/Eclipse/"/>
    
    
    <category term="java" scheme="http://justskim.github.io/tags/java/"/>
    
    <category term="eclipse" scheme="http://justskim.github.io/tags/eclipse/"/>
    
  </entry>
  
  <entry>
    <title>重新安装JDK后Eclipse更改配置</title>
    <link href="http://justskim.github.io/2022/03/06/%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85JDK%E5%90%8EEclipse%E6%9B%B4%E6%94%B9%E9%85%8D%E7%BD%AE/"/>
    <id>http://justskim.github.io/2022/03/06/%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85JDK%E5%90%8EEclipse%E6%9B%B4%E6%94%B9%E9%85%8D%E7%BD%AE/</id>
    <published>2022-03-06T00:42:59.456Z</published>
    <updated>2022-03-06T09:16:31.632Z</updated>
    
    <content type="html"><![CDATA[<p>博主在将原先的JDK卸载，又重新安装JDK11后，发现了Eclipse软件无法正常打开的情况：</p><p><img src="/images/%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85Java%E5%90%8EEclipse%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80.PNG" alt="重新安装Java后Eclipse无法打开"></p><p>这种情况下我们一般先检查环境变量，通过命令行和系统环境的Java变量配置查看均无异常。我们查询当时Eclipse的安装教程，看是否有Eclipse软件相关的环境变量需要重新配置，结果的no。</p><p>那么，问题很明显，Eclipse软件会在第一次使用的时候获取系统的Java相关环境变量，然后将其存入自己的相关配置文件中，之后就不必获取了。在网上搜索得到Eclipse软件的配置文件为安装目录下bin文件夹中的<code>eclipse.ini</code>文件，我们打开搜索，可以看到<code>vm</code>（virtual machine 虚拟机）选项下有个旧版本<code>JDK</code>安装路径的bin文件夹：</p><p><img src="/images/eclipse.ini%E4%B8%AD%E4%BF%AE%E6%94%B9vm%E4%B8%8Bjavaw.exe%E7%9A%84%E8%B7%AF%E5%BE%84.PNG" alt="eclipse.ini中修改vm下javaw.exe的路径.PNG"></p><p>我们将其修改为重新安装的<code>JDK</code>路径下bin文件夹：<code>C:\Program Files\Java\jdk-11.0.2\bin</code>，重新打开Eclipse软件，可以成功运行！</p><p>这里顺便提一下，很多软件安装完之后都有一个bin文件夹，<em>bin</em>是binary的缩写，代表的意思是二进制，该文件夹下一般都存放二进制可执行文件。</p><p><em>ini 文件</em>，全称 “Initialization File”，即初始化文件，是windows的系统配置文件所采用的存储格式，统管windows的各项配置。<a href="https://blog.csdn.net/a123441/article/details/90668032">配置文件的好处</a>在于，能够通过直接编辑<code>ini</code>文件来修改配置：</p><blockquote><p>如果我们的程序没有任何配置文件时，这样的程序对外是全封闭的，一旦程序需要修改一些参数必须要修改程序代码本身并重新编译，这样很不好，所以要用配置文件，让程序出厂后还能根据需要进行必要的配置；配置文件有很多，如INI配置文件，<a href="https://so.csdn.net/so/search?q=XML&spm=1001.2101.3001.7020">XML</a>配置文件，还有就是可以使用系统注册表等。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;博主在将原先的JDK卸载，又重新安装JDK11后，发现了Eclipse软件无法正常打开的情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85Java%E5%90%8EEclipse%E6%97%A</summary>
      
    
    
    
    <category term="Java" scheme="http://justskim.github.io/categories/Java/"/>
    
    <category term="Eclipse" scheme="http://justskim.github.io/categories/Java/Eclipse/"/>
    
    
    <category term="java" scheme="http://justskim.github.io/tags/java/"/>
    
    <category term="eclipse" scheme="http://justskim.github.io/tags/eclipse/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7系统安装python3.7.8</title>
    <link href="http://justskim.github.io/2022/03/06/CentOS7%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85python3.7.8/"/>
    <id>http://justskim.github.io/2022/03/06/CentOS7%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85python3.7.8/</id>
    <published>2022-03-05T17:17:00.722Z</published>
    <updated>2022-03-07T01:33:57.245Z</updated>
    
    <content type="html"><![CDATA[<p>首先在<a href="https://www.python.org/downloads/source/">Python官方网站</a>中找到我们特定版本的安装包，这里我们要选择适合Linux系统的<code>tar.xz</code>格式压缩包。我们要注意，大部分Linux系统发行版，比如博主所用的Centos7都预装了python2，可以使用命令<code>python -V</code>查看其版本为2.7.5，但可能没有装pip工具。但是这样也有个好处，下载包的时候免得我们混淆。我们注意<a href="https://blog.csdn.net/qq_40584960/article/details/86082019">pip2和pip3的关系</a>：</p><blockquote><ol><li>pip是python的包管理工具，pip和pip3版本不同，都位于Scripts\目录下；</li><li>如果系统中只安装了Python2，那么就只能使用pip；</li><li>如果系统中只安装了Python3，那么既可以使用pip也可以使用pip3，二者是等价的；</li><li>如果系统中同时安装了Python2和Python3，则pip默认给Python2用，pip3指定给Python3用；</li><li>使用<code>pip install XXX</code>安装的库会位于路径<code>python2.X/site-packages</code>中，而使用<code>pip3 install XXX</code>安装的库会放在目录<code>python3.X/site-packages</code>下。</li></ol></blockquote><p>博主按照网上常见的教程安装后，一直显示的是<code>python 3.6.8</code>，跑到路径<code>/usr/bin</code>下使用命令<code>rm -rf python3*</code>删除了旧的python文件（前缀为python3的，前缀为python没有3的是python2版本的文件），再重新安装，编译，成功启动程序。</p><p><code>which python3 </code>命令在PATH变量指定的路径中，<strong>搜索系统命令<code>python</code>的位置</strong>，并且返回第一个搜索结果（使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先在&lt;a href=&quot;https://www.python.org/downloads/source/&quot;&gt;Python官方网站&lt;/a&gt;中找到我们特定版本的安装包，这里我们要选择适合Linux系统的&lt;code&gt;tar.xz&lt;/code&gt;格式压缩包。我们要注意，大部分Linu</summary>
      
    
    
    
    <category term="Programming languages and projects" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/"/>
    
    <category term="Python3" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"/>
    
    
    <category term="linux" scheme="http://justskim.github.io/tags/linux/"/>
    
    <category term="python" scheme="http://justskim.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Windows系统下环境变量配置与计算机重启</title>
    <link href="http://justskim.github.io/2022/03/05/Windows%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E5%90%AF/"/>
    <id>http://justskim.github.io/2022/03/05/Windows%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E5%90%AF/</id>
    <published>2022-03-05T08:50:11.668Z</published>
    <updated>2022-03-05T09:59:52.900Z</updated>
    
    <content type="html"><![CDATA[<p>我们来看一下<a href="https://blog.csdn.net/shuixin536/article/details/8084612">对于Windows不重启使环境变量修改生效的解释</a>：</p><blockquote><p>一个程序启动时，环境变量被复制到该程序所在的环境中，在该程序执行过程中不会被除该程序以外的其他程序所改变。也就是说，假设我们启动了一个cmd程序，然后通过控制面板修改了环境变量设置，但是已经启动了的cmd所拥有的环境变量并不会被改变。如果我们在修改环境变量之后启动cmd程序，则该程序将拥有新的环境变量。<br>那么结论就很明显了：修改环境变量之后，如果受影响的是应用程序，那么只要简单地重新启动此应用程序，环境变量的修改就会反映到该程序中，而不必重新启动计算机；但是，如果受影响的是系统服务，就必须重新启动才能将环境变量的修改反映到系统服务中（因为没有办法在不重启计算机的情况下重新启动系统服务管理器）</p></blockquote><p>那么有没有什么办法可以不重启就使一切修改的环境变量配置生效呢？有，当我们很不想重启windows系统时可以尝试这么做：</p><blockquote><p>以修改环境变量“PATH”为例，修改完成后，进入DOS命令提示符，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set PATH=C: 1</span><br></pre></td></tr></table></figure><p>关闭DOS窗口。再次打开DOS窗口，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo %PATH% 1</span><br></pre></td></tr></table></figure><p>可以发现“我的电脑”-&gt;“属性”-&gt;“高级”-&gt;“环境变量”中设置的 PATH 值已经生效。<br>不用担心DOS窗口中的修改会影响环境变量的值，DOS窗口中的环境变量只是Windows环境变量的一个副本而已。但是对副本的修改却会引发Windows环境变量的刷新，这正是我们想要的！</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们来看一下&lt;a href=&quot;https://blog.csdn.net/shuixin536/article/details/8084612&quot;&gt;对于Windows不重启使环境变量修改生效的解释&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个程序启动时，环境变量被复</summary>
      
    
    
    
    <category term="Windows" scheme="http://justskim.github.io/categories/Windows/"/>
    
    
    <category term="windows" scheme="http://justskim.github.io/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>Java基础语法学习要注意的小细节</title>
    <link href="http://justskim.github.io/2022/03/02/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%B0%8F%E7%BB%86%E8%8A%82/"/>
    <id>http://justskim.github.io/2022/03/02/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%B0%8F%E7%BB%86%E8%8A%82/</id>
    <published>2022-03-01T19:38:13.360Z</published>
    <updated>2022-04-02T07:38:18.936Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java基础语法学习要注意的小细节"><a href="#Java基础语法学习要注意的小细节" class="headerlink" title="Java基础语法学习要注意的小细节"></a>Java基础语法学习要注意的小细节</h1><p><strong>最最基本的</strong></p><p><code>Java</code><strong>8</strong>和11是两个最常用的版本，也是推荐新手起步安装的版本，博主一开始使用最新的JDK17，但很多文件位置和环境配置都不同，看使用旧版本的开发教程时很麻烦。Java平台包括Java se(J2SE，标准版)  Java ee(J2EE，企业版，J2SE是其子集) Java me(J2ME，用于嵌入式的，比较少)。普通用户只需安装JER(Java Runtime Environment)来运行Java程序，而开发者必须安装JDK来对程序进行编译调试。版本的关系对应为：Java X &#x3D; Java SE X &#x3D; JDK 1.X 。</p><p>对于Java SE，<a href="https://www.huoxiaoqiang.com/experience/javae/2381.html">各大厂商的JDK</a>有所区别。官网的下载速度很慢还要注册账号，我们可以在<a href="https://blog.csdn.net/wanghao72214/article/details/109720371">推荐的三家国内jdk镜像站</a>中下载相应的JDK。其中，<a href="https://mirrors.tuna.tsinghua.edu.cn/AdoptOpenJDK/11/jdk/x64/windows/">清华大学开源软件镜像站</a>的<code>JDK</code>为Eclipse Temurin Java SE，由Eclipse基金会发布，即OpenJDK的”生产就绪“构建，免费试用，且所有版本都通过了Oracle的Java SE技术兼容性工具包测试以及Eclipse AQAvit互操作性和性能测试。不过博主还是选择了传统的OpenJDK11版本，在之后可能会再使用探究（尽可能省去麻烦）。安装<code>JDK</code>时，路径中不能有中文和空格，并且要单独取消外部公共<code>JRE</code>的安装。</p><p>虚拟机 <code>JVM</code> ⫋ 运行环境 <code>JRE</code> ⫋ 开发工具 <code>JDK </code></p><p><strong>编译的编码与修改环境变量</strong></p><p>使用命令<code>javac </code>编译<code>java</code>文件，可能会出现中文信息乱码的情况，我们首先选择添加参数<code>-encoding UTF8</code>来解决问题。但博主在卸载Java11，转而安装Java9后出现的乱码问题却无法通过此方式解决。但是博主看到在一大堆的乱码报错信息前有这么一条：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF-<span class="number">8</span></span><br></pre></td></tr></table></figure><p>这可能是博主先前想通过startup.bat文件来启动tomcat10，而千方百计设置Java11环境变量遗留下来的，于是博主在环境变量中将此系统变量移除。</p><p><img src="/images/%E5%88%A0%E9%99%A4JAVA_TOOL_OPTIONS%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%90%8E%E9%87%8D%E5%90%AF.PNG" alt="删除JAVA_TOOL_OPTIONS环境变量后重启"></p><p>重新打开一个<code>cmd</code>窗口，执行编译命令依然乱码。只好在重启后重来一次，才成功编译。</p><p><strong>文件名和类名</strong></p><p>一个<code>java</code>文件中可以有很多类，但最多只能有一个类的类名和文件名相同——如果该类被<code>public</code>修饰，那么其类名必须和文件名相同，<strong>一个<code>java</code>文件中也最多只有一个类被public修饰</strong>。</p><p>尽管windows系统下文件名不区分大小写，但为了方便起见，以及在Linux操作系统下文件能被顺利编译执行，我们所有的<code>java</code>文件名及public修饰类，以及在windows控制台下运行时输入的文件名，都要保持一致的大小写！</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>&gt;<span class="title">javac</span>  <span class="title">DEMOCONST.java</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>&gt;<span class="title">java</span>  <span class="title">DEMOCONST</span></span></span><br><span class="line"><span class="function">错误: 找不到或无法加载主类 <span class="title">DEMOCONST</span></span></span><br><span class="line"><span class="function">原因: <span class="title">java.lang.NoClassDefFoundError</span>: <span class="title">DemoConst</span> (<span class="title">wrong</span> <span class="title">name</span>: <span class="title">DEMOCONST</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>&gt;<span class="title">java</span>  <span class="title">DemoConst</span></span></span><br><span class="line"><span class="function"><span class="title">the</span> <span class="title">name</span> <span class="title">of</span> <span class="title">class</span> <span class="title">is</span> <span class="title">democonst</span></span></span><br><span class="line"><span class="function"><span class="title">true</span></span></span><br><span class="line"><span class="function"><span class="title">false</span></span></span><br><span class="line"><span class="function">#可以看到，对于文件<span class="title">Democonst.java</span>，大小写不一致情况下<span class="title">javac</span>命令能编译，但<span class="title">java</span>命令不能执行</span></span><br></pre></td></tr></table></figure><p><strong>引用路径和包</strong><br>在学习类和对象的时候，博主定义了两个程序，并将其放在同一个文件夹(cn)下，首先是定义一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//package cn;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="comment">//成员变量</span></span><br><span class="line">String name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="comment">//成员方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;eat now!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;sleep now!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;study now!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，是在另一个Java程序中使用这个类创建对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//package cn;</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;<span class="comment">//这一行可以让我们引用同一个目标文件夹下的java类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demoStudent</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line"><span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">System.out.println(<span class="string">&quot;student&#x27;s name is &quot;</span>+stu.name);</span><br><span class="line">System.out.println(<span class="string">&quot;student&#x27;s age is &quot;</span>+stu.age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们在控制台可以编译后执行程序，注意，声明后<strong>没有被赋值的成员变量会有一个默认值（但是Java中局部变量未赋值将无法通过编译）</strong></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>\<span class="title">cn</span>&gt;<span class="title">javac</span> -<span class="title">encoding</span> <span class="title">UTF</span>-8 <span class="title">demoStudent.java</span></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>\<span class="title">cn</span>&gt;<span class="title">java</span> <span class="title">demoStudent</span></span></span><br><span class="line"><span class="function"><span class="title">student</span>&#x27;<span class="title">s</span> <span class="title">name</span> <span class="title">is</span> <span class="title">null</span></span></span><br><span class="line"><span class="function"><span class="title">student</span>&#x27;<span class="title">s</span> <span class="title">age</span> <span class="title">is</span> 0</span></span><br></pre></td></tr></table></figure><p>而如果我们取消注释的代码，并将<code>import java.io.*;</code>这一行注释掉，会发现，第二个程序编译时会报错：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>\<span class="title">cn.itcast.demo</span>&gt;<span class="title">javac</span> -<span class="title">encoding</span> <span class="title">UTF</span>-8 <span class="title">demoStudent.java</span></span></span><br><span class="line"><span class="function"><span class="title">demoStudent.java</span>:5: 错误: 无法访问<span class="title">Student</span></span></span><br><span class="line"><span class="function">                <span class="title">Student</span> <span class="title">stu</span> = <span class="title">new</span> <span class="title">Student</span>();</span></span><br><span class="line"><span class="function">                ^</span></span><br><span class="line"><span class="function">  错误的源文件: .\<span class="title">Student.java</span></span></span><br><span class="line"><span class="function">    文件不包含类<span class="title">Student</span></span></span><br><span class="line"><span class="function">    请删除该文件或确保该文件位于正确的源路径子目录中。</span></span><br><span class="line"><span class="function">1 个错误</span></span><br></pre></td></tr></table></figure><p>但是这样的写法在Eclipse软件的Java项目中又是能正常运行的，因此，博主决定探究一下Java的package机制，以及其在Windows系统下的编译机制，来确定我们命令语句该怎么输入（Eclipse和IDEA这类软件肯定是把这个步骤封装好的，不过我还是要了解这个原理）。</p><p>类是Java中一种引用数据类型（Java中除了八种基本数据类型，其它的都是<strong>对象，也就是引用类型，包括数组</strong>和字符串），对其使用以下三步走：</p><ol><li>导包：<ul><li>如果要使用的目标类，和当前类（含有main方法）位于<strong>同一个包</strong>下，可以省略导包不写；</li><li>否则需要使用<code>import</code>导包语句。</li></ul></li><li>创建对象：类名称 对象名 &#x3D; new 类名称();</li><li>使用。</li></ol><p>最后，我们根据该<a href="https://blog.csdn.net/scgaliguodong123_/article/details/41804667">博客</a>提出的方法，能在命令行中正确编译并执行以上的Java文件——配置参数，编译后，<strong>返回到包名父目录</strong>，运行程序。</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>\<span class="title">cn</span>&gt;<span class="title">javac</span> -<span class="title">encoding</span> <span class="title">UTF</span>-8 -<span class="title">sourcepath</span> <span class="title">E</span>:/<span class="title">Java_practice</span> <span class="title">demoStudent.java</span></span></span><br><span class="line"><span class="function">#注意！<span class="title">sourcepath</span>参数这里不能带上任何一级的包名，就能正确编译</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>\<span class="title">cn</span>&gt;<span class="title">java</span> <span class="title">demoStudent</span></span></span><br><span class="line"><span class="function">错误: 找不到或无法加载主类 <span class="title">demoStudent</span></span></span><br><span class="line"><span class="function">原因: <span class="title">java.lang.NoClassDefFoundError</span>: <span class="title">cn</span>/<span class="title">demoStudent</span> (<span class="title">wrong</span> <span class="title">name</span>: <span class="title">demoStudent</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>\<span class="title">cn</span>&gt;<span class="title">java</span> <span class="title">cn.demoStudent</span></span></span><br><span class="line"><span class="function">错误: 找不到或无法加载主类 <span class="title">cn.demoStudent</span></span></span><br><span class="line"><span class="function">原因: <span class="title">java.lang.ClassNotFoundException</span>: <span class="title">cn.demoStudent</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>\<span class="title">cn</span>&gt;<span class="title">cd</span> ..</span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>&gt;<span class="title">java</span> <span class="title">cn.demoStudent</span></span></span><br><span class="line"><span class="function"><span class="title">student</span>&#x27;<span class="title">s</span> <span class="title">name</span> <span class="title">is</span> <span class="title">null</span></span></span><br><span class="line"><span class="function"><span class="title">student</span>&#x27;<span class="title">s</span> <span class="title">age</span> <span class="title">is</span> 0</span></span><br><span class="line"><span class="function">#在控制台编译运行，使用<span class="title">java</span>命令运行时要加上包名：<span class="title">java</span> 包名.类名</span></span><br></pre></td></tr></table></figure><p>我们重新写一下两个文件，这次弄的复杂点，我们两个文件是在多级包(<code>cn.demo</code>)下的：</p><p><img src="/images/%E5%90%8C%E4%B8%80%E4%B8%AA%E5%8C%85%E4%B8%8B%E7%9A%84%E4%B8%A4%E4%B8%AAjava%E6%96%87%E4%BB%B6.png" alt="同一个包下的两个java文件"></p><p>在控制台中使用<code>tree</code>命令查看目录结构树，可以看到，这两个文件都放在demo文件夹下：</p><p><img src="/images/%E5%8C%85cn.demo%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E6%A0%91.png" alt="包cn.demo的目录结构树"></p><p>在控制台中的正确编译运行命令如下：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>\<span class="title">cn</span>\<span class="title">demo</span>&gt;<span class="title">javac</span> -<span class="title">encoding</span> <span class="title">UTF</span>-8 -<span class="title">classpath</span> <span class="title">E</span>:/<span class="title">Java_practice</span> <span class="title">Student.java</span></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>\<span class="title">cn</span>\<span class="title">demo</span>&gt;<span class="title">javac</span> -<span class="title">encoding</span> <span class="title">UTF</span>-8 -<span class="title">classpath</span> <span class="title">E</span>:/<span class="title">Java_practice</span> <span class="title">demoStudent.java</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>\<span class="title">cn</span>\<span class="title">demo</span>&gt;<span class="title">cd</span> ..</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>\<span class="title">cn</span>&gt;<span class="title">java</span> <span class="title">demo.demoStudent</span></span></span><br><span class="line"><span class="function">错误: 找不到或无法加载主类 <span class="title">demo.demoStudent</span></span></span><br><span class="line"><span class="function">原因: <span class="title">java.lang.NoClassDefFoundError</span>: <span class="title">cn</span>/<span class="title">demo</span>/<span class="title">demoStudent</span> (<span class="title">wrong</span> <span class="title">name</span>: <span class="title">demo</span>/<span class="title">demoStudent</span>)</span></span><br><span class="line"><span class="function">#注意，是要在最顶级包的父文件夹下才能运行</span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>\<span class="title">cn</span>&gt;<span class="title">cd</span> ..</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>&gt;<span class="title">java</span> <span class="title">cn.demo.demoStudent</span></span></span><br><span class="line"><span class="function"><span class="title">student</span>&#x27;<span class="title">s</span> <span class="title">name</span> <span class="title">is</span> <span class="title">null</span></span></span><br><span class="line"><span class="function"><span class="title">student</span>&#x27;<span class="title">s</span> <span class="title">age</span> <span class="title">is</span> 0</span></span><br></pre></td></tr></table></figure><p><strong>main方法的参数<code>args[]</code></strong></p><p>所有的 Java 程序，都由 <strong>public static void main(String[] args)</strong> 方法开始执行，在一般情况下我们不会用到main方法的这个形参，但一定要加上！否则可以通过编译，但在运行时会报错：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误: 在类 mainFunction 中找不到 main 方法, 请将 main 方法定义为:</span><br><span class="line">   public static void main(String[] args)</span><br><span class="line">否则 JavaFX 应用程序类必须扩展javafx.application.Application</span><br></pre></td></tr></table></figure><p>我们下面来尝试下这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainFunction</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;打印main方法中的输入参数：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(String element: args)&#123;</span><br><span class="line">System.out.println(element);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>&gt;<span class="title">java</span> <span class="title">mainFunction</span> <span class="title">gogoing</span>,<span class="title">ukr</span>,<span class="title">xibanya</span>...<span class="title">ufo</span> -<span class="title">sss</span> <span class="title">STK1</span></span></span><br><span class="line"><span class="function">打印<span class="title">main</span>方法中的输入参数：</span></span><br><span class="line"><span class="function"><span class="title">gogoing</span>,<span class="title">ukr</span>,<span class="title">xibanya</span>...<span class="title">ufo</span></span></span><br><span class="line"><span class="function">-<span class="title">sss</span></span></span><br><span class="line"><span class="function"><span class="title">STK1</span></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>&gt;<span class="title">java</span> <span class="title">mainFunction</span> <span class="title">gogo</span>--|<span class="title">ukr</span> &quot;<span class="title">xibanya</span>&quot; &#x27;<span class="title">s</span>&#x27; <span class="title">ufo</span> -<span class="title">sss</span> <span class="title">STK1</span></span></span><br><span class="line"><span class="function">&#x27;<span class="title">ukr</span>&#x27; 不是内部或外部命令，也不是可运行的程序</span></span><br><span class="line"><span class="function">或批处理文件。</span></span><br><span class="line"><span class="function">#注意这里，符号“|”会被<span class="title">windows</span>控制台识别为过滤命令！所以报错</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>&gt;<span class="title">java</span> <span class="title">mainFunction</span> <span class="title">gogo</span>-- <span class="title">ukr</span> &quot;<span class="title">xibanya</span>&quot; &#x27;<span class="title">s</span>&#x27; <span class="title">ufo</span> -<span class="title">sss</span> <span class="title">STK1</span></span></span><br><span class="line"><span class="function">打印<span class="title">main</span>方法中的输入参数：</span></span><br><span class="line"><span class="function"><span class="title">gogo</span>--</span></span><br><span class="line"><span class="function"><span class="title">ukr</span></span></span><br><span class="line"><span class="function">0<span class="title">xibanya</span></span></span><br><span class="line"><span class="function">&#x27;<span class="title">s</span>&#x27;</span></span><br><span class="line"><span class="function"><span class="title">ufo</span></span></span><br><span class="line"><span class="function">-<span class="title">sss</span></span></span><br><span class="line"><span class="function"><span class="title">STK1</span></span></span><br><span class="line"><span class="function">#我们可以看到，输入字符串参数，是按照空格来隔开的，注意双引号的使用，单引号会正常打印</span></span><br></pre></td></tr></table></figure><p><strong>编译并执行程序</strong></p><p><code>javac</code> 可以将<code>java</code>格式源文件编译为class字节码文件，也就是把我们写的<code>java</code>代码编译成计算机能识别的内部代码；<code>java</code>则可以运行该class字节码文件。</p><p>在命令行中输入<code>javac -help</code>可以看到其<a href="https://www.cnblogs.com/wangpei/p/7084341.html">用法</a>：</p><blockquote><p>用法: javac <options> <source files></p><p><code>options</code>命令行选项。<code>sourcefiles</code>一个或多个要编译的源文件（例如 MyClass.java）</p><ul><li>如果源文件数量少，在命令行上列出文件名即可。</li><li>如果源文件数量多，则将源文件名列在一个文件中，名称间用空格或回车行来进行分隔。然后在 javac 命令行中使用该列表文件名，文件名前冠以 @ 字符</li></ul></blockquote><p>其中，**-encoding**，设置源文件编码名称，不设置则默认为操作系统默认的字符编码（windows下为<code>GBK</code>），因此我们常常发现有关编码的报错信息，我们可以使用命令<code>javac -encoding UTF8 myclass.java</code>来成功编译。</p><p><strong>能为空的，是字符串（String）还是字符（Character）</strong>?</p><blockquote><p>Java语言提供了八种基本类型：六种数字类型（四个整数型，两个浮点型），一种字符类型（<strong>char</strong>），还有一种是布尔型。</p><p>和C语言类似，Java中的char 类型是一个<strong>单一</strong>的 16 位 Unicode 字符，最小值是 **<code>\u0000</code>**（十进制等效值为 0），最大值是 **<code>\uffff</code>**（十进制下等效于 65535）；</p></blockquote><p>Character 类用于对单个字符进行操作，在对象中包装一个基本类型 char 的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="comment">// Unicode 字符表示形式</span></span><br><span class="line"><span class="type">char</span> <span class="variable">uniChar</span> <span class="operator">=</span> <span class="string">&#x27;\u039A&#x27;</span></span><br><span class="line"><span class="comment">//Character类提供了一系列方法来操纵字符，我们可以使用Character的构造方法创建一个Character类对象</span></span><br><span class="line"><span class="type">Character</span> <span class="variable">ch_object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Character</span>(<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。有两种方法：使用关键字或者构造方法来创建 String 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;SKT&quot;</span>;</span><br><span class="line">String str2=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;SSW&quot;</span>);</span><br></pre></td></tr></table></figure><p>这两种方法的区别在于：<u>String 创建的字符串存储在公共池中，而 new 创建的字符串对象在堆上</u>。</p><p>关于这一点我们日后再进行深入探究，并和<strong>JavaScript中String()与new String()的区别</strong>做对比。</p><p>我们要注意，<u>单个字符的char类型不能为空，但String对象可以为一个空字符串。跟C语言一样，单引号中的只能是一个字符，双引号中的只能是字符串，但该字符串可以只有单个字符！</u>。我们在程序中依次对下面几行进行注释，然后将<code>java</code>文件编译执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;&quot;</span>);<span class="comment">//输出一行空行</span></span><br><span class="line">System.out.println(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="comment">/*编译时就无法通过，会报错</span></span><br><span class="line"><span class="comment">DEMOCONST.java:5: 错误: 空字符文字</span></span><br><span class="line"><span class="comment">                System.out.println(&#x27;&#x27;);</span></span><br><span class="line"><span class="comment">                                   ^</span></span><br><span class="line"><span class="comment">1 个错误</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">System.out.println(<span class="literal">true</span>);<span class="comment">//输出字符串true</span></span><br><span class="line">System.out.println(<span class="literal">false</span>);<span class="comment">//输出字符串false</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="literal">null</span>); <span class="comment">//null代表空，什么都没有</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">DemoConst.java:8: 错误: 对println的引用不明确</span></span><br><span class="line"><span class="comment">                System.out.println(null);</span></span><br><span class="line"><span class="comment">                          ^</span></span><br><span class="line"><span class="comment">  PrintStream 中的方法 println(char[]) 和 PrintStream 中的方法 println(String) 都匹配</span></span><br><span class="line"><span class="comment">1 个错误</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>for-each循环</strong></p><p><code>JDK</code>1.5 中引进的一种新的循环类型，能在不使用下标的情况下遍历数组，在Python和JavaScript中也有类似语法。注意，数组索引从0开始，不能像Python那样使用负数索引！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">team</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">double</span>[] teamList = &#123;<span class="number">1.2</span>, <span class="number">3.4</span>, <span class="number">9.3</span>, <span class="number">5.5</span>&#125;;</span><br><span class="line">      <span class="comment">// 打印所有数组元素，这里的i只是一个指代其中任一元素的作用</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">double</span> i: teamList) &#123;</span><br><span class="line">         System.out.println(i);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(teamList.length);<span class="comment">//打印数组长度</span></span><br><span class="line">       System.out.println(teamList[<span class="number">99</span>]);<span class="comment">//数组越界，编译不会报错，但运行时会报错</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法重载</strong></p><p>类似于C语言，Java也有方法重载的效果，允许在一个类中,存在多个方法拥有不同的参数（无论是参数的个数还是类型、顺序），而却有相同的名字。比如我们要想用一个函数来实现数字相加和字符串拼接两个功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainFunction</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> sum(<span class="number">100</span>,<span class="number">200</span>);<span class="comment">//注意！！变量的名称可以跟方法的一样，但不推荐这么写！</span></span><br><span class="line"><span class="comment">//不必像c语言中声明方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;sum(100+200) = &quot;</span>+sum);</span><br><span class="line">System.out.println(sum(<span class="string">&quot;ssudi&quot;</span>,<span class="string">&quot;+ jhderhyiu&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a,<span class="type">double</span> b)</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> a+b;<span class="comment">//注意！！要运算的数据类型不一样时，结果为数据范围大的那一个类型！！</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">sum</span><span class="params">(String a,String b)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后，运行结果为：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>&gt;<span class="title">java</span> <span class="title">mainFunction</span></span></span><br><span class="line"><span class="function"><span class="title">sum</span>(100+200) = 300</span></span><br><span class="line"><span class="function"><span class="title">ssudi</span>+ <span class="title">jhderhyiu</span></span></span><br></pre></td></tr></table></figure><p>在其他编程语言中，Python由于可以接受任何类型的参数，对于缺少的参数也可以设置为缺省参数，因此不需要也不支持函数重载。而在JavaScript中，同一个作用域内，两个名称相同的函数，后来居上——后面的函数会覆盖前面的，这是因为<strong>声明提升</strong>——函数声明和变量声明总会被解释器提升到作用域的最顶端去执行。不过，<a href="https://segmentfault.com/a/1190000015602959">我们可以在JavaScript中实现模拟重载的效果</a>。</p><p><strong>局部变量和成员变量</strong></p><p>不同之处：</p><ol><li>定义的位置不同：局部变量定义在方法内部；成员变量直接定义在类当中，在方法外面；</li><li>内存中的位置不一样：局部变量在栈内存中，成员变量在堆内存中；</li><li>生命周期不同：局部变量随着方法的进栈而出现，方法出栈时消失；成员变量当对象被创建时出现，在对象被<code>JVM</code>回收，也就是垃圾回收时消失;</li><li>默认值不同：局部变量没有默认值，必须赋值后才可使用，成员变量声明后自动有一个默认值。</li></ol><h2 id="类方法，static修饰符"><a href="#类方法，static修饰符" class="headerlink" title="类方法，static修饰符"></a>类方法，static修饰符</h2><ul><li><p>变量，可以按照两种方式划分：</p><ol><li><p>按位置来分：成员变量——类中方法外的变量（有默认值），局部变量——类中方法内的变量；</p></li><li><p>按是否使用<code>static</code>关键字声明来分：</p><ul><li><p>类变量(静态变量)：在类中<strong>使用static关键字声明</strong>，但位于方法、构造函数、块之外。无论一个类实例化多少对象，它的静态变量只有一份拷贝。为了加以区分，我们用static声明的局部变量称之为静态局部变量；</p></li><li><p>实例变量：由类生成对象时，才分配存储空间。各对象间的实例变量互不干扰，能通过对象的引用来访问实例变量。但在Java多线程中，实例变量是多个线程共享资源，要注意同步访问时可能出现的问题。</p></li></ul></li><li><p>注意：static修饰的成员（字段和方法）应该使用<strong>类名.成员名</strong>访问，也可以使用对象名.成员名，但是不推荐。</p></li></ol></li><li><p>成员方法：类中的方法，包含：</p><ul><li>静态方法：被static修饰的成员方法，不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据；</li><li>实例方法：没有用关键字static修饰的成员方法。</li></ul></li><li><p>构造方法：类中专门用来创建对象的方法，通过<code>new</code>关键字创建对象时就是在调用构造方法，注意一下两点：</p><ol><li>构造方法<strong>不能写返回值类型！包括void也不能写！</strong></li><li>构造方法的名称必须和所在的类名称完全一致（包括大小写一致）</li></ol></li></ul><p><strong>被static修饰的成员变量和成员方法独立于该类的任何对象</strong>。也就是说，它不依赖类特定的实例，<strong>被类的所有实例共享</strong>。只要这个类被加载，Java虚拟机就能根据类名在运行时数据区或者方法区内找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。 而用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它类的对象时，不生成static变量的副本，而是类的所有实例共享同一个static变量。 这也就意味着我们可以通过类&#x2F;对象来修改静态变量的值，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String name=<span class="string">&quot;cattt&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span>  <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">ct1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        ct1.name=<span class="string">&quot;sss&quot;</span>;<span class="comment">//这一句也可以换成 Cat.name=&quot;sss&quot;;</span></span><br><span class="line">        System.out.println(Cat.name);<span class="comment">//结果为sss</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有加<code>public/private</code>修饰符的变量，默认为<code>public</code>公开类型，可以被外部调用，当然这样不安全，一般采用加<code>private</code>修饰符，配合特定<code>setter/getter</code>方法的使用。</p><p>我们接着来看一下，<code>static</code>修饰符在类中的应用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">String name;String address;<span class="type">int</span> age;</span><br><span class="line"><span class="keyword">static</span> <span class="type">String</span> <span class="variable">country</span> <span class="operator">=</span> <span class="string">&quot;大清&quot;</span>;<span class="comment">//被static修饰的静态变量</span></span><br><span class="line"><span class="comment">//构造方法的名称必须跟类名称相同！</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name,String address)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="built_in">this</span>.address = address;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;北平&quot;</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;南昌&quot;</span>);</span><br><span class="line"><span class="comment">//下面我们对数值分别进行更改</span></span><br><span class="line">p1.country = <span class="string">&quot;民国&quot;</span>;<span class="comment">//不推荐这样使用静态变量</span></span><br><span class="line">p1.address = <span class="string">&quot;北京&quot;</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;p1.country = &quot;</span>+p1.country+<span class="string">&quot;\np1.address = &quot;</span>+p1.address+<span class="string">&quot;\np1.age = &quot;</span>+p1.age);</span><br><span class="line">System.out.println(<span class="string">&quot;p2.country = &quot;</span>+p2.country+<span class="string">&quot;\np2.address = &quot;</span>+p2.address+<span class="string">&quot;\np2.age = &quot;</span>+p2.age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>\<span class="title">cn</span>\<span class="title">demo</span>&gt;<span class="title">java</span> <span class="title">Person</span></span></span><br><span class="line"><span class="function"><span class="title">p1.country</span> = 民国</span></span><br><span class="line"><span class="function"><span class="title">p1.address</span> = 北京</span></span><br><span class="line"><span class="function"><span class="title">p1.age</span> = 0#<span class="title">int</span>类型的成员变量默认值为0</span></span><br><span class="line"><span class="function"><span class="title">p2.country</span> = 民国</span></span><br><span class="line"><span class="function"><span class="title">p2.address</span> = 南昌</span></span><br><span class="line"><span class="function"><span class="title">p2.age</span> = 0</span></span><br></pre></td></tr></table></figure><p>可以看到，我们只更改了对象<code>p1</code>中的country属性，但因为这是个被<code>static</code>修饰的静态变量，因此所有由<code>Person</code>类所构造的对象中，这一项属性都改变了。</p><h3 id="静态变量与实例化"><a href="#静态变量与实例化" class="headerlink" title="静态变量与实例化"></a>静态变量与实例化</h3><p>我们首先写一个程序，这里有静态变量和静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">staticFunction</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//实例变量</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">99</span>;<span class="comment">//静态变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printCountpublic</span><span class="params">()</span>&#123;</span><br><span class="line">count++; </span><br><span class="line">System.out.println(<span class="string">&quot;Now,count = &quot;</span>+count+age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printCountstatic</span><span class="params">()</span>&#123;</span><br><span class="line">count+=<span class="number">10</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;Now,count = &quot;</span>+count);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序将无法编译通过，并报错：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>\<span class="title">cn</span>\<span class="title">demo</span>&gt;<span class="title">javac</span> -<span class="title">encoding</span> <span class="title">UTF</span>-8 <span class="title">staticFunction.java</span></span></span><br><span class="line"><span class="function"><span class="title">staticFunction.java</span>:9: 错误: 无法从静态上下文中引用非静态变量 <span class="title">count</span></span></span><br><span class="line"><span class="function">                <span class="title">count</span>+=10;</span></span><br><span class="line"><span class="function">                ^</span></span><br><span class="line"><span class="function"><span class="title">staticFunction.java</span>:10: 错误: 无法从静态上下文中引用非静态变量 <span class="title">count</span></span></span><br><span class="line"><span class="function">                <span class="title">System.out.println</span>(&quot;<span class="title">Now</span>,<span class="title">count</span> = &quot;+<span class="title">count</span>);</span></span><br><span class="line"><span class="function">                                                  ^</span></span><br><span class="line"><span class="function">2 个错误</span></span><br></pre></td></tr></table></figure><p>报错原因是：静态方法只能访问静态变量；如果<strong>要让静态方法访问动态变量</strong>，<strong>必须将动态变量实例化</strong>。</p><p><strong>继承与静态</strong></p><p>我们创建一个父类<code>LiYua</code>和一个继承它的子类<code>LiShiMing</code>，并在父类中定义了静态变量，静态方法与实例变量，实例方法。可以看到，IDEA软件会智能提示能否使用该类&#x2F;对象的属性&#x2F;方法（在我们输入的时候可以看到在其智能提示输入中是否存在该项），时刻牢记，<code>static</code>修饰的静态变量&#x2F;方法，只存在一份拷贝，可以被类&#x2F;对象调用，我们可以通过子类使用它们，但这不是继承！<em>原因</em>：继承是对于实体而言的，而静态的东西不属于实体，也可以说，静态与类是一个级别。</p><p>但是实例变量只能在创建对象（也就是实例化）之后通过该对象进行调用：</p><p><img src="/images/%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%99%E6%80%81.PNG" alt="继承与静态"></p><p><strong>多态，向上&#x2F;下转型</strong></p><p>在学会继承之后，我们可以定义一个父类<code>Animal</code>，在其中定义一个实例方法<code>eat</code>，这样，无论我们定义多少个该父类下的子类（比如猫狗鸡鸭鹅），都有一个继承来的<code>eat</code>方法，就不必在这些子类的Java代码中编写了。那么，问题来了，如果我们要编写一个<code>feed</code>方法来代表喂养动物，由于这些动物的子类是不同的，意味着作为传入到<code>feed</code>函数中的参数也是不同的类，那我们岂不是要在代码中重载（<strong>在一个类中的叫重载，子类对父类方法的叫重写</strong>）很多个<code>feed</code>方法？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Cat cat01)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Dog dg01)</span>&#123;&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>事实上我们不用这么干，只需要利用多态的向上转型：类的对象赋给了父类的引用，这样的缺点是屏蔽掉子类中特有的方法，然后我们只定义参数为父类<code>Animal</code>型对象的一个<code>feed</code>函数即可，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">ani1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"><span class="type">Animal</span> <span class="variable">ani2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Animal ani)</span>&#123;ani.eat();&#125;</span><br></pre></td></tr></table></figure><p>但是，这样子，对象<code>ani2</code>这只狗只是被当作动物看待，无法使用<code>Dog</code>子类中的一个特有方法<code>guard</code>，为了解决这一点，我们可以使用向下转型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span>  <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Animal</span> <span class="variable">ani1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">    <span class="comment">//向上转型——子类的对象赋给了父类的引用，猫狗当做动物来看，会屏蔽掉类中特有的方法</span></span><br><span class="line">    <span class="type">Animal</span> <span class="variable">ani2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">ani0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">pr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="comment">//ani0.feed(ani1);这一个就报错了，原因在于ani0已经向上转型成父类型Animal，没有了feed函数</span></span><br><span class="line">        pr.feed(ani1);</span><br><span class="line">        <span class="comment">//pr.feed(ani2);这一处的错误在于ani2没有被我们定义成静态变量而是实例化变量</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">ani3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">//ani3.guard();    输入ani3后，在IDEA给的输入提示里面选择guard，会自动将ani3.guard修改为((Dog) ani3).guard();</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dg</span> <span class="operator">=</span> (Dog) ani3;<span class="comment">//向下转型</span></span><br><span class="line">        dg.guard();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Animal ani)</span>&#123;</span><br><span class="line">        ani.eat();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Cat ct)</span>&#123;ct.eat();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java中由于继承和向上转型的存在，子类型可以非常自然地转成父类，但向下转型，即父类转子类，必须强制转型。Java中的基本数据转型也是强制转型。</p><p>注意，如果子类重写了父类的方法，子类对象<strong>向上转型</strong>之后，调用的还是<strong>重载之后的子类方法</strong>。</p><p><strong>一个子类，只能继承一个父类，但可以实现多个接口</strong></p><p>接口这一块主要是架构师来负责的内容。我们定义两个接口<code>Valuable</code>和<code>Protectable</code>，由类<code>Panda</code>来继承父类<code>Animal</code>，并实现这两个接口，如上面所说的，执行的是子类<code>Panda</code>对象的<code>eat</code>方法，重写后将父类的覆盖了：</p><p><img src="/images/%E7%BB%A7%E6%89%BF%E4%B8%80%E4%B8%AA%E7%88%B6%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3.PNG" alt="继承一个父类实现多个接口"></p><p>注意，<strong>无论抽象类还是实体类都只能implements实现接口，能extends继承接口的只能是接口，接口可以继承多个接口</strong>。</p><p><strong>instanceof关键字与父子类</strong></p><p>根据相关定义：</p><blockquote><p>instanceof 是 Java 的一个二元操作符，类似于 &#x3D;&#x3D;，&gt;，&lt; 等操作符。作用是测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型。</p></blockquote><p>我们用下面一个例子来说明，<code>Panda</code>是继承自<code>Animal</code>的子类，可以看到，<strong>子类对象既是子类的实例，又是父类的实例</strong>，但反过来就不是了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Panda</span> <span class="variable">panda</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Panda</span>();</span><br><span class="line">System.out.println(panda <span class="keyword">instanceof</span> Panda);<span class="comment">//true</span></span><br><span class="line">System.out.println(panda <span class="keyword">instanceof</span> Animal);<span class="comment">//true</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> (Animal)panda;</span><br><span class="line">System.out.println(animal <span class="keyword">instanceof</span> Panda);<span class="comment">//true</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">yuan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line"><span class="comment">//Panda panda1 = (Panda)yuan; 这种做法是不被允许的！</span></span><br><span class="line">System.out.println(yuan <span class="keyword">instanceof</span> Panda);<span class="comment">//false</span></span><br><span class="line"><span class="type">Panda</span> <span class="variable">panda2</span> <span class="operator">=</span> (Panda)animal;</span><br><span class="line">System.out.println(panda2 <span class="keyword">instanceof</span> Panda);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>被注释掉的那行代码<code>Panda panda1 = (Panda)yuan</code>会报错，是因为这并不是向下转型——Java中，只有是<u>由子类对象向上转型转成的</u>父类对象，才能向下转型又再次成为子类对象！！</p><h3 id="静态构造器"><a href="#静态构造器" class="headerlink" title="静态构造器"></a>静态构造器</h3><p>又称静态构造函数，是实现对一个类进行初始化的方法成员，一般用于对静态数据的初始化（<strong>静态变量也是最先初始化的</strong>）。静态构造函数不能有参数，不能有修饰符，不能被调用。当类被加载时，类的静态构造函数自动被调用。因此，在一个程序的执行过程中，静态构造器<strong>最多执行一次</strong>。注意执行顺序：</p><ol><li><p>静态构造器在任何类的静态成员被引用之前执行；</p></li><li><p>静态构造器在任何类的实例变量被分配之前执行；</p></li><li><p>静态构造器在类的静态成员初始化之后执行，或者说编译器会将静态成员初始化语句转换成赋值语句放在静态构造器执行的最开始。</p></li></ol><p>我们用下面这个例子来实践一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">staticTest</span>&#123;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;这里是通用构造器&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;静态构造器&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">staticTest</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;构造方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="comment">//在主方法中调用构造方法，创建一个对象，就不用再写一个java程序来验证了</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">staticTest</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，可以看到，静态构造器是最先被执行的。</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>\<span class="title">cn</span>\<span class="title">demo</span>&gt;<span class="title">java</span> <span class="title">staticTest</span></span></span><br><span class="line"><span class="function">静态构造器</span></span><br><span class="line"><span class="function">这里是通用构造器</span></span><br><span class="line"><span class="function">构造方法</span></span><br></pre></td></tr></table></figure><p>在有继承的情况下，执行顺序为：<strong>父类静态代码块 &gt; 子类静态代码块 &gt; 父类构造代码块 &gt; 父类构造器 &gt; 子类构造代码块 &gt; 子类构造器</strong></p><p><strong>Java语言中，标准类（pojo类）</strong></p><p><code>POJO</code>的全称为<code>plain old java object</code>，可以翻译成：普通Java类。主要用于数据的临时传递，但它只能装载数据， 作为数据存储的载体，而不具有业务逻辑处理的能力，也就是说，<u><code>POJO</code>类中不允许有业务方法，也不能携带connection之类的方法</u>。</p><p>**<a name="标准类的四个必要条件">标准类的四个<u>必要</u>组成部分</a>**（四个必要条件）</p><ol><li>所有的成员<strong>变量</strong>都要使用 private 关键字进行修饰；</li><li>为每一个成员变量编写 set、get 方法；</li><li>创建一个无参数的构造方法；</li><li>创建一个有参数的构造方法。</li></ol><p><strong>pojo类和java bean的关系</strong></p><p><a href="https://blog.csdn.net/tiantangdizhibuxiang/article/details/81784873">博客</a></p><blockquote><p>按着Sun公司的定义，Java Bean是一个可重复使用的软件组件。实际上Java Bean是一种<a href="https://so.csdn.net/so/search?q=Java&spm=1001.2101.3001.7020">Java</a>类，通过封装属性和方法成为具有某种功能或者处理某个业务的对象，简称bean。</p><p><code>JavaBean</code> 是一种JAVA语言写成的可重用组件，不是一种技术，而是一种规范，它的方法命名，构造及行为必须符合特定的约定：</p><ol><li>这个类必须有一个公共的缺省构造函数；</li><li>这个类的属性使用getter和setter来访问，其他方法遵从标准命名规范;</li><li>这个类应是可<strong>序列化</strong>的（一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象——详见<a href="https://www.runoob.com/java/java-serialization.html">类的序列化</a>）。</li></ol><p><code>Java Bean</code>的任务可以概括为: “Write once, run anywhere, reuse everywhere”，即“一次性编写，任何地方执行，任何地方重用”。可分为两种：</p><ol><li>是有用户界面（UI，User Interface）的Java Bean；</li><li>没有用户界面，主要负责处理事务（如数据运算，操纵数据库）的Java Bean（部署于网络服务器上的<code>JSP</code>，又称<code>JavaServer Pages</code>，通常访问的是这一种Java Bean）。</li></ol><p>简而言之，当一个<code>PoJo</code>可序列化，有一个无参的构造函数，使用getter和setter方法来访问属性时，他就是一个Java Bean。</p></blockquote><p>然而，通常情况下，由于 Java Bean 是被容器所创建（如 Tomcat) 的，<strong>所以 Java Bean 应具有一个无参的构造器</strong>，另外，通常 <strong>Java Bean 还要实现 <code>Serializable</code> 接口用于实现 Bean 的持久性</strong>。 Java Bean 是不能被跨进程访问的。一般在web应用程序中建立一个数据库的映射对象时，我们只能称它为<code>POJO</code>——一个普通Java对象，而不是一个特殊的对象，其主要用来指代那些没有遵从特定的Java对象模型、约定或框架（如<code>EJB</code>）的Java对象。理想地讲，一个<code>POJO</code>是一个不受任何限制的Java对象（除了Java语言规范）</p><p>Java中还有很多特定类（<code>entity</code>、 <code>VO</code> 、<code>DTO</code>等）的概念和作用，我们详见好心人整理的<a href="https://www.pianshen.com/article/5933825452/">专栏</a>和<a href="https://www.cnblogs.com/feily/articles/14225139.html">博客</a>。</p><p><img src="/images/java%E5%90%84%E7%A7%8D%E7%B1%BB%E5%9C%A8%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8.png" alt="java各种类在实际项目中的运用"></p><p>我们再顺便了解另一个概念：<strong>entity(实体类)</strong></p><p>通常定义在model层里面，一个实体映射一张表，其中的<strong>属性</strong>对应数据表中的<strong>字段</strong>，，一般无业务逻辑代码。</p><p>entity类也要满足<a href="#标准类的四个必要条件">普通JavaBeans类的四个必要条件</a>，这篇<a href="https://blog.csdn.net/u012393192/article/details/80808237">博客</a>还介绍了entity的其他优点：</p><ol><li>对象实体的封装，体现<strong>OO(Object Oriented面向对象)思想</strong>——Java是面向对象的语言，由于面向对象有<strong>封装、继承、多态</strong>性的特性，可以设计出低耦合的系统，并使系统更加灵活和易于维护，缺点是性能比面向过程的低；</li><li>entity类中的属性可以对字段定义和状态进行判断和过滤；</li><li>一个数据库表映射成一个实体类，对数据库操作起来方便（在程序中可以把实体类作为参数传递），使程序员程序员在对数据库操作的时候不用写<code>SQL</code>语句,专注逻辑关系。换句话说，实体类就是把对某一个数据表（table）的操作全写在一个类里面：创建一个Entity Bean对象相当于创建一条记录，删除一个Entity Bean对象会同时从数据库中删除对应记录，修改一个Entity Bean时，容器会自动将Entity Bean的状态和数据库同步。</li></ol><p>另外，在Java开发中对于定义entity类的总结经验如下：</p><ul><li><p>实体类的名字尽量和数据库的表的名字对应相同；</p></li><li><p>实体类应该实现<code>java.io.Serializable</code>接口；</p></li><li><p>实体类应该有个无参的构造方法；</p></li><li><p>实体类应该至少有一个有参数的构造方法；</p></li><li><p>实体类有属性和方法，属性对应数据库中表的字段，主要有getter和setter方法。</p></li><li><p>实体类还应该有个属性<code>serialVersionUID</code>。例如：<code>private static final long serialVersionUID = -6125297654796395674L;</code></p></li><li><p>在实体类中，<strong>属性</strong>一般是<strong>private</strong>类型，而<strong>方法</strong>为<strong>public</strong>类型，对于数据库自动生成的ID字段对应的属性的<strong>set方法应为private</strong>。</p></li></ul><h2 id="引用和引用数据类型"><a href="#引用和引用数据类型" class="headerlink" title="引用和引用数据类型"></a>引用和引用数据类型</h2><p>Java中的数据类型可以分为两类，基本数据类型（只有八种），其他的都是**引用数据类型：类(class)、 接口类型(interface)、 数组类型(array)、 枚举类型(enum)、 注解类型(annotation)、 字符串型(string)**（这些都在<code>java.lang.*</code>下），如果我们不定义的话，这些都默认为强引用<br><a href="https://www.cnblogs.com/maskwolf/p/9972982.html">基本数据类型和引用数据类型区别</a>：</p><blockquote><ol><li><p>存储位置：</p><ul><li>基本变量类型：在方法中定义的非全局基本数据类型变量的具体内容是存储在栈中的</li><li>引用变量类型：具体内容都是存放在堆中的，而栈中存放的是其具体内容所在内存的地址（通过变量地址可以找到变量的具体内容，就如同通过房间号可以找到房间一般）</li></ul></li><li><p>传递方式：</p><ul><li>基本类型变量：在方法中定义的非全局基本数据类型变量，调用方法时作为参数是按数值传递的</li><li>引用类型变量：调用方法时作为参数是按引用传递的，传递的是引用的副本</li></ul></li></ol></blockquote><p><strong>Java注解</strong></p><p>Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。在编译时注解会被检查，但执行的时候不会被执行到。</p><p>Java 语言中的类、方法、变量、参数和包等都可以被标注。和 Javadoc 不同，Java  标注可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 ，Java也支持自定义 Java 标注。</p><blockquote><p>Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。</p><p><strong>作用在代码的注解是</strong></p><ul><li>@Override - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li><li>@Deprecated - 标记过时方法。如果使用该方法，会报编译警告。</li><li>@SuppressWarnings - 指示编译器去忽略注解中声明的警告。</li></ul><p>作用在其他注解的注解(或者说 元注解)是:</p><ul><li>@Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</li><li>@Documented - 标记这些注解是否包含在用户文档中。</li><li>@Target - 标记这个注解应该是哪种 Java 成员。</li><li>@Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)</li></ul><p>从 Java 7 开始，额外添加了 3 个注解:</p><ul><li>@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li><li>@FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。</li><li>@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</li></ul></blockquote><p>以重写的<code>@Override</code>注解为例，即使我们不在重写方法的上一行加上此注解，依然可以运行，只是不方便后续程序维护（比如重写的函数名写错的情况）</p><p><strong>包装类</strong></p><p>包装类：将基本数据类型封装成一个类，包含的方法基本相同。java中的包装类提供了将原始数据类型转换为对象，以及将对象转换为原始数据类型的机制。包装类属于<strong>引用数据类型</strong>， 其中6个包装类（Double、Float、Byte、Short、Integer 以及 Long）都是 Number 这一个<strong>抽象类</strong>（因此其不能直接实例化，而是必须实例化其具体的子类）的子类。<code>java.lang.Number</code>的父类是Object类。</p><p>Object 类存储在**java.lang.<em><strong>包中，是所有java类 (Object 类除外)的终极</strong>父类</em><em>。Java中规定：如果一个类没有显式声明它的父类，那么默认这个类的父类就是java.lang.Object 。注意，</em>子类是抽象类，父类也不一定是抽象类*（比如Object 是具体类，却是Number的父类，只要子类添加了自己的抽象方法，子类就必须是抽象类而无论其父类是不是。不过父类是具体类，而其唯一的子类是抽象类的情况没有使用的必要）</p><p>原始类型不能为<code>null</code>，但包装类可以为<code>null</code>，因此包装类可用于实现多态性。</p><table><thead><tr><th>基本数据类型</th><th>包装类型</th><th>该包装类的父类</th></tr></thead><tbody><tr><td>byte</td><td>java.lang.Byte</td><td>java.lang.Number</td></tr><tr><td>short</td><td>java.lang.Short</td><td>java.lang.Number</td></tr><tr><td>int</td><td>java.lang.Integer</td><td>java.lang.Number</td></tr><tr><td>long</td><td>java.lang.Long</td><td>java.lang.Number</td></tr><tr><td>float</td><td>java.lang.Float</td><td>java.lang.Number</td></tr><tr><td>double</td><td>java.lang.Double</td><td>java.lang.Number</td></tr><tr><td>boolean</td><td>java.lang.Boolean</td><td>java.lang.Object</td></tr><tr><td>char</td><td>java.lang.Character</td><td>java.lang.Object</td></tr></tbody></table><p>包装类的构造方法：</p><ol><li><p><code>Integer(int number);</code>传入一个int值.获取一个Integer类.来操作；</p></li><li><p><code>Integer(String str);</code> 传入一个字符串.用字符串来获取Integer对象<br>我们要注意两个名词：<a href="https://blog.csdn.net/xxyneymar/article/details/120223189">装箱和拆箱</a></p><blockquote><p><em>装箱</em>：基本数据类型–(转换为)–&gt;引用数据类型<br><em>拆箱</em>：引用数据类型–(转化为)–&gt;基本数据类型<br>在JDK1.5之后，支持<em>自动装箱和自动拆箱机制</em>了。<br>自动装箱：基本数据类型自动转换成包装类。<br>自动拆箱：包装类自动转换成基本数据类型。<br><img src="https://img-blog.csdnimg.cn/2021091016343182.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeHh5bmV5bWFy,size_20,color_FFFFFF,t_70,g_se,x_16" alt="转换"></p></blockquote></li></ol><p><strong>Java集合类</strong></p><p>Java集合类存放于 java.util 包中（需要收到<code>import</code>引入），是一个用来存放对象的容器。</p><p>注意：①、集合<strong>只能存放对象</strong>。比如你存一个 int 型数据 1放入集合中，其实它是<em>自动转换成 Integer 类</em>后存入的，Java中每一种基本类型都有对应的引用类型。</p><p>　　　②、集合存放的是多个对象的引用，对象本身还是放在堆内存中。</p><p>　　　③、集合可以存放不同类型，不限数量的数据类型。</p><p>定义集合的示例：<code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</code></p><p><strong>集合类体系结构</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A(集合)--&gt;B1(Collection)</span><br><span class="line">A--&gt;B2(Map)</span><br><span class="line">B1--&gt;C1(List)</span><br><span class="line">C1--&gt;E1(ArrayList)</span><br><span class="line">C1--&gt;E2(LinkedList)</span><br><span class="line">C1--&gt;E3(.....)</span><br><span class="line">B1--&gt;C2(Set)</span><br><span class="line">C2--&gt;F1(HashSet)</span><br><span class="line">C2--&gt;F2(TreeSet)</span><br><span class="line">C2--&gt;F3(.....)</span><br><span class="line">B2--&gt;D1(HashMap)</span><br><span class="line">B2--&gt;D2(....)</span><br></pre></td></tr></table></figure><p>其中，最底层的是具体的实现类，而第二、三层的诸如Collection，Map，List，Set和HashMap等实际只是接口。Set和List区别在于其中元素能否重复。和单列的Collection不同，Map是“key -&gt; value”对的存储方式，即双列结构。runoob网站中对此有一个简单的介绍：</p><blockquote><p>Java 集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键&#x2F;值对映射。Collection 接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 <a href="https://www.runoob.com/java/java-arraylist.html">ArrayList</a>、<a href="https://www.runoob.com/java/java-linkedlist.html">LinkedList</a>、<a href="https://www.runoob.com/java/java-hashset.html">HashSet</a>、LinkedHashSet、<a href="https://www.runoob.com/java/java-hashmap.html">HashMap</a>、LinkedHashMap 等等。</p></blockquote><p>注意，<strong>JDK不提供单例集合的顶层接口——Collection的任何直接实现，而只提供更具体的子接口（Set和List等）的实现</strong>，这很正常，毕竟这些数据结构差别太大。注意Collection和Collection<strong>s</strong>的区别：</p><blockquote><p>java.util.Collection 是一个 <strong>集合接口</strong>。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。</p><p>而java.util.Collections 是一个包装类。它包含有各种有关集合操作的 <strong>静态多态方法</strong>。此类 <strong>不能实例化</strong>，就像一 <strong>个工具类</strong>，服务于Java的Collection框架。</p></blockquote><p>创建Collection集合对象的方式有以下两种：</p><ol><li><p>通过多态：比如<code>Collection &lt;String&gt; c = new ArrayList&lt;String&gt;();</code>其中“&lt;&gt;”中是集合汇总元素的类型。<a href="https://blog.csdn.net/weixin_39946313/article/details/114173639">集合类的定义</a>：</p><blockquote><p>集合类是放在java.util.*；这个包里。集合类存放的都是对象的引用，而非对象本身，为了说起来方便些，我们称集合中的对象就是指集合中对象的引用(reference)。引用的概念大家不会忘了吧，在前边我们讲数据类型时讲的。 集合类型主要有3种：set(集)、list(列表)、map(映射)和Queue(队列)。&#x2F;&#x2F;队列为jdk5中的加上的</p></blockquote></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">collection_demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        arrayList.add(<span class="string">&quot;adc&quot;</span>);</span><br><span class="line">        arrayList.add(<span class="number">1222</span>);</span><br><span class="line">        System.out.println(arrayList);</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">ap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();<span class="comment">//这么写没有问题</span></span><br><span class="line">        <span class="comment">//Collection是一个接口，new的是接口的实现类ArrayList，像我们上边所讲的</span></span><br><span class="line">        ap.add(<span class="string">&quot;jdsi&quot;</span>);</span><br><span class="line">        System.out.println(ap);</span><br><span class="line">        Collection &lt;Integer&gt; ad = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        ad.add(<span class="string">&quot;jdsi&quot;</span>);<span class="comment">//会报错  java: 不兼容的类型: java.lang.String无法转换为java.lang.Integer</span></span><br><span class="line">        ad.add(<span class="number">8</span>);</span><br><span class="line">        System.out.println(ap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用具体的实现类ArrayList</li></ol><p><strong>Collection集合的遍历——迭代器的使用</strong></p><p><a href="https://www.runoob.com/java/java-iterator.html">runoob的集合框架中这么描述迭代器</a>：</p><blockquote><p>Java Iterator（迭代器）不是一个集合，它是一种用于访问集合的方法，可用于迭代 <a href="https://www.runoob.com/java/java-arraylist.html">ArrayList</a> 和 <a href="https://www.runoob.com/java/java-hashset.html">HashSet</a> 等集合。</p><p>Iterator 是 Java 迭代器最简单的实现，ListIterator 是 Collection API 中的接口， 它扩展了 Iterator 接口。</p></blockquote><p>在<code>JDK 11</code>文档中Collection集合的方法下可以找到一个<code>iterator</code>方法，是返回此集合中元素的迭代器。其返回值的变量类型为<code>Iterator&lt;E&gt;</code>。</p><p><code>Iterator&lt;E&gt;</code>中常用的方法有：</p><table><thead><tr><th>变量和类型</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>default void</code></td><td><code>forEachRemaining(Consumer&lt;? super E&gt; action)</code></td><td>对每个剩余元素执行给定操作，直到处理完所有元素或操作引发异常。</td></tr><tr><td><code>boolean</code></td><td><code>hasNext()</code></td><td>如果迭代具有更多元素，则返回 <code>true</code> 。</td></tr><tr><td><code>E</code></td><td><code>next()</code></td><td>返回迭代中的下一个元素。</td></tr><tr><td><code>default void</code></td><td><code>remove()</code></td><td>从底层集合中移除此迭代器返回的最后一个元素（可选操作）。</td></tr></tbody></table><p>其中，<em>java</em>中&lt;<strong>E**&gt;是表示泛型，就是指任意类型，这也符合<code>next</code>函数返回迭代中下一个元素的作用。类似的</strong>java 中泛型标记符：**为了易于分辨，约定俗成的写法有以下这几种：</p><ul><li><p><strong>E</strong> - Element (在集合中使用，因为集合中存放的是元素)</p></li><li><p><strong>T</strong> - Type（Java 类）</p></li><li><p><strong>K</strong> - Key（键）</p></li><li><p><strong>V</strong> - Value（值）</p></li><li><p><strong>N</strong> - Number（数值类型）</p></li><li><p><strong>？</strong> - 表示不确定的 java 类型</p></li></ul><p>Java中迭代器的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();<span class="comment">//创建集合对象，这里的对象是String类型，我们当然也可以用自定义的类，比如Collection&lt;Student&gt;创建学生类的集合对象</span></span><br><span class="line">c.add(<span class="string">&quot;hello&quot;</span>);c.add(<span class="string">&quot;world&quot;</span>);c.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">Iterator&lt;String&gt; it = c.iterator();<span class="comment">//通过集合对象获取迭代器对象，注意类型要相同</span></span><br><span class="line">System.out.println(<span class="string">&quot;it = &quot;</span>+it);<span class="comment">//it = java.util.ArrayList$Itr@5ebec15</span></span><br><span class="line">System.out.println(it.next());<span class="comment">//hello</span></span><br><span class="line">System.out.println(it.next());<span class="comment">//world</span></span><br><span class="line">System.out.println(it.next());<span class="comment">//java</span></span><br></pre></td></tr></table></figure><p>如果迭代没有更多元素，那么<code>next</code>方法将会抛出异常<code>NoSuchElementException</code>。</p><p>注意，如果给<code>Set</code>集合添加两个相同的元素，不会报错，但<code>Set</code>集合中只会存在一个元素。</p><p>Java中有四种引用——引用强度和生命周期长度依次为：强引用&gt;软引用＞弱引用＞虚引用。（JDK1.2之后的引用概念扩充）</p><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>默认声明的就是强引用，比如<code>Object obj = new Object()</code>，只要obj还指向Object对象（也就是强引用还存在），Object对象就不会被垃圾回收器回收。即使内存不足时，<code>JVM</code>也会直接抛出<code>OutOfMemoryError</code>而不会去回收。若想中断强引用与对象之间的联系，可以将强引用赋值为null。另外的，字符串<code>String str = new String();</code>也是强引用类型，不过使用时是默认导入了<code>java.lang.String</code>包（<code>java.lang.*</code>不用我们导入，编译器会自动导入）</p><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>描述一些非必需但仍有用的对象。<strong>在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常</strong>。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。在 JDK1.2 之后，用java.lang.ref.SoftReference类来表示软引用。</p><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了<strong>只具有弱引用</strong>的对象，不管当前内存空间足够与否，都会回收它的内存——也就是说，<strong>无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收</strong>。在 JDK1.2 之后，用 java.lang.ref.WeakReference 来表示弱引用。</p><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>又称为“幽灵引用”或“幻影引用”，最弱的一种引用关系，其存在与否，不会对对象的生存产生任何影响，且也无法通过虚引用来获得对象实例。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收。创建虚引用需要使用java.lang.ref.PhantomReference。这个类的源码中只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象。与软引用、弱引用不同的是，虚引用必须要和 ReferenceQueue 引用队列一起使用。</p><h3 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h3><p>引用队列可以与软引用、弱引用以及虚引用一起配合使用（强引用自然不行），当垃圾回收器准备回收一个对象时，如果发现它还有引用，那么就会在回收对象之前，把这个引用加入到与之关联的引用队列中去。程序可以通过判断引用队列中是否已经加入了引用，来判断被引用的对象是否将要被垃圾回收，这样就可以在对象被回收之前采取一些必要的措施。牢记：虚引用必须和引用队列一起使用。</p><p><strong>接口类型的变量</strong></p><p>Java中接口不能实例化对象，但可以<strong>使用接口类型来声明一个变量</strong>，使其成为一个空指针，或是被绑定在一个以此接口实现的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*！这种方式是错误的，能实例化对象的必须是具体类！</span></span><br><span class="line"><span class="comment">public interface Person&#123;&#125;</span></span><br><span class="line"><span class="comment">Person person = new Person();*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现接口的子类可以通过创建对象赋值给接口</span></span><br><span class="line"><span class="comment">//声明变量被绑定在一个以此为接口实现的对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Anim</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Anim</span>&#123;&#125;</span><br><span class="line"><span class="type">Anim</span> <span class="variable">anim</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意，子类创建对象赋值给接口后，接口再赋值给子类需要强制转换</span></span><br><span class="line"><span class="type">Anim</span> <span class="variable">anim</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"><span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat)anim;</span><br></pre></td></tr></table></figure><h2 id="类与导包import"><a href="#类与导包import" class="headerlink" title="类与导包import"></a>类与导包import</h2><p>所有的类都需要导包才能使用，除了两种情况：</p><ol><li>要使用的目标类，和当前类位于同一个包（package）下；</li><li>要使用的目标类，位于<code>java.lang</code>包下，但是不包含子包内容（比如路径<code>C:\Program Files\Java\jdk-11.0.2\lib\src\java.base\java\lang\reflect</code>下的Field.java这一个类，就需要引用）</li></ol><p>我们使用的字符串对象，是String类，其实就属于第二种情况，在博主使用的JDK11版本中，我们可以在路径<code>C:\Program Files\Java\jdk-11.0.2\lib\src\java.base\java\lang</code>看到文件<code>String.java</code>。</p><p>字符串是对象，却可以原封不动打印出来，是因为<code>println</code>方法的判断逻辑：</p><ol><li>若是字符串类型，直接显示内容；</li><li>若不是字符串类型，就将其内部通过某些方法转换成字符串再显示（参考定义println方法的源码可知，比如int基本数据类型的会被String.valueOf方法转换为字符串类型）；</li><li>最终打印出来的一定是字符串类型。</li></ol><p>比方说，我们引入一个使用自定Employee类的程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo_println</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">Employee</span> <span class="variable">adc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;adcssss&quot;</span>);</span><br><span class="line">System.out.println(adc);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台中的打印结果：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>&gt;<span class="title">java</span> <span class="title">Demo_println</span></span></span><br><span class="line"><span class="function"><span class="title">Employee</span>@512<span class="title">ddf17</span></span></span><br><span class="line"><span class="function">#一般的对象都是使用“类型信息+@+地址值”来作为字符串内容</span></span><br></pre></td></tr></table></figure><h3 id="类、实例与Class类、Class对象"><a href="#类、实例与Class类、Class对象" class="headerlink" title="类、实例与Class类、Class对象"></a>类、实例与Class类、Class对象</h3><p>通俗约定，Java中类用class(首字母小写)来表示。前面我们知道，new 一个对象，就是对类的实例化。</p><p>类的生命周期：加载—验证—准备—解析—初始化—使用—卸载</p><p><strong>Class</strong>，注意首字母大写！在java中是一个实际存在的类，在包<code>java.lang</code>下，有一个<code>Class.java</code>文件，<code>jdk 11</code>文档中对其有如下描述：</p><blockquote><p>模块 <a href="../../module-summary.html">java.base</a> </p><p>软件包 <a href="package-summary.html">java.lang</a> </p><h2 id="Class-Class"><a href="#Class-Class" class="headerlink" title="Class Class"></a>Class Class<T></h2><ul><li><p><a href="Object.html">java.lang.Object</a> </p></li><li><ul><li>java.lang.Class<T></li></ul></li><li><ul><li><p>参数类型 </p><p><code>T</code> - 此<code>类</code>对象建模的类的类型。 例如，  <code>String.class</code>的类型是<code>Class&lt;String&gt;</code> 。  如果正在建模的类未知，请使用<code>Class&lt;?&gt;</code> 。 </p></li><li><p>实现的所有接口 </p><p><code>Serializable</code> ， <code>AnnotatedElement</code> ， <code>GenericDeclaration</code> ， <code>Type</code></p></li></ul><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final class Class&lt;T&gt;</span><br><span class="line">extends Object</span><br><span class="line">implements Serializable, GenericDeclaration, Type, AnnotatedElement</span><br></pre></td></tr></table></figure><p>类<code>类</code>实例表示正在运行的Java应用程序中的类和接口。枚举类型是一种类，注释类型是一种接口。每个数组也属于一个类，该类反映为<code>类</code>对象，由具有相同元素类型和维数的所有数组共享。原始Java类型（ <code>boolean</code> ， <code>byte</code> ， <code>char</code> ，  <code>short</code> ， <code>int</code> ， <code>long</code> ， <code>float</code>  ，和<code>double</code> ），以及关键字<code>void</code>也表示为<code>类</code>对象。</p><p><code>类</code>没有公共构造函数。 而是当类加载器调用<code>defineClass</code>方法之一并传递<code>class</code>文件的字节时，Java虚拟机会自动构造<code>类</code>对象。 </p><p>类<code>类</code>的方法暴露了类或接口的许多特征。  大多数特性派生自类加载器传递给Java虚拟机的<code>class</code>文件。 一些特性由运行时的类加载环境决定，例如<code>getModule()</code>返回的模块。 </p><p>类<code>类</code>某些方法公开Java源代码中的类或接口的声明是否<em>包含</em>在另一个声明中。  其他方法描述了类或接口如何位于<em>嵌套中</em> 。 nest是一组类和接口，在同一运行时包中，允许相互访问其<code>private</code>成员。  类和接口称为<em>nestmates</em> 。 一个巢穴充当<em>巢主</em>  ，并列举属于巢的其他巢穴; 它们中的每一个又将其记录为嵌套主机。  属于嵌套的类（包括其主机）的类和接口是在生成<code>class</code>文件时确定的，例如，Java编译器通常会将顶级类记录为嵌套的主机，其中其他成员是类，声明包含在顶级类声明中的接口。</p></li></ul></blockquote><p>在Java里，所有的类，包括<strong>Class类（又称为“类类”）</strong>的根源都是Object类。Class是继承自Object的一个特殊的类，内部可以记录类的成员、接口等信息——<strong>在Java中，Class是一个用来表示类的类</strong>，可以<strong>为其创建实例——Class对象</strong>（Class实例）。</p><p>Java中对象可分为两种：实例对象和Class对象。每个类的运行时的<strong>类型信息</strong>就是用Class对象表示的。它包含了与类有关的信息。实例对象其实是通过Class对象来创建的。Java使用Class对象执行其RTTI（运行时类型识别，Run-Time Type Identification），多态是基于RTTI实现的。</p><p>每一个类都有一个Class对象，每当编译一个新类就产生一个Class对象，基本类型 (boolean, byte, char, short,  int, long, float, and  double)有Class对象，数组有Class对象，就连关键字void也有Class对象（void.class）。Class对象对应着java.lang.Class类，如果说类是对象抽象和集合的话，那么Class类就是对类的抽象和集合。</p><p><strong>Class对象只能由系统建立对象，没有公共的构造方法</strong>，Class对象是在类加载的时候由<strong>Java虚拟机</strong>以及通过调用类加载器中的 defineClass 方法自动构造的，因此不能显式地声明一个Class对象。一个加载的类在JVM中只会有一个Class实例，一个Class对象对应的是一个加载到JVM中的一个.class文件。每个类的实例都会记得自己是由哪个Class实例所生成，因此通过Class可以完整地得到一个类中所有被加载的结构。每一个<a href="https://blog.csdn.net/dufufd/article/details/80537638">一个类被加载到内存并供我们使用需要经历如下三个阶段：加载-&gt;链接-&gt;初始化</a>：</p><blockquote><ol><li><strong>加载</strong>：由类加载器（ClassLoader）执行的。通过一个类的全限定名来获取其定义的二进制字节流（Class字节码），将这个字节流所代表的静态存储结构转化为方法去的运行时数据接口，根据字节码在java堆中生成一个代表这个类的java.lang.Class对象。</li><li><strong>链接</strong>：在链接阶段将验证Class文件中的字节流包含的信息是否符合当前虚拟机的要求，为静态域分配存储空间并设置类变量的初始值（默认的零值），并且如果必需的话，将常量池中的符号引用转化为直接引用。</li><li><strong>初始化</strong>：此阶段才真正开始执行类中定义的java程序代码。执行该类的静态初始器和静态初始块，如果该类有父类的话，则优先对其父类进行初始化。</li></ol></blockquote><p>注意，<strong>所有的类都是在对其第一次使用时，动态加载到JVM中的（懒加载）。</strong>当程序创建第一个对类的静态成员的引用时，就会加载这个类。使用new创建<a href="https://so.csdn.net/so/search?q=%E7%B1%BB%E5%AF%B9%E8%B1%A1&spm=1001.2101.3001.7020">类对象</a>的时候也会被当作对类的静态成员的引用。<strong>因此java程序程序在它开始运行之前并非被完全加载，其各个类都是在必需时才加载的</strong>，这一点与许多传统语言如C++，都不同。</p><p>Class类是Java反射机制的根源，对于任何我们想动态加载运行的类，必须先获得其相应的Class对象。</p><p>Java中提供了下面3种获取到类的Class对象的方法：</p><ol><li><p>利用对象实例，调用getClass()方法获取该对象的Class实例：<code>Class cla=Person.getClass()</code>；</p></li><li><p>使用Class类的静态方法forName(“包名+类名”)，用类的名字获取一个Class实例，注意要抛出异常ClassNotFoundException：<code>Class cla =Class.forName(&quot;demo01.Student&quot;) </code>；</p></li><li><p>运用“类名.class”的方式来获取Class实例，最安全可靠，性能高：<code>Class clazz = Person.class</code>；</p></li><li><p>对于内置基本数据类型，都有一个TYPE属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">go</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line">System.out.println(<span class="type">int</span>.class);<span class="comment">//int</span></span><br></pre></td></tr></table></figure></li><li><p>使用ClassLoader</p></li></ol><p><strong><a href="https://blog.csdn.net/mocas_wang/article/details/107428506">一些重要的Class类方法</a></strong></p><ul><li>getname()：以string类型返回class对象表示的实体（类，接口，数组，基本类型，void等）名称</li><li>newInstance():创建一个实例，只能调用默认构造器。（JDK1.9版本，即Java9之后被弃用）</li><li>getSuperclass():返回class表示的实体超类(父类)的名称</li><li>getSimpleName()。不办含包名的类名。</li><li>isInterfence:告诉你这个class对象是否表示某个接口。</li><li>Class.forName():返回一个类对象，会引发加载过程，也就是说JVM会执行该类的静态代码段，静态代码是和class绑定的，class装载成功就表示执行了你的静态代码了。执行了”加载—验证—准备—解析—初始化（类的初始化）“，即将一个类加载到内存中，并最终形成虚拟机直接使用的Java类型。这个过程会执行static块。</li></ul><p>简单地说，一个类在内存中只有一个Class对象，该类被加载后，类的整个结构都会被封装在Class对象中。</p><p>怎么理解呢？比方我们创建一个test02.java文件，在其中通过反射获取类的Class对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.demo01;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">        <span class="comment">//forName方法会抛出异常java.lang.ClassNotFoundException</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.kuang.demo01.User&quot;</span>);</span><br><span class="line">        System.out.println(c1);<span class="comment">//打印：class com.kuang.demo01.User</span></span><br><span class="line">      System.out.println(c1.hashCode());<span class="comment">//返回Java对象唯一的hash值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;<span class="comment">/*这里是一个实体类，不用定义什么*/</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>java中hash值，“&#x3D;&#x3D;”符号与equals方法</strong></p><p>“&#x3D;&#x3D;”符号直接比较两个对象的堆内存地址，相等则说明两个引用是指向同一个对象地址的。对于8种基本数据类型，在常量池中，一个常量只会对应一个地址。对于基本数据的包装类型（Byte，Short，Character，Integar，Float，Double，Long，Boolean），其中除了Float和Double外，也都实现了常量池，因此<strong>一般也可以直接通过“&#x3D;&#x3D;”符号来判断是否相等</strong></p><p>注意，常量池中的存储范围！</p><p>网上大部分博客，认为equals方法比较的是对象的内容，这不完全准确，在java.lang.Object包，源代码Object.java文件中是这么描述这个函数的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span> == obj);<span class="comment">//直接通过“==”运算符来比较，二者没有任何区别</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之所以说equals方法与“&#x3D;&#x3D;”运算符有所不同，是因为<strong>可以自己重写equals方法</strong>，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;<span class="comment">//形参类型Object，重载</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span> == obj)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>((obj==<span class="literal">null</span>)||(obj.getClass()!=<span class="built_in">this</span>.getClass()))<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//返回此Object的运行时类</span></span><br><span class="line">    <span class="type">test02</span> <span class="variable">test</span> <span class="operator">=</span> (test02) obj;<span class="comment">//向下转型</span></span><br><span class="line">    <span class="keyword">return</span> num==test.num &amp;&amp; (data==test.data||(data!=<span class="literal">null</span>&amp;&amp;data.equals(test.data)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hash(num,data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重写equals方法的同时也要重写hashCode方法原因如下：</p><ol><li>要维护hashCode方法的常规约定：值相同的对象必须有相同的hashCode(输入的值相同，采用一样的hash算法，所得出的结果也必须相同)；</li><li>向一个Hash结构的集合中添加某个元素，集合会首先调用hashCode方法，以直接定位该元素存储的位置，若该处没有其他元素，则直接保存；若已有其他元素存在，就调用equals方法判断两个元素是否相同，相同则不存，不同则散列到其他位置——hashCode为一个int值，比较起来速度更快，效率更高。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>native 修饰符主要用于方法上：</p><ol><li>Java本身不能对操作系统底层进行访问和操作，但可以通过Java Native Interface(即JNI，Java本机接口)调用其他语言来实现对底层的访问；</li><li>一个native方法就是一个Java程序调用非Java代码的接口，native方法由其他编程语言来实现；</li><li>定义一个native方法时，不提供实现体。</li></ol><p>可见，Java原生的hashCode是一个本地方法，其实现与本地机器有关。</p><p><a href="https://blog.csdn.net/havedream_one/article/details/49028935">new 方式和Class.forName()的区别</a>：</p><ol><li><p>newInstance( )是一个方法，而new是一个关键字。创建对象的方式也不一样，前者是使用类加载机制，后者是创建一个新类；</p></li><li><p>Class下的newInstance()的使用有局限，因为它生成对象只能调用无参的构造函数，而使用 new关键字生成对象没有这个限制；</p></li><li><p>简言之：</p><ul><li>newInstance(): 弱类型，低效率，只能调用无参构造。</li><li>new: 强类型，相对高效，能调用任何public构造。</li><li>Class.forName(“”)返回的是类。</li><li>Class.forName(“”).newInstance()返回的是object 。</li></ul></li></ol><h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><p>与其他语言相比，<a href="https://blog.csdn.net/young_1004/article/details/82912714">Java具有独特的输入和输出机制</a>，Java的I&#x2F;O建立在流（stream）之上：</p><blockquote><p>输入流读取文件，输出流写入文件，不同的流类，如java.io.FileInputStream和sun.net.TelnetOutputStream会读&#x2F;写某个特定的数据源，但是所有的输出流都有相同的基本方法来写入数据，所有的输入流使用相同的基本方法来读取数据。创建一个流之后，读&#x2F;写时通常可以忽略读&#x2F;写的具体细节。</p><p>过滤器流（filter）可以串链到输入流或输出流上。读&#x2F;写数据时，过滤器可以修改数据（例如，通过加密或压缩），或者只是提供额外的方法，将读&#x2F;写的数据转换为其他格式。例如，java.io.DataOutputStream类就提供了一个方法，将int转换为4字节，并把这些字节写入底层的输入流。</p><p>阅读器（reader）和书写器（writer）可以串链到输入和输出流上，允许程序读&#x2F;些文本（即字符） 而不是字节。只要正确的使用，阅读器和书写器可以处理很多字符编码，包括多字节字符即SJIS和UTF-8。</p><p>流是同步的，也就是说，当程序（确切的讲是线程）请求一个流读&#x2F;写一段数据时，在任何其他操作时，它要等待所读&#x2F;写的数据。</p><p>Java还支持使用通道和缓冲区的非阻塞I&#x2F;O。非阻塞I&#x2F;O稍微有些复杂，但在某些高吞吐量的应用程序中（如web服务器），非阻塞I&#x2F;O要快的多。通常情况下，基本流模型就是实现客户端所需要和应当使用的全部内容。由于通道和缓冲区依赖于流，下面首先介绍流和客户端。</p></blockquote><p>IO流分类：</p><ul><li><p>按照数据流向分：</p><ul><li><p>输入流：写数据</p></li><li><p>输出流：读数据</p></li></ul></li><li><p>按照数据类型分：</p><ul><li>字节流：字节输入流，字节输出流</li><li>字符流：字符输入流，字符输出流</li></ul></li></ul><p>IO流的分类<strong>一般按照数据类型划分</strong>，区别使用字节流和字符流的一个小技巧：</p><blockquote><p>如果数据能通过Window系统自带的记事本软件打开，且其中的内容没有乱码则使用字符流；否则使用字节流。当不确定使用哪种类型的流时，使用字节流。</p></blockquote><p><strong>输入流写数据</strong></p><p>打开jdk11API中文文档，在“搜索”一栏输入<code>InputStream</code>可以查看该类相关信息：</p><figure class="highlight plaintext"><figcaption><span>wiki</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">模块  java.base </span><br><span class="line">软件包  java.io </span><br><span class="line">Class InputStream</span><br><span class="line">java.lang.Object </span><br><span class="line">java.io.InputStream </span><br><span class="line"></span><br><span class="line">实现的所有接口 </span><br><span class="line">Closeable ， AutoCloseable </span><br><span class="line">已知直接子类： </span><br><span class="line">AudioInputStream ， ByteArrayInputStream ， FileInputStream ， FilterInputStream ， ObjectInputStream ， PipedInputStream ， SequenceInputStream ， StringBufferInputStream </span><br></pre></td></tr></table></figure><p><strong>该抽象类java.io.InputStream位于java.io这个package下，是表示输入字节流的所有类的超类</strong></p><p>可以使用字符串类型的文件名来创建一个输入流对象来读取文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;C:/java/hello&quot;</span>);</span><br><span class="line"><span class="comment">//如上所示，这里用的是向上转型的方法，子类转父类</span></span><br></pre></td></tr></table></figure><p>注意，IO类的定义要搭配异常处理（比如在函数签名尾部用throws关键字声明 IOException）</p><p><img src="/images/FileNotFoundException.png" alt="FileNotFoundException"></p><p>原因在于：FileInputStream、FileOutputStream的构造器用throws关键字声明了FileNotFoundException异常<br>，而且该构造器的代码中判定如果文件无效就用throws关键字抛出异常对象，这是因为Java设计考虑到IO操作时文件路径不存在等异常情况。这一块我们也可以参考Java的父子异常处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="comment">//注意，IO类要我们手动导入</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileOutputStreamDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建字节流输出对象，这里的路径命名要注意</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;E:\\Java_practice\\web_study\\fos.txt&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 做了三件事情：</span></span><br><span class="line"><span class="comment">        * 1. 调用系统功能创建了文件</span></span><br><span class="line"><span class="comment">        * 2. 创建了字节输出流对象</span></span><br><span class="line"><span class="comment">        * 3. 让字节输出流对象指向创建好的文件</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将指定的字节写入此文件输出流</span></span><br><span class="line">        fos.write(<span class="number">98</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//所有和IO相关的方法最后都要释放资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代理</strong></p><p>Java 的代理——客户类不再直接和委托类打交道, 而是通过一个中间层来访问, 这个中间层就是代理，代理有 2 个优势：</p><ol><li>可以隐藏委托类的实现；</li><li>可以实现客户与委托类之间的解耦, 在不修改委托类代码的情况下能够做一些额外的处理</li></ol><p><strong>静态代理</strong></p><p>方式：开发者自己手动创建或者在程序运行前就已经存在的代理类</p><p>场景：需求增强的需要——假设已经有学生、老师两个类，均继承Person接口的<code>chifan()</code>方法，现有一程序Test.java将会定义一个Student类，并运行其<code>chifan()</code>函数。现要增强功能，比如“学生吃饭前要跑步一圈”，而我们不应在Student这一委托类中加上该功能。</p><p>使用静态代理方法，要求我们新建一个代理类ProxyStudent，在其中添加要增强的功能，该类同样要实现Person接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyStudent</span> <span class="keyword">implements</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Student s;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyStudent</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.s = <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">chifan</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//这里可以定义我们要增强的功能，而不必去修改Student类</span></span><br><span class="line">        System.out.println(<span class="string">&quot;学生吃饭前先跑一圈&quot;</span>);</span><br><span class="line">        <span class="comment">//函数核心功能还是Student对象的</span></span><br><span class="line">        s.chifan();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态代理</strong></p><p> Java 的动态代理中, 主要涉及 2 个类，<code>java.lang.reflect</code>下的<code>InvocationHandler</code>和<code>Proxy</code>。详见<a href="https://cloud.tencent.com/developer/article/1429932">文章</a></p><p><strong>Lambda表达式</strong></p><p>也称为闭包，是Java8之后的特性， 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。使用条件：</p><ol><li>接口中只有一个抽象方法的接口(函数式接口)</li><li></li></ol><p>分为两种：显示Lambda表达式会声明参数类型，隐式Lambda表达式则<strong>不声明所有参数类型，由编译器自己推断</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(String msg) -&gt; &#123;System.out.println(msg);&#125; </span><br><span class="line"><span class="comment">//后边一段即lambda表达式，可以用隐式写法，省略参数类型</span></span><br><span class="line">(msg)-&gt;&#123;System.out.println(msg);&#125;</span><br><span class="line"><span class="comment">//对于单个参数lambda表达式，我们在省略了参数类型的前提下，还可以省略括号。</span></span><br><span class="line">msg-&gt;&#123;System.out.println(msg);&#125;</span><br></pre></td></tr></table></figure><p>注意！对于没有参数的lambda表达式，我们仍然需要括号，如:</p><p><code>() -&gt; &#123; System.out.println(&quot;hi&quot;); &#125;</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java基础语法学习要注意的小细节&quot;&gt;&lt;a href=&quot;#Java基础语法学习要注意的小细节&quot; class=&quot;headerlink&quot; title=&quot;Java基础语法学习要注意的小细节&quot;&gt;&lt;/a&gt;Java基础语法学习要注意的小细节&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;最最</summary>
      
    
    
    
    <category term="Java" scheme="http://justskim.github.io/categories/Java/"/>
    
    
    <category term="java" scheme="http://justskim.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>tomcat下startup.bat启动报错详解</title>
    <link href="http://justskim.github.io/2022/03/01/tomcat%E4%B8%8Bstartup.bat%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99%E8%AF%A6%E8%A7%A3/"/>
    <id>http://justskim.github.io/2022/03/01/tomcat%E4%B8%8Bstartup.bat%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-03-01T03:10:04.038Z</published>
    <updated>2022-04-09T09:12:54.075Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tomcat下startup-bat启动报错详解"><a href="#tomcat下startup-bat启动报错详解" class="headerlink" title="tomcat下startup.bat启动报错详解"></a>tomcat下startup.bat启动报错详解</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>博主在tomcat服务器的安装启动时，遇到问题：在官网下载的tomcat10压缩包版本，解压后可以在bin文件夹中双击tomcat10.exe并成功运行，但是双击startup.bat会闪退。而在网上找到的博客所遇到的问题都跟博主的相反，都是tomcat.exe不能运行。在控制台运行该程序，会得到信息如下：</p><p><img src="/images/startup.bat%E9%97%AA%E9%80%80.PNG" alt="startup.bat闪退.PNG"></p><p>博主也检测了主机安装<code>java</code>的配置以及环境变量，<strong>使用命令<code>netstat -ano|findstr 8080</code>也没有发现占用端口的程序</strong>，在控制台中使用命令<code>java -version</code>打印结果也正常，因此查询tomcat相关资料，探究该问题。</p><h2 id="startup与catalina"><a href="#startup与catalina" class="headerlink" title="startup与catalina"></a>startup与catalina</h2><p>我们在tomcat安装目录的bin目录下，可以看到有四个文件：startup.bat，startup.sh，catalina.bat，catalina.sh。</p><p>这其中，sh格式的文件是linux系统下的脚本文件，在Windows系统下无需理会。我们只看另外两个bat文件就行——bat是<strong>dos下的批处理文件</strong>。我们要启动tomcat除了双击startup.bat和tomcat.exe，还有一种方式就是在该目录下的命令行中输入<code>catalina.bat run</code>或者<code>catalina run</code>。startup.bat在执行时也会在最后调用catalina.bat，并且传递了start参数，设置了CATALINA_HOME和CURRENT_DIR俩个临时环境变量，当然我们也可以在系统中自行添加这两个变量。这两个文件的另一个区别在于：startup是在新界面运行，而<code>catalina run</code>命令会使相关程序在当前界面运行，会有更多的报错信息：</p><p><img src="/images/catalina.bat%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF.png" alt="catalina.bat报错信息"></p><h2 id="原因查询"><a href="#原因查询" class="headerlink" title="原因查询"></a>原因查询</h2><p>原因可能是JDK版本过高（博主所用的JDK17）所导致的，AVA11以后大大简化了JAVA环境配置方式，也没有jre文件夹，不过我们可以在jdk目录下使用命令<code>bin\jlink.exe --module-path jmods --add-modules java.desktop --output jre</code>来自动生成。<code>JAVA_HOME/lib</code>目录下没有tool.jar, dt.jar这两个文件，因此我们需要在配置环境变量的时候，要写成:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH  ;%JAVA_HOME%\bin\;%JAVA_HOME%\jre\bin\; CLASSPATH=.;%JAVA_HOME%\lib;%JAVA_HOME%\jre\lib;</span><br></pre></td></tr></table></figure><p>即使如此，博主还是依然无法通过startup.bat或者catalina.bat来启动tomcat，依旧只能选择tomcat.exe的启动方式┓( ´∀&#96; )┏</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;tomcat下startup-bat启动报错详解&quot;&gt;&lt;a href=&quot;#tomcat下startup-bat启动报错详解&quot; class=&quot;headerlink&quot; title=&quot;tomcat下startup.bat启动报错详解&quot;&gt;&lt;/a&gt;tomcat下startup</summary>
      
    
    
    
    <category term="服务器" scheme="http://justskim.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="Tomcat" scheme="http://justskim.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Tomcat/"/>
    
    
    <category term="服务器" scheme="http://justskim.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="java" scheme="http://justskim.github.io/tags/java/"/>
    
    <category term="tomcat" scheme="http://justskim.github.io/tags/tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Linux服务器上的nginx与apache</title>
    <link href="http://justskim.github.io/2022/02/26/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84nginx%E4%B8%8Eapache/"/>
    <id>http://justskim.github.io/2022/02/26/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84nginx%E4%B8%8Eapache/</id>
    <published>2022-02-26T11:00:54.169Z</published>
    <updated>2022-02-26T17:45:10.530Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux服务器上的nginx与apache"><a href="#Linux服务器上的nginx与apache" class="headerlink" title="Linux服务器上的nginx与apache"></a>Linux服务器上的nginx与apache</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>博主在进行<a href="https://www.byhy.net/tut/webdev/django/07/">django框架的web项目练习</a>时，参考<a href="https://www.byhy.net/tut/webdev/django/16/#%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4-nginx">相关教程</a>进行<code>django</code>项目在Linux云服务器上的部署。<code>nginx</code>无法启动服务，需要修改路径<code>/etc/nginx/nginx.conf</code>（使用命令<code>yum -y install nginx</code>默认安装）下的<code>nginx.conf</code>文件。而在浏览器上的web端阿里云控制台上，使用<code>linux</code>系统自带的<code>vim</code>编辑器，不像在桌面系统上编辑那么容易。因此打算使用第三方工具（如<code>win-scp</code>，<code>Xshell</code>），在本地编辑文件后直接拖拽进去替代。但是在这些终端模拟器上无法与阿里云服务器建立ssh连接，但却可以ping通云服务器的公网<code>ip</code>地址，如下图所示。因此博主决定深入探究，并解决该问题。</p><p><img src="/images/ssh%E8%BF%9E%E6%8E%A5%E6%8A%A5%E9%94%99.PNG" alt="ssh连接报错"></p><h2 id="没有公网ip地址-x3D-端口被屏蔽？"><a href="#没有公网ip地址-x3D-端口被屏蔽？" class="headerlink" title="没有公网ip地址&#x3D;端口被屏蔽？"></a>没有公网<code>ip</code>地址&#x3D;端口被屏蔽？</h2><p>博主遇到的这一个离谱的问题，当阿里云的服务器设置了白名单以及安全组等配置后，无法在家庭网络的三台主机中使用ssh命令或者第三方工具通过22端口进行连接。而在阿里云网页端的官方控制台可以远程连接。异地协助的朋友也可以在他的主机上直接使用<code>ssh</code>命令或者<code>Xshell</code>等第三方工具。</p><h3 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h3><ol><li><p>首先是一如既往地检查阿里云服务器的安全组设置，请求客服协助，均没有问题；</p></li><li><p>在<code>win10</code>系统的主机上打开防火墙高级设置，设置22端口的出站规则；</p></li><li><p>使用命令<code>netstat -ano|findstr 22</code>查看端口，22端口和80、443等端口均没有发生占用情况；</p></li><li><p>使用手机开启移动4G热点，主机连接该热点后竟然能够成功ssh连接阿里云远程服务器！</p></li></ol><h3 id="真正的问题所在"><a href="#真正的问题所在" class="headerlink" title="真正的问题所在"></a>真正的问题所在</h3><p>经过问题排查的过程后，博主将目标锁定在运营商的端口规则上。</p><p><code>ISP</code>的全称是<code>Internet Service Provider</code>，翻译为互联网服务提供商，即向广大用户综合提供互联网接入业务、信息业务、和增值业务的电信<strong>运营商</strong>。</p><p>为了了解我们的运营商屏蔽了哪些端口，我们使用<a href="https://www.sojson.com/zz/portscan.html">站长工具中的端口扫描工具</a>，或者<a href="https://gist.github.com/vfreex/32b7de2e36422dbee94454afc762305e">相关脚本</a>来扫描看看哪些端口可以代为使用。对博主主机扫描的结果是所有端口都被屏蔽，无法使用。。。</p><p>根据网络相关文章，这可能跟博主所用的主机并没有公网ip地址有关，以及运营商的屏蔽规则，导致正常无法使用端口。</p><p>最后，给你们介绍一下，博主家里使用的是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">宽带类型：广电</span><br><span class="line">宽带业务：高清电视(IPTV)业务</span><br><span class="line">接入方式：光纤接入(FTTH)</span><br></pre></td></tr></table></figure><h2 id="80端口与Nginx与Apache"><a href="#80端口与Nginx与Apache" class="headerlink" title="80端口与Nginx与Apache"></a>80端口与Nginx与Apache</h2><p>Apache和Nginx都属于Web服务器（也称为WWW(WORLD WIDE WEB)服务器，主要功能是提供网上信息浏览服务），都实现了HTTP 1.1协议。我们在具体工程项目中选择哪个，都是根据应用场景来决定的，关于这两个服务器的更多异同我们将在之后进行学习探讨。</p><p>80端口是为HTTP超文本传输协议开放的端口卡相关的限制。<code>Apache</code>与<code>nginx</code>都会使用到该端口。比如博主在启动<code>nginx</code>时遇到的一个报错：“<strong>Address already in use</strong>…”，就说明该端口已经被其他程序所占用（大多数情况下是Apache，可能是很多软件不注意间被我们设置开机自动启动了）因此，要么将其中一个的端口进行修改，要么至启动一个（正常生产环境下的操作，无需两个都使用，功能有重复的地方）</p><p>我们使用<code>systemctl  stop httpd</code>来结束apache服务，使用<code>systemctl start nginx</code>来启动<code>nginx</code>服务，反之亦然。</p><p>解决了<code>nginx</code>启动报错的问题后，我们得以部署成功，在浏览器上输入相关<code>ip</code>地址路由，可以成功访问到页面！</p><p><img src="/images/%E6%88%90%E5%8A%9F%E7%99%BB%E5%BD%95%E4%B8%8A%E8%87%AA%E5%B7%B1%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%A1%B9%E7%9B%AE.PNG" alt="成功登录上自己服务器的项目"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux服务器上的nginx与apache&quot;&gt;&lt;a href=&quot;#Linux服务器上的nginx与apache&quot; class=&quot;headerlink&quot; title=&quot;Linux服务器上的nginx与apache&quot;&gt;&lt;/a&gt;Linux服务器上的nginx与apac</summary>
      
    
    
    
    <category term="网络" scheme="http://justskim.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="http://justskim.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="nginx" scheme="http://justskim.github.io/tags/nginx/"/>
    
    <category term="apache" scheme="http://justskim.github.io/tags/apache/"/>
    
  </entry>
  
</feed>
