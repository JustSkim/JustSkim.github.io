<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://justskim.github.io/atom.xml" rel="self"/>
  
  <link href="http://justskim.github.io/"/>
  <updated>2023-01-27T19:43:27.936Z</updated>
  <id>http://justskim.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>win10系统停止更新</title>
    <link href="http://justskim.github.io/2023/01/26/win10%E7%B3%BB%E7%BB%9F%E5%81%9C%E6%AD%A2%E6%9B%B4%E6%96%B0/"/>
    <id>http://justskim.github.io/2023/01/26/win10%E7%B3%BB%E7%BB%9F%E5%81%9C%E6%AD%A2%E6%9B%B4%E6%96%B0/</id>
    <published>2023-01-26T02:42:58.923Z</published>
    <updated>2023-01-27T19:43:27.936Z</updated>
    
    <content type="html"><![CDATA[<p>目的：防止win10频繁的系统更新和升级为win 11 。  </p><p>方法：  </p><ol><li>按键”win”+”R”，在运行的窗口中输入”winver”，可以看到博主的系统版本是22H2的Windows 10专业版</li><li>在运行的窗口中输入”gpedit”，点击”管理模板”-&gt;”Windows 组件”-&gt;”Windows 更新”-&gt;”适用于企业的Windows更新”，对”选择目标功能更新版本”进行编辑，选择启用，并在选项中分别填写”Windows 10”和”22H2”(也就是博主主机目前版本)</li><li>应用并确认后，重启即可。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;目的：防止win10频繁的系统更新和升级为win 11 。  &lt;/p&gt;
&lt;p&gt;方法：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;按键”win”+”R”，在运行的窗口中输入”winver”，可以看到博主的系统版本是22H2的Windows 10专业版&lt;/li&gt;
&lt;li&gt;在运行的窗口中输入</summary>
      
    
    
    
    <category term="Windows" scheme="http://justskim.github.io/categories/Windows/"/>
    
    
    <category term="windows" scheme="http://justskim.github.io/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>神经网络与OOD，ODIN</title>
    <link href="http://justskim.github.io/2022/05/09/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8EOOD%EF%BC%8CODIN/"/>
    <id>http://justskim.github.io/2022/05/09/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8EOOD%EF%BC%8CODIN/</id>
    <published>2022-05-09T05:48:08.708Z</published>
    <updated>2022-09-20T14:55:10.891Z</updated>
    
    <content type="html"><![CDATA[<h2 id="神经网络简要介绍"><a href="#神经网络简要介绍" class="headerlink" title="神经网络简要介绍"></a>神经网络简要介绍</h2><p>机器学习的内容</p><h3 id="CNN-卷积神经网络"><a href="#CNN-卷积神经网络" class="headerlink" title="CNN 卷积神经网络"></a>CNN 卷积神经网络</h3><p>卷积神经网络（CNN）常被用在计算机视觉领域，其包括以下几个模型：</p><p><strong>ResNet模型</strong></p><p><strong>DenseNet模型</strong></p><p>基本思路与ResNet一致，但是它建立的是前面所有层与后面层的密集连接（dense connection），它的名称也是由此而来。DenseNet的另一大特色是通过特征在channel上的连接来实现特征重用（feature reuse）。这些特点让DenseNet在参数和计算成本更少的情形下实现比ResNet更优的性能</p><p><a href="https://zhuanlan.zhihu.com/p/37189203">关于DenseNet在Pytorch上的实现</a>：</p><p>相比ResNet，DenseNet提出了一个更激进的密集连接机制：即互相连接所有的层，具体来说就是每个层都会接受其前面所有层作为其额外的输入。图1为ResNet网络的连接机制。</p><p><img src="https://pic3.zhimg.com/80/v2-862e1c2dcb24f10d264544190ad38142_720w.jpg" alt="ResNet网络的连接机制"></p><p>作为对比，图2为DenseNet的密集连接机制。可以看到，ResNet是每个层与前面的某层（一般是2~3层）短路连接在一起，连接方式是通过元素级相加。而在DenseNet中，每个层都会与前面所有层在channel维度上连接（concat）在一起（这里各个层的特征图大小是相同的，后面会有说明），并作为下一层的输入。</p><p><img src="https://pic3.zhimg.com/80/v2-2cb01c1c9a217e56c72f4c24096fe3fe_720w.jpg" alt="DenseNet的密集连接机制"></p><p>对于一个<strong>L</strong>层的网络，DenseNet 共包含 <code>L(L+1)/2</code>个连接，是一种密集连接。而且DenseNet是直接concat来自不同层的特征图，这可以实现特征重用，提升效率，这一特点是DenseNet与ResNet最主要的区别。</p><p>用公式表示三者的区别：$y&#x3D;ax+b$</p><ul><li>传统神经网络在<code>i</code>层输出为： $x_{i}$</li></ul><h3 id="Wide-ResNet-WRN"><a href="#Wide-ResNet-WRN" class="headerlink" title="Wide ResNet (WRN)"></a>Wide ResNet (WRN)</h3><p>设计思想：</p><ul><li>希望使用一种较浅的，并在每个单层上更宽的（维度）模型来提升模型性能</li><li>增加深度和宽度都有好处，但都会参数太大，导致正则化不够容易过拟合</li><li>ResNet通过BN层进行正则化，而WideResNet通过Dropout正则化。</li><li>宽度的增加提高了性能</li><li>提高训练速度，相同参数，WideResNet的训练速度快于ResNet</li></ul><h2 id="OOD检测"><a href="#OOD检测" class="headerlink" title="OOD检测"></a>OOD检测</h2><p>OOD detection 指的是<strong>模型能够检测出 OOD 样本</strong>，而 OOD 样本是相对于 In Distribution (ID) 样本来说的。</p><p>现有的机器学习模型大多基于封闭世界假设进行训练，其中假设测试数据是来自与训练数据相同的分布，称为**in-distribution (ID)**。 然而，当模型部署在开放世界场景时，测试样本可能是OOD。 分布漂移可能由语义漂移（例如，OOD 样本来自不同类）或covariate shift（例如，来自不同域的 OOD 样本）引起。</p><blockquote><p>封闭世界：目前模型的训练需要大量的标记样本，而且训练集类别与测试集<strong>类别</strong>必需完全一致；</p><p>开放世界学习（open world learning，OWL）：不要求训练集和测试集完全一致，学习模型需<strong>准确的识别已知类</strong>，还能<strong>区分开新类</strong>。</p></blockquote><p>广义OOD检测框架包括：anomaly 检测 (AD), novelty 检测 (ND), open set 识别 (OSR), out-of- distribution 检测 (OOD)和outlier 检测 (OD)</p><p><img src="https://pic3.zhimg.com/80/v2-b0a89f17eb13d3e98bb88826e53a5322_720w.jpg" alt="Taxonomy of generalized OOD detection framework"></p><p>这里着重讲一下<strong>OOD（Out-of-distribution）检测</strong>：</p><p>OOD检测旨在检测相对训练数据不重叠标签的测试样本。 形式上，OOD 检测设置中的测试样本来自in-distribution（ID）语义漂移的分布。 这个in-distribution（ID）数据可以包含单个类或多个类。 当训练中存在多个类时，OOD 检测不应损害其in-distribution（ID）数据分类能力。</p><p>OOD检测的应用通常属于安全-紧要情况，例如自动驾驶。在构建算法基准时，OOD 数据集不应与in-distribution（ID）数据集有标签重叠。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;神经网络简要介绍&quot;&gt;&lt;a href=&quot;#神经网络简要介绍&quot; class=&quot;headerlink&quot; title=&quot;神经网络简要介绍&quot;&gt;&lt;/a&gt;神经网络简要介绍&lt;/h2&gt;&lt;p&gt;机器学习的内容&lt;/p&gt;
&lt;h3 id=&quot;CNN-卷积神经网络&quot;&gt;&lt;a href=&quot;#CNN-</summary>
      
    
    
    
    <category term="机器学习" scheme="http://justskim.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="python3" scheme="http://justskim.github.io/tags/python3/"/>
    
    <category term="machine learning" scheme="http://justskim.github.io/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统下的make编译和CMake</title>
    <link href="http://justskim.github.io/2022/04/29/Linux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%9A%84make%E7%BC%96%E8%AF%91%E5%92%8CCMake/"/>
    <id>http://justskim.github.io/2022/04/29/Linux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%9A%84make%E7%BC%96%E8%AF%91%E5%92%8CCMake/</id>
    <published>2022-04-29T10:14:31.675Z</published>
    <updated>2022-05-06T03:22:21.506Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>博主在读<a href="https://ieeexplore.ieee.org/document/7539326">论文”Hashedcubes: Simple, Low Memory, Real-Time Visual Exploration of Big Data”</a>的时候，在末尾找到作者的源代码公开链接<code>https://github.com/cicerolp/hashedcubes</code>，在Centos 7系统上<code>git clone</code>代码后，按照作者README.md中的教程，无法正确地部署，产生报错。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>Centos 7 系统中预装的gcc和g++版本都为较低的4.8，在编译时需要换用更高版本以上的gcc，</p><p>具体可以参见网上相关gcc版本升级的文章。</p><p>在升级之后，可以使用命令<code>gcc --version</code>来查看gcc编译器的版本。</p><p>如果在编译过程中，仍然提示<code>-c++:std=14</code>的报错，那么可能是编译时候使用的gcc-c++还是预装的4.8版本，可以在CMakeLists.txt文件的开头加上这么两句，来使用指定位置的gcc编译器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_C_COMPLIER&quot;/usr/bin/gcc&quot;)</span><br><span class="line">set(CMAKE_CXX_COMPLIER&quot;/usr/bin/g++&quot;)</span><br></pre></td></tr></table></figure><h2 id="boost的下载与安装"><a href="#boost的下载与安装" class="headerlink" title="boost的下载与安装"></a>boost的下载与安装</h2><h2 id="cmake与CMakeList-txt文件"><a href="#cmake与CMakeList-txt文件" class="headerlink" title="cmake与CMakeList.txt文件"></a>cmake与CMakeList.txt文件</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;博主在读&lt;a href=&quot;https://ieeexplore.ieee.org/document/7539326&quot;&gt;论文”Hashedcu</summary>
      
    
    
    
    <category term="Linux" scheme="http://justskim.github.io/categories/Linux/"/>
    
    
    <category term="linux" scheme="http://justskim.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>hadoop学习过程中本地vmware的网络配置</title>
    <link href="http://justskim.github.io/2022/04/14/hadoop%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%9C%AC%E5%9C%B0vmware%E7%9A%84%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    <id>http://justskim.github.io/2022/04/14/hadoop%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%9C%AC%E5%9C%B0vmware%E7%9A%84%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</id>
    <published>2022-04-14T09:44:24.228Z</published>
    <updated>2022-05-08T19:11:34.803Z</updated>
    
    <content type="html"><![CDATA[<p>在前面的文章中，我们介绍了<a href="https://justskim.github.io/2021/11/16/%E5%9C%A8vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5/"><code>vmware</code> 虚拟机中的网络连接</a>，这一次，博主在学习<code>hadoop</code>框架的时候，电脑上配置虚拟机需要配置虚拟机的IP地址，</p><p><img src="/images/vmware%E7%9A%84%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C%E7%BC%96%E8%BE%91%E5%99%A8.PNG" alt="vmware的虚拟网络编辑器.PNG"></p><p>虚拟机不占用主机所在局域网的ip，通过使用主机的NAT功能访问局域网和互联网，意味着虚拟机可以访问局域网中的其他电脑，但是其他电脑不知道虚拟机的存在。使用这种模式时，虚拟机不需要设置静态IP，只需要使用DHCP功能自动获取ip即可。</p><p>使用NAT技术，主机能上网，虚拟机就可以访问Internet，但是主机不能访问虚拟机</p><p>为了与视频教程同步，博主将自己的虚拟机子网IP地址也更改为：192.168.10.0，子网掩码仍为255.255.255.0，并在NAT设置中，将网关IP也设置为“192.168.10.2”。注意，必须启用管理员权限才能更改上述配置。</p><p>随后，我们来到控制面板下的网络连接选项，可以看到出现了VMWare network的选项：</p><p><img src="/images/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E4%B8%AD%E5%87%BA%E7%8E%B0%E4%BA%86%E6%96%B0%E9%80%89%E9%A1%B9.PNG" alt="网络连接中出现了新选项"></p><p>注意，VMnet1对应的是主机模式的外部连接，VMnet8对应的是我们上面修改的NAT模式连接，从上一副图中也可以看到。我们点击VMnet8的属性，勾选选项“Internet 协议版本4（TCP&#x2F;IPv4）”，随后点击该项，可以看到，IP地址和子网掩码都已经默认配置好了，我们要按照之前所说的需求配置默认网关和DNS服务器几项，配置完成结果如下：</p><p><img src="/images/VMnet8%E7%9A%84%E9%85%8D%E7%BD%AE%E7%BB%93%E6%9E%9C.PNG" alt="VMnet8的配置结果"></p><p>这里有必要了解一下：<a href="https://justskim.github.io/2022/04/14/DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE">DNS服务器是什么？为什么要修改备用DNS服务器为8.8.8.8?</a></p><p>然后，我们来到Linux系统中，打开终端，获得管理员权限后，使用命令<code>cd /etc/sysconfig/network-scripts</code>，来到该目录下编辑文件<code>ifcfg-ens33</code>——<a href="https://blog.csdn.net/zhangchao_cn/article/details/85246558">centos7中的网卡配置文件，各参数介绍如下</a>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DEVICE     接口名（设备,网卡）</span><br><span class="line">USERCTL    [yes|no]（非root用户是否可以控制该设备）</span><br><span class="line">BOOTPROTO  IP的配置方法[none|static|bootp|dhcp]（引导时不使用协议(默认静态)|静态分配IP|BOOTP协议|DHCP协议）</span><br><span class="line">HWADDR     MAC地址   </span><br><span class="line">ONBOOT     系统启动的时候网络接口是否有效（yes/no）   </span><br><span class="line">TYPE       网络类型（通常是Ethemet）   </span><br><span class="line">NETMASK    网络掩码   </span><br><span class="line">IPADDR     IP地址   </span><br><span class="line">IPV6INIT   IPV6是否有效（yes/no）   </span><br><span class="line">GATEWAY    默认网关IP地址</span><br><span class="line">BROADCAST  广播地址</span><br><span class="line">NETWORK    网络地址</span><br></pre></td></tr></table></figure><p>其中，<code>BOOTPROTO</code>这一项默认为<code>dhcp</code>， 表示动态获取 IP 地址， 我们要将此项修改为 static以静态分配IP。并在该文件的末尾加入以下三行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#IP地址，注意是最后一个是100而不是0</span><br><span class="line">IPADDR=192.168.10.100</span><br><span class="line">#网关</span><br><span class="line">GATEWAY=192.168.10.2</span><br><span class="line">#我们刚才配置的域名解析器</span><br><span class="line">DNS1=192.168.10.2</span><br></pre></td></tr></table></figure><p>在<code>terminal</code>中使用<code>hostname</code>命令可以查看主机名，为了方便后续操作，我们在<code>/etc</code>目录下的文件<code>hostname</code>中将主机名修改为 <code>hadoop100</code>。这意味着我们后面可以用主机名<code>hadoop100</code>来代替我们的IP地址<code>192.168.10.100</code>，这样做的好处是相当于定义了一个全局变量，后面出现IP地址的地方统一用<code>hadoop100</code>替换。即使我们后面的IP地址被修改了，也不用去项目的各个程序和配置文件中逐一修改，只需一直使用主机名即可。</p><p>为了配置Linux克隆机主机名称映射hosts文件（后面最多会配置8台服务器，配置8台映射），我们在文件<code>/etc/hosts</code>的末尾加入以下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">192.168.10.100 hadoop100</span><br><span class="line">192.168.10.101 hadoop101</span><br><span class="line">192.168.10.102 hadoop102</span><br><span class="line">192.168.10.103 hadoop103</span><br><span class="line">192.168.10.104 hadoop104</span><br><span class="line">192.168.10.105 hadoop105</span><br><span class="line">192.168.10.106 hadoop106</span><br><span class="line">192.168.10.107 hadoop107</span><br><span class="line">192.168.10.108 hadoop108</span><br></pre></td></tr></table></figure><p>为了使配置生效，我们在终端中输入<code>reboot</code>重启我们的Linux系统。</p><p>重启后，在终端中ping一下看看能否ping通，不能ping通的话先要检查下ifcfg-ens33这一网卡配置文件中各项的值是否正确（特别注意<code>ONBOOT</code>需要为yes），然后使用命令<code>systemctl restart network</code>重启下网卡。</p><p>博主的虚拟机也是一开始无法ping通，使用命令<code>ifconfig</code>查看网络配置：</p><p><img src="/images/%E4%BD%BF%E7%94%A8ifconfig%E6%9F%A5%E7%9C%8B%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE.PNG" alt="使用ifconfig查看网络配置"></p><p>可以看到，IP地址和网卡都没能成功修改，但是ifcfg-ens这一网卡配置文件中的内容是正确的。企图重启网卡发生报错。由于reboot重启系统的时候会自动重启网卡，那么无法ping通的原因应该就是在这里了。</p><p><strong>无法ping通的解决方案</strong></p><p>依次在terminal中输入以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop NetworkManager</span><br><span class="line">systemctl <span class="built_in">disable</span> NetworkManager</span><br><span class="line"><span class="comment">#NetworkManager服务是管理和监控网络设置的守护进程，CentOS7更加注重使用NetworkManager服务来实现网络的配置和管理。NetworkManager是2004年RedHat启动的项目，皆在能够让Linux用户更轻松的处理现代网络需求，尤其是无线网络，能够自动发现网卡并配置IP地址。</span></span><br><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure><p>然后我们使用命令<code>ifconfig</code>查看网络配置，可以看到配置成功生效了！也能ping通了！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在前面的文章中，我们介绍了&lt;a href=&quot;https://justskim.github.io/2021/11/16/%E5%9C%A8vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E8%BF%9B%E8%A1%8C%E7%BD%9</summary>
      
    
    
    
    <category term="Linux" scheme="http://justskim.github.io/categories/Linux/"/>
    
    
    <category term="linux" scheme="http://justskim.github.io/tags/linux/"/>
    
    <category term="虚拟机" scheme="http://justskim.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    <category term="vmware" scheme="http://justskim.github.io/tags/vmware/"/>
    
    <category term="centos" scheme="http://justskim.github.io/tags/centos/"/>
    
    <category term="hadoop" scheme="http://justskim.github.io/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>Maven项目中JSP文件引用的静态资源无法加载问题</title>
    <link href="http://justskim.github.io/2022/04/13/Maven%E9%A1%B9%E7%9B%AE%E4%B8%ADJSP%E6%96%87%E4%BB%B6%E5%BC%95%E7%94%A8%E7%9A%84%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E9%97%AE%E9%A2%98/"/>
    <id>http://justskim.github.io/2022/04/13/Maven%E9%A1%B9%E7%9B%AE%E4%B8%ADJSP%E6%96%87%E4%BB%B6%E5%BC%95%E7%94%A8%E7%9A%84%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E9%97%AE%E9%A2%98/</id>
    <published>2022-04-13T15:17:24.517Z</published>
    <updated>2022-04-13T15:56:40.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>不使用框架，直接建造一个maven项目，并新建error和img等文件目录用于存放特定的jsp文件和图片。在500.jsp文件中引入一张图片，代码：<code>&lt;img src=&quot;../img/500.jpg&quot;/&gt;</code>，项目的文件结构为：</p><p><img src="/images/javaweb-jsp%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.PNG" alt="javaweb-jsp项目文件结构.PNG"></p><p>打开浏览器，在相关页面中可以看到图片未能正常显示，报错404：</p><p><img src="/images/%E6%89%BE%E4%B8%8D%E5%88%B0%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90.PNG" alt="找不到静态资源.PNG"></p><h2 id="排查问题步骤"><a href="#排查问题步骤" class="headerlink" title="排查问题步骤"></a>排查问题步骤</h2><ol><li><p>将静态资源所在的文件夹标记为资源文件；</p></li><li><p>检查target文件夹和out文件夹中是否存在相关文件，如果无则更新资源或者重新部署；</p></li><li><p>重新部署或者重新更新服务器。</p></li></ol><p>以上步骤都没有用，博主返回到软件中查看tomcat服务器设置，发现自己在<strong>tomcat服务器配置中的应用程序上下文 Application context</strong>，被默认设置为<code>http://localhost:8080/javaweb_jsp_war_exploded/</code>，因此，在导入静态资源的时候，也应当把项目路径加上，正确的写法为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/javaweb_jsp_war_exploded/img/500.jpg&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>注意我们修改了tomcat的配置，因此需要选择重启服务器来使新的配置生效。<br>如果我们想要使用原来默认的jsp文件相对路径引入静态资源写法：<code>&lt;img src=&quot;../img/500.jpg&quot;/&gt;</code>，则在tomcat中修改应用程序上下文为：<code>http://localhost:8080/</code>即可，但不推荐这种方式，特别是在同时部署多个模块的时候。<br>注意，要修改tomcat配置中 “deployment”下的“Application context”选项而不是URL项，URL项只是打开浏览器时使用的路径：<br>![tomcat服务器中的Application context](&#x2F;images&#x2F;tomcat服务器中的Application context.PNG)</p><p>我们也可以使用绝对路径的方式引入静态资源：<code>&lt;img src=&quot;$&#123;pageContext.request.contextPath&#125;/img/500.jpg&quot;/&gt;</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;不使用框架，直接建造一个maven项目，并新建error和img等文件目录用于存放特定的jsp文件和图片。在500.jsp文件中引入一张图片</summary>
      
    
    
    
    <category term="Java" scheme="http://justskim.github.io/categories/Java/"/>
    
    <category term="Maven" scheme="http://justskim.github.io/categories/Java/Maven/"/>
    
    
    <category term="java" scheme="http://justskim.github.io/tags/java/"/>
    
    <category term="tomcat" scheme="http://justskim.github.io/tags/tomcat/"/>
    
    <category term="servlet" scheme="http://justskim.github.io/tags/servlet/"/>
    
    <category term="maven" scheme="http://justskim.github.io/tags/maven/"/>
    
    <category term="IDEA" scheme="http://justskim.github.io/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>IDEA中Maven项目的打包与tomcat服务器运行</title>
    <link href="http://justskim.github.io/2022/04/12/IDEA%E4%B8%ADMaven%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%89%93%E5%8C%85%E4%B8%8Etomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E8%A1%8C/"/>
    <id>http://justskim.github.io/2022/04/12/IDEA%E4%B8%ADMaven%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%89%93%E5%8C%85%E4%B8%8Etomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E8%A1%8C/</id>
    <published>2022-04-12T11:06:52.334Z</published>
    <updated>2022-04-13T16:14:45.665Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因以及解决方案"><a href="#起因以及解决方案" class="headerlink" title="起因以及解决方案"></a>起因以及解决方案</h2><p>在学习狂神说 Java web中的servlet项目时，学到<a href="https://www.bilibili.com/video/BV12J411M7Sj?p=15">第15课 javaweb的应用</a>时，想跳转到的项目的发布路径一直显示404，页面的报错信息为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP Status 404 – Not Found</span><br><span class="line">Type Status Report</span><br><span class="line">Message 文.件[/request_war_exploded/success.jsp] 未找到</span><br><span class="line">Description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists.</span><br><span class="line">Apache Tomcat/9.0.62</span><br></pre></td></tr></table></figure><p>经过多次检查代码，并没有发现错误的地方，最后发现是模块打包的target文件夹下，并没有success.jsp文件，即使多次重启或者重新部署tomcat服务器后依然未能解决该问题：</p><p><img src="/images/%E6%89%93%E5%8C%85%E7%9A%84target%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E6%B2%A1%E6%9C%89success.jsp%E6%96%87%E4%BB%B6.PNG" alt="打包的target文件夹下没有success.jsp文件"> </p><p>手动将success.jsp文件复制粘贴到打包的request文件夹下，问题解决！</p><h2 id="maven项目打包机制与target文件夹"><a href="#maven项目打包机制与target文件夹" class="headerlink" title="maven项目打包机制与target文件夹"></a>maven项目打包机制与target文件夹</h2><p>maven项目创建完后，要打包并部署到服务器上。</p><h3 id="Java打包"><a href="#Java打包" class="headerlink" title="Java打包"></a>Java打包</h3><p>Java中两种项目打包的格式：jar 包和 war包。</p><ul><li><p>jar包，将项目看成一整个拼图，引入的每个jar包就是一个拼块，在依赖中经常使用，向项目中添加某些依赖就是下载相应的 jar 包添加到项目中。jar包中只是用java来写的项目打包来的，里面只有编译后的class和一些部署文件。</p></li><li><p>war包，在 <strong>Java web</strong>中通常都是将项目打包成<strong>war包</strong>再进行部署——这是因为war包不仅包含代码编译成的class文件，还有依赖的包、配置文件，以及包括html，jsp等等在内的资源文件。一个war包可以理解为一个web项目，里面有项目的所有东西。<br>pom.xml文件中可以规定打包的相关要求，比如<code>&lt;packaging&gt;war&lt;/packaging&gt;</code>会要求打包成war格式包。</p></li></ul><p><a href="https://blog.csdn.net/qq_41394352/article/details/119192755">maven常用打包命令</a>：</p><blockquote><ol><li><code>mvn compile</code> 编译,将Java 源程序编译成 class 字节码文件。</li><li><code>mvn test</code> 测试，并生成测试报告</li><li><code>mvn clean</code> 将以前编译得到的旧的 class 字节码文件删除</li><li><code>mvn pakage</code> 打包,动态 web工程打 war包，Java工程打 jar 包。</li><li><code>mvn install</code> 将项目生成 jar 包放在仓库中，以便别的模块调用</li><li><code>mvn clean install -Dmaven.test.skip=true</code> 打成jar包，并且抛弃测试用例打包</li><li><code>mvn clean pakage -Dmaven.test.skip=true </code>动态 web工程打 war包，Java工程打 jar 包 ，并且抛弃测试用例打包</li></ol></blockquote><p>target文件夹是用来存放maven项目构建时生成的文件和目录、jar包、war包、编译的class文件</p><h2 id="热加载和热部署"><a href="#热加载和热部署" class="headerlink" title="热加载和热部署"></a><a href="https://blog.csdn.net/Wangdiankun/article/details/105753755">热加载和热部署</a></h2><p><strong>热加载(Hot Reload)<strong>：实现方式是 Web 容器（Context组件）启动一个后台线程，定期检测类文件的变化，如果有变化，就重新加载类，即在运行时重新加载class。在这个过程中不会清空 Session，不安全，一般用在开发环境。</strong>Tomcat默认情况下不开启热加载功能</strong>，包括博主所用的tomcat 9 版本。如果需要用到热加载功能，则要在Tomcat安装路径下的 Context.xml文件中配置 reloadable 参数来开启。</p><p>**热部署(Hot Swap)**：原理类似，也由后台线程定时检测 Web 应用的变化，但会重新加载整个 Web 应用。这种方式会清空Session，比热加载更加干净、彻底，一般用在生产环境。<br>本质区别：热加载的粒度比较小，主要是针对类文件的更新，通过创建新的类加载器来实现重新加载。而热部署是针对整个 Web应用的，重新部署 Web 应用，服务器如Tomcat，会将原来的 Context 对象（包括其所关联的一切资源，比如Session）整个销毁掉，再重新创建 Context 容器对象。<br>相同的目的：在不重启 Tomcat 的情况下实现 Web 应用的更新。</p><h2 id="tomcat服务器上的重启与热加载、重新部署"><a href="#tomcat服务器上的重启与热加载、重新部署" class="headerlink" title="tomcat服务器上的重启与热加载、重新部署"></a>tomcat服务器上的重启与热加载、重新部署</h2><p><a href="https://www.jetbrains.com/help/idea/updating-applications-on-application-servers.html">IDEA的官方文档中介绍了tomcat服务器更新的四个选项区别所在</a>：</p><p><img src="/images/IDEA%E4%B8%ADtomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9B%B4%E6%96%B0%E7%9A%84%E5%9B%9B%E4%B8%AA%E9%80%89%E9%A1%B9.PNG" alt="IDEA中tomcat服务器更新的四个选项"></p><ol><li><p>更新资源 Update resources：更新所有更改的资源，例如 HTML、JSP、JavaScript、CSS 和图像；</p></li><li><p>更新类和资源 Update classes and resources：更新所有更改的资源并重新编译所有更改的 Java 类（EJB、servlet） 等；</p></li></ol><p>以上两者都是热部署——在不重启tomcat服务器的前提下，将自己的项目部署到tomcat服务器中。</p><ol start="3"><li><p>重新部署 redeploy：把当前的一个项目重新部署到Tomcat服务器上；</p></li><li><p>重启服务器 restart：在重新部署的基础上，对Tomcat的相关配置文件进行刷新。在tomcat为debug 模式下，修改当前正在用的类的定义（包括：类名，方法，方法名称，参数等等……），需要重启tomcat</p></li></ol><p>因此，如果我们项目处于开发模式（即我们在之前的博客中讲到的 war exploded部署方式）下，如果只是修改了已有的JSP文件或者其他资源文件，采用第一个选项即可（无论tomcat处于运行模式还是调试模式）；如果<strong>修改了java代码，需要更新class类文件</strong>，且<strong>tomcat处于调试模式下</strong>，那么我们**可以选择第二个选项<code>Update classes and resources</code>**，处于运行模式下的tomcat服务器无法更新java程序，只能更新已有的被修改的资源文件。</p><p>但是注意以上两个方式，只能用于更新已经被部署到tomcat服务器上的资源和类文件，无论tomcat处于运行状态还是debug状态，对于我们新建的资源&#x2F;类文件都必须重新打包部署！使用“更新类和资源”操作，虽然可以在target文件夹中看到新建的资源文件和class类，但因为没有被部署到tomcat服务器上，会报告404的http转换码。同时，上述两个操作也无法应用于删除类文件或资源的情形，在项目中删除相关文件后，必须使用重新部署的方式，才能删除target包中的对应文件。</p><p>对于我们新建的文件，又或者是处于生产模式下，就需要采用 redeploy 方式重新部署了；若我们修改了tomcat服务器的相关配置，则应选择最后一个选项将服务器重启。</p><p>在前面我们说道，web.xml文件并非每个java web工程都必须的，但web.xml文件会被用于servlet程序等一系列配置，因此如果我们<strong>更新了web.xml文件</strong>，无论tomcat处于运行还是调试模式，更新类和资源操作都无法使web.xml中修改的配置生效，<strong>必须重新部署才行</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;起因以及解决方案&quot;&gt;&lt;a href=&quot;#起因以及解决方案&quot; class=&quot;headerlink&quot; title=&quot;起因以及解决方案&quot;&gt;&lt;/a&gt;起因以及解决方案&lt;/h2&gt;&lt;p&gt;在学习狂神说 Java web中的servlet项目时，学到&lt;a href=&quot;https:/</summary>
      
    
    
    
    <category term="Java" scheme="http://justskim.github.io/categories/Java/"/>
    
    <category term="Maven" scheme="http://justskim.github.io/categories/Java/Maven/"/>
    
    
    <category term="java" scheme="http://justskim.github.io/tags/java/"/>
    
    <category term="tomcat" scheme="http://justskim.github.io/tags/tomcat/"/>
    
    <category term="servlet" scheme="http://justskim.github.io/tags/servlet/"/>
    
    <category term="maven" scheme="http://justskim.github.io/tags/maven/"/>
    
    <category term="IDEA" scheme="http://justskim.github.io/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>Python中graphviz包的安装与bug解决</title>
    <link href="http://justskim.github.io/2022/04/12/Python%E4%B8%ADgraphviz%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8Ebug%E8%A7%A3%E5%86%B3/"/>
    <id>http://justskim.github.io/2022/04/12/Python%E4%B8%ADgraphviz%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8Ebug%E8%A7%A3%E5%86%B3/</id>
    <published>2022-04-12T03:33:44.869Z</published>
    <updated>2022-04-12T07:07:14.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>按照学校课程要求，配合scikit-learn官方文档，学习机器学习的过程中，在<a href="https://scikit-learn.org/stable/modules/tree.html">决策树</a>这一章，安装graphviz模块后运行程序产生报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AttributeError: module <span class="string">&#x27;graphviz.backend&#x27;</span> has no attribute <span class="string">&#x27;ENCODING&#x27;</span></span><br></pre></td></tr></table></figure><p>Graphviz是一款自动排版的绘图软件，而python graphviz则是该软件在python的实现，graphviz模块提供了Graph和Digraph两个类，分别以DOT语言为无向图和有向图创建图描述。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>搜索该问题解决方案，相关中文博客中给出的以下两个解决方案：</p><ol><li><p>下载模块python-graphviz；</p></li><li><p>本地下载安装graphviz软件，在系统变量中配置环境变量<code>GRAPHVIZ_INSTALL_DIR</code>（路径为bin文件夹）和<code>GRAPHVIZ_DOT</code>（路径为bin文件夹下的dot.exe程序），在用户变量中也要配置<code>GRAPHVIZ_INSTALL_DIR</code>，然后重启计算机；</p></li></ol><p>但是经过以上尝试过后，该问题依旧没有解决，最后在<a href="https://stackoverflow.com/questions/69989691/how-to-resolve-attributeerror-module-graphviz-backend-has-no-attribute-encod">stackoverflow上的相关问题</a>中，发现问题的根源在于graphviz的版本，并摸索出了相关的解决方案：</p><ol><li><p>使用命令<code>conda uninstall graphviz</code>后，还要将本地环境下的两个文件夹<code>graphviz</code>和<code>graphviz-0.19.2.dist-info</code>删除，否则使用第二步的命令时会被提示已安装；</p></li><li><p>使用命令<code>pip install graphviz=0.19.2 </code>下载符合要求的包；</p></li><li><p>在程序中，加入这么两句代码，添加路径：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">&quot;PATH&quot;</span>]+=os.pathsep+<span class="string">&quot;E:/download/Graphviz/bin&quot;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;按照学校课程要求，配合scikit-learn官方文档，学习机器学习的过程中，在&lt;a href=&quot;https://sciki</summary>
      
    
    
    
    <category term="机器学习" scheme="http://justskim.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="python" scheme="http://justskim.github.io/tags/python/"/>
    
    <category term="machine learning" scheme="http://justskim.github.io/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>IDEA中maven项目无法自动导入包的问题解决</title>
    <link href="http://justskim.github.io/2022/04/09/IDEA%E4%B8%ADmaven%E9%A1%B9%E7%9B%AE%E6%97%A0%E6%B3%95%E8%87%AA%E5%8A%A8%E5%AF%BC%E5%85%A5%E5%8C%85%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>http://justskim.github.io/2022/04/09/IDEA%E4%B8%ADmaven%E9%A1%B9%E7%9B%AE%E6%97%A0%E6%B3%95%E8%87%AA%E5%8A%A8%E5%AF%BC%E5%85%A5%E5%8C%85%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</id>
    <published>2022-04-09T08:50:55.411Z</published>
    <updated>2022-04-13T11:06:09.830Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在IDEA中创建项目工程后（父工程的src文件夹可以在创建后删除），再选择“module”创建子工程，发现无法自动导入依赖，具体表现为“HttpServlet”等不是java jdk自带的包会在代码中爆红，即使在pom.xml文件中按要求添加了相关依赖，也无法解决问题。按照网上教程所说的有以下方法：</p><ol><li>在settings中设置maven相关项</li><li>点击“文件”-&gt; “清除缓存”；</li><li>点击界面最右边一侧的“maven”设置，clean后install，或者点击项目菜单中的“reimport”选项</li></ol><p>以上做法均失效（对于引入jdk自带的包，比如java.lang中的包，可以采用上边的方式让其自动引入）。</p><h2 id="排查问题"><a href="#排查问题" class="headerlink" title="排查问题"></a>排查问题</h2><p>查看父工程的外部库External libaries可以发现，其中只有jdk11自带的包，而没有出现我们需要引入的依赖包，成功引入的界面应该是长下面这样：</p><p><img src="/images/%E6%88%90%E5%8A%9F%E4%BB%8E%E5%A4%96%E9%83%A8%E5%BA%93%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96%E5%8C%85.PNG" alt="成功从外部库引入依赖包"></p><p>重新新建一个项目来探究问题所在，发现在选择骨架创建子工程后，下方maven控制台的运行中，会出现一项<code>org.apache.maven.plugins:maven-archetype-plugin:RELEASE:generate</code>一直处于加载的状态！有时候甚至加载了十分钟依然未能成功！</p><p>这是因为子项目使用骨架创建时，需要从外部联网下载，<strong>因此由于网络的缘故导致工程骨架未能完全下载</strong>，进而导致功能不全的报错。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><strong>调整一下网络</strong>就可以成功创建项目。</p><h3 id="将负责配置的xml文件下载到本地"><a href="#将负责配置的xml文件下载到本地" class="headerlink" title="将负责配置的xml文件下载到本地"></a>将负责配置的xml文件下载到本地</h3><p>如果不想每次都让IDEA去联网下载archetype-catalog.xml文件（IDEA每次新建maven项目都会下载一次这个文件），可以将其下载到本地用户的<code>.m2</code>文件夹下，在新建maven项目时使用本地文件，并在IDEA的maven runner设置中的<code>VM Options</code>一栏输入：<code>-DarchetypeCatalog=local</code></p><h3 id="改变依赖的jar包的下载地址——采用国内镜像"><a href="#改变依赖的jar包的下载地址——采用国内镜像" class="headerlink" title="改变依赖的jar包的下载地址——采用国内镜像"></a>改变依赖的jar包的下载地址——采用国内镜像</h3><p>同样，IDEA的maven项目可以设置自动添加依赖功能，当我们的仓库中没有该jar包的时候可以设置让其自动下载。但是这样添加jar包时要连接网络仓库，为了更快的下载速度，需要更改maven的仓库地址——采用国内阿里云的镜像：在IDEA安装路径下，搜素“settings.xml”（不同版本该文件位置不同），然后在“mirrors”标签中添加我们的mirror标签，如下面的代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重新创建项目，可以发现，使用镜像地址和本地文件后，下载骨架的速度很快，子模块中的文件夹和配置文件的加载也是很快就出来。同时，外部库中也自动地将maven所需的依赖如”maven:junit”引入。在父工程的pom.xml文件中设置servlet的相关依赖后，点击“maven”小图标加载maven变更，外部库中也成功地出现相关依赖jar包。</p><p>实际上，在maven的仓库配置这一块，IDEA软件是自带maven的，如果我们要使用本地计算机原有安装的不同版本的maven，只需要在设置中进行修改，然后在本地计算机的maven安装路径的xml配置文件中，同样设置镜像就可以了。</p><h2 id="Maven-父子项目的依赖继承"><a href="#Maven-父子项目的依赖继承" class="headerlink" title="Maven 父子项目的依赖继承"></a>Maven 父子项目的依赖继承</h2><p>在父项目的pom.xml文件中，在depencyManagement结构体中添加相关依赖dependencies，然后在子项目的依赖文件中，只需要添加groupId和artifactId即可，版本号在父项目的pom.xml中已经定义好了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--子项目的依赖--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet.jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果maven同步后显示子项目代码中引入相关包的报错，可以先在子项目中把version一项加上，同步一次之后再删除这一项。</p><h2 id="Tomcat对IDEA开发项目的部署"><a href="#Tomcat对IDEA开发项目的部署" class="headerlink" title="Tomcat对IDEA开发项目的部署"></a>Tomcat对IDEA开发项目的部署</h2><p><strong>工件和外部源</strong><br>工件 Artifact：Artifact 是maven中的一个概念，表示某个module要如何打包，包括一个项目将要产生的文件，可以是jar文件，源文件，二进制文件，war文件，甚至是pom文件。每个artifact都由groupId:artifactId:version组成的标识符唯一识别。需要被使用(依赖)的artifact都要放在仓库(Repository)中。一个module有了 Artifacts 就可以部署到应用服务器中了。<br>注意，当我们不使用任何框架来创建maven项目时，如果直接添加tomcat配置，会发现只有外部源，而没有工件这一个选项。我们需要右键单击项目，选择添加框架支持，并选择其中的web程序，这样，在配置中就可以看到工件并在其中选择我们的一个或者多个项目模块了。如果还是不行，<a href="https://blog.csdn.net/qq_26963495/article/details/105169789">可能问题出现在IDEA的配置问题中</a>，<a href="https://www.trinea.cn/android/maven/">更多maven概念名词可参见博客</a>。</p><p><strong>发布模式（生产环境）和开发模式（开发环境）</strong></p><p>在IDEA中配置Tomcat服务器时，需要在部署deployment中手动二选一设置：</p><ol><li>servlet-01:war</li><li>servlet-01:war exploded</li></ol><p>这里的servlet-01是web工程的模块名称，两个部署方式在区别在于：</p><ol><li><p>war模式（发布模式）：将web工程以包的形式上传到服务器；</p></li><li><p>war exploded模式（开发模式）：将web工程以当前文件夹的位置关系上传到服务器</p></li></ol><p>很显然，在我们需要不断调试程序的开发过程中，更应使用war exploded模式，这种方式也支持热部署。</p><p>使用war exploded部署方式，还需要在tomcat配置中的Server选项中进行如下改动：</p><ol><li>执行更新操作——<code>On &#39;Update&#39; action</code>项选择<code>Update resources</code>；</li><li>框架停用时——<code>On frame deactivation</code>项选择<code>Update resources</code>；</li></ol><h2 id="maven工程框架的目录-x2F-文件缺失问题"><a href="#maven工程框架的目录-x2F-文件缺失问题" class="headerlink" title="maven工程框架的目录&#x2F;文件缺失问题"></a>maven工程框架的目录&#x2F;文件缺失问题</h2><p>即使我们使用了本地文件+国内镜像的相关配置，有时候使用框架创建maven项目依然可能出现目录&#x2F;文件缺失的情况，这里以webapp文件夹为例，如果我们使用框架搭建的maven项目缺失了该文件夹：</p><ol><li>点击IDEA的第一个”File”选项，点击项目结构”Project Structure”；</li><li>修改Web资源目录和Web模块部署描述符</li></ol><p><img src="/images/%E4%BF%AE%E6%94%B9Web%E8%B5%84%E6%BA%90%E7%9B%AE%E5%BD%95%E5%92%8CWeb%E6%A8%A1%E5%9D%97%E9%83%A8%E7%BD%B2%E6%8F%8F%E8%BF%B0%E7%AC%A6.PNG" alt="修改Web资源目录和Web模块部署描述符"></p><p>如果缺失了其他的文件，我们也可以手动增加。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;在IDEA中创建项目工程后（父工程的src文件夹可以在创建后删除），再选择“module”创建子工程，发现无法自动导入依赖，</summary>
      
    
    
    
    <category term="Java" scheme="http://justskim.github.io/categories/Java/"/>
    
    
    <category term="服务器" scheme="http://justskim.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="java" scheme="http://justskim.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat服务器与Servlet程序</title>
    <link href="http://justskim.github.io/2022/04/08/Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8EServlet%E7%A8%8B%E5%BA%8F/"/>
    <id>http://justskim.github.io/2022/04/08/Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8EServlet%E7%A8%8B%E5%BA%8F/</id>
    <published>2022-04-08T09:50:37.820Z</published>
    <updated>2022-04-08T16:05:53.645Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>按照<a href="https://www.bilibili.com/video/BV12J411M7Sj">狂神的JavaWeb教程</a>，在为Maven项目配置Servlet的映射时，出现了访问地址404的问题，检查文件<code>web.xml</code>的代码，发现在路径映射这一块并没有写错</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--注册Servlet--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.kuang.servlet.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--servlet的请求路径--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="web-xml文件详解"><a href="#web-xml文件详解" class="headerlink" title="web.xml文件详解"></a>web.xml文件详解</h3><p>web.xml的模式文件是由Sun公司定义的，但不是必须的。<strong>web.xml文件是用来配置：欢迎页、servlet、filter等的。当创建的java web工程没用到这些功能时，可以不用web.xml文件来配置你的web工程。</strong>web.xml的模式(Schema)文件中定义了多少种标签元素，web.xml中就可以出现它的模式文件所定义的标签元素，它就能拥有定义出来的那些功能。</p><h3 id="web项目启动的第一步-——web-xml加载过程"><a href="#web项目启动的第一步-——web-xml加载过程" class="headerlink" title="web项目启动的第一步 ——web.xml加载过程"></a>web项目启动的第一步 ——web.xml加载过程</h3><p>启动一个WEB项目时，容器包括（JBoss、Tomcat等）首先会读取项目web.xml配置文件里的配置，当这一步骤成功完成之后，项目才正常启动。更详细的加载过程和文件作用详见<a href="https://www.cnblogs.com/linhuaming/p/9464356.html%E3%80%82">https://www.cnblogs.com/linhuaming/p/9464356.html。</a></p><h2 id="排查问题"><a href="#排查问题" class="headerlink" title="排查问题"></a>排查问题</h2><p>首先在<code>Intellj IDEA</code>界面中查看程序逻辑，并没有运行报错的地方，然后查看tomcat服务器，可以看到Web应用被正常部署并启动：</p><p><img src="/images/tomcat10%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E8%A1%8C%E4%BF%A1%E6%81%AF.PNG" alt="tomcat10中的服务器运行信息"></p><p>在我们设置的 项目部署地址<code>http://localhost:8080/kuang</code>中，可以成功看到<code>hello wordl</code>的返回页面。但是在<code>web.xml</code>文件中<code>Servlet</code>的映射路径<code>http://localhost:8080/kuang/hello</code>中，我们<strong>第一次刷新到此页面</strong>时，可以看得到HTTP状态码500的报错页面：</p><p><img src="/images/%E7%8A%B6%E6%80%81%E7%A0%81500.PNG" alt="状态码500"></p><p>如果再次刷新或者选择其他前缀相同的地址输入，则返回的只是404页面：</p><p><img src="/images/%E7%8A%B6%E6%80%81%E7%A0%81404.PNG" alt="状态码404.PNG"></p><h2 id="排查问题-1"><a href="#排查问题-1" class="headerlink" title="排查问题"></a>排查问题</h2><p>注意我们一开报错的状态码500界面，里面提示<code>jakarta.servlet.ServletException:实例化[com.kuang.servlet.HelloServlet]异常</code>，后面的类是我们自己编写的程序，那么前面的<code>jakarta.servlet</code>包又是怎么回事呢？</p><h3 id="Tomcat与Servlet的关系"><a href="#Tomcat与Servlet的关系" class="headerlink" title="Tomcat与Servlet的关系"></a>Tomcat与Servlet的关系</h3><p>Tomcat是Web应用服务器Server，也是一个Servlet&#x2F;JSP容器，处理Client发来的请求，将请求传递给Servlet，并将Servlet的响应Response传递给Client。</p><p>Servlet 是Java编写的服务端程序，<strong>与协议、平台均无关</strong>，可以动态地扩展Server的能力，像上边说的用请求-响应模式提供Web服务。<strong>编写一个Servlet</strong>，<strong>实际就是按照Servlet规范编写一个Java类</strong>。由于Servlet没有main方法，不能独立运行，因此其必须被部署到Servlet容器中，由容器来实例化并调用Servlet的方法（例如doGet()和doPost()）。</p><p><strong>Servlet容器又称为Servlet引擎</strong>，在Servlet的生命周期内包容和管理Servlet——JSP技术推出后，管理和运行Servlet&#x2F;JSP的容器也称作Web容器。Tomcat就是一个免费开源的Servlet容器。</p><h3 id="Tomcat-10的版本问题"><a href="#Tomcat-10的版本问题" class="headerlink" title="Tomcat 10的版本问题"></a>Tomcat 10的版本问题</h3><p>在IDEA的服务界面中，打开<strong>Tomcat Localhost log</strong>可以看到这么一句报错信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.apache.catalina.core.StandardWrapperValve.invoke 分配异常的servlet [hello]</span><br><span class="line">java.lang.ClassNotFoundException: javax.servlet.http.HttpServlet</span><br></pre></td></tr></table></figure><p>经过查询，发现问题的原因在于<a href="https://blog.csdn.net/qq_55069056/article/details/118105044">Tomcat 10中Servlet无法正常使用</a>，教学视频中演示所用的是tomcat 9，出在了服务器版本问题：</p><blockquote><p>在<code>Tomcat 10</code>中把包名从以往版本的<code>javax</code>改成了<code>jakarta</code>，而<code>maven</code>导包的时候依旧使用原来的<code>javax</code>，导致<code>Tomcat 10</code>服务器的<code>Servlet</code>接口和我写的<code>servlet</code>文件不匹配，从而无法正常运行。</p></blockquote><p>截止至2022年，tomcat 10是最新的版本，这里要提醒踩坑，因为(<strong>Jakarta EE</strong>)[<a href="https://www.cnblogs.com/amon2021/p/15622511.html]%E7%9A%84%E7%BC%98%E6%95%85%E3%80%82%E5%9C%A8Tomcat10.0%E7%89%88%E6%9C%AC%E4%B8%AD%EF%BC%8C%E9%87%8C%E9%9D%A2%E7%9A%84javax.servlet%E4%B8%AD%E7%9A%84%E5%8C%85%E5%90%8D%E5%B7%B2%E7%BB%8F%E6%94%B9%E4%B8%BAjakarta.servlet%E6%9C%80%E5%A5%BD%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E6%9C%80%E6%96%B0%E7%89%88%E7%9A%84tomcat">https://www.cnblogs.com/amon2021/p/15622511.html]的缘故。在Tomcat10.0版本中，里面的javax.servlet中的包名已经改为jakarta.servlet最好不要使用最新版的tomcat</a> 10。对于一切 Java EE，无论是哪个JDK版本，只推荐使用tomcat 9。</p><p>换用tomcat 9之后，重新配置，成功启动！</p><p>这里注意<a href="https://tomcat.apache.org/download-90.cgi">tomcat 9的安装</a>尽可能选择安装版而非压缩包，可以省去环境变量手动配置的麻烦——可能start.bat文件打开后会闪退，但不影响在电脑中的运行。</p><h3 id="端口号8080被占用导致无法启动tomcat服务器"><a href="#端口号8080被占用导致无法启动tomcat服务器" class="headerlink" title="端口号8080被占用导致无法启动tomcat服务器"></a>端口号8080被占用导致无法启动tomcat服务器</h3><p>使用命令 <code>netstat -ano|findstr 端口号</code> 查看占用端口号8080的进程，最右边一列为进程PID，使用命令<code>taskkill /T /F /PID 进程pid</code>终止进程，如果无法终止则在IDEA中改用其他端口。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;按照&lt;a href=&quot;https://www.bilibili.com/video/BV12J411M7Sj&quot;&gt;狂神的JavaWeb教程&lt;/</summary>
      
    
    
    
    <category term="Java" scheme="http://justskim.github.io/categories/Java/"/>
    
    <category term="Servlet" scheme="http://justskim.github.io/categories/Java/Servlet/"/>
    
    
    <category term="java" scheme="http://justskim.github.io/tags/java/"/>
    
    <category term="tomcat" scheme="http://justskim.github.io/tags/tomcat/"/>
    
    <category term="servlet" scheme="http://justskim.github.io/tags/servlet/"/>
    
  </entry>
  
  <entry>
    <title>计算机的各类期刊分级与介绍</title>
    <link href="http://justskim.github.io/2022/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%90%84%E7%B1%BB%E6%9C%9F%E5%88%8A%E5%88%86%E7%BA%A7%E4%B8%8E%E4%BB%8B%E7%BB%8D/"/>
    <id>http://justskim.github.io/2022/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%90%84%E7%B1%BB%E6%9C%9F%E5%88%8A%E5%88%86%E7%BA%A7%E4%B8%8E%E4%BB%8B%E7%BB%8D/</id>
    <published>2022-03-31T10:34:55.244Z</published>
    <updated>2022-05-07T13:25:05.394Z</updated>
    
    <content type="html"><![CDATA[<h2 id="会议论文和期刊论文"><a href="#会议论文和期刊论文" class="headerlink" title="会议论文和期刊论文"></a>会议论文和期刊论文</h2><p>会议论文和期刊论文是两种主要的论文形式：</p><ul><li>会议论文：针对某个学术会议投稿，由学术会议的会务组决定是否录用；</li><li>期刊论文：针对某学术期刊投稿，由期刊编辑部决定是否录用，审稿专家只负责审稿并返回意见，真正决定录用权在期刊编辑手上。</li></ul><p>二者的不同还有以下几点：</p><ol><li>审稿周期上：会议论文一般都比较短，在2周左右，甚至快的只需1周；期刊论文相对慢，国内中文核心期刊一般2个月，普刊在1到3周左右，部分水刊录用速度很快。</li><li>权威性上：会议论文现在很多都比较水，期刊的话也有水刊，这些都难以被单位认可。有论文集出版的会议论文，在国内的认可度相对较好。<a href="https://zhuanlan.zhihu.com/p/49521821">要学会如何判断EI会议权威性</a>。</li></ol><p>尚未被会议论文集出版的会议论文可以发期刊（出版了就有版权），但是需要在会议论文的基础上进行再次加工——这是因为<strong>会议论文基本上没有完成</strong>，在会议上发表论文的用意是为了让其他人知道自己的研究并取得反馈。扩充的比例依期刊审稿严格程度而定，多数要求扩充30%以上。</p><h2 id="A类、B类、C类期刊"><a href="#A类、B类、C类期刊" class="headerlink" title="A类、B类、C类期刊"></a>A类、B类、C类期刊</h2><p>A、B、C类期刊是<strong>科研单位自主对学术期刊的简单认定，标准由单位自定</strong>。A类最好，B类其次，C类刊物有时会称之为C刊（注意，和人文社科期刊中的C刊——CSSCI期刊要划分开来，同名不同意）。以上三类在一些单位也会被分为一二三类期刊。D刊较为少见，一些有刊号非核心的期刊会被称为省级期刊，不会被科研单位算入成绩。<br>计算机领域通常的A、B、C类期刊，是CCF（中国计算机学会）推荐的高水平期刊，也就是CCF 1，CCF B，CCF C——CCF A非常难，一篇足以博士毕业了——其划分可参考<a href="https://blog.csdn.net/ztf312/article/details/102918185">该文章</a>。</p><h2 id="SCI，SSCI，EI"><a href="#SCI，SSCI，EI" class="headerlink" title="SCI，SSCI，EI"></a>SCI，SSCI，EI</h2><p>国际三大科技文献检索分别是 SCI（科学引文索引）、EI（工程索引）和ISTP（科技会议录索引）。</p><h3 id="SCI"><a href="#SCI" class="headerlink" title="SCI"></a>SCI</h3><p>SCI即《科学引文索引》（Science Citation Index），从来源期刊数量分为：</p><ul><li>SCI：来源期刊为3500多种的SCI印刷版和SCI光盘版（SCI Compact Disc Edition，简称SCI CDE）</li><li>SCI-E：即SCI Expanded，是SCI的扩展库，收录更多，接近6000种来源期刊，可通过联网进行检索。</li></ul><h3 id="SSCI"><a href="#SSCI" class="headerlink" title="SSCI"></a>SSCI</h3><p>SSCI即社会科学引文索引（Social Sciences Citation Index），收录社会科学类期刊。</p><h3 id="CSSCI"><a href="#CSSCI" class="headerlink" title="CSSCI"></a>CSSCI</h3><p>CSSCI是南京大学的“中文社会科学引文索引”，也被称为C刊（注意和C类刊物分开），又称为南大核心。工科学生了解这个名词就行。</p><h3 id="EI"><a href="#EI" class="headerlink" title="EI"></a>EI</h3><p>EI 即《工程索引》（The Engineering Index）。国内的EI期刊有自动化学报、软件学报、通信学报、计算机辅助设计与图形学学报等，EI检索到的通常是这些刊物的英文版。<strong>EI期刊的发表要求和学术价值都高于EI会议</strong>。</p><h3 id="能被上述索引检索到的中文期刊"><a href="#能被上述索引检索到的中文期刊" class="headerlink" title="能被上述索引检索到的中文期刊"></a>能被上述索引检索到的中文期刊</h3><p>能够被以上这些国际学术检索系统检索到的中文刊物，其发表难度要求与其他英文期刊也是一视同仁的！由于中文稿投稿SCI也要翻译成英文，因此有些作者一开始就用英文写作可以提高效率。<br>国内的EI期刊：自动化学报、软件学报、通信学报、计算机辅助设计与图形学学报等。<br>中文SCI期刊：</p><h2 id="一区，二区"><a href="#一区，二区" class="headerlink" title="一区，二区"></a>一区，二区</h2><p>一区、二区等指中科院对SCI的分区（不同地方可能有所不同，但大部分常用中科院的标准），按照各类期刊影响因子划分，前5%为该类一区，前6%<del>20%为二区，21%</del>50%为三区，其余为四区，越靠前自然质量越高。</p><h3 id="CCF-ABC与SCI的分区关系"><a href="#CCF-ABC与SCI的分区关系" class="headerlink" title="CCF ABC与SCI的分区关系"></a>CCF ABC与SCI的分区关系</h3><p><strong>二者之间没有必然练习，CCF是计算机行业权威人士排行，因此计算机学科比较注重CCF的分类</strong>。</p><h2 id="可视化方向的期刊"><a href="#可视化方向的期刊" class="headerlink" title="可视化方向的期刊"></a>可视化方向的期刊</h2><p>IEEE Transactions on Visualization and Computer Graphics，可视化领域最权威的期刊</p><p>谷歌学术中搜索：<code>visualization source:(&quot;IEEE Transactions source:on source:Visualization source:and source:Computer source:Graphics&quot;)</code></p><p><code>source:</code>前面的是要搜索的关键字</p><p>注意！不能搜<code>hadoop source:(&quot;IEEE Transactions Visualization and Computer Graphics&quot;)</code>，会得到错误或者空白的结果。</p><p>VIS顶会——全称 IEEE Visualization and Visual Analytics</p><p>注意，上面两个名词，一个是期刊，一个是会议，有<a href="https://zhuanlan.zhihu.com/p/259298679?utm_source=wechat_session">厉害的文章</a>可以两个都进。</p><p>info和vast都是年会的重要组成部分，收录的文章相似，但还是有些区别。具体细节可参考VIS会议的官方网站: InfoVis和VAST。<br><a href="https://www.jianshu.com/p/a6aebce572bd?t=123">具体的二者差别</a>：<br>VAST(IEEE Visual Analytics Science and Technology)—— IEEE <strong>视觉分析</strong>科学与技术会议 ( VAST 2017) 是领先的国际会议，致力于 视觉分析的进步。 会议范围，同地 在 VIS 与年度 IEEE 科学可视化会议和 IEEE 信息可视化会议，包括 可视化分析中的基础研究贡献以及 视觉分析在科学、工程、医学中的应用， 健康、媒体、商业、社交互动、安全和 调查分析等学科。<br>INFO(IEEE Information Visualization)——IEEE <strong>信息可视化</strong> (InfoVis) 原创研究论文。 论文可能会贡献新的或改进的视觉编码或交互技术； 评估技术和工具； 与可视化相关的模型或理论； 支持可视化数据分析的系统； 以及将可视化应用于广泛的现实世界环境和领域。 </p><p><a href="http://chinavis.org/2022/index.html">ChinaVis</a>——中国可视化与可视分析大会，宗旨是促进中国及周边地区的可视化与可视分析研究与应用的交流，探讨在大数据时代可视化与可视分析发展的方向与机遇，每年均有论文征稿，可见<a href="http://chinavis.org/2022/callforpaper.html">官网详细征稿信息</a>。2022年大会录取的英文研究论文将发表到 SCI期刊《Journal of Visualization》，中文论文将发表到CCF中文A类期刊《计算机辅助设计与图形学学报》。大会录取的英文综述论文将在SCI期刊《Visual Informatics》上发表，中文综述论文将在CCF中文A类期刊《计算机辅助设计与图形学学报》上发表。该会议每年还会举办<a href="http://chinavis.org/2021/challenge.html">数据可视化竞赛</a> 。            </p><p><a href="https://blog.csdn.net/amych_/article/details/108616961">如何使用IEEE搜索指定期刊&#x2F;会议</a>？</p><p>在2022年的新版页面设计中，”calls a paper”这个选项要到页面底部去查找，我们点击该选项后，可以在<a href="https://publication-recommender.ieee.org/home">“Search for upcoming call for paper deadlines in your field of interest”</a>中选择会议（Conferences）或者期刊（Periodicals），中间白色输入框内输入检索关键字，然后点击“Get Recommendation”。</p><p>如果我们搜的是期刊“IEEE Transactions Visualization and Computer Graphics”（注意，呈现的结果是“Visualization and Computer Graphics, IEEE Transactions on”），点击进入页面中，可以看到IEEE TVCG 的影响因子（Impact factor）为4.579，相当高了。页面中会提示期刊主页(IEEE Periodical home page)——<a href="https://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=2945">IEEE Transactions on Visualization and Computer Graphics</a>，但是在”current issue”中可以采用左边的搜索框只能搜索到该年的文献，在”all issue”中则无法进行检索。</p><p><strong>IEEE检索某个期刊下全部符合条件的文章</strong></p><p>在搜索框中输入关键词后，在左侧过滤选项的“<strong>Publication Title</strong>”中选择期刊，我们可以看到最顶上的就是TVCG。</p><p>如果我们搜的是会议“IEEE Visualization and Visual Analytics”，会发现会议是没有影响因子的，就如我们之前说的，<strong>会议论文往往尚未完成</strong>。在导向的网站中没有可以看论文的地方，详见如下：</p><p><a href="https://blog.csdn.net/Strive_For_Future/article/details/118361928">如何使用谷歌学术搜索指定期刊</a>？在谷歌学术中找不到VIS的论文——因为大部分论文完成后，都会被推荐到期刊发表（比如顶级的TVCG）。</p><p><strong>检索综述某个类型的文献</strong></p><p>以知识图谱的综述为例，在<a href="http://www.scopus.com中搜索&quot;knowledge/">www.scopus.com中搜索&quot;Knowledge</a> Graph”后，可以在左侧栏目中，找到文献类型一栏，点击其中的“review”，限制范围后得到关于知识图谱的综述类论文。</p><p>或者在搜索中添加相关字段，如“overview”“survey”“review”</p><p><img src="/images/%E6%9F%A5%E6%89%BE%E7%BB%BC%E8%BF%B0%E7%B1%BB%E8%AE%BA%E6%96%87.png" alt="查找综述类论文.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;会议论文和期刊论文&quot;&gt;&lt;a href=&quot;#会议论文和期刊论文&quot; class=&quot;headerlink&quot; title=&quot;会议论文和期刊论文&quot;&gt;&lt;/a&gt;会议论文和期刊论文&lt;/h2&gt;&lt;p&gt;会议论文和期刊论文是两种主要的论文形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;会议论文：针对某</summary>
      
    
    
    
    <category term="Diary" scheme="http://justskim.github.io/categories/Diary/"/>
    
    
    <category term="life" scheme="http://justskim.github.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Java Reflection反射机制</title>
    <link href="http://justskim.github.io/2022/03/30/Java-Reflection%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>http://justskim.github.io/2022/03/30/Java-Reflection%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</id>
    <published>2022-03-30T10:20:57.484Z</published>
    <updated>2022-03-30T15:11:17.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>Java 反射机制</strong>可以让我们在编译期（Compile Time）之外的运行期（Runtime）获得任何一个类的字节码。 包括接口、变量、方法等信息。</p><p>编译期：把源码交给编译器编译成计算机可以执行的文件的过程。在 Java 中也就是把 Java 代码编成 class 文件的过程。编译期只是做了一些翻译功能，并没有把代码放在内存中运行起来，而只是把代码当成文本进行操作，比如检查错误；</p><p>运行期：把编译后的文件交给计算机执行，直到程序运行结束。运行期中会把在磁盘中的代码放到内存中执行起来。</p><h3 id="使用背景"><a href="#使用背景" class="headerlink" title="使用背景"></a>使用背景</h3><p><a href="https://blog.csdn.net/weixin_42041027/article/details/101451331">为什么需要Java反射</a>？我们先看一下Java的内存模型</p><p><img src="/images/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="Java内存模型"></p><p><strong>class对象</strong>：不是new出来的对象o，而是<strong>类的类型对象，每个类只有一个class对象，作为方法区类的数据结构的接口</strong>。<a href="https://so.csdn.net/so/search?q=jvm&spm=1001.2101.3001.7020"><code>jvm</code></a>创建对象前，会先检查类是否加载，寻找类对应的class对象，若加载好，则为你的对象分配内存，初始化也就是代码:new Object()。</p><p><strong>方法区</strong>存的是类的信息，不是存类对象的。</p><p><strong>类加载器</strong>加载类是通过方法区上类的信息在堆上创建一个类的Class对象，这个Class对象是唯一的，由<code>JVM</code>保证唯一，之后对这个类的创建都是根据这个Class对象来操作的</p><p>程序对象是自己new的，程序相当于写死了给jvm去跑。假如一个服务器上突然遇到某个请求要用到某个类但没加载进<code>jvm</code>，还要停下来自己写段代码，new一下，重新启动一下服务器</p><p>因此需要使用到反射：当我们的程序在运行时，需要动态的加载一些类，这些类可能之前用不到所以不用加载到<code>jvm</code>，而是在运行时根据需要才加载，这样的好处对于服务器来说不言而喻。</p><blockquote><p>动态语言（弱类型语言）：在运行时可以改变数据类型，变量在使用之前无需声明类型，通常变量的值是被赋值的那个值的类型。包括：PHP，JavaScript，Python。</p><p>静态语言（强类型语言）：编译时变量的数据类型即可确定，其中大多数会要求在使用变量之前声明其数据类型，包括：C&#x2F;C++，Java。</p></blockquote><p>尽管Java是静态语言，但反射机制的存在使Java被称为“准动态语言”，可以利用反射机制获得类似动态语言的特性。反射机制允许程序在运行期借助于 <strong>Reflection API</strong> 取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。<br>加载完类之后，在堆内存的方法区中产生一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。<strong>这个对象就像一面镜子一样，我们可以通过这个对象看到类的结构，因此，称之为：反射</strong>。<br>正常方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[引入需要的包类名称] --&gt; B[通过new实例化]</span><br><span class="line">B--&gt;C[取得实例化对象]</span><br></pre></td></tr></table></figure><p>反射方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[实例化对象] --&gt;B[&quot;getClass()&quot;方法]</span><br><span class="line">B--&gt;C[得到完整的包类名称]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Java 反射机制&lt;/strong&gt;可以让我们在编译期（Compile Time）之外的运行期（Runtime）获得任何一个</summary>
      
    
    
    
    <category term="Java" scheme="http://justskim.github.io/categories/Java/"/>
    
    
    <category term="java" scheme="http://justskim.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>LaTex,mikTex与word中auora插入</title>
    <link href="http://justskim.github.io/2022/03/27/LaTex,mikTex%E4%B8%8Eword%E4%B8%ADauora%E6%8F%92%E5%85%A5/"/>
    <id>http://justskim.github.io/2022/03/27/LaTex,mikTex%E4%B8%8Eword%E4%B8%ADauora%E6%8F%92%E5%85%A5/</id>
    <published>2022-03-27T02:48:02.292Z</published>
    <updated>2022-03-27T02:48:02.296Z</updated>
    
    <content type="html"><![CDATA[<p>latex和tex及相关软件都是<strong>跨平台、免费、开源</strong>的。LaTeX是基于TeX的一组宏集，相当于对TeX进行了一次封装。我相信使用LaTeX的用户一定对编程语言有一定了解，可以对某些功能进行封装，屏蔽一些细节，LaTeX是在TeX基础上，规范化出了一种格式，一种编写风格。</p><p><a href="https://blog.csdn.net/jucksu/article/details/116307244">在word中插入算法伪代码需要安装miktex和aurora</a>。注意路径<code>\miktex\bin\x64</code>下有<code>mitkex-console.exe</code>的控制台启动文件。</p><p>在windows系统中编写latex文件有多种方式，基于我们上边已经安装了mikTex，可以选择<a href="https://www.jianshu.com/p/5d59f2929d06">下载并安装texStudio工具</a>来作为latex文件的编辑器。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;latex和tex及相关软件都是&lt;strong&gt;跨平台、免费、开源&lt;/strong&gt;的。LaTeX是基于TeX的一组宏集，相当于对TeX进行了一次封装。我相信使用LaTeX的用户一定对编程语言有一定了解，可以对某些功能进行封装，屏蔽一些细节，LaTeX是在TeX基础上，规范</summary>
      
    
    
    
    <category term="Latex" scheme="http://justskim.github.io/categories/Latex/"/>
    
    
    <category term="latex" scheme="http://justskim.github.io/tags/latex/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程编程</title>
    <link href="http://justskim.github.io/2022/03/26/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    <id>http://justskim.github.io/2022/03/26/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</id>
    <published>2022-03-26T08:42:38.194Z</published>
    <updated>2022-03-30T10:03:10.437Z</updated>
    
    <content type="html"><![CDATA[<p>jdk11API中文文档中对java.lang.Thread类的介绍：</p><blockquote><ul><li><p><a href="Object.html">java.lang.Object</a> </p></li><li><ul><li>java.lang.Thread</li></ul></li><li><ul><li><p>实现的所有接口 </p><p><code>Runnable</code> </p></li><li><p>已知直接子类： </p><p><code>ForkJoinWorkerThread</code></p></li></ul><p> public class Thread</p></li></ul><p>extends Object<br>implements Runnable线程是程序中执行的线程。 Java虚拟机允许应用程序同时运行多个执行线程。     </p></blockquote><p>操作系统中，我们了解到当CPU的核数&lt;当前任务运行数量的时候，多任务的执行其实是轮流交替的。一个任务&#x3D;一个进程，而进程内至少有一个线程，即子任务。<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1304521607217185">多线程模型是Java程序最基本的并发模型，数据库处理和Web操作等都要依赖它</a>：</p><blockquote><p>Java语言内置了多线程支持：一个Java程序实际上是一个JVM进程，JVM进程用一个主线程来执行<code>main()</code>方法，在<code>main()</code>方法内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。</p><p>进程和线程是包含关系，但是多任务既可以由多进程实现，也可以由单进程内的多线程实现，还可以混合多进程＋多线程。</p><p>具体采用哪种方式，要考虑到进程和线程的特点。</p><p>和多线程相比，多进程的缺点在于：</p><ul><li>创建进程比创建线程开销大，尤其是在Windows系统上；</li><li>进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。</li></ul><p>而多进程的优点在于：</p><p>多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。</p></blockquote><p>我们创建一个程序来新建一个线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"><span class="comment">//可以重写父类的run()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;System.out.println(<span class="string">&quot;run()方法中执行&quot;</span>+i);&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String []args)</span>&#123;</span><br><span class="line">        <span class="type">TestThread1</span> <span class="variable">testThread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestThread1</span>();</span><br><span class="line">        <span class="comment">//建一个新线程非常容易，我们需要实例化一个Thread实例，然后调用它的start()方法，start()方法会在内部自动调用实例的run()方法</span></span><br><span class="line">        testThread1.start();</span><br><span class="line">        <span class="comment">//start()方法被调用时，JVM就创建了一个新线程，线程开启不一定立即执行，由CPU调度执行，所以我们可以看到控制台交替打印“run()...”“main()...”</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        testThread1.run();</span></span><br><span class="line"><span class="comment">        注意，如果我们把上面的start语句注释掉，直接调用run方法，相当于调用了一个普通的Java方法，当前线程并没有任何改变，也不会启动新线程。</span></span><br><span class="line"><span class="comment">        必须调用Thread实例的start()方法才能启动新线程，如果我们查看Thread类的源代码，会看到start()方法内部调用了一个private native void start0()方法，</span></span><br><span class="line"><span class="comment">        native修饰符表示这个方法是由JVM虚拟机内部的C代码实现的，不是由Java代码实现的。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">222</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main()方法中执行&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用<code>Thread.setPriority(int n)</code>来设置<strong>线程</strong>优先级，但注意！优先级高的线程被操作系统调度的优先级较高，操作系统对高优先级线程可能调度更频繁，但我们决不能通过设置优先级来确保高优先级的线程一定会先执行。</p><p>注意，Java用一个<code>Thread</code>对象表示一个线程，通过调用<code>start()</code>启动一个新线程，像进程的创建状态一样一个线程对象只能调用一次<code>start()</code>方法。无论采用何种方法创建线程，都要将线程的执行代码写在重写的<code>run()</code>方法中：</p><blockquote><p>如果此线程是使用单独的<code>Runnable</code>运行对象构造的，则调用该<code>Runnable</code>对象的<code>run</code>方法;  否则，此方法不执行任何操作并返回。</p><p>这很好理解，创建线程必然是要赋予其功能的，采用Thread类创建的线程默认没有任务功能，自然不进行任何操作，相当于无效占用资源。</p></blockquote><p>线程调度由操作系统决定，程序本身无法决定调度顺序；</p><p><code>Thread.sleep()</code>可以把当前线程暂停一段时间。</p><p>使用<code>getState()</code>可以返回线程的状态，返回值是一个<code>java.lang.Thread.State </code>的枚举类型（注意<strong>java.lang.Enum</strong> 类是所有<strong>Java</strong>语言枚举类型的公共基类）</p><p>线程的各种状态变化如下图：</p><p><img src="/images/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%84%E7%A7%8D%E7%8A%B6%E6%80%81.jpg" alt="线程的各种状态"></p><p>这里注意一下<a href="https://blog.csdn.net/muzhixi/article/details/105197446">WAITING、TIMED_WAITING与BLOCKED的区别</a>：</p><blockquote><ul><li>WAITING：进入等待状态，方式：wait&#x2F;join&#x2F;park方法进入无限等待，通过notify&#x2F;notifyAll&#x2F;unpark唤醒；</li><li>TIMED_WAITING：与WAITING类似，方式：a. 给定等待时间的wait&#x2F;join&#x2F;park方法；b. sleep方法；</li><li>BLOCKED：被动进入等待状态，方式：进入Synchronized块。</li></ul></blockquote><h3 id="进程的结束"><a href="#进程的结束" class="headerlink" title="进程的结束"></a>进程的结束</h3><p>Java程序入口就是由JVM启动<code>main</code>线程，<code>main</code>线程又可以启动其他线程。当所有线程都运行结束时，JVM退出，进程结束。</p><p>如果有一个线程没有退出，JVM进程就不会退出。所以，必须保证所有线程都能及时结束。</p><p>但是这样引发一个问题，比如有一些线程是定时执行或者随时都在执行的，不结束就无法结束<code>JVM</code>进程，同时也没有专门的线程用来负责结束这一类线程。这时候就要使用<strong>守护线程（Daemon Thread）</strong>——为其他线程服务的线程。在<code>JVM</code>中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。创建守护线程，只需在<code>start()</code>函数前调用<code>setDaemon(true)</code>把该线程标记为守护线程即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure><h3 id="使用接口创建线程"><a href="#使用接口创建线程" class="headerlink" title="使用接口创建线程"></a>使用接口创建线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;<span class="comment">//线程的主体类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;System.out.println(<span class="string">&quot;start new thread!&quot;</span>);&#125;</span><br><span class="line">    <span class="comment">//线程的主体方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在文章开头我们给出了<code>jdk11</code>文档中<code>Thread</code>类的说明，反应到代码中就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>可知，继承Thread类时覆写的还是Runnable接口的run()方法。</p><p>如果一个类<strong>继承Thread，则不适合资源共享</strong>（注意并不是不能，当以Thread方式去实现资源共享时，实际上源码内部是将thread向下转型为了Runnable，实际上内部依然是以Runnable形式去实现的资源共享），但若实现了Runable接口的话，则很容易的实现资源共享。</p><ul><li>继承Thread类：<ul><li>子类继承Thread类具备多线程能力</li><li>启动线程：子类对象.start()</li><li>不建议使用：避免OOP单继承局限性</li></ul></li><li>实现Runnable接口：<ul><li>实现Runnable接口具有多线程能力</li><li>启动线程：传入目标对象+Thread对象.start()</li><li>推荐使用：避免单继承局限性，<strong>方便同一个对象被多个线程使用</strong></li></ul></li></ul><blockquote><p>java中的单继承是指<strong>一个子类最多只能有一个父类</strong>，不支持多继承。单继承使JAVA的继承关系很简单，一个类只能有一个父类，易于管理程序。但一个类可以实现多个接口，从而克服单继承的缺点。</p></blockquote><p>还有一种比较少用的，Java1.5之后才出现的Callable接口方式，Callable接口和Runnable接口的异同：</p><ul><li>都是 Functional 接口（函数式接口），因此可以直接使用Lamba表达式来实现线程函数，而不一定非得实现一个类来实现接口。</li><li>Runnable 可以直接传给 Thread 构造方法，Callable 不可以;</li><li>Callable 只能使用 ExecutorService，但是Callable可以返回线程的运行结果，Runnable 不可以。</li></ul><blockquote><p>附注：函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口，函数式接口可以被隐式转换为 lambda 表达式。</p></blockquote><h3 id="Thread类中的静态方法"><a href="#Thread类中的静态方法" class="headerlink" title="Thread类中的静态方法"></a>Thread类中的静态方法</h3><p>Thread类中的静态方法表示操作的线程是”<strong>正在执行静态方法所在的代码块的线程</strong>“。用处：能对CPU<strong>当前正在运行的线程</strong>进行操作。下面来看一下Thread类中的静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Race</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">//winner</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String winner;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获取现在正在运行的进程，currentThread会返回一个Thread对象的引用，getName是实例（非静态）方法，会返回一个String类型的线程对象的名称</span></span><br><span class="line">        <span class="keyword">if</span>(Thread.currentThread().getName().equals(<span class="string">&quot;rabbit&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2</span>);</span><br><span class="line">                <span class="comment">//sleep是一个静态方法，让线程休眠2毫秒</span></span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Race</span> <span class="variable">race</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Race</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(race,<span class="string">&quot;rabbit&quot;</span>).start();<span class="comment">//新建一个线程并随之启动</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(race,<span class="string">&quot;tortoise&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在Java5之后，并发线程这块发生了根本的变化，最重要的莫过于新的启动、调度、管理线程的一大堆API了。在Java5以后，通过Executor来启动线程比用Thread的start()更好。在新特征中，可以很容易控制线程的启动、执行和关闭过程，还可以很容易使用线程池的特性。</p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>背景：经常创建、销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大</p><p>思路：提前创建好多个线程，放入线程池<code>ThreadPool</code>中，使用时直接获取，使用完放回池中，避免频繁创建销毁，实现重复利用，类似路上的公共交通工具。从JDK5.0开始提供了线程池的两个相关API：<code>ExecutorService</code>和<code>Executors</code></p><p><code>ExecutorService</code>：真正的线程池接口，实现该接口的最常见子类**<code>ThreadPoolExecutor</code>**，有以下三个常用方法：</p><ol><li><code>void execute(Runnable command)</code>：执行任务&#x2F;命令，没有返回值，一般用来执行<code>Runnable</code></li><li><code>&lt;T&gt; Fulture&lt;T&gt;submit(Callable&lt;T&gt; task)</code>：执行任务，且有返回值</li><li><code>void shutdown()</code>：关闭连接池</li></ol><p><code>Executors</code>：工具类、线程池的工厂类，作用：创建并返回不同类型的线程池。</p><p><code>ThreadPoolExecutor()</code>类构造方法中有以下三个重要参数：</p><ul><li><p>corePoolSize：池中保留的线程数，即核心池的大小</p></li><li><p>maximumPoolSize：最大线程数</p></li><li><p>keepAliveTime：线程没有任务时最多保持多长时间后会终止</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建服务，创建线程池，参数为：线程池大小</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">System.out.println(service.getClass());</span><br><span class="line">        <span class="comment">//输出结果为：class java.util.concurrent.ThreadPoolExecutor 是ExecutorService接口下的一个实现类</span></span><br><span class="line">        <span class="comment">//执行</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">MyThread</span>());</span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">MyThread</span>());</span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">MyThread</span>());</span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">MyThread</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭链接</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;System.out.println(Thread.currentThread().getName());&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在前面讲到了通过接口Runnable创建线程的方式，这里使用Executors类的静态方法<code>newFixedThreadPool(int nThreads)</code>来创建一个线程池，该方法会返回一个接口类型——实际是返回值付给一个实现了此接口的实现类的实例。</p><p>Executors类中定义的newFixedThreadPool方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());&#125;</span><br></pre></td></tr></table></figure><p>我们查看newFixedThreadPool方法的源代码，可以发现，返回值是一个ExecutorService接口下的ThreadPoolExecutor类对象</p><p><img src="/images/ExecutorSercice%E6%8E%A5%E5%8F%A3.PNG" alt="ExecutorSercice接口"></p><p>该类中有一方法<code>void execute(Runnable command)</code>，用于在将来某个时期执行给定的任务。</p><h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p>private 关键字可以保证数据对象智能被方法访问。synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符(public、protected、default、private)。<code>synchronized</code>关键字包括两种用法：<code>synchronized</code>方法和<code>synchronized</code>块</p><p>同步方法：<code>public synchronized void method(int args[])&#123;&#125;</code></p><p><code>synchronized</code>方法控制对“对象”的访问，每个对象对应一把锁，每个<code>synchronized</code>方法都必须获得调用该方法的对象的锁才能执行，否则线程阻塞。而方法一旦执行，就独占该锁，知道该方法返回才将该锁释放，后面被阻塞的线程才能获得这个锁，继续执行。<strong>由<code>synchronized</code>关键字声明的方法同一时间只能被一个线程访问</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">showDetails</span><span class="params">()</span>&#123;</span><br><span class="line">.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注： synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类</strong></p><h2 id="Java并发包"><a href="#Java并发包" class="headerlink" title="Java并发包"></a>Java并发包</h2><p>“并发包”指的是 JDK 1.5 版本引入的<code>java.util.concurrent</code>包，简称 J.U.C，其中包含大量多线程和并发编程的工具，其中有以下几个常用类：</p><blockquote><p>CopyOnWriteArrayList是ArrayList的线程安全版本，在有写操作的时候会copy一份数据，然后写完再设置成新的数据，适用于读多写少的并发场景。CopyOnWriteArraySet是线程安全版本的Set实现，它的内部通过一个CopyOnWriteArrayList来代理读写等操作，使得CopyOnWriteArraySet表现出了和CopyOnWriteArrayList一致的并发行为，他们的区别在于数据结构模型的不同，set不允许多个相同的元素插入容器中。</p><p>Seamphore（信号量），在多线程环境下使用的一种设施。类似于控制并发的时候用到的“令牌桶”算法，负责协调各个线程，通过控制信号总数，不断释放和回收信号来控制并发数量，以保证它们能够正确、合理的使用公共资源。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;jdk11API中文文档中对java.lang.Thread类的介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;Object.html&quot;&gt;java.lang.Object&lt;/a&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;java.</summary>
      
    
    
    
    <category term="Java" scheme="http://justskim.github.io/categories/Java/"/>
    
    
    <category term="java" scheme="http://justskim.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>编程语言的文档注释</title>
    <link href="http://justskim.github.io/2022/03/18/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A/"/>
    <id>http://justskim.github.io/2022/03/18/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A/</id>
    <published>2022-03-18T13:51:04.790Z</published>
    <updated>2022-03-19T03:03:14.052Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-文档注释"><a href="#Java-文档注释" class="headerlink" title="Java 文档注释"></a>Java 文档注释</h2><p>Java 支持三种注释方式。前两种和<code>C++</code>的注释一样，分别是 <code>//</code> 和 <code>/* */</code>。<strong>第三种</strong>被称作<strong>说明注释</strong>，它以 <code>/**</code>开始，以 <code>*/</code>结束。</p><blockquote><p>说明注释允许我们在程序中嵌入关于程序的信息，也可以使用 javadoc 工具软件来生成信息，并输出到HTML文件中。</p></blockquote><p>菜鸟教程给出了以下的<a href="https://www.runoob.com/java/java-documentation.html"><code>javadoc</code>标签</a>：</p><table><thead><tr><th align="left"><strong>标签</strong></th><th align="center"><strong>描述</strong></th><th align="center"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left">@author</td><td align="center">标识一个类的作者</td><td align="center">@author description</td></tr><tr><td align="left">@deprecated</td><td align="center">指名一个过期的类或成员</td><td align="center">@deprecated description</td></tr><tr><td align="left">{@docRoot}</td><td align="center">指明当前文档根目录的路径</td><td align="center">Directory Path</td></tr><tr><td align="left">@exception</td><td align="center">标志一个类抛出的异常</td><td align="center">@exception exception-name explanation</td></tr><tr><td align="left">{@inheritDoc}</td><td align="center">从直接父类继承的注释</td><td align="center">Inherits a comment from the immediate surperclass.</td></tr><tr><td align="left">{@link}</td><td align="center">插入一个到另一个主题的链接</td><td align="center">{@link name text}</td></tr><tr><td align="left">{@linkplain}</td><td align="center">插入一个到另一个主题的链接，但是该链接显示纯文本字体</td><td align="center">Inserts an in-line link to another topic.</td></tr><tr><td align="left">@param</td><td align="center">说明一个方法的参数</td><td align="center">@param parameter-name explanation</td></tr><tr><td align="left">@return</td><td align="center">说明返回值类型</td><td align="center">@return explanation</td></tr><tr><td align="left">@see</td><td align="center">指定一个到另一个主题的链接</td><td align="center">@see anchor</td></tr><tr><td align="left">@serial</td><td align="center">说明一个序列化属性</td><td align="center">@serial description</td></tr><tr><td align="left">@serialData</td><td align="center">说明通过writeObject( ) 和 writeExternal( )方法写的数据</td><td align="center">@serialData description</td></tr><tr><td align="left">@serialField</td><td align="center">说明一个ObjectStreamField组件</td><td align="center">@serialField name type description</td></tr><tr><td align="left">@since</td><td align="center">标记当引入一个特定的变化时</td><td align="center">@since release</td></tr><tr><td align="left">@throws</td><td align="center">和 @exception标签一样.</td><td align="center">The @throws tag has the same meaning as the @exception tag.</td></tr><tr><td align="left">{@value}</td><td align="center">显示常量的值，该常量必须是static属性。</td><td align="center">Displays the value of a constant, which must be a static field.</td></tr><tr><td align="left">@version</td><td align="center">指定类的版本</td><td align="center">@version info</td></tr></tbody></table><p><a href="http://c.biancheng.net/view/6262.html">C语言中文网</a>中有着更详细的<code>Javadoc</code>介绍：</p><p>对两种标签格式的说明：</p><ul><li>@tag 格式的标签（不被<code>&#123; &#125;</code>包围的标签）为块标签，只能在主要描述（类注释中对该类的详细说明为主要描述）后面的标签部分（如果块标签放在主要描述的前面，则生成 API 帮助文档时会检测不到主要描述）。</li><li>{@tag} 格式的标签（由<code>&#123; &#125;</code>包围的标签）为内联标签，可以放在主要描述中的任何位置或块标签的注释中。</li></ul><p><code>Javadoc</code>标签注意事项：</p><ul><li>Javadoc 标签必须从一行的开头开始，否则将被视为普通文本。</li><li>一般具有相同名称的标签放在一起。</li><li>Javadoc 标签区分大小写，代码中对于大小写错误的标签不会发生编译错误，但是在生成 API 帮助文档时会检测不到该注释内容。</li></ul><h3 id="Javadoc命令"><a href="#Javadoc命令" class="headerlink" title="Javadoc命令"></a>Javadoc命令</h3><p><code>Javadoc</code> 用法格式如下：</p><p><code>javadoc [options] [packagenames] [sourcefiles]</code></p><p>其中options 表示<code>Javadoc</code> 命令的选项，<code>packagenames</code>表示包名，这两个是可选项。</p><p>如果我们的代码中有中文的注释，可以使用命令<code>javadoc -encoding UTF-8 -charset UTF-8 Javadoc_demo.java</code>编译出相应的Html文档让我们阅读。</p><h3 id="java说明注释——javadoc标签的使用"><a href="#java说明注释——javadoc标签的使用" class="headerlink" title="java说明注释——javadoc标签的使用"></a><code>java</code>说明注释——<code>javadoc</code>标签的使用</h3><p>以<code>IDEA</code>软件为例，由于其自动补全的功能，我们只需要输入<code>/**</code>然后回车即可，每一行都会智能地为我们的注释文字在开头补上<code>*</code>符号。我们不仅可以在主类外写说明注释，还可以先写上类中的成员函数，然后在成员函数上头输入<code>/**</code>，<code>IDEA</code>将会自动为我们补全相关信息，比如参数 <code>param</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mike</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Javadoc_test</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JSDoc——JavaScript之注释规范化"><a href="#JSDoc——JavaScript之注释规范化" class="headerlink" title="JSDoc——JavaScript之注释规范化"></a>JSDoc——JavaScript之注释规范化</h2><p>原生的JavaScript语法中并没有像Java那样的说明注释，<code>JSDoc</code> 是一个针对 JavaScript 的 <code>API</code> 文档生成器，可以在其<a href="https://jsdoc.app/index.html">官网</a>查看介绍，类似于 Java 中的 <code>Javadoc</code> 或者 <code>PHP</code> 中的 <code>phpDocumentor</code>。我们在<code>js</code>格式代码中添加像<code>javadoc</code>标签般的注释，即可被<code>JSDoc</code>工具自动扫描并生成<code>API</code>文档。<a href="https://knightyun.github.io/2020/03/13/js-comment-format">这位博主的博客文章中介绍了该工具的使用</a>：</p><blockquote><p>首先要使用<code>npm</code>进行安装，我们选择全局安装较为方便：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g jsdoc</span><br></pre></td></tr></table></figure><p>书写符合形式的代码及说明注释，在<code>js</code>文件的当前目录下执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jsdoc doc.js</span><br></pre></td></tr></table></figure><p>就会在当前目录下生成一个名为 <code>out</code> 的目录（也可以另外指定目录），然后我们就可以通过浏览器访问这个 <code>out</code> 目录中的相关网页。</p></blockquote><p>对于JavaScript的业务开发，我们可以参考<a href="https://juejin.cn/post/6995464881205936164">这一篇掘金的文章</a>。尤其是<strong>针对参数的描述，要注意格式为：</strong></p><p><strong><code>@param &#123;paramDataType&#125; p1 descriptionStatements</code></strong></p><p>其中：</p><ul><li><code>p1</code>代表<strong>必选参数</strong></li><li><code>[p1]</code>代表<strong>可选参数</strong></li><li><code>[p1=xxx]</code>代表<strong>带默认值的参数</strong></li></ul><p>对于<code>typescript</code>，<code>JSDoc</code> 的提供的注释标记类型可以参考Block Tags, 但是到现在为止，<code>TypeScript</code> <strong>只支持了部分标记。</strong> 在语法方面，由于<code>JSDoc</code> 主要借鉴于 closure-compiler, 而 <strong><code>TypeScript</code></strong> 则有自己的一套类型语法，因此存在部分的差异。</p><h2 id="Python中的注释和文档"><a href="#Python中的注释和文档" class="headerlink" title="Python中的注释和文档"></a>Python中的注释和文档</h2><p>单行注释和多行注释都是基本语法知识，需要注意的是由于Python按缩进来划分代码块的语法特性，编写多行注释的时候要注意首尾<code>&#39;&#39;&#39;</code>符号的对齐和缩进，多行注释可以用三个单引号 <strong>‘’’</strong> 或者三个双引号 <strong>“””</strong> 将注释括起来。</p><h3 id="Docstring——Python的文档注释"><a href="#Docstring——Python的文档注释" class="headerlink" title="Docstring——Python的文档注释"></a>Docstring——Python的文档注释</h3><p>按照<a href="https://python-guide.gitbooks.io/python-style-guide/content/style-guide/comment_and_docs.html">gitbook上Python的指导文档</a>可以看到：</p><blockquote><p>作为文档的Docstring一般出现在模块头部、函数和类的头部，这样在python中可以通过对象的__doc__对象获取文档，编辑器和IDE也可以根据Docstring给出自动提示。文档注释中对函数参数、返回值等的说明采用<code>numpy</code>标准。文档注释以 <code>&quot;&quot;&quot;</code> 开头和结尾，<strong>首行不换行，如有多行，末行必需换行</strong></p></blockquote><p>注意！为了代码的效率和信息不冗余，不要在文档注释复制函数定义原型，而要具体地描述其具体内容，解释具体参数和返回值等，如下面的示例写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  不推荐的写法(不要写函数原型等废话)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">function</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;function(a, b) -&gt; list&quot;&quot;&quot;</span></span><br><span class="line">    ... ...</span><br><span class="line"><span class="comment">#  正确的写法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">function</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算并返回a到b范围内数据的平均值&quot;&quot;&quot;</span></span><br><span class="line">    ... ...</span><br></pre></td></tr></table></figure><p><code>pydoc</code>是python自带的一个文档生成工具，可以提取注释。在控制台中，我们可以使用命令<code>pydoc pydoc_demo &gt; doc.md</code>来生成文档。之后使用<code>python pydoc_demo.py</code>命令启动<code>pydoc_demo.py</code>文件，就可以看得到相关的文档注释。</p><p>使用命令<code>pydoc -w pydoc_demo</code>可以生成<code>html</code>格式文件<code>pydoc_demo.html</code>，更具体的使用可以参考<a href="https://www.cnblogs.com/meitian/p/6704488.html">pydoc用法</a>。</p><h3 id="Python文件头注释"><a href="#Python文件头注释" class="headerlink" title="Python文件头注释"></a>Python文件头注释</h3><p>我们以一个常见的Python开头注释为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author:XXX</span></span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/shizilunya/p/8081285.html">第一行<code>#!/usr/bin/env python</code>的意义</a>：</p><blockquote><p><strong>这些注释并不仅仅是写给读者看的注释，它也写给操作系统看的，这些注释决定了系统将如何运行这些文件。</strong></p><p>Linux系统自带python解释器（通常是Python 2的版本，比如Centos 7中就是如此）。在编写.py文件时，只要写上了#!&#x2F;usr&#x2F;bin&#x2F;python这行注释，用户就可以直接在命令行用文件名来执行py文件，例如：  testmode.py </p><p>意义：<strong>指定系统环境变量设定的解释器路径</strong>。类似于在window命令行中，你必须得写 python testmode.py 或 javac testmode.java 或 java testmode.class 来运行文件，你要通过文件名前面的<strong>关键字</strong>才能去启动对应的解释器。而有了这行注释，Linux系统就知道了你要用什么来执行这个文件，你就可以直接用文件名去跑它了。</p><p><code>#!/usr/bin/python</code>注释的问题：Linux只会使用系统默认的py解释器（也就是自带的那个）来运行文件。这样用户就无法使用自己的python版本了，不同的py版本之间语法有些差异，尤其是变动比较大的py2和py3，这些差异会使得整个程序无法正常运行。而#!&#x2F;usr&#x2F;bin&#x2F;env python 的出现可则让用户可以自行选择python版本，用户可以在<strong>环境变量</strong>中配置自己的py解释器（ps：用户安装的版本默认定位在Linux的local文件夹中）。<code>#!/usr/bin/env python</code>这行注释，会使linux在解析文件时，知道要去使用环境变量中的py解释器而非系统自带的那个。</p><p>所以如果你要使用该注释，推荐使用<code>#!/usr/bin/env python</code>的注释，而非<code>#!/usr/bin/python</code>。</p></blockquote><p>第二行<code># -*- coding:utf-8 -*-</code>作用是<strong>在Linux下指定文件的编码方式，用于支持中文</strong>。由于Python 3 默认支持中文，因此该行注释可以省略。</p><p>在<code>windows</code>系统的Python 3环境下运行我们的程序，可以不写上面的两行注释，但为了跨平台以及兼容，还是应该写上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java-文档注释&quot;&gt;&lt;a href=&quot;#Java-文档注释&quot; class=&quot;headerlink&quot; title=&quot;Java 文档注释&quot;&gt;&lt;/a&gt;Java 文档注释&lt;/h2&gt;&lt;p&gt;Java 支持三种注释方式。前两种和&lt;code&gt;C++&lt;/code&gt;的注释一样，分别</summary>
      
    
    
    
    <category term="Programming languages and projects" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/"/>
    
    
    <category term="python" scheme="http://justskim.github.io/tags/python/"/>
    
    <category term="java" scheme="http://justskim.github.io/tags/java/"/>
    
    <category term="javascript" scheme="http://justskim.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>知识图谱专业术语与基本知识</title>
    <link href="http://justskim.github.io/2022/03/16/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    <id>http://justskim.github.io/2022/03/16/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</id>
    <published>2022-03-16T07:04:43.745Z</published>
    <updated>2022-05-08T19:04:47.355Z</updated>
    
    <content type="html"><![CDATA[<h2 id="知识图谱的应用：我们为什么要做知识图谱"><a href="#知识图谱的应用：我们为什么要做知识图谱" class="headerlink" title="知识图谱的应用：我们为什么要做知识图谱"></a>知识图谱的应用：我们为什么要做知识图谱</h2><ol><li><p>语义搜索</p></li><li><p>智能问答</p></li><li><p>个性化推荐</p></li><li><p>辅助决策</p></li></ol><h2 id="起源和基本概念"><a href="#起源和基本概念" class="headerlink" title="起源和基本概念"></a>起源和基本概念</h2><p>在这篇<a href="https://zhuanlan.zhihu.com/p/148785892">知识图谱的介绍专栏</a>中，可以知道，<strong>知识图谱起源于语义网络（semantic nets or semantic networks）</strong>，语义网络一种用互联的的节点和弧来表示知识的一个结构，节点可以代表一个概念(concept)、一个属性(attribute)、一个事件(event)或者一个实体(entity)，而弧则用来表示节点之间的关系，弧的标签指明了关系的类型。<br>知识图谱不能仅理解为一个图，应该说：知识图谱是一种采用图模型（即由点和线组成的图形）来对人类知识进行表示的知识库或者知识的集合，并且符合某种语法和语义。</p><blockquote><p>知识图谱的图模型是一个有向图G&#x3D;&lt;O,E&gt;，这里O是一个实体或者字面量（literal）的集合，一般有以下几种：</p><ol><li>实例，即一个现实世界中具体的实物，比如说图1中的resource&#x2F;2019新型冠状病毒感染肺炎；</li><li>概念，可以看成是实例的集合，比如说图1中的class&#x2F;疾病；</li><li>字面量（literal），主要分为字符串和数据类型，这里数据类型包括日期值、高度等。</li></ol><p>知识图谱中<strong>一条知识</strong>称为<strong>三元组</strong>，即**<code>&lt;o1, e, o2&gt;</code><strong>的格式，这里<code>o1</code>和<code>o2</code>是实体或者字面量，而e则是带标签的边（类似图结构中我们要用两个点，一条边来表示）。</strong>一个三元组可以等价于一条主谓宾的知识，即<code>o1</code>和<code>o2</code>分别对应主语和宾语，e对应谓语**。</p></blockquote><p><a href="https://www.jianshu.com/p/941dc6d7e760">三元组的基本组成部分</a>：</p><blockquote><ul><li>实体（Entity）：实体是对客观个体的抽象，一个人、一部电影、一句话都可以看作是一个实体。例如：姚明，李安，我不是潘金莲</li><li>类型（type）：类型是对具有相同特点或属性的实体集合的抽象。举例：中国是一个实体，美国是一个实体，法国是一个实体。这些实体都有首都、人口、面积等共同特征，因此例如像中国、美国、法国等都有首都、人口、面积等特征的实体可以抽象为“国家”类型</li><li>属性（property）：属性是对实体与实体之间关系的抽象，例如李安是一个实体，李安是一个人物（type），少年派的奇幻漂流是一个实体，少年派的奇幻漂流是一个电影（type），很明显两个实体之间存在着关系即为：李安→导演→少年派的奇幻漂流因此李安与少年派的奇幻漂流之间的关系可以用属性“导演”刻画。那么可以根据属性构建一层关系，人物（type）→导演（property）→电影（type）。</li><li>关系（relation）：关系是<strong>实体与实体之间</strong>关系的抽象，李安（entity）→导演（relation）→少年派的奇幻漂流（entity），导演这个relation则是描述李安和少年派的奇幻漂流的关系。</li><li>域（domain）：域是类型的集合，凌驾于类型之上，是对某一领域所有类型的抽象，例如：国家是对中国、美国这样实体的一种抽象，是一种类型，而一个地理位置除了国家类型之外，还包括其他类型：城市、区域、洲等等，而把这些所有类型：洲、国家、城市、区域等类型抽象起来，就形成了地理位置域。</li><li>值（value）：值是用来描述实体的，可以分为文本型和数值型，EG：姚明（entity）→身高（relation）→ 226 cm（value）。</li></ul></blockquote><p>想要系统学习知识图谱，基础阶段可以看一下知乎上这一位博主的<a href="https://zhuanlan.zhihu.com/p/396516565">知识图谱专栏学习笔记</a>，比如他这里介绍的知识图谱构建方法：</p><p><img src="https://pic3.zhimg.com/80/v2-367fae46217b2666f15e20255a803eb2_720w.jpg" alt="知识图谱的构建"></p><p>建立知识图谱的第一步是获得数据，根据数据的类型可以分为：</p><ol><li><p>结构化的数据：表格、数据库等按照一定格式表示的数据，通常可以直接用来构建知识图谱；</p></li><li><p>非结构化的数据：文本、音频、视频、图片等，需要对它们进行信息抽取才能进一步建立知识图谱；</p></li><li><p>半结构化数据是介于结构化和非结构化之间的一种数据，也需要进行信息抽取才能建立知识图谱。</p></li></ol><p><a href="https://blog.csdn.net/taon1607/article/details/107087408">连续型数据和非连续型数据</a>：</p><blockquote><p>离散型数据都是类别值，如：男生，女生，商务座，一等座，二等座等等。连续型数据基本上都是数值型数据，如年龄（10岁，11岁…），身高（110cm, 175cm…），海拔，薪资等等。<br>既然连续型数据都是数值，是可以直接拿来供计算机使用的，那么连续型数据该如何处理？这里我们提出一个处理思想：连续型数据离散化。连续型数据离散化以后的建模效果一定会比原来的好吗？这个答案是不一定的</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200106162929139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MzA0ODUx,size_16,color_FFFFFF,t_70" alt="对不同类型数据的处理"></p><p><strong>信息抽取（知识抽取）</strong></p><blockquote><p>可以分为实体识别、关系抽取、属性抽取等。目前结构化的数据时最主要的知识来源。针对结构化的数据，知识图谱通常可以直接利用和转化，形成基础数据集，再利用知识图谱补全技术进一步扩展知识图谱。</p><p>针对文本型数据这种非结构化数据，知识获取的方式主要包括实体识别、关系抽取、属性抽取等。具体的方法又包括基于特征模版的方法、基于核函数的监督学习方法、基于深度学习的方法等</p><p>实体识别：指在一段文本中识别哪些词代表实体，并打上标签（进行分类）。例如“演员于和伟出演了电视剧《觉醒年代》”这句话中，“于和伟”和“《觉醒年代》”就是两个实体</p><p>关系抽取：识别文本（或其他数据）中实体之间的关系。例如“演员于和伟出演了电视剧《觉醒年代》”这句话中，“出演”为“演员于和伟”与“电视剧《觉醒年代》”之间的关系</p></blockquote><h3 id="知识表示与建模"><a href="#知识表示与建模" class="headerlink" title="知识表示与建模"></a>知识表示与建模</h3><p><strong>知识表示</strong></p><p>用一定的结构和符号语言来描述知识，并且能够用计算机进行推理、计算等操作的技术。知识表示的方法：谓词逻辑表示法、框架表示法、基于语意网路的表示法等。</p><p><strong>知识融合</strong> <strong>Knowledge fusion</strong></p><p>由于得到的数据可能会存在交叉和重叠，因此同一个概念、实体可能会反复出现，知识融合的目的就是把表示相同概念的实体进行合并。根据专栏作者的解释：</p><blockquote><p>主要任务包括实体消歧和指代消解，它们都用来判断知识库中的同名实体是代表同一含义、是否有其他实体也表示相同含义。实体消歧专门用于解决同名实体产生歧义的问题，通常采用聚类法、空间向量模型、语义模型等。指代消解则为了避免代词指代不清的情况。</p></blockquote><h3 id="知识推理-Knowledge-Reasoning"><a href="#知识推理-Knowledge-Reasoning" class="headerlink" title="知识推理 Knowledge Reasoning"></a>知识推理 Knowledge Reasoning</h3><blockquote><p>知识推理是根据已有的数据模型和数据，依据推理规则，获取新的知识或者结论，新的知识或结论应该是满足语义的。知识推理，依据描述逻辑系统实现。描述逻辑(Description Logic)是基于对象的知识表示的形式化，也叫概念表示语言或术语逻辑，是一阶谓词逻辑的一个可判定子集。</p><p>一个描述逻辑系统由四个基本部分组成： 最基本的元素：概念、关系、个体；TBox术语集：概念术语的公理集合； Abox断言集：个体的断言集合；TBox 和 ABox上的推理机制。</p><p>描述逻辑涉及到的内容也比较多，此处举几个例子，比如实体的分类包含关系，一个电脑椅是椅子，椅子是家具，可以说，一个电脑椅是家具。常识规则的推理，一个男人的孩子是A，一个女人的孩子是A，可以知道，这个男人和女人是配偶。</p></blockquote><p><img src="https://pic4.zhimg.com/80/v2-86c66ac77e2b89d0f39b31b230bfdf7f_720w.jpg" alt="知识推理的三大方式"></p><p>简单地说，推理任务主要有：通过<strong>规则挖掘</strong>对知识图谱进行<strong>补全（Knowledge Base Completion,KBC）与质量校验</strong>、<strong>链接预测、关联关系推理</strong>与<strong>冲突检测</strong>等。</p><p>基于规则的推理通过定义或学习知识中存在的规则进行挖掘与推理，从早期的ILP(Inductive Logic Programming)系统中衍生的AMIE、AMIE+算法， 强调通过自动化的规则学习方法，快速有效的从大规模知识图谱中学习出置信度较高的规则，并且应用于推理任务。</p><p><img src="https://pic2.zhimg.com/80/v2-ced25261ed496e505147fc23aa9cb95d_720w.jpg" alt="各种推理方法极其优缺点总结"></p><h3 id="Trans-E-算法细说"><a href="#Trans-E-算法细说" class="headerlink" title="Trans E 算法细说"></a>Trans E 算法细说</h3><p>transE算法就是一个非常经典的知识表示学习，用<a href="https://so.csdn.net/so/search?q=%E5%88%86%E5%B8%83%E5%BC%8F&spm=1001.2101.3001.7020">分布式</a>表示（distributed representation）来描述知识库中的三元组，<a href="https://blog.csdn.net/shunaoxi2313/article/details/89766467">这里可以看下其简单的算法思想</a>：</p><blockquote><p>知识图谱中的事实是用三元组 ( h , l , t ) (h,l,t)(h,l,t) 表示的，那么如何用低维稠密向量来表示它们，才能得到这种依赖关系呢？transE算法的思想非常简单，它受word2vec平移不变性的启发，希望h + l ≈ t h+l≈th+l≈t（此为归纳偏差？）。</p><p>光有这一个约束可不够。想让h + l ≈ t h+l≈th+l≈t，如何设置损失函数是个关键。我们发现表示学习都没有明显的监督信号，也就是不会明确告诉模型你学到的表示正不正确，那么想要快速收敛就得引入“相对”概念，即相对负例来说，正例的打分要更高，方法学名：<strong>“negative sampling”</strong>，也就是<strong>负采样</strong>。</p></blockquote><p>转移距离模型（Translational Distance Model）的主要思想是将衡量向量化后的知识图谱中三元组的合理性问题，转化成衡量头实体和尾实体的距离问题。这一方法的重点是如何设计得分函数，得分函数常常被设计成利用关系把头实体转移到尾实体的合理性的函数。 受词向量的启发，由词与词在向量空间的语义层面关系，可以拓展到知识图谱中头实体和尾实体在向量空间的关系。也就是说，同样可以 考虑把知识图谱中的头实体和尾实体映射到向量空间中，且它们之间的 联系也可以考虑成三元组中的关系。</p><p>TransE便是受到了词向量中平移不变性的启发，在 TransE 中，把实体和关系都表示为向量，对于某一个具体的关系（head, relation, tail），把关系的向量表示解释成头实体的向量到尾实体的向量的转移向量（Translation vector）。也就是说， 如果在一个知识图谱中，某一个三元组成立，则它的实体和关系需要满 足关系head+relation≈tail。</p><h3 id="知识图谱的嵌入"><a href="#知识图谱的嵌入" class="headerlink" title="知识图谱的嵌入"></a>知识图谱的嵌入</h3><p>知识图谱通常存在链接缺失问题，这限制了知识图谱在相关下游任务中的应用。为解决该问题，知识图谱补全任务应运而生。知识图谱补全旨在根据知识图谱中已有事实推断出新的事实，从而使得知识图谱更完整。</p><p>知识图谱嵌入 (Knowledge Graph Embedding) 是解决知识图谱补全问题的重要方法之一，它通过将知识图谱中的实体 (Entity) 和关系 (Relation) 嵌入到连续向量空间，从而在方便计算的同时保留知识图谱中的结构信息。知识图谱嵌入模型大致可以分为三类：</p><blockquote><h2 id="知识图谱补全任务"><a href="#知识图谱补全任务" class="headerlink" title="知识图谱补全任务"></a>知识图谱补全任务</h2><h3 id="符号定义"><a href="#符号定义" class="headerlink" title="符号定义"></a>符号定义</h3><p>知识图谱通常以三<a href="https://so.csdn.net/so/search?q=%E5%85%83%E7%BB%84&spm=1001.2101.3001.7020">元组</a> (Triple) 来表示知识，三元组的一般格式为 (<em>头实体</em>，<em>关系</em>，<em>尾实体</em>)，如“金庸的表兄是徐志摩”表示成三元组为 (<em>金庸</em>，<em>表兄</em>，<em>徐志摩</em>)，其中<em>金庸</em>为头实体，<em>徐志摩</em>为尾实体，<em>表兄</em>是这两个实体之间的关系。我们使用小写的字母 来分别表示头实体、关系和尾实体， 表示知识图谱中的一个三元组。相应地，小写加粗字母 分别表示头实体、关系和尾实体对应的嵌入向量。向量 的第 个元素记作 。 表示嵌入向量的维度。  表示两个向量间的 Hadamard (element-wise) product。另外，我们使用 来分别表示 和 范数。</p><h3 id="补全任务与性能指标"><a href="#补全任务与性能指标" class="headerlink" title="补全任务与性能指标"></a>补全任务与性能指标</h3><p>知识图谱补全 (Knowledge Graph Completion)，是根据知识图谱中已有的三元组去对未知三元组进行预测。我们使用 表示已知头实体和关系来预测尾实体， 表示已知关系和尾实体来预测头实体，其中 和 被称为查询 (Query)。实际上，知识图谱补全任务，本质上给定查询下的排序问题。比如，对于图2所示的查询 (<em>陆小曼</em>，<em>丈夫</em>，<em>？</em>)，返回的是预测答案的排序列表，正确答案排名越高，预测的效果就越好。</p></blockquote><h3 id="质量评估"><a href="#质量评估" class="headerlink" title="质量评估"></a>质量评估</h3><p>在知识推理完了之后，我们也不能忘记质量评估这一个最后的步骤：</p><blockquote><p>质量评估就是对最后的结果数据进行评估，将合格的数据放入知识图谱中。质量评估的方法，根据所构建的知识图谱的不同，对数据要求的差异而有所差别。总的目的是要获得合乎要求的知识图谱数据，要求的标准根据具体情况确定。 比如对于公共领域的知识图谱，知识的获取采用了众包的方法，对于同一个知识点，可能会有很多人来完成，如果这个知识点只有一个答案，可以采用的一种策略是，将多人的标注结果进行比较，取投票多的结果作为最终的结果。当然，这是不严谨的，因为真理往往掌握在少数人的手里，特别是针对一些行业的知识图谱，表现尤为突出。行业内的一条知识，可能只有行业专家能够给出权威正确的答案，如果让大众投票来决定，可能会得到一条错误的知识。所以，针对行业知识图谱，可能会采用不同于公共知识图谱的策略，来进行知识的质量评估。</p></blockquote><h3 id="NLP中的负采样（Negative-Sampling）"><a href="#NLP中的负采样（Negative-Sampling）" class="headerlink" title="NLP中的负采样（Negative Sampling）"></a>NLP中的负采样（Negative Sampling）</h3><p>负采样是NLP领域一个出现频次极高的词，负抽样的目的是为了最终输出的上下文单词（正样本），在采样过程中应该保留下来并更新，同时也需要采集部分负样本（非上下文单词）。通过负采样，在更新隐层到输出层的权重时，只需更负采样的单词，而不用更新词汇表所有单词，<br><a href="https://blog.csdn.net/ningyanggege/article/details/87869393">对负采样理解</a>来自于word2vec算法：</p><blockquote><p>比如说  love 和me两个单词；<br>使用特殊思维模式；假设整个词汇表只有100个单词；love 表示成one-hot向量； me表示成one-hot向量；<br>模型输入为love的one-hot向量；模型输出为me的one-hot向量；<br>假设模型的神经网络结构为100<em>10</em>100；输出层100个；<br>输出层中除了me对应位置的1外，其他全是0；称这为负样本；参数数量为10<em>100<br>采样就是从这样负样本中抽样；比如说抽取5个；那么在此次梯度更新中就只更新10</em>5；更新数量为原来的1&#x2F;20</p><p>因此，可以看到负采样的本质：每次让一个训练样本<strong>只更新部分权重</strong>，<strong>其他权重全部固定</strong>；<strong>减少计算量</strong>；（一定程度上还可以增加随机性）</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;知识图谱的应用：我们为什么要做知识图谱&quot;&gt;&lt;a href=&quot;#知识图谱的应用：我们为什么要做知识图谱&quot; class=&quot;headerlink&quot; title=&quot;知识图谱的应用：我们为什么要做知识图谱&quot;&gt;&lt;/a&gt;知识图谱的应用：我们为什么要做知识图谱&lt;/h2&gt;&lt;ol&gt;
</summary>
      
    
    
    
    <category term="知识图谱" scheme="http://justskim.github.io/categories/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
    
    <category term="知识图谱" scheme="http://justskim.github.io/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
  </entry>
  
  <entry>
    <title>visual studio code中无法切换Python版本的解决</title>
    <link href="http://justskim.github.io/2022/03/07/visual-studio-code%E4%B8%AD%E6%97%A0%E6%B3%95%E5%88%87%E6%8D%A2Python%E7%89%88%E6%9C%AC%E7%9A%84%E8%A7%A3%E5%86%B3/"/>
    <id>http://justskim.github.io/2022/03/07/visual-studio-code%E4%B8%AD%E6%97%A0%E6%B3%95%E5%88%87%E6%8D%A2Python%E7%89%88%E6%9C%AC%E7%9A%84%E8%A7%A3%E5%86%B3/</id>
    <published>2022-03-07T01:50:49.323Z</published>
    <updated>2022-03-07T02:05:47.908Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>使用Python进行机器学习，需要引入<code>sklearn</code>模块，因此在我们建立的<code>anaconda</code>环境（名称<code>py378</code>，用的Python 3.7.8的版本）中activate该环境，并安装<code>scikit-learn</code>库（安装的模块名和导入的库名称不一样，这个见网上详细解释，<code>scikit-learn</code>其实就是其工具包）。但来到软件<code>visual studio code</code>界面中却发现无法正常切换Python版本，工作区也未能生成<code>.vscode</code>文件夹：</p><p>![visual studio code无法切换python环境](&#x2F;images&#x2F;visual studio code无法切换python环境.PNG)</p><p>我们可以看到，在左下角并没有加载出Python Interpreter，终端中手动输入命令切换环境也依然无法奏效。</p><h2 id="尝试步骤"><a href="#尝试步骤" class="headerlink" title="尝试步骤"></a>尝试步骤</h2><ol><li><p>按住<code>ctrl+shift+p</code>，输入<code>Python Interpreter</code>切换环境，发现已经被切换到<code>py378</code></p></li><li><p>打开<code>Preferences</code>中的设置，在<code>settings.json</code>中找到<code>python.defaultInterpreterPath</code>，由于之前博主为了能像<code>anaconda</code>那般切换环境，在<code>visual studio code</code>进行配置，此项为<code>anaconda</code>下的<code>python.exe</code>文件，博主手动将其修改为<code>C:\\Users\\YourUserName\\Anaconda3\\envs\\py378\\python.exe</code></p></li><li><p>在上边的设置中，搜索<code>cmd</code>，查看终端<code>terminal</code>是否为<code>cmd</code>而不是<code>powershell</code>（据网上说法<code>powershell较不稳定</code>），但博主这里的设置无误：</p><p><img src="/images/visual-studio-code%E4%B8%ADterminal%E8%AE%BE%E7%BD%AE.PNG" alt="visual-studio-code中terminal设置"></p></li></ol><p>经过以上步骤依然无效</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;使用Python进行机器学习，需要引入&lt;code&gt;sklearn&lt;/code&gt;模块，因此在我们建立的&lt;code&gt;anaconda&lt;/code</summary>
      
    
    
    
    <category term="Programming languages and projects" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/"/>
    
    <category term="Python3" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"/>
    
    
    <category term="python" scheme="http://justskim.github.io/tags/python/"/>
    
    <category term="visual studio code" scheme="http://justskim.github.io/tags/visual-studio-code/"/>
    
  </entry>
  
  <entry>
    <title>Eclipse web 工程的项目目录结构</title>
    <link href="http://justskim.github.io/2022/03/06/Eclipse-web-%E5%B7%A5%E7%A8%8B%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
    <id>http://justskim.github.io/2022/03/06/Eclipse-web-%E5%B7%A5%E7%A8%8B%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</id>
    <published>2022-03-06T10:10:07.896Z</published>
    <updated>2022-03-19T03:14:27.784Z</updated>
    
    <content type="html"><![CDATA[<p>在使用Eclipse学习Java开发的过程中，发现我自己新建<code>dynamic web project</code>的项目目录结构和视频中演示的不同，最明显的区别是没有Java Resources和JavaScript Resources这两个文件夹：</p><p><img src="/images/%E6%96%B0%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.PNG" alt="新建web项目目录结构"></p><p>查阅多方资料显示，这种项目结构的不同对于程序执行并没有大问题，要参考项目中各个文件和目录的功能，可以见以下三篇博客：</p><ol><li><a href="https://blog.csdn.net/yyuanxiwen/article/details/94600630">https://blog.csdn.net/yyuanxiwen/article/details/94600630</a></li><li><a href="https://blog.csdn.net/Alan_Wdd/article/details/90514928">https://blog.csdn.net/Alan_Wdd/article/details/90514928</a></li><li><a href="https://www.cnblogs.com/jetdl/p/9724651.html">https://www.cnblogs.com/jetdl/p/9724651.html</a></li></ol><p>在webapp下有一个WEB-INF文件夹。该目录是一个专用区域， 容器不能把此目录中的内容提供给用户。这个目录下的文件只供容器使用，里面包含不应该由客户直接下载的资源。<strong>Web 容器要求在你的应用程序中必须有 WEB-INF 目录。WEB-INF 中包含着发布描述符（也就是 web.xml 文件）, 一个 classes 目录和一个 lib目录, 以及其它内容。注意： 如果你的 Web 应用程序中没有包含这个目录, 它可能将无法工作 。</strong></p><p>web.xml文件在 J2EE Web 应用程序发布之后帮助管理 Web 应用程序的配置。在web.xml文件中会设置welcome-file标签，这是因为&#x2F;WEB-INF目录下的文件本来是不允许直接访问的，但如果在web.xml中配置了如上欢迎页面，并且在&#x2F;WEB-INF目录下放置了index.html，那么在浏览器地址栏输入<a href="http://127.0.0.1:8080/myWeb%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AEindex.html%E9%A1%B5%E9%9D%A2%EF%BC%8C%E8%B7%AF%E5%BE%84%E4%B8%AD%E7%9A%84myWeb%E6%98%AF%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E5%90%8D%E3%80%82">http://127.0.0.1:8080/myWeb可以访问index.html页面，路径中的myWeb是项目文件名。</a></p><p>在web.xml文件下需要添加约束，约束文件可以在我们tomcat安装目录下的<code>/conf</code>子文件夹中的web.xml文件中拷贝。</p><p>我们打开eclipse时，会要求我们设定workspace。在我们设定workspace的那个文件夹下，我们可以发现一个**隐藏文件夹<code>.metadata</code>**，它存在于eclipse第一次启动时指定的workspace目录下， project name 和 workspace 分别对应的目录不能是同一个目录，否则无法建立project name。</p><p>当我们通过<a href="https://so.csdn.net/so/search?q=eclipse&spm=1001.2101.3001.7020">eclipse</a>启动tomcat运行工程时，eclipse会将工程发布到org.eclipse.wst.server.core中，就像发布到tomcat中一样。使用tomcat服务器的话，默认的部署路径为<code>.metadata/.plugins/org.eclipse.wst.server.core/tmp0</code>，可以看到有一个server.xml，可以看到<code>deployDir=&quot;wtpwebapps&quot;</code>。</p><p>因此在该路径下的wtpwebapps文件夹（注意最后不是webapps）下可以看到发布的项目。</p><p>当我们为Eclipse配置默认使用的本机tomcat服务器后，我们可以在Project Explorer窗口中找到一个Servers目录，其中有一个server.xml。Service标签代表包含着一个服务（默认情况下name&#x3D;”Catalina”)，一个服务器可以包含多个服务，就对应着多个Service标签。因为是web项目，我们这里的服务要给浏览器使用，因此需要用到连接器Connector，并在其中配置端口号（默认为port&#x3D;”8080”）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在使用Eclipse学习Java开发的过程中，发现我自己新建&lt;code&gt;dynamic web project&lt;/code&gt;的项目目录结构和视频中演示的不同，最明显的区别是没有Java Resources和JavaScript Resources这两个文件夹：&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="Java" scheme="http://justskim.github.io/categories/Java/"/>
    
    <category term="Eclipse" scheme="http://justskim.github.io/categories/Java/Eclipse/"/>
    
    
    <category term="java" scheme="http://justskim.github.io/tags/java/"/>
    
    <category term="eclipse" scheme="http://justskim.github.io/tags/eclipse/"/>
    
  </entry>
  
  <entry>
    <title>重新安装JDK后Eclipse更改配置</title>
    <link href="http://justskim.github.io/2022/03/06/%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85JDK%E5%90%8EEclipse%E6%9B%B4%E6%94%B9%E9%85%8D%E7%BD%AE/"/>
    <id>http://justskim.github.io/2022/03/06/%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85JDK%E5%90%8EEclipse%E6%9B%B4%E6%94%B9%E9%85%8D%E7%BD%AE/</id>
    <published>2022-03-06T00:42:59.456Z</published>
    <updated>2022-03-06T09:16:31.632Z</updated>
    
    <content type="html"><![CDATA[<p>博主在将原先的JDK卸载，又重新安装JDK11后，发现了Eclipse软件无法正常打开的情况：</p><p><img src="/images/%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85Java%E5%90%8EEclipse%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80.PNG" alt="重新安装Java后Eclipse无法打开"></p><p>这种情况下我们一般先检查环境变量，通过命令行和系统环境的Java变量配置查看均无异常。我们查询当时Eclipse的安装教程，看是否有Eclipse软件相关的环境变量需要重新配置，结果的no。</p><p>那么，问题很明显，Eclipse软件会在第一次使用的时候获取系统的Java相关环境变量，然后将其存入自己的相关配置文件中，之后就不必获取了。在网上搜索得到Eclipse软件的配置文件为安装目录下bin文件夹中的<code>eclipse.ini</code>文件，我们打开搜索，可以看到<code>vm</code>（virtual machine 虚拟机）选项下有个旧版本<code>JDK</code>安装路径的bin文件夹：</p><p><img src="/images/eclipse.ini%E4%B8%AD%E4%BF%AE%E6%94%B9vm%E4%B8%8Bjavaw.exe%E7%9A%84%E8%B7%AF%E5%BE%84.PNG" alt="eclipse.ini中修改vm下javaw.exe的路径.PNG"></p><p>我们将其修改为重新安装的<code>JDK</code>路径下bin文件夹：<code>C:\Program Files\Java\jdk-11.0.2\bin</code>，重新打开Eclipse软件，可以成功运行！</p><p>这里顺便提一下，很多软件安装完之后都有一个bin文件夹，<em>bin</em>是binary的缩写，代表的意思是二进制，该文件夹下一般都存放二进制可执行文件。</p><p><em>ini 文件</em>，全称 “Initialization File”，即初始化文件，是windows的系统配置文件所采用的存储格式，统管windows的各项配置。<a href="https://blog.csdn.net/a123441/article/details/90668032">配置文件的好处</a>在于，能够通过直接编辑<code>ini</code>文件来修改配置：</p><blockquote><p>如果我们的程序没有任何配置文件时，这样的程序对外是全封闭的，一旦程序需要修改一些参数必须要修改程序代码本身并重新编译，这样很不好，所以要用配置文件，让程序出厂后还能根据需要进行必要的配置；配置文件有很多，如INI配置文件，<a href="https://so.csdn.net/so/search?q=XML&spm=1001.2101.3001.7020">XML</a>配置文件，还有就是可以使用系统注册表等。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;博主在将原先的JDK卸载，又重新安装JDK11后，发现了Eclipse软件无法正常打开的情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85Java%E5%90%8EEclipse%E6%97%A</summary>
      
    
    
    
    <category term="Java" scheme="http://justskim.github.io/categories/Java/"/>
    
    <category term="Eclipse" scheme="http://justskim.github.io/categories/Java/Eclipse/"/>
    
    
    <category term="java" scheme="http://justskim.github.io/tags/java/"/>
    
    <category term="eclipse" scheme="http://justskim.github.io/tags/eclipse/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7系统安装python3.7.8</title>
    <link href="http://justskim.github.io/2022/03/06/CentOS7%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85python3.7.8/"/>
    <id>http://justskim.github.io/2022/03/06/CentOS7%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85python3.7.8/</id>
    <published>2022-03-05T17:17:00.722Z</published>
    <updated>2022-03-07T01:33:57.245Z</updated>
    
    <content type="html"><![CDATA[<p>首先在<a href="https://www.python.org/downloads/source/">Python官方网站</a>中找到我们特定版本的安装包，这里我们要选择适合Linux系统的<code>tar.xz</code>格式压缩包。我们要注意，大部分Linux系统发行版，比如博主所用的Centos7都预装了python2，可以使用命令<code>python -V</code>查看其版本为2.7.5，但可能没有装pip工具。但是这样也有个好处，下载包的时候免得我们混淆。我们注意<a href="https://blog.csdn.net/qq_40584960/article/details/86082019">pip2和pip3的关系</a>：</p><blockquote><ol><li>pip是python的包管理工具，pip和pip3版本不同，都位于Scripts\目录下；</li><li>如果系统中只安装了Python2，那么就只能使用pip；</li><li>如果系统中只安装了Python3，那么既可以使用pip也可以使用pip3，二者是等价的；</li><li>如果系统中同时安装了Python2和Python3，则pip默认给Python2用，pip3指定给Python3用；</li><li>使用<code>pip install XXX</code>安装的库会位于路径<code>python2.X/site-packages</code>中，而使用<code>pip3 install XXX</code>安装的库会放在目录<code>python3.X/site-packages</code>下。</li></ol></blockquote><p>博主按照网上常见的教程安装后，一直显示的是<code>python 3.6.8</code>，跑到路径<code>/usr/bin</code>下使用命令<code>rm -rf python3*</code>删除了旧的python文件（前缀为python3的，前缀为python没有3的是python2版本的文件），再重新安装，编译，成功启动程序。</p><p><code>which python3 </code>命令在PATH变量指定的路径中，<strong>搜索系统命令<code>python</code>的位置</strong>，并且返回第一个搜索结果（使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先在&lt;a href=&quot;https://www.python.org/downloads/source/&quot;&gt;Python官方网站&lt;/a&gt;中找到我们特定版本的安装包，这里我们要选择适合Linux系统的&lt;code&gt;tar.xz&lt;/code&gt;格式压缩包。我们要注意，大部分Linu</summary>
      
    
    
    
    <category term="Programming languages and projects" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/"/>
    
    <category term="Python3" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"/>
    
    
    <category term="linux" scheme="http://justskim.github.io/tags/linux/"/>
    
    <category term="python" scheme="http://justskim.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Windows系统下环境变量配置与计算机重启</title>
    <link href="http://justskim.github.io/2022/03/05/Windows%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E5%90%AF/"/>
    <id>http://justskim.github.io/2022/03/05/Windows%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E5%90%AF/</id>
    <published>2022-03-05T08:50:11.668Z</published>
    <updated>2022-03-05T09:59:52.900Z</updated>
    
    <content type="html"><![CDATA[<p>我们来看一下<a href="https://blog.csdn.net/shuixin536/article/details/8084612">对于Windows不重启使环境变量修改生效的解释</a>：</p><blockquote><p>一个程序启动时，环境变量被复制到该程序所在的环境中，在该程序执行过程中不会被除该程序以外的其他程序所改变。也就是说，假设我们启动了一个cmd程序，然后通过控制面板修改了环境变量设置，但是已经启动了的cmd所拥有的环境变量并不会被改变。如果我们在修改环境变量之后启动cmd程序，则该程序将拥有新的环境变量。<br>那么结论就很明显了：修改环境变量之后，如果受影响的是应用程序，那么只要简单地重新启动此应用程序，环境变量的修改就会反映到该程序中，而不必重新启动计算机；但是，如果受影响的是系统服务，就必须重新启动才能将环境变量的修改反映到系统服务中（因为没有办法在不重启计算机的情况下重新启动系统服务管理器）</p></blockquote><p>那么有没有什么办法可以不重启就使一切修改的环境变量配置生效呢？有，当我们很不想重启windows系统时可以尝试这么做：</p><blockquote><p>以修改环境变量“PATH”为例，修改完成后，进入DOS命令提示符，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set PATH=C: 1</span><br></pre></td></tr></table></figure><p>关闭DOS窗口。再次打开DOS窗口，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo %PATH% 1</span><br></pre></td></tr></table></figure><p>可以发现“我的电脑”-&gt;“属性”-&gt;“高级”-&gt;“环境变量”中设置的 PATH 值已经生效。<br>不用担心DOS窗口中的修改会影响环境变量的值，DOS窗口中的环境变量只是Windows环境变量的一个副本而已。但是对副本的修改却会引发Windows环境变量的刷新，这正是我们想要的！</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们来看一下&lt;a href=&quot;https://blog.csdn.net/shuixin536/article/details/8084612&quot;&gt;对于Windows不重启使环境变量修改生效的解释&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个程序启动时，环境变量被复</summary>
      
    
    
    
    <category term="Windows" scheme="http://justskim.github.io/categories/Windows/"/>
    
    
    <category term="windows" scheme="http://justskim.github.io/tags/windows/"/>
    
  </entry>
  
</feed>
