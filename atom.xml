<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://justskim.github.io/atom.xml" rel="self"/>
  
  <link href="http://justskim.github.io/"/>
  <updated>2022-03-19T03:03:14.052Z</updated>
  <id>http://justskim.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>编程语言的文档注释</title>
    <link href="http://justskim.github.io/2022/03/18/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A/"/>
    <id>http://justskim.github.io/2022/03/18/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A/</id>
    <published>2022-03-18T13:51:04.790Z</published>
    <updated>2022-03-19T03:03:14.052Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-文档注释"><a href="#Java-文档注释" class="headerlink" title="Java 文档注释"></a>Java 文档注释</h2><p>Java 支持三种注释方式。前两种和<code>C++</code>的注释一样，分别是 <code>//</code> 和 <code>/* */</code>。<strong>第三种</strong>被称作<strong>说明注释</strong>，它以 <code>/**</code>开始，以 <code>*/</code>结束。</p><blockquote><p>说明注释允许我们在程序中嵌入关于程序的信息，也可以使用 javadoc 工具软件来生成信息，并输出到HTML文件中。</p></blockquote><p>菜鸟教程给出了以下的<a href="https://www.runoob.com/java/java-documentation.html"><code>javadoc</code>标签</a>：</p><table><thead><tr><th align="left"><strong>标签</strong></th><th align="center"><strong>描述</strong></th><th align="center"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left">@author</td><td align="center">标识一个类的作者</td><td align="center">@author description</td></tr><tr><td align="left">@deprecated</td><td align="center">指名一个过期的类或成员</td><td align="center">@deprecated description</td></tr><tr><td align="left">{@docRoot}</td><td align="center">指明当前文档根目录的路径</td><td align="center">Directory Path</td></tr><tr><td align="left">@exception</td><td align="center">标志一个类抛出的异常</td><td align="center">@exception exception-name explanation</td></tr><tr><td align="left">{@inheritDoc}</td><td align="center">从直接父类继承的注释</td><td align="center">Inherits a comment from the immediate surperclass.</td></tr><tr><td align="left">{@link}</td><td align="center">插入一个到另一个主题的链接</td><td align="center">{@link name text}</td></tr><tr><td align="left">{@linkplain}</td><td align="center">插入一个到另一个主题的链接，但是该链接显示纯文本字体</td><td align="center">Inserts an in-line link to another topic.</td></tr><tr><td align="left">@param</td><td align="center">说明一个方法的参数</td><td align="center">@param parameter-name explanation</td></tr><tr><td align="left">@return</td><td align="center">说明返回值类型</td><td align="center">@return explanation</td></tr><tr><td align="left">@see</td><td align="center">指定一个到另一个主题的链接</td><td align="center">@see anchor</td></tr><tr><td align="left">@serial</td><td align="center">说明一个序列化属性</td><td align="center">@serial description</td></tr><tr><td align="left">@serialData</td><td align="center">说明通过writeObject( ) 和 writeExternal( )方法写的数据</td><td align="center">@serialData description</td></tr><tr><td align="left">@serialField</td><td align="center">说明一个ObjectStreamField组件</td><td align="center">@serialField name type description</td></tr><tr><td align="left">@since</td><td align="center">标记当引入一个特定的变化时</td><td align="center">@since release</td></tr><tr><td align="left">@throws</td><td align="center">和 @exception标签一样.</td><td align="center">The @throws tag has the same meaning as the @exception tag.</td></tr><tr><td align="left">{@value}</td><td align="center">显示常量的值，该常量必须是static属性。</td><td align="center">Displays the value of a constant, which must be a static field.</td></tr><tr><td align="left">@version</td><td align="center">指定类的版本</td><td align="center">@version info</td></tr></tbody></table><p><a href="http://c.biancheng.net/view/6262.html">C语言中文网</a>中有着更详细的<code>Javadoc</code>介绍：</p><p>对两种标签格式的说明：</p><ul><li>@tag 格式的标签（不被<code>&#123; &#125;</code>包围的标签）为块标签，只能在主要描述（类注释中对该类的详细说明为主要描述）后面的标签部分（如果块标签放在主要描述的前面，则生成 API 帮助文档时会检测不到主要描述）。</li><li>{@tag} 格式的标签（由<code>&#123; &#125;</code>包围的标签）为内联标签，可以放在主要描述中的任何位置或块标签的注释中。</li></ul><p><code>Javadoc</code>标签注意事项：</p><ul><li>Javadoc 标签必须从一行的开头开始，否则将被视为普通文本。</li><li>一般具有相同名称的标签放在一起。</li><li>Javadoc 标签区分大小写，代码中对于大小写错误的标签不会发生编译错误，但是在生成 API 帮助文档时会检测不到该注释内容。</li></ul><h3 id="Javadoc命令"><a href="#Javadoc命令" class="headerlink" title="Javadoc命令"></a>Javadoc命令</h3><p><code>Javadoc</code> 用法格式如下：</p><p><code>javadoc [options] [packagenames] [sourcefiles]</code></p><p>其中options 表示<code>Javadoc</code> 命令的选项，<code>packagenames</code>表示包名，这两个是可选项。</p><p>如果我们的代码中有中文的注释，可以使用命令<code>javadoc -encoding UTF-8 -charset UTF-8 Javadoc_demo.java</code>编译出相应的Html文档让我们阅读。</p><h3 id="java说明注释——javadoc标签的使用"><a href="#java说明注释——javadoc标签的使用" class="headerlink" title="java说明注释——javadoc标签的使用"></a><code>java</code>说明注释——<code>javadoc</code>标签的使用</h3><p>以<code>IDEA</code>软件为例，由于其自动补全的功能，我们只需要输入<code>/**</code>然后回车即可，每一行都会智能地为我们的注释文字在开头补上<code>*</code>符号。我们不仅可以在主类外写说明注释，还可以先写上类中的成员函数，然后在成员函数上头输入<code>/**</code>，<code>IDEA</code>将会自动为我们补全相关信息，比如参数 <code>param</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mike</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Javadoc_test</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JSDoc——JavaScript之注释规范化"><a href="#JSDoc——JavaScript之注释规范化" class="headerlink" title="JSDoc——JavaScript之注释规范化"></a>JSDoc——JavaScript之注释规范化</h2><p>原生的JavaScript语法中并没有像Java那样的说明注释，<code>JSDoc</code> 是一个针对 JavaScript 的 <code>API</code> 文档生成器，可以在其<a href="https://jsdoc.app/index.html">官网</a>查看介绍，类似于 Java 中的 <code>Javadoc</code> 或者 <code>PHP</code> 中的 <code>phpDocumentor</code>。我们在<code>js</code>格式代码中添加像<code>javadoc</code>标签般的注释，即可被<code>JSDoc</code>工具自动扫描并生成<code>API</code>文档。<a href="https://knightyun.github.io/2020/03/13/js-comment-format">这位博主的博客文章中介绍了该工具的使用</a>：</p><blockquote><p>首先要使用<code>npm</code>进行安装，我们选择全局安装较为方便：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g jsdoc</span><br></pre></td></tr></table></figure><p>书写符合形式的代码及说明注释，在<code>js</code>文件的当前目录下执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jsdoc doc.js</span><br></pre></td></tr></table></figure><p>就会在当前目录下生成一个名为 <code>out</code> 的目录（也可以另外指定目录），然后我们就可以通过浏览器访问这个 <code>out</code> 目录中的相关网页。</p></blockquote><p>对于JavaScript的业务开发，我们可以参考<a href="https://juejin.cn/post/6995464881205936164">这一篇掘金的文章</a>。尤其是<strong>针对参数的描述，要注意格式为：</strong></p><p><strong><code>@param &#123;paramDataType&#125; p1 descriptionStatements</code></strong></p><p>其中：</p><ul><li><code>p1</code>代表<strong>必选参数</strong></li><li><code>[p1]</code>代表<strong>可选参数</strong></li><li><code>[p1=xxx]</code>代表<strong>带默认值的参数</strong></li></ul><p>对于<code>typescript</code>，<code>JSDoc</code> 的提供的注释标记类型可以参考Block Tags, 但是到现在为止，<code>TypeScript</code> <strong>只支持了部分标记。</strong> 在语法方面，由于<code>JSDoc</code> 主要借鉴于 closure-compiler, 而 <strong><code>TypeScript</code></strong> 则有自己的一套类型语法，因此存在部分的差异。</p><h2 id="Python中的注释和文档"><a href="#Python中的注释和文档" class="headerlink" title="Python中的注释和文档"></a>Python中的注释和文档</h2><p>单行注释和多行注释都是基本语法知识，需要注意的是由于Python按缩进来划分代码块的语法特性，编写多行注释的时候要注意首尾<code>&#39;&#39;&#39;</code>符号的对齐和缩进，多行注释可以用三个单引号 <strong>‘’’</strong> 或者三个双引号 <strong>“””</strong> 将注释括起来。</p><h3 id="Docstring——Python的文档注释"><a href="#Docstring——Python的文档注释" class="headerlink" title="Docstring——Python的文档注释"></a>Docstring——Python的文档注释</h3><p>按照<a href="https://python-guide.gitbooks.io/python-style-guide/content/style-guide/comment_and_docs.html">gitbook上Python的指导文档</a>可以看到：</p><blockquote><p>作为文档的Docstring一般出现在模块头部、函数和类的头部，这样在python中可以通过对象的__doc__对象获取文档，编辑器和IDE也可以根据Docstring给出自动提示。文档注释中对函数参数、返回值等的说明采用<code>numpy</code>标准。文档注释以 <code>&quot;&quot;&quot;</code> 开头和结尾，<strong>首行不换行，如有多行，末行必需换行</strong></p></blockquote><p>注意！为了代码的效率和信息不冗余，不要在文档注释复制函数定义原型，而要具体地描述其具体内容，解释具体参数和返回值等，如下面的示例写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  不推荐的写法(不要写函数原型等废话)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">function</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;function(a, b) -&gt; list&quot;&quot;&quot;</span></span><br><span class="line">    ... ...</span><br><span class="line"><span class="comment">#  正确的写法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">function</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算并返回a到b范围内数据的平均值&quot;&quot;&quot;</span></span><br><span class="line">    ... ...</span><br></pre></td></tr></table></figure><p><code>pydoc</code>是python自带的一个文档生成工具，可以提取注释。在控制台中，我们可以使用命令<code>pydoc pydoc_demo &gt; doc.md</code>来生成文档。之后使用<code>python pydoc_demo.py</code>命令启动<code>pydoc_demo.py</code>文件，就可以看得到相关的文档注释。</p><p>使用命令<code>pydoc -w pydoc_demo</code>可以生成<code>html</code>格式文件<code>pydoc_demo.html</code>，更具体的使用可以参考<a href="https://www.cnblogs.com/meitian/p/6704488.html">pydoc用法</a>。</p><h3 id="Python文件头注释"><a href="#Python文件头注释" class="headerlink" title="Python文件头注释"></a>Python文件头注释</h3><p>我们以一个常见的Python开头注释为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Author:XXX</span></span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/shizilunya/p/8081285.html">第一行<code>#!/usr/bin/env python</code>的意义</a>：</p><blockquote><p><strong>这些注释并不仅仅是写给读者看的注释，它也写给操作系统看的，这些注释决定了系统将如何运行这些文件。</strong></p><p>Linux系统自带python解释器（通常是Python 2的版本，比如Centos 7中就是如此）。在编写.py文件时，只要写上了#!&#x2F;usr&#x2F;bin&#x2F;python这行注释，用户就可以直接在命令行用文件名来执行py文件，例如：  testmode.py </p><p>意义：<strong>指定系统环境变量设定的解释器路径</strong>。类似于在window命令行中，你必须得写 python testmode.py 或 javac testmode.java 或 java testmode.class 来运行文件，你要通过文件名前面的<strong>关键字</strong>才能去启动对应的解释器。而有了这行注释，Linux系统就知道了你要用什么来执行这个文件，你就可以直接用文件名去跑它了。</p><p><code>#!/usr/bin/python</code>注释的问题：Linux只会使用系统默认的py解释器（也就是自带的那个）来运行文件。这样用户就无法使用自己的python版本了，不同的py版本之间语法有些差异，尤其是变动比较大的py2和py3，这些差异会使得整个程序无法正常运行。而#!&#x2F;usr&#x2F;bin&#x2F;env python 的出现可则让用户可以自行选择python版本，用户可以在<strong>环境变量</strong>中配置自己的py解释器（ps：用户安装的版本默认定位在Linux的local文件夹中）。<code>#!/usr/bin/env python</code>这行注释，会使linux在解析文件时，知道要去使用环境变量中的py解释器而非系统自带的那个。</p><p>所以如果你要使用该注释，推荐使用<code>#!/usr/bin/env python</code>的注释，而非<code>#!/usr/bin/python</code>。</p></blockquote><p>第二行<code># -*- coding:utf-8 -*-</code>作用是<strong>在Linux下指定文件的编码方式，用于支持中文</strong>。由于Python 3 默认支持中文，因此该行注释可以省略。</p><p>在<code>windows</code>系统的Python 3环境下运行我们的程序，可以不写上面的两行注释，但为了跨平台以及兼容，还是应该写上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java-文档注释&quot;&gt;&lt;a href=&quot;#Java-文档注释&quot; class=&quot;headerlink&quot; title=&quot;Java 文档注释&quot;&gt;&lt;/a&gt;Java 文档注释&lt;/h2&gt;&lt;p&gt;Java 支持三种注释方式。前两种和&lt;code&gt;C++&lt;/code&gt;的注释一样，分别</summary>
      
    
    
    
    <category term="Programming languages and projects" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/"/>
    
    
    <category term="python" scheme="http://justskim.github.io/tags/python/"/>
    
    <category term="java" scheme="http://justskim.github.io/tags/java/"/>
    
    <category term="javascript" scheme="http://justskim.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>知识图谱专业术语与基本知识</title>
    <link href="http://justskim.github.io/2022/03/16/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    <id>http://justskim.github.io/2022/03/16/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</id>
    <published>2022-03-16T07:04:43.745Z</published>
    <updated>2022-03-18T02:28:29.290Z</updated>
    
    <content type="html"><![CDATA[<h2 id="知识图谱的应用：我们为什么要做知识图谱"><a href="#知识图谱的应用：我们为什么要做知识图谱" class="headerlink" title="知识图谱的应用：我们为什么要做知识图谱"></a>知识图谱的应用：我们为什么要做知识图谱</h2><ol><li><p>语义搜索</p></li><li><p>智能问答</p></li><li><p>个性化推荐</p></li><li><p>辅助决策</p></li></ol><h2 id="起源和基本概念"><a href="#起源和基本概念" class="headerlink" title="起源和基本概念"></a>起源和基本概念</h2><p>在这篇<a href="https://zhuanlan.zhihu.com/p/148785892">知识图谱的介绍专栏</a>中，可以知道，<strong>知识图谱起源于语义网络（semantic nets or semantic networks）</strong>，语义网络一种用互联的的节点和弧来表示知识的一个结构，节点可以代表一个概念(concept)、一个属性(attribute)、一个事件(event)或者一个实体(entity)，而弧则用来表示节点之间的关系，弧的标签指明了关系的类型。<br>知识图谱不能仅理解为一个图，应该说：知识图谱是一种采用图模型（即由点和线组成的图形）来对人类知识进行表示的知识库或者知识的集合，并且符合某种语法和语义。</p><blockquote><p>知识图谱的图模型是一个有向图G&#x3D;&lt;O,E&gt;，这里O是一个实体或者字面量（literal）的集合，一般有以下几种：</p><ol><li>实例，即一个现实世界中具体的实物，比如说图1中的resource&#x2F;2019新型冠状病毒感染肺炎；</li><li>概念，可以看成是实例的集合，比如说图1中的class&#x2F;疾病；</li><li>字面量（literal），主要分为字符串和数据类型，这里数据类型包括日期值、高度等。</li></ol><p>知识图谱中<strong>一条知识</strong>称为<strong>三元组</strong>，即**<code>&lt;o1, e, o2&gt;</code><strong>的格式，这里<code>o1</code>和<code>o2</code>是实体或者字面量，而e则是带标签的边（类似图结构中我们要用两个点，一条边来表示）。</strong>一个三元组可以等价于一条主谓宾的知识，即<code>o1</code>和<code>o2</code>分别对应主语和宾语，e对应谓语**。</p></blockquote><p><a href="https://www.jianshu.com/p/941dc6d7e760">三元组的基本组成部分</a>：</p><blockquote><ul><li>实体（Entity）：实体是对客观个体的抽象，一个人、一部电影、一句话都可以看作是一个实体。例如：姚明，李安，我不是潘金莲</li><li>类型（type）：类型是对具有相同特点或属性的实体集合的抽象。举例：中国是一个实体，美国是一个实体，法国是一个实体。这些实体都有首都、人口、面积等共同特征，因此例如像中国、美国、法国等都有首都、人口、面积等特征的实体可以抽象为“国家”类型</li><li>属性（property）：属性是对实体与实体之间关系的抽象，例如李安是一个实体，李安是一个人物（type），少年派的奇幻漂流是一个实体，少年派的奇幻漂流是一个电影（type），很明显两个实体之间存在着关系即为：李安→导演→少年派的奇幻漂流因此李安与少年派的奇幻漂流之间的关系可以用属性“导演”刻画。那么可以根据属性构建一层关系，人物（type）→导演（property）→电影（type）。</li><li>关系（relation）：关系是<strong>实体与实体之间</strong>关系的抽象，李安（entity）→导演（relation）→少年派的奇幻漂流（entity），导演这个relation则是描述李安和少年派的奇幻漂流的关系。</li><li>域（domain）：域是类型的集合，凌驾于类型之上，是对某一领域所有类型的抽象，例如：国家是对中国、美国这样实体的一种抽象，是一种类型，而一个地理位置除了国家类型之外，还包括其他类型：城市、区域、洲等等，而把这些所有类型：洲、国家、城市、区域等类型抽象起来，就形成了地理位置域。</li><li>值（value）：值是用来描述实体的，可以分为文本型和数值型，EG：姚明（entity）→身高（relation）→ 226 cm（value）。</li></ul></blockquote><p>想要系统学习知识图谱，基础阶段可以看一下知乎上这一位博主的<a href="https://zhuanlan.zhihu.com/p/396516565">知识图谱专栏学习笔记</a>，比如他这里介绍的知识图谱构建方法：</p><p><img src="https://pic3.zhimg.com/80/v2-367fae46217b2666f15e20255a803eb2_720w.jpg" alt="知识图谱的构建"></p><p>建立知识图谱的第一步是获得数据，根据数据的类型可以分为：</p><ol><li><p>结构化的数据：表格、数据库等按照一定格式表示的数据，通常可以直接用来构建知识图谱；</p></li><li><p>非结构化的数据：文本、音频、视频、图片等，需要对它们进行信息抽取才能进一步建立知识图谱；</p></li><li><p>半结构化数据是介于结构化和非结构化之间的一种数据，也需要进行信息抽取才能建立知识图谱。</p></li></ol><p><a href="https://blog.csdn.net/taon1607/article/details/107087408">连续型数据和非连续型数据</a>：</p><blockquote><p>离散型数据都是类别值，如：男生，女生，商务座，一等座，二等座等等。连续型数据基本上都是数值型数据，如年龄（10岁，11岁…），身高（110cm, 175cm…），海拔，薪资等等。<br>既然连续型数据都是数值，是可以直接拿来供计算机使用的，那么连续型数据该如何处理？这里我们提出一个处理思想：连续型数据离散化。连续型数据离散化以后的建模效果一定会比原来的好吗？这个答案是不一定的</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200106162929139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MzA0ODUx,size_16,color_FFFFFF,t_70" alt="对不同类型数据的处理"></p><p><strong>信息抽取（知识抽取）</strong></p><blockquote><p>可以分为实体识别、关系抽取、属性抽取等。目前结构化的数据时最主要的知识来源。针对结构化的数据，知识图谱通常可以直接利用和转化，形成基础数据集，再利用知识图谱补全技术进一步扩展知识图谱。</p><p>针对文本型数据这种非结构化数据，知识获取的方式主要包括实体识别、关系抽取、属性抽取等。具体的方法又包括基于特征模版的方法、基于核函数的监督学习方法、基于深度学习的方法等</p><p>实体识别：指在一段文本中识别哪些词代表实体，并打上标签（进行分类）。例如“演员于和伟出演了电视剧《觉醒年代》”这句话中，“于和伟”和“《觉醒年代》”就是两个实体</p><p>关系抽取：识别文本（或其他数据）中实体之间的关系。例如“演员于和伟出演了电视剧《觉醒年代》”这句话中，“出演”为“演员于和伟”与“电视剧《觉醒年代》”之间的关系</p></blockquote><h3 id="知识表示与建模"><a href="#知识表示与建模" class="headerlink" title="知识表示与建模"></a>知识表示与建模</h3><p><strong>知识表示</strong></p><p>用一定的结构和符号语言来描述知识，并且能够用计算机进行推理、计算等操作的技术。知识表示的方法：谓词逻辑表示法、框架表示法、基于语意网路的表示法等。</p><p><strong>知识融合</strong></p><p>由于得到的数据可能会存在交叉和重叠，因此同一个概念、实体可能会反复出现，知识融合的目的就是把表示相同概念的实体进行合并。根据专栏作者的解释：</p><blockquote><p>主要任务包括实体消歧和指代消解，它们都用来判断知识库中的同名实体是代表同一含义、是否有其他实体也表示相同含义。实体消歧专门用于解决同名实体产生歧义的问题，通常采用聚类法、空间向量模型、语义模型等。指代消解则为了避免代词指代不清的情况。</p></blockquote><h3 id="知识推理"><a href="#知识推理" class="headerlink" title="知识推理"></a>知识推理</h3><blockquote><p>知识推理是根据已有的数据模型和数据，依据推理规则，获取新的知识或者结论，新的知识或结论应该是满足语义的。知识推理，依据描述逻辑系统实现。描述逻辑(Description Logic)是基于对象的知识表示的形式化，也叫概念表示语言或术语逻辑，是一阶谓词逻辑的一个可判定子集。</p><p>一个描述逻辑系统由四个基本部分组成： 最基本的元素：概念、关系、个体；TBox术语集：概念术语的公理集合； Abox断言集：个体的断言集合；TBox 和 ABox上的推理机制。</p><p>描述逻辑涉及到的内容也比较多，此处举几个例子，比如实体的分类包含关系，一个电脑椅是椅子，椅子是家具，可以说，一个电脑椅是家具。常识规则的推理，一个男人的孩子是A，一个女人的孩子是A，可以知道，这个男人和女人是配偶。</p></blockquote><p><img src="https://pic4.zhimg.com/80/v2-86c66ac77e2b89d0f39b31b230bfdf7f_720w.jpg" alt="知识推理的三大方式"></p><p>简单地说，推理任务主要有：通过<strong>规则挖掘</strong>对知识图谱进行<strong>补全（Knowledge Base Completion,KBC）与质量校验</strong>、<strong>链接预测、关联关系推理</strong>与<strong>冲突检测</strong>等。</p><p>基于规则的推理通过定义或学习知识中存在的规则进行挖掘与推理，从早期的ILP(Inductive Logic Programming)系统中衍生的AMIE、AMIE+算法， 强调通过自动化的规则学习方法，快速有效的从大规模知识图谱中学习出置信度较高的规则，并且应用于推理任务。</p><p><img src="https://pic2.zhimg.com/80/v2-ced25261ed496e505147fc23aa9cb95d_720w.jpg" alt="各种推理方法极其优缺点总结"></p><h3 id="Trans-E-算法细说"><a href="#Trans-E-算法细说" class="headerlink" title="Trans E 算法细说"></a>Trans E 算法细说</h3><p>transE算法就是一个非常经典的知识表示学习，用<a href="https://so.csdn.net/so/search?q=%E5%88%86%E5%B8%83%E5%BC%8F&spm=1001.2101.3001.7020">分布式</a>表示（distributed representation）来描述知识库中的三元组，<a href="https://blog.csdn.net/shunaoxi2313/article/details/89766467">这里可以看下其简单的算法思想</a>：</p><blockquote><p>知识图谱中的事实是用三元组 ( h , l , t ) (h,l,t)(h,l,t) 表示的，那么如何用低维稠密向量来表示它们，才能得到这种依赖关系呢？transE算法的思想非常简单，它受word2vec平移不变性的启发，希望h + l ≈ t h+l≈th+l≈t（此为归纳偏差？）。</p><p>光有这一个约束可不够。想让h + l ≈ t h+l≈th+l≈t，如何设置损失函数是个关键。我们发现表示学习都没有明显的监督信号，也就是不会明确告诉模型你学到的表示正不正确，那么想要快速收敛就得引入“相对”概念，即相对负例来说，正例的打分要更高，方法学名：<strong>“negative sampling”</strong>，也就是<strong>负采样</strong>。</p></blockquote><p>转移距离模型（Translational Distance Model）的主要思想是将衡量向量化后的知识图谱中三元组的合理性问题，转化成衡量头实体和尾实体的距离问题。这一方法的重点是如何设计得分函数，得分函数常常被设计成利用关系把头实体转移到尾实体的合理性的函数。 受词向量的启发，由词与词在向量空间的语义层面关系，可以拓展到知识图谱中头实体和尾实体在向量空间的关系。也就是说，同样可以 考虑把知识图谱中的头实体和尾实体映射到向量空间中，且它们之间的 联系也可以考虑成三元组中的关系。</p><p>TransE便是受到了词向量中平移不变性的启发，在 TransE 中，把实体和关系都表示为向量，对于某一个具体的关系（head, relation, tail），把关系的向量表示解释成头实体的向量到尾实体的向量的转移向量（Translation vector）。也就是说， 如果在一个知识图谱中，某一个三元组成立，则它的实体和关系需要满 足关系head+relation≈tail。</p><h3 id="知识图谱的嵌入"><a href="#知识图谱的嵌入" class="headerlink" title="知识图谱的嵌入"></a>知识图谱的嵌入</h3><p>知识图谱通常存在链接缺失问题，这限制了知识图谱在相关下游任务中的应用。为解决该问题，知识图谱补全任务应运而生。知识图谱补全旨在根据知识图谱中已有事实推断出新的事实，从而使得知识图谱更完整。</p><p>知识图谱嵌入 (Knowledge Graph Embedding) 是解决知识图谱补全问题的重要方法之一，它通过将知识图谱中的实体 (Entity) 和关系 (Relation) 嵌入到连续向量空间，从而在方便计算的同时保留知识图谱中的结构信息。知识图谱嵌入模型大致可以分为三类：</p><blockquote><h2 id="知识图谱补全任务"><a href="#知识图谱补全任务" class="headerlink" title="知识图谱补全任务"></a>知识图谱补全任务</h2><h3 id="符号定义"><a href="#符号定义" class="headerlink" title="符号定义"></a>符号定义</h3><p>知识图谱通常以三<a href="https://so.csdn.net/so/search?q=%E5%85%83%E7%BB%84&spm=1001.2101.3001.7020">元组</a> (Triple) 来表示知识，三元组的一般格式为 (<em>头实体</em>，<em>关系</em>，<em>尾实体</em>)，如“金庸的表兄是徐志摩”表示成三元组为 (<em>金庸</em>，<em>表兄</em>，<em>徐志摩</em>)，其中<em>金庸</em>为头实体，<em>徐志摩</em>为尾实体，<em>表兄</em>是这两个实体之间的关系。我们使用小写的字母 来分别表示头实体、关系和尾实体， 表示知识图谱中的一个三元组。相应地，小写加粗字母 分别表示头实体、关系和尾实体对应的嵌入向量。向量 的第 个元素记作 。 表示嵌入向量的维度。  表示两个向量间的 Hadamard (element-wise) product。另外，我们使用 来分别表示 和 范数。</p><h3 id="补全任务与性能指标"><a href="#补全任务与性能指标" class="headerlink" title="补全任务与性能指标"></a>补全任务与性能指标</h3><p>知识图谱补全 (Knowledge Graph Completion)，是根据知识图谱中已有的三元组去对未知三元组进行预测。我们使用 表示已知头实体和关系来预测尾实体， 表示已知关系和尾实体来预测头实体，其中 和 被称为查询 (Query)。实际上，知识图谱补全任务，本质上给定查询下的排序问题。比如，对于图2所示的查询 (<em>陆小曼</em>，<em>丈夫</em>，<em>？</em>)，返回的是预测答案的排序列表，正确答案排名越高，预测的效果就越好。</p></blockquote><h3 id="质量评估"><a href="#质量评估" class="headerlink" title="质量评估"></a>质量评估</h3><p>在知识推理完了之后，我们也不能忘记质量评估这一个最后的步骤：</p><blockquote><p>质量评估就是对最后的结果数据进行评估，将合格的数据放入知识图谱中。质量评估的方法，根据所构建的知识图谱的不同，对数据要求的差异而有所差别。总的目的是要获得合乎要求的知识图谱数据，要求的标准根据具体情况确定。 比如对于公共领域的知识图谱，知识的获取采用了众包的方法，对于同一个知识点，可能会有很多人来完成，如果这个知识点只有一个答案，可以采用的一种策略是，将多人的标注结果进行比较，取投票多的结果作为最终的结果。当然，这是不严谨的，因为真理往往掌握在少数人的手里，特别是针对一些行业的知识图谱，表现尤为突出。行业内的一条知识，可能只有行业专家能够给出权威正确的答案，如果让大众投票来决定，可能会得到一条错误的知识。所以，针对行业知识图谱，可能会采用不同于公共知识图谱的策略，来进行知识的质量评估。</p></blockquote><h3 id="NLP中的负采样（Negative-Sampling）"><a href="#NLP中的负采样（Negative-Sampling）" class="headerlink" title="NLP中的负采样（Negative Sampling）"></a>NLP中的负采样（Negative Sampling）</h3><p>负采样是NLP领域一个出现频次极高的词，负抽样的目的是为了最终输出的上下文单词（正样本），在采样过程中应该保留下来并更新，同时也需要采集部分负样本（非上下文单词）。通过负采样，在更新隐层到输出层的权重时，只需更负采样的单词，而不用更新词汇表所有单词，<br><a href="https://blog.csdn.net/ningyanggege/article/details/87869393">对负采样理解</a>来自于word2vec算法：</p><blockquote><p>比如说  love 和me两个单词；<br>使用特殊思维模式；假设整个词汇表只有100个单词；love 表示成one-hot向量； me表示成one-hot向量；<br>模型输入为love的one-hot向量；模型输出为me的one-hot向量；<br>假设模型的神经网络结构为100<em>10</em>100；输出层100个；<br>输出层中除了me对应位置的1外，其他全是0；称这为负样本；参数数量为10<em>100<br>采样就是从这样负样本中抽样；比如说抽取5个；那么在此次梯度更新中就只更新10</em>5；更新数量为原来的1&#x2F;20</p><p>因此，可以看到负采样的本质：每次让一个训练样本<strong>只更新部分权重</strong>，<strong>其他权重全部固定</strong>；<strong>减少计算量</strong>；（一定程度上还可以增加随机性）</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;知识图谱的应用：我们为什么要做知识图谱&quot;&gt;&lt;a href=&quot;#知识图谱的应用：我们为什么要做知识图谱&quot; class=&quot;headerlink&quot; title=&quot;知识图谱的应用：我们为什么要做知识图谱&quot;&gt;&lt;/a&gt;知识图谱的应用：我们为什么要做知识图谱&lt;/h2&gt;&lt;ol&gt;
</summary>
      
    
    
    
    <category term="知识图谱" scheme="http://justskim.github.io/categories/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
    
    <category term="知识图谱" scheme="http://justskim.github.io/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
  </entry>
  
  <entry>
    <title>visual studio code中无法切换Python版本的解决</title>
    <link href="http://justskim.github.io/2022/03/07/visual-studio-code%E4%B8%AD%E6%97%A0%E6%B3%95%E5%88%87%E6%8D%A2Python%E7%89%88%E6%9C%AC%E7%9A%84%E8%A7%A3%E5%86%B3/"/>
    <id>http://justskim.github.io/2022/03/07/visual-studio-code%E4%B8%AD%E6%97%A0%E6%B3%95%E5%88%87%E6%8D%A2Python%E7%89%88%E6%9C%AC%E7%9A%84%E8%A7%A3%E5%86%B3/</id>
    <published>2022-03-07T01:50:49.323Z</published>
    <updated>2022-03-07T02:05:47.908Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>使用Python进行机器学习，需要引入<code>sklearn</code>模块，因此在我们建立的<code>anaconda</code>环境（名称<code>py378</code>，用的Python 3.7.8的版本）中activate该环境，并安装<code>scikit-learn</code>库（安装的模块名和导入的库名称不一样，这个见网上详细解释，<code>scikit-learn</code>其实就是其工具包）。但来到软件<code>visual studio code</code>界面中却发现无法正常切换Python版本，工作区也未能生成<code>.vscode</code>文件夹：</p><p>![visual studio code无法切换python环境](&#x2F;images&#x2F;visual studio code无法切换python环境.PNG)</p><p>我们可以看到，在左下角并没有加载出Python Interpreter，终端中手动输入命令切换环境也依然无法奏效。</p><h2 id="尝试步骤"><a href="#尝试步骤" class="headerlink" title="尝试步骤"></a>尝试步骤</h2><ol><li><p>按住<code>ctrl+shift+p</code>，输入<code>Python Interpreter</code>切换环境，发现已经被切换到<code>py378</code></p></li><li><p>打开<code>Preferences</code>中的设置，在<code>settings.json</code>中找到<code>python.defaultInterpreterPath</code>，由于之前博主为了能像<code>anaconda</code>那般切换环境，在<code>visual studio code</code>进行配置，此项为<code>anaconda</code>下的<code>python.exe</code>文件，博主手动将其修改为<code>C:\\Users\\YourUserName\\Anaconda3\\envs\\py378\\python.exe</code></p></li><li><p>在上边的设置中，搜索<code>cmd</code>，查看终端<code>terminal</code>是否为<code>cmd</code>而不是<code>powershell</code>（据网上说法<code>powershell较不稳定</code>），但博主这里的设置无误：</p><p><img src="/images/visual-studio-code%E4%B8%ADterminal%E8%AE%BE%E7%BD%AE.PNG" alt="visual-studio-code中terminal设置"></p></li></ol><p>经过以上步骤依然无效</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;使用Python进行机器学习，需要引入&lt;code&gt;sklearn&lt;/code&gt;模块，因此在我们建立的&lt;code&gt;anaconda&lt;/code</summary>
      
    
    
    
    <category term="Programming languages and projects" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/"/>
    
    <category term="Python3" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"/>
    
    
    <category term="python" scheme="http://justskim.github.io/tags/python/"/>
    
    <category term="visual studio code" scheme="http://justskim.github.io/tags/visual-studio-code/"/>
    
  </entry>
  
  <entry>
    <title>Eclipse web 工程的项目目录结构</title>
    <link href="http://justskim.github.io/2022/03/06/Eclipse-web-%E5%B7%A5%E7%A8%8B%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
    <id>http://justskim.github.io/2022/03/06/Eclipse-web-%E5%B7%A5%E7%A8%8B%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</id>
    <published>2022-03-06T10:10:07.896Z</published>
    <updated>2022-03-06T14:14:59.757Z</updated>
    
    <content type="html"><![CDATA[<p>在使用Eclipse学习Java开发的过程中，发现我自己新建<code>dynamic web project</code>的项目目录结构和视频中演示的不同，最明显的区别是没有Java Resources和JavaScript Resources这两个文件夹：</p><p><img src="/images/%E6%96%B0%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="新建web项目目录结构"></p><p>查阅多方资料显示，这种项目结构的不同对于程序执行并没有大问题，要参考项目中各个文件和目录的功能，可以见以下三篇博客：</p><ol><li><a href="https://blog.csdn.net/yyuanxiwen/article/details/94600630">https://blog.csdn.net/yyuanxiwen/article/details/94600630</a></li><li><a href="https://blog.csdn.net/Alan_Wdd/article/details/90514928">https://blog.csdn.net/Alan_Wdd/article/details/90514928</a></li><li><a href="https://www.cnblogs.com/jetdl/p/9724651.html">https://www.cnblogs.com/jetdl/p/9724651.html</a></li></ol><p>在webapp下有一个WEB-INF文件夹。该目录是一个专用区域， 容器不能把此目录中的内容提供给用户。这个目录下的文件只供容器使用，里面包含不应该由客户直接下载的资源。<strong>Web 容器要求在你的应用程序中必须有 WEB-INF 目录。WEB-INF 中包含着发布描述符（也就是 web.xml 文件）, 一个 classes 目录和一个 lib目录, 以及其它内容。注意： 如果你的 Web 应用程序中没有包含这个目录, 它可能将无法工作 。</strong></p><p>web.xml文件在 J2EE Web 应用程序发布之后帮助管理 Web 应用程序的配置。在web.xml文件中会设置welcome-file标签，这是因为&#x2F;WEB-INF目录下的文件本来是不允许直接访问的，但如果在web.xml中配置了如上欢迎页面，并且在&#x2F;WEB-INF目录下放置了index.html，那么在浏览器地址栏输入<a href="http://127.0.0.1:8080/myWeb%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AEindex.html%E9%A1%B5%E9%9D%A2%EF%BC%8C%E8%B7%AF%E5%BE%84%E4%B8%AD%E7%9A%84myWeb%E6%98%AF%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E5%90%8D%E3%80%82">http://127.0.0.1:8080/myWeb可以访问index.html页面，路径中的myWeb是项目文件名。</a></p><p>在web.xml文件下需要添加约束，约束文件可以在我们tomcat安装目录下的<code>/conf</code>子文件夹中的web.xml文件中拷贝。</p><p>我们打开eclipse时，会要求我们设定workspace。在我们设定workspace的那个文件夹下，我们可以发现一个**隐藏文件夹<code>.metadata</code>**，它存在于eclipse第一次启动时指定的workspace目录下， project name 和 workspace 分别对应的目录不能是同一个目录，否则无法建立project name。</p><p>当我们通过<a href="https://so.csdn.net/so/search?q=eclipse&spm=1001.2101.3001.7020">eclipse</a>启动tomcat运行工程时，eclipse会将工程发布到org.eclipse.wst.server.core中，就像发布到tomcat中一样。使用tomcat服务器的话，默认的部署路径为<code>.metadata/.plugins/org.eclipse.wst.server.core/tmp0</code>，可以看到有一个server.xml，可以看到<code>deployDir=&quot;wtpwebapps&quot;</code>。</p><p>因此在该路径下的wtpwebapps文件夹（注意最后不是webapps）下可以看到发布的项目。</p><p>当我们为Eclipse配置默认使用的本机tomcat服务器后，我们可以在Project Explorer窗口中找到一个Servers目录，其中有一个server.xml。Service标签代表包含着一个服务（默认情况下name&#x3D;”Catalina”)，一个服务器可以包含多个服务，就对应着多个Service标签。因为是web项目，我们这里的服务要给浏览器使用，因此需要用到连接器Connector，并在其中配置端口号（默认为port&#x3D;”8080”）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在使用Eclipse学习Java开发的过程中，发现我自己新建&lt;code&gt;dynamic web project&lt;/code&gt;的项目目录结构和视频中演示的不同，最明显的区别是没有Java Resources和JavaScript Resources这两个文件夹：&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="Java" scheme="http://justskim.github.io/categories/Java/"/>
    
    <category term="Eclipse" scheme="http://justskim.github.io/categories/Java/Eclipse/"/>
    
    
    <category term="java" scheme="http://justskim.github.io/tags/java/"/>
    
    <category term="eclipse" scheme="http://justskim.github.io/tags/eclipse/"/>
    
  </entry>
  
  <entry>
    <title>重新安装JDK后Eclipse更改配置</title>
    <link href="http://justskim.github.io/2022/03/06/%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85JDK%E5%90%8EEclipse%E6%9B%B4%E6%94%B9%E9%85%8D%E7%BD%AE/"/>
    <id>http://justskim.github.io/2022/03/06/%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85JDK%E5%90%8EEclipse%E6%9B%B4%E6%94%B9%E9%85%8D%E7%BD%AE/</id>
    <published>2022-03-06T00:42:59.456Z</published>
    <updated>2022-03-06T09:16:31.632Z</updated>
    
    <content type="html"><![CDATA[<p>博主在将原先的JDK卸载，又重新安装JDK11后，发现了Eclipse软件无法正常打开的情况：</p><p><img src="/images/%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85Java%E5%90%8EEclipse%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80.PNG" alt="重新安装Java后Eclipse无法打开"></p><p>这种情况下我们一般先检查环境变量，通过命令行和系统环境的Java变量配置查看均无异常。我们查询当时Eclipse的安装教程，看是否有Eclipse软件相关的环境变量需要重新配置，结果的no。</p><p>那么，问题很明显，Eclipse软件会在第一次使用的时候获取系统的Java相关环境变量，然后将其存入自己的相关配置文件中，之后就不必获取了。在网上搜索得到Eclipse软件的配置文件为安装目录下bin文件夹中的<code>eclipse.ini</code>文件，我们打开搜索，可以看到<code>vm</code>（virtual machine 虚拟机）选项下有个旧版本<code>JDK</code>安装路径的bin文件夹：</p><p><img src="/images/eclipse.ini%E4%B8%AD%E4%BF%AE%E6%94%B9vm%E4%B8%8Bjavaw.exe%E7%9A%84%E8%B7%AF%E5%BE%84.PNG" alt="eclipse.ini中修改vm下javaw.exe的路径.PNG"></p><p>我们将其修改为重新安装的<code>JDK</code>路径下bin文件夹：<code>C:\Program Files\Java\jdk-11.0.2\bin</code>，重新打开Eclipse软件，可以成功运行！</p><p>这里顺便提一下，很多软件安装完之后都有一个bin文件夹，<em>bin</em>是binary的缩写，代表的意思是二进制，该文件夹下一般都存放二进制可执行文件。</p><p><em>ini 文件</em>，全称 “Initialization File”，即初始化文件，是windows的系统配置文件所采用的存储格式，统管windows的各项配置。<a href="https://blog.csdn.net/a123441/article/details/90668032">配置文件的好处</a>在于，能够通过直接编辑<code>ini</code>文件来修改配置：</p><blockquote><p>如果我们的程序没有任何配置文件时，这样的程序对外是全封闭的，一旦程序需要修改一些参数必须要修改程序代码本身并重新编译，这样很不好，所以要用配置文件，让程序出厂后还能根据需要进行必要的配置；配置文件有很多，如INI配置文件，<a href="https://so.csdn.net/so/search?q=XML&spm=1001.2101.3001.7020">XML</a>配置文件，还有就是可以使用系统注册表等。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;博主在将原先的JDK卸载，又重新安装JDK11后，发现了Eclipse软件无法正常打开的情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85Java%E5%90%8EEclipse%E6%97%A</summary>
      
    
    
    
    <category term="Java" scheme="http://justskim.github.io/categories/Java/"/>
    
    <category term="Eclipse" scheme="http://justskim.github.io/categories/Java/Eclipse/"/>
    
    
    <category term="java" scheme="http://justskim.github.io/tags/java/"/>
    
    <category term="eclipse" scheme="http://justskim.github.io/tags/eclipse/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7系统安装python3.7.8</title>
    <link href="http://justskim.github.io/2022/03/06/CentOS7%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85python3.7.8/"/>
    <id>http://justskim.github.io/2022/03/06/CentOS7%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85python3.7.8/</id>
    <published>2022-03-05T17:17:00.722Z</published>
    <updated>2022-03-07T01:33:57.245Z</updated>
    
    <content type="html"><![CDATA[<p>首先在<a href="https://www.python.org/downloads/source/">Python官方网站</a>中找到我们特定版本的安装包，这里我们要选择适合Linux系统的<code>tar.xz</code>格式压缩包。我们要注意，大部分Linux系统发行版，比如博主所用的Centos7都预装了python2，可以使用命令<code>python -V</code>查看其版本为2.7.5，但可能没有装pip工具。但是这样也有个好处，下载包的时候免得我们混淆。我们注意<a href="https://blog.csdn.net/qq_40584960/article/details/86082019">pip2和pip3的关系</a>：</p><blockquote><ol><li>pip是python的包管理工具，pip和pip3版本不同，都位于Scripts\目录下；</li><li>如果系统中只安装了Python2，那么就只能使用pip；</li><li>如果系统中只安装了Python3，那么既可以使用pip也可以使用pip3，二者是等价的；</li><li>如果系统中同时安装了Python2和Python3，则pip默认给Python2用，pip3指定给Python3用；</li><li>使用<code>pip install XXX</code>安装的库会位于路径<code>python2.X/site-packages</code>中，而使用<code>pip3 install XXX</code>安装的库会放在目录<code>python3.X/site-packages</code>下。</li></ol></blockquote><p>博主按照网上常见的教程安装后，一直显示的是<code>python 3.6.8</code>，跑到路径<code>/usr/bin</code>下使用命令<code>rm -rf python3*</code>删除了旧的python文件（前缀为python3的，前缀为python没有3的是python2版本的文件），再重新安装，编译，成功启动程序。</p><p><code>which python3 </code>命令在PATH变量指定的路径中，<strong>搜索系统命令<code>python</code>的位置</strong>，并且返回第一个搜索结果（使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先在&lt;a href=&quot;https://www.python.org/downloads/source/&quot;&gt;Python官方网站&lt;/a&gt;中找到我们特定版本的安装包，这里我们要选择适合Linux系统的&lt;code&gt;tar.xz&lt;/code&gt;格式压缩包。我们要注意，大部分Linu</summary>
      
    
    
    
    <category term="Programming languages and projects" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/"/>
    
    <category term="Python3" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"/>
    
    
    <category term="linux" scheme="http://justskim.github.io/tags/linux/"/>
    
    <category term="python" scheme="http://justskim.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Windows系统下环境变量配置与计算机重启</title>
    <link href="http://justskim.github.io/2022/03/05/Windows%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E5%90%AF/"/>
    <id>http://justskim.github.io/2022/03/05/Windows%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E5%90%AF/</id>
    <published>2022-03-05T08:50:11.668Z</published>
    <updated>2022-03-05T09:59:52.900Z</updated>
    
    <content type="html"><![CDATA[<p>我们来看一下<a href="https://blog.csdn.net/shuixin536/article/details/8084612">对于Windows不重启使环境变量修改生效的解释</a>：</p><blockquote><p>一个程序启动时，环境变量被复制到该程序所在的环境中，在该程序执行过程中不会被除该程序以外的其他程序所改变。也就是说，假设我们启动了一个cmd程序，然后通过控制面板修改了环境变量设置，但是已经启动了的cmd所拥有的环境变量并不会被改变。如果我们在修改环境变量之后启动cmd程序，则该程序将拥有新的环境变量。<br>那么结论就很明显了：修改环境变量之后，如果受影响的是应用程序，那么只要简单地重新启动此应用程序，环境变量的修改就会反映到该程序中，而不必重新启动计算机；但是，如果受影响的是系统服务，就必须重新启动才能将环境变量的修改反映到系统服务中（因为没有办法在不重启计算机的情况下重新启动系统服务管理器）</p></blockquote><p>那么有没有什么办法可以不重启就使一切修改的环境变量配置生效呢？有，当我们很不想重启windows系统时可以尝试这么做：</p><blockquote><p>以修改环境变量“PATH”为例，修改完成后，进入DOS命令提示符，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set PATH=C: 1</span><br></pre></td></tr></table></figure><p>关闭DOS窗口。再次打开DOS窗口，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo %PATH% 1</span><br></pre></td></tr></table></figure><p>可以发现“我的电脑”-&gt;“属性”-&gt;“高级”-&gt;“环境变量”中设置的 PATH 值已经生效。<br>不用担心DOS窗口中的修改会影响环境变量的值，DOS窗口中的环境变量只是Windows环境变量的一个副本而已。但是对副本的修改却会引发Windows环境变量的刷新，这正是我们想要的！</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们来看一下&lt;a href=&quot;https://blog.csdn.net/shuixin536/article/details/8084612&quot;&gt;对于Windows不重启使环境变量修改生效的解释&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个程序启动时，环境变量被复</summary>
      
    
    
    
    <category term="Windows" scheme="http://justskim.github.io/categories/Windows/"/>
    
    
    <category term="windows" scheme="http://justskim.github.io/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>Java基础语法学习要注意的小细节</title>
    <link href="http://justskim.github.io/2022/03/02/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%B0%8F%E7%BB%86%E8%8A%82/"/>
    <id>http://justskim.github.io/2022/03/02/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%B0%8F%E7%BB%86%E8%8A%82/</id>
    <published>2022-03-01T19:38:13.360Z</published>
    <updated>2022-03-13T13:50:59.387Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java基础语法学习要注意的小细节"><a href="#Java基础语法学习要注意的小细节" class="headerlink" title="Java基础语法学习要注意的小细节"></a>Java基础语法学习要注意的小细节</h1><p><strong>最最基本的</strong></p><p><code>Java</code><strong>8</strong>和11是两个最常用的版本，也是推荐新手起步安装的版本，博主一开始使用最新的JDK17，但很多文件位置和环境配置都不同，看使用旧版本的开发教程时很麻烦。Java平台包括Java se(J2SE，标准版)  Java ee(J2EE，企业版，J2SE是其子集) Java me(J2ME，用于嵌入式的，比较少)。普通用户只需安装JER(Java Runtime Environment)来运行Java程序，而开发者必须安装JDK来对程序进行编译调试。版本的关系对应为：Java X &#x3D; Java SE X &#x3D; JDK 1.X 。</p><p>对于Java SE，<a href="https://www.huoxiaoqiang.com/experience/javae/2381.html">各大厂商的JDK</a>有所区别。官网的下载速度很慢还要注册账号，我们可以在<a href="https://blog.csdn.net/wanghao72214/article/details/109720371">推荐的三家国内jdk镜像站</a>中下载相应的JDK。其中，<a href="https://mirrors.tuna.tsinghua.edu.cn/AdoptOpenJDK/11/jdk/x64/windows/">清华大学开源软件镜像站</a>的<code>JDK</code>为Eclipse Temurin Java SE，由Eclipse基金会发布，即OpenJDK的”生产就绪“构建，免费试用，且所有版本都通过了Oracle的Java SE技术兼容性工具包测试以及Eclipse AQAvit互操作性和性能测试。不过博主还是选择了传统的OpenJDK11版本，在之后可能会再使用探究（尽可能省去麻烦）。安装<code>JDK</code>时，路径中不能有中文和空格，并且要单独取消外部公共<code>JRE</code>的安装。</p><p>虚拟机 <code>JVM</code> ⫋ 运行环境 <code>JRE</code> ⫋ 开发工具 <code>JDK </code></p><p><strong>编译的编码与修改环境变量</strong></p><p>使用命令<code>javac </code>编译<code>java</code>文件，可能会出现中文信息乱码的情况，我们首先选择添加参数<code>-encoding UTF8</code>来解决问题。但博主在卸载Java11，转而安装Java9后出现的乱码问题却无法通过此方式解决。但是博主看到在一大堆的乱码报错信息前有这么一条：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF-<span class="number">8</span></span><br></pre></td></tr></table></figure><p>这可能是博主先前想通过startup.bat文件来启动tomcat10，而千方百计设置Java11环境变量遗留下来的，于是博主在环境变量中将此系统变量移除。</p><p><img src="/images/%E5%88%A0%E9%99%A4JAVA_TOOL_OPTIONS%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%90%8E%E9%87%8D%E5%90%AF.PNG" alt="删除JAVA_TOOL_OPTIONS环境变量后重启"></p><p>重新打开一个<code>cmd</code>窗口，执行编译命令依然乱码。只好在重启后重来一次，才成功编译。</p><p><strong>文件名和类名</strong></p><p>一个<code>java</code>文件中可以有很多类，但最多只能有一个类的类名和文件名相同——如果该类被<code>public</code>修饰，那么其类名必须和文件名相同，<strong>一个<code>java</code>文件中也最多只有一个类被public修饰</strong>。</p><p>尽管windows系统下文件名不区分大小写，但为了方便起见，以及在Linux操作系统下文件能被顺利编译执行，我们所有的<code>java</code>文件名及public修饰类，以及在windows控制台下运行时输入的文件名，都要保持一致的大小写！</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>&gt;<span class="title">javac</span>  <span class="title">DEMOCONST.java</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>&gt;<span class="title">java</span>  <span class="title">DEMOCONST</span></span></span><br><span class="line"><span class="function">错误: 找不到或无法加载主类 <span class="title">DEMOCONST</span></span></span><br><span class="line"><span class="function">原因: <span class="title">java.lang.NoClassDefFoundError</span>: <span class="title">DemoConst</span> (<span class="title">wrong</span> <span class="title">name</span>: <span class="title">DEMOCONST</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>&gt;<span class="title">java</span>  <span class="title">DemoConst</span></span></span><br><span class="line"><span class="function"><span class="title">the</span> <span class="title">name</span> <span class="title">of</span> <span class="title">class</span> <span class="title">is</span> <span class="title">democonst</span></span></span><br><span class="line"><span class="function"><span class="title">true</span></span></span><br><span class="line"><span class="function"><span class="title">false</span></span></span><br><span class="line"><span class="function">#可以看到，对于文件<span class="title">Democonst.java</span>，大小写不一致情况下<span class="title">javac</span>命令能编译，但<span class="title">java</span>命令不能执行</span></span><br></pre></td></tr></table></figure><p><strong>引用路径和包</strong><br>在学习类和对象的时候，博主定义了两个程序，并将其放在同一个文件夹(cn)下，首先是定义一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//package cn;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="comment">//成员变量</span></span><br><span class="line">String name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="comment">//成员方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;eat now!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;sleep now!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;study now!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，是在另一个Java程序中使用这个类创建对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//package cn;</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;<span class="comment">//这一行可以让我们引用同一个目标文件夹下的java类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demoStudent</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line"><span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">System.out.println(<span class="string">&quot;student&#x27;s name is &quot;</span>+stu.name);</span><br><span class="line">System.out.println(<span class="string">&quot;student&#x27;s age is &quot;</span>+stu.age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们在控制台可以编译后执行程序，注意，声明后<strong>没有被赋值的成员变量会有一个默认值（但是Java中局部变量未赋值将无法通过编译）</strong></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>\<span class="title">cn</span>&gt;<span class="title">javac</span> -<span class="title">encoding</span> <span class="title">UTF</span>-8 <span class="title">demoStudent.java</span></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>\<span class="title">cn</span>&gt;<span class="title">java</span> <span class="title">demoStudent</span></span></span><br><span class="line"><span class="function"><span class="title">student</span>&#x27;<span class="title">s</span> <span class="title">name</span> <span class="title">is</span> <span class="title">null</span></span></span><br><span class="line"><span class="function"><span class="title">student</span>&#x27;<span class="title">s</span> <span class="title">age</span> <span class="title">is</span> 0</span></span><br></pre></td></tr></table></figure><p>而如果我们取消注释的代码，并将<code>import java.io.*;</code>这一行注释掉，会发现，第二个程序编译时会报错：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>\<span class="title">cn.itcast.demo</span>&gt;<span class="title">javac</span> -<span class="title">encoding</span> <span class="title">UTF</span>-8 <span class="title">demoStudent.java</span></span></span><br><span class="line"><span class="function"><span class="title">demoStudent.java</span>:5: 错误: 无法访问<span class="title">Student</span></span></span><br><span class="line"><span class="function">                <span class="title">Student</span> <span class="title">stu</span> = <span class="title">new</span> <span class="title">Student</span>();</span></span><br><span class="line"><span class="function">                ^</span></span><br><span class="line"><span class="function">  错误的源文件: .\<span class="title">Student.java</span></span></span><br><span class="line"><span class="function">    文件不包含类<span class="title">Student</span></span></span><br><span class="line"><span class="function">    请删除该文件或确保该文件位于正确的源路径子目录中。</span></span><br><span class="line"><span class="function">1 个错误</span></span><br></pre></td></tr></table></figure><p>但是这样的写法在Eclipse软件的Java项目中又是能正常运行的，因此，博主决定探究一下Java的package机制，以及其在Windows系统下的编译机制，来确定我们命令语句该怎么输入（Eclipse和IDEA这类软件肯定是把这个步骤封装好的，不过我还是要了解这个原理）。</p><p>类是Java中一种引用数据类型（Java中除了八种基本数据类型，其它的都是<strong>对象，也就是引用类型，包括数组</strong>和字符串），对其使用以下三步走：</p><ol><li>导包：<ul><li>如果要使用的目标类，和当前类（含有main方法）位于<strong>同一个包</strong>下，可以省略导包不写；</li><li>否则需要使用<code>import</code>导包语句。</li></ul></li><li>创建对象：类名称 对象名 &#x3D; new 类名称();</li><li>使用。</li></ol><p>最后，我们根据该<a href="https://blog.csdn.net/scgaliguodong123_/article/details/41804667">博客</a>提出的方法，能在命令行中正确编译并执行以上的Java文件——配置参数，编译后，<strong>返回到包名父目录</strong>，运行程序。</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>\<span class="title">cn</span>&gt;<span class="title">javac</span> -<span class="title">encoding</span> <span class="title">UTF</span>-8 -<span class="title">sourcepath</span> <span class="title">E</span>:/<span class="title">Java_practice</span> <span class="title">demoStudent.java</span></span></span><br><span class="line"><span class="function">#注意！<span class="title">sourcepath</span>参数这里不能带上任何一级的包名，就能正确编译</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>\<span class="title">cn</span>&gt;<span class="title">java</span> <span class="title">demoStudent</span></span></span><br><span class="line"><span class="function">错误: 找不到或无法加载主类 <span class="title">demoStudent</span></span></span><br><span class="line"><span class="function">原因: <span class="title">java.lang.NoClassDefFoundError</span>: <span class="title">cn</span>/<span class="title">demoStudent</span> (<span class="title">wrong</span> <span class="title">name</span>: <span class="title">demoStudent</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>\<span class="title">cn</span>&gt;<span class="title">java</span> <span class="title">cn.demoStudent</span></span></span><br><span class="line"><span class="function">错误: 找不到或无法加载主类 <span class="title">cn.demoStudent</span></span></span><br><span class="line"><span class="function">原因: <span class="title">java.lang.ClassNotFoundException</span>: <span class="title">cn.demoStudent</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>\<span class="title">cn</span>&gt;<span class="title">cd</span> ..</span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>&gt;<span class="title">java</span> <span class="title">cn.demoStudent</span></span></span><br><span class="line"><span class="function"><span class="title">student</span>&#x27;<span class="title">s</span> <span class="title">name</span> <span class="title">is</span> <span class="title">null</span></span></span><br><span class="line"><span class="function"><span class="title">student</span>&#x27;<span class="title">s</span> <span class="title">age</span> <span class="title">is</span> 0</span></span><br><span class="line"><span class="function">#在控制台编译运行，使用<span class="title">java</span>命令运行时要加上包名：<span class="title">java</span> 包名.类名</span></span><br></pre></td></tr></table></figure><p>我们重新写一下两个文件，这次弄的复杂点，我们两个文件是在多级包(<code>cn.demo</code>)下的：</p><p><img src="/images/%E5%90%8C%E4%B8%80%E4%B8%AA%E5%8C%85%E4%B8%8B%E7%9A%84%E4%B8%A4%E4%B8%AAjava%E6%96%87%E4%BB%B6.png" alt="同一个包下的两个java文件"></p><p>在控制台中使用<code>tree</code>命令查看目录结构树，可以看到，这两个文件都放在demo文件夹下：</p><p><img src="/images/%E5%8C%85cn.demo%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E6%A0%91.png" alt="包cn.demo的目录结构树"></p><p>在控制台中的正确编译运行命令如下：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>\<span class="title">cn</span>\<span class="title">demo</span>&gt;<span class="title">javac</span> -<span class="title">encoding</span> <span class="title">UTF</span>-8 -<span class="title">classpath</span> <span class="title">E</span>:/<span class="title">Java_practice</span> <span class="title">Student.java</span></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>\<span class="title">cn</span>\<span class="title">demo</span>&gt;<span class="title">javac</span> -<span class="title">encoding</span> <span class="title">UTF</span>-8 -<span class="title">classpath</span> <span class="title">E</span>:/<span class="title">Java_practice</span> <span class="title">demoStudent.java</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>\<span class="title">cn</span>\<span class="title">demo</span>&gt;<span class="title">cd</span> ..</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>\<span class="title">cn</span>&gt;<span class="title">java</span> <span class="title">demo.demoStudent</span></span></span><br><span class="line"><span class="function">错误: 找不到或无法加载主类 <span class="title">demo.demoStudent</span></span></span><br><span class="line"><span class="function">原因: <span class="title">java.lang.NoClassDefFoundError</span>: <span class="title">cn</span>/<span class="title">demo</span>/<span class="title">demoStudent</span> (<span class="title">wrong</span> <span class="title">name</span>: <span class="title">demo</span>/<span class="title">demoStudent</span>)</span></span><br><span class="line"><span class="function">#注意，是要在最顶级包的父文件夹下才能运行</span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>\<span class="title">cn</span>&gt;<span class="title">cd</span> ..</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>&gt;<span class="title">java</span> <span class="title">cn.demo.demoStudent</span></span></span><br><span class="line"><span class="function"><span class="title">student</span>&#x27;<span class="title">s</span> <span class="title">name</span> <span class="title">is</span> <span class="title">null</span></span></span><br><span class="line"><span class="function"><span class="title">student</span>&#x27;<span class="title">s</span> <span class="title">age</span> <span class="title">is</span> 0</span></span><br></pre></td></tr></table></figure><p><strong>main方法的参数<code>args[]</code></strong></p><p>所有的 Java 程序，都由 <strong>public static void main(String[] args)</strong> 方法开始执行，在一般情况下我们不会用到main方法的这个形参，但一定要加上！否则可以通过编译，但在运行时会报错：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误: 在类 mainFunction 中找不到 main 方法, 请将 main 方法定义为:</span><br><span class="line">   public static void main(String[] args)</span><br><span class="line">否则 JavaFX 应用程序类必须扩展javafx.application.Application</span><br></pre></td></tr></table></figure><p>我们下面来尝试下这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainFunction</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;打印main方法中的输入参数：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(String element: args)&#123;</span><br><span class="line">System.out.println(element);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>&gt;<span class="title">java</span> <span class="title">mainFunction</span> <span class="title">gogoing</span>,<span class="title">ukr</span>,<span class="title">xibanya</span>...<span class="title">ufo</span> -<span class="title">sss</span> <span class="title">STK1</span></span></span><br><span class="line"><span class="function">打印<span class="title">main</span>方法中的输入参数：</span></span><br><span class="line"><span class="function"><span class="title">gogoing</span>,<span class="title">ukr</span>,<span class="title">xibanya</span>...<span class="title">ufo</span></span></span><br><span class="line"><span class="function">-<span class="title">sss</span></span></span><br><span class="line"><span class="function"><span class="title">STK1</span></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>&gt;<span class="title">java</span> <span class="title">mainFunction</span> <span class="title">gogo</span>--|<span class="title">ukr</span> &quot;<span class="title">xibanya</span>&quot; &#x27;<span class="title">s</span>&#x27; <span class="title">ufo</span> -<span class="title">sss</span> <span class="title">STK1</span></span></span><br><span class="line"><span class="function">&#x27;<span class="title">ukr</span>&#x27; 不是内部或外部命令，也不是可运行的程序</span></span><br><span class="line"><span class="function">或批处理文件。</span></span><br><span class="line"><span class="function">#注意这里，符号“|”会被<span class="title">windows</span>控制台识别为过滤命令！所以报错</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>&gt;<span class="title">java</span> <span class="title">mainFunction</span> <span class="title">gogo</span>-- <span class="title">ukr</span> &quot;<span class="title">xibanya</span>&quot; &#x27;<span class="title">s</span>&#x27; <span class="title">ufo</span> -<span class="title">sss</span> <span class="title">STK1</span></span></span><br><span class="line"><span class="function">打印<span class="title">main</span>方法中的输入参数：</span></span><br><span class="line"><span class="function"><span class="title">gogo</span>--</span></span><br><span class="line"><span class="function"><span class="title">ukr</span></span></span><br><span class="line"><span class="function">0<span class="title">xibanya</span></span></span><br><span class="line"><span class="function">&#x27;<span class="title">s</span>&#x27;</span></span><br><span class="line"><span class="function"><span class="title">ufo</span></span></span><br><span class="line"><span class="function">-<span class="title">sss</span></span></span><br><span class="line"><span class="function"><span class="title">STK1</span></span></span><br><span class="line"><span class="function">#我们可以看到，输入字符串参数，是按照空格来隔开的，注意双引号的使用，单引号会正常打印</span></span><br></pre></td></tr></table></figure><p><strong>编译并执行程序</strong></p><p><code>javac</code> 可以将<code>java</code>格式源文件编译为class字节码文件，也就是把我们写的<code>java</code>代码编译成计算机能识别的内部代码；<code>java</code>则可以运行该class字节码文件。</p><p>在命令行中输入<code>javac -help</code>可以看到其<a href="https://www.cnblogs.com/wangpei/p/7084341.html">用法</a>：</p><blockquote><p>用法: javac <options> <source files></p><p><code>options</code>命令行选项。<code>sourcefiles</code>一个或多个要编译的源文件（例如 MyClass.java）</p><ul><li>如果源文件数量少，在命令行上列出文件名即可。</li><li>如果源文件数量多，则将源文件名列在一个文件中，名称间用空格或回车行来进行分隔。然后在 javac 命令行中使用该列表文件名，文件名前冠以 @ 字符</li></ul></blockquote><p>其中，**-encoding**，设置源文件编码名称，不设置则默认为操作系统默认的字符编码（windows下为<code>GBK</code>），因此我们常常发现有关编码的报错信息，我们可以使用命令<code>javac -encoding UTF8 myclass.java</code>来成功编译。</p><p><strong>能为空的，是字符串（String）还是字符（Character）</strong>?</p><blockquote><p>Java语言提供了八种基本类型：六种数字类型（四个整数型，两个浮点型），一种字符类型（<strong>char</strong>），还有一种是布尔型。</p><p>和C语言类似，Java中的char 类型是一个<strong>单一</strong>的 16 位 Unicode 字符，最小值是 **<code>\u0000</code>**（十进制等效值为 0），最大值是 **<code>\uffff</code>**（十进制下等效于 65535）；</p></blockquote><p>Character 类用于对单个字符进行操作，在对象中包装一个基本类型 char 的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="comment">// Unicode 字符表示形式</span></span><br><span class="line"><span class="type">char</span> <span class="variable">uniChar</span> <span class="operator">=</span> <span class="string">&#x27;\u039A&#x27;</span></span><br><span class="line"><span class="comment">//Character类提供了一系列方法来操纵字符，我们可以使用Character的构造方法创建一个Character类对象</span></span><br><span class="line"><span class="type">Character</span> <span class="variable">ch_object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Character</span>(<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。有两种方法：使用关键字或者构造方法来创建 String 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;SKT&quot;</span>;</span><br><span class="line">String str2=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;SSW&quot;</span>);</span><br></pre></td></tr></table></figure><p>这两种方法的区别在于：<u>String 创建的字符串存储在公共池中，而 new 创建的字符串对象在堆上</u>。</p><p>关于这一点我们日后再进行深入探究，并和<strong>JavaScript中String()与new String()的区别</strong>做对比。</p><p>我们要注意，<u>单个字符的char类型不能为空，但String对象可以为一个空字符串</u>。我们在程序中依次对下面几行进行注释，然后将<code>java</code>文件编译执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;&quot;</span>);<span class="comment">//输出一行空行</span></span><br><span class="line">System.out.println(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="comment">/*编译时就无法通过，会报错</span></span><br><span class="line"><span class="comment">DEMOCONST.java:5: 错误: 空字符文字</span></span><br><span class="line"><span class="comment">                System.out.println(&#x27;&#x27;);</span></span><br><span class="line"><span class="comment">                                   ^</span></span><br><span class="line"><span class="comment">1 个错误</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">System.out.println(<span class="literal">true</span>);<span class="comment">//输出字符串true</span></span><br><span class="line">System.out.println(<span class="literal">false</span>);<span class="comment">//输出字符串false</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="literal">null</span>); <span class="comment">//null代表空，什么都没有</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">DemoConst.java:8: 错误: 对println的引用不明确</span></span><br><span class="line"><span class="comment">                System.out.println(null);</span></span><br><span class="line"><span class="comment">                          ^</span></span><br><span class="line"><span class="comment">  PrintStream 中的方法 println(char[]) 和 PrintStream 中的方法 println(String) 都匹配</span></span><br><span class="line"><span class="comment">1 个错误</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>for-each循环</strong></p><p><code>JDK</code>1.5 中引进的一种新的循环类型，能在不使用下标的情况下遍历数组，在Python和JavaScript中也有类似语法。注意，数组索引从0开始，不能像Python那样使用负数索引！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">team</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">double</span>[] teamList = &#123;<span class="number">1.2</span>, <span class="number">3.4</span>, <span class="number">9.3</span>, <span class="number">5.5</span>&#125;;</span><br><span class="line">      <span class="comment">// 打印所有数组元素，这里的i只是一个指代其中任一元素的作用</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">double</span> i: teamList) &#123;</span><br><span class="line">         System.out.println(i);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(teamList.length);<span class="comment">//打印数组长度</span></span><br><span class="line">       System.out.println(teamList[<span class="number">99</span>]);<span class="comment">//数组越界，编译不会报错，但运行时会报错</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法重载</strong></p><p>类似于C语言，Java也有方法重载的效果，允许在一个类中,存在多个方法拥有不同的参数（无论是参数的个数还是类型、顺序），而却有相同的名字。比如我们要想用一个函数来实现数字相加和字符串拼接两个功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainFunction</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> sum(<span class="number">100</span>,<span class="number">200</span>);<span class="comment">//注意！！变量的名称可以跟方法的一样，但不推荐这么写！</span></span><br><span class="line"><span class="comment">//不必像c语言中声明方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;sum(100+200) = &quot;</span>+sum);</span><br><span class="line">System.out.println(sum(<span class="string">&quot;ssudi&quot;</span>,<span class="string">&quot;+ jhderhyiu&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a,<span class="type">double</span> b)</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> a+b;<span class="comment">//注意！！要运算的数据类型不一样时，结果为数据范围大的那一个类型！！</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">sum</span><span class="params">(String a,String b)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后，运行结果为：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>&gt;<span class="title">java</span> <span class="title">mainFunction</span></span></span><br><span class="line"><span class="function"><span class="title">sum</span>(100+200) = 300</span></span><br><span class="line"><span class="function"><span class="title">ssudi</span>+ <span class="title">jhderhyiu</span></span></span><br></pre></td></tr></table></figure><p>在其他编程语言中，Python由于可以接受任何类型的参数，对于缺少的参数也可以设置为缺省参数，因此不需要也不支持函数重载。而在JavaScript中，同一个作用域内，两个名称相同的函数，后来居上——后面的函数会覆盖前面的，这是因为<strong>声明提升</strong>——函数声明和变量声明总会被解释器提升到作用域的最顶端去执行。不过，<a href="https://segmentfault.com/a/1190000015602959">我们可以在JavaScript中实现模拟重载的效果</a>。</p><p><strong>局部变量和成员变量</strong></p><p>不同之处：</p><ol><li>定义的位置不同：局部变量定义在方法内部；成员变量直接定义在类当中，在方法外面；</li><li>内存中的位置不一样：局部变量在栈内存中，成员变量在堆内存中；</li><li>生命周期不同：局部变量随着方法的进栈而出现，方法出栈时消失；成员变量当对象被创建时出现，在对象被<code>JVM</code>回收，也就是垃圾回收时消失;</li><li>默认值不同：局部变量没有默认值，必须赋值后才可使用，成员变量声明后自动有一个默认值。</li></ol><h2 id="类方法，static修饰符"><a href="#类方法，static修饰符" class="headerlink" title="类方法，static修饰符"></a>类方法，static修饰符</h2><ul><li><p>变量，可以按照两种方式划分：</p><ol><li><p>按位置来分：成员变量——类中方法外的变量（有默认值），局部变量——类中方法内的变量；</p></li><li><p>按是否使用<code>static</code>关键字声明来分：</p><ul><li><p>类变量(静态变量)：在类中<strong>使用static关键字声明</strong>，但位于方法、构造函数、块之外。无论一个类实例化多少对象，它的静态变量只有一份拷贝。为了加以区分，我们用static声明的局部变量称之为静态局部变量；</p></li><li><p>实例变量：由类生成对象时，才分配存储空间。各对象间的实例变量互不干扰，能通过对象的引用来访问实例变量。但在Java多线程中，实例变量是多个线程共享资源，要注意同步访问时可能出现的问题。</p></li></ul></li><li><p>注意：static修饰的成员（字段和方法）应该使用<strong>类名.成员名</strong>访问，也可以使用对象名.成员名，但是不推荐。</p></li></ol></li><li><p>成员方法：类中的方法，包含：</p><ul><li>静态方法：被static修饰的成员方法，不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据；</li><li>实例方法：没有用关键字static修饰的成员方法。</li></ul></li><li><p>构造方法：类中专门用来创建对象的方法，通过<code>new</code>关键字创建对象时就是在调用构造方法，注意一下两点：</p><ol><li>构造方法<strong>不能写返回值类型！包括void也不能写！</strong></li><li>构造方法的名称必须和所在的类名称完全一致（包括大小写一致）</li></ol></li></ul><p><strong>被static修饰的成员变量和成员方法独立于该类的任何对象</strong>。也就是说，它不依赖类特定的实例，<strong>被类的所有实例共享</strong>。只要这个类被加载，Java虚拟机就能根据类名在运行时数据区或者方法区内找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。 而用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它类的对象时，不生成static变量的副本，而是类的所有实例共享同一个static变量。 这也就意味着我们可以通过类&#x2F;对象来修改静态变量的值，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String name=<span class="string">&quot;cattt&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span>  <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">ct1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        ct1.name=<span class="string">&quot;sss&quot;</span>;<span class="comment">//这一句也可以换成 Cat.name=&quot;sss&quot;;</span></span><br><span class="line">        System.out.println(Cat.name);<span class="comment">//结果为sss</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有加<code>public/private</code>修饰符的变量，默认为<code>public</code>公开类型，可以被外部调用，当然这样不安全，一般采用加<code>private</code>修饰符，配合特定<code>setter/getter</code>方法的使用。</p><p>我们接着来看一下，<code>static</code>修饰符在类中的应用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">String name;String address;<span class="type">int</span> age;</span><br><span class="line"><span class="keyword">static</span> <span class="type">String</span> <span class="variable">country</span> <span class="operator">=</span> <span class="string">&quot;大清&quot;</span>;<span class="comment">//被static修饰的静态变量</span></span><br><span class="line"><span class="comment">//构造方法的名称必须跟类名称相同！</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name,String address)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="built_in">this</span>.address = address;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;北平&quot;</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;南昌&quot;</span>);</span><br><span class="line"><span class="comment">//下面我们对数值分别进行更改</span></span><br><span class="line">p1.country = <span class="string">&quot;民国&quot;</span>;<span class="comment">//不推荐这样使用静态变量</span></span><br><span class="line">p1.address = <span class="string">&quot;北京&quot;</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;p1.country = &quot;</span>+p1.country+<span class="string">&quot;\np1.address = &quot;</span>+p1.address+<span class="string">&quot;\np1.age = &quot;</span>+p1.age);</span><br><span class="line">System.out.println(<span class="string">&quot;p2.country = &quot;</span>+p2.country+<span class="string">&quot;\np2.address = &quot;</span>+p2.address+<span class="string">&quot;\np2.age = &quot;</span>+p2.age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>\<span class="title">cn</span>\<span class="title">demo</span>&gt;<span class="title">java</span> <span class="title">Person</span></span></span><br><span class="line"><span class="function"><span class="title">p1.country</span> = 民国</span></span><br><span class="line"><span class="function"><span class="title">p1.address</span> = 北京</span></span><br><span class="line"><span class="function"><span class="title">p1.age</span> = 0#<span class="title">int</span>类型的成员变量默认值为0</span></span><br><span class="line"><span class="function"><span class="title">p2.country</span> = 民国</span></span><br><span class="line"><span class="function"><span class="title">p2.address</span> = 南昌</span></span><br><span class="line"><span class="function"><span class="title">p2.age</span> = 0</span></span><br></pre></td></tr></table></figure><p>可以看到，我们只更改了对象<code>p1</code>中的country属性，但因为这是个被<code>static</code>修饰的静态变量，因此所有由<code>Person</code>类所构造的对象中，这一项属性都改变了。</p><h3 id="静态变量与实例化"><a href="#静态变量与实例化" class="headerlink" title="静态变量与实例化"></a>静态变量与实例化</h3><p>我们首先写一个程序，这里有静态变量和静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">staticFunction</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//实例变量</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">99</span>;<span class="comment">//静态变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printCountpublic</span><span class="params">()</span>&#123;</span><br><span class="line">count++; </span><br><span class="line">System.out.println(<span class="string">&quot;Now,count = &quot;</span>+count+age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printCountstatic</span><span class="params">()</span>&#123;</span><br><span class="line">count+=<span class="number">10</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;Now,count = &quot;</span>+count);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序将无法编译通过，并报错：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>\<span class="title">cn</span>\<span class="title">demo</span>&gt;<span class="title">javac</span> -<span class="title">encoding</span> <span class="title">UTF</span>-8 <span class="title">staticFunction.java</span></span></span><br><span class="line"><span class="function"><span class="title">staticFunction.java</span>:9: 错误: 无法从静态上下文中引用非静态变量 <span class="title">count</span></span></span><br><span class="line"><span class="function">                <span class="title">count</span>+=10;</span></span><br><span class="line"><span class="function">                ^</span></span><br><span class="line"><span class="function"><span class="title">staticFunction.java</span>:10: 错误: 无法从静态上下文中引用非静态变量 <span class="title">count</span></span></span><br><span class="line"><span class="function">                <span class="title">System.out.println</span>(&quot;<span class="title">Now</span>,<span class="title">count</span> = &quot;+<span class="title">count</span>);</span></span><br><span class="line"><span class="function">                                                  ^</span></span><br><span class="line"><span class="function">2 个错误</span></span><br></pre></td></tr></table></figure><p>报错原因是：静态方法只能访问静态变量；如果<strong>要让静态方法访问动态变量</strong>，<strong>必须将动态变量实例化</strong>。</p><p><strong>继承与静态</strong></p><p>我们创建一个父类<code>LiYua</code>和一个继承它的子类<code>LiShiMing</code>，并在父类中定义了静态变量，静态方法与实例变量，实例方法。可以看到，IDEA软件会智能提示能否使用该类&#x2F;对象的属性&#x2F;方法（在我们输入的时候可以看到在其智能提示输入中是否存在该项），时刻牢记，<code>static</code>修饰的静态变量&#x2F;方法，只存在一份拷贝，可以被类&#x2F;对象调用，我们可以通过子类使用它们，但这不是继承！<em>原因</em>：继承是对于实体而言的，而静态的东西不属于实体，也可以说，静态与类是一个级别。</p><p>但是实例变量只能在创建对象（也就是实例化）之后通过该对象进行调用：</p><p><img src="/images/%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%99%E6%80%81.PNG" alt="继承与静态"></p><p><strong>多态，向上&#x2F;下转型</strong></p><p>在学会继承之后，我们可以定义一个父类<code>Animal</code>，在其中定义一个实例方法<code>eat</code>，这样，无论我们定义多少个该父类下的子类（比如猫狗鸡鸭鹅），都有一个继承来的<code>eat</code>方法，就不必在这些子类的Java代码中编写了。那么，问题来了，如果我们要编写一个<code>feed</code>方法来代表喂养动物，由于这些动物的子类是不同的，意味着作为传入到<code>feed</code>函数中的参数也是不同的类，那我们岂不是要在代码中重载（<strong>在一个类中的叫重载，子类对父类方法的叫重写</strong>）很多个<code>feed</code>方法？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Cat cat01)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Dog dg01)</span>&#123;&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>事实上我们不用这么干，只需要利用多态的向上转型：类的对象赋给了父类的引用，这样的缺点是屏蔽掉子类中特有的方法，然后我们只定义参数为父类<code>Animal</code>型对象的一个<code>feed</code>函数即可，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">ani1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"><span class="type">Animal</span> <span class="variable">ani2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Animal ani)</span>&#123;ani.eat();&#125;</span><br></pre></td></tr></table></figure><p>但是，这样子，对象<code>ani2</code>这只狗只是被当作动物看待，无法使用<code>Dog</code>子类中的一个特有方法<code>guard</code>，为了解决这一点，我们可以使用向下转型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span>  <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Animal</span> <span class="variable">ani1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">    <span class="comment">//向上转型——子类的对象赋给了父类的引用，猫狗当做动物来看，会屏蔽掉类中特有的方法</span></span><br><span class="line">    <span class="type">Animal</span> <span class="variable">ani2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">ani0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">pr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="comment">//ani0.feed(ani1);这一个就报错了，原因在于ani0已经向上转型成父类型Animal，没有了feed函数</span></span><br><span class="line">        pr.feed(ani1);</span><br><span class="line">        <span class="comment">//pr.feed(ani2);这一处的错误在于ani2没有被我们定义成静态变量而是实例化变量</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">ani3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">//ani3.guard();    输入ani3后，在IDEA给的输入提示里面选择guard，会自动将ani3.guard修改为((Dog) ani3).guard();</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dg</span> <span class="operator">=</span> (Dog) ani3;<span class="comment">//向下转型</span></span><br><span class="line">        dg.guard();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Animal ani)</span>&#123;</span><br><span class="line">        ani.eat();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Cat ct)</span>&#123;ct.eat();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java中由于继承和向上转型的存在，子类型可以非常自然地转成父类，但向下转型，即父类转子类，必须强制转型。Java中的基本数据转型也是强制转型。</p><p>注意，如果子类重写了父类的方法，子类对象<strong>向上转型</strong>之后，调用的还是<strong>重载之后的子类方法</strong>。</p><p><strong>一个子类，只能继承一个父类，但可以实现多个接口</strong></p><p>接口这一块主要是架构师来负责的内容。我们定义两个接口<code>Valuable</code>和<code>Protectable</code>，由类<code>Panda</code>来继承父类<code>Animal</code>，并实现这两个接口，如上面所说的，执行的是子类<code>Panda</code>对象的<code>eat</code>方法，重写后将父类的覆盖了：</p><p><img src="/images/%E7%BB%A7%E6%89%BF%E4%B8%80%E4%B8%AA%E7%88%B6%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3.PNG" alt="继承一个父类实现多个接口"></p><p><strong>instanceof关键字与父子类</strong></p><p>根据相关定义：</p><blockquote><p>instanceof 是 Java 的一个二元操作符，类似于 &#x3D;&#x3D;，&gt;，&lt; 等操作符。作用是测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型。</p></blockquote><p>我们用下面一个例子来说明，<code>Panda</code>是继承自<code>Animal</code>的子类，可以看到，<strong>子类对象既是子类的实例，又是父类的实例</strong>，但反过来就不是了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Panda</span> <span class="variable">panda</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Panda</span>();</span><br><span class="line">System.out.println(panda <span class="keyword">instanceof</span> Panda);<span class="comment">//true</span></span><br><span class="line">System.out.println(panda <span class="keyword">instanceof</span> Animal);<span class="comment">//true</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> (Animal)panda;</span><br><span class="line">System.out.println(animal <span class="keyword">instanceof</span> Panda);<span class="comment">//true</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">yuan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line"><span class="comment">//Panda panda1 = (Panda)yuan; 这种做法是不被允许的！</span></span><br><span class="line">System.out.println(yuan <span class="keyword">instanceof</span> Panda);<span class="comment">//false</span></span><br><span class="line"><span class="type">Panda</span> <span class="variable">panda2</span> <span class="operator">=</span> (Panda)animal;</span><br><span class="line">System.out.println(panda2 <span class="keyword">instanceof</span> Panda);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>被注释掉的那行代码<code>Panda panda1 = (Panda)yuan</code>会报错，是因为这并不是向下转型——Java中，只有是<u>由子类对象向上转型转成的</u>父类对象，才能向下转型又再次成为子类对象！！</p><h3 id="静态构造器"><a href="#静态构造器" class="headerlink" title="静态构造器"></a>静态构造器</h3><p>又称静态构造函数，是实现对一个类进行初始化的方法成员，一般用于对静态数据的初始化（<strong>静态变量也是最先初始化的</strong>）。静态构造函数不能有参数，不能有修饰符，不能被调用。当类被加载时，类的静态构造函数自动被调用。因此，在一个程序的执行过程中，静态构造器<strong>最多执行一次</strong>。注意执行顺序：</p><ol><li><p>静态构造器在任何类的静态成员被引用之前执行；</p></li><li><p>静态构造器在任何类的实例变量被分配之前执行；</p></li><li><p>静态构造器在类的静态成员初始化之后执行，或者说编译器会将静态成员初始化语句转换成赋值语句放在静态构造器执行的最开始。</p></li></ol><p>我们用下面这个例子来实践一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">staticTest</span>&#123;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;这里是通用构造器&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;静态构造器&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">staticTest</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;构造方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="comment">//在主方法中调用构造方法，创建一个对象，就不用再写一个java程序来验证了</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">staticTest</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，可以看到，静态构造器是最先被执行的。</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>\<span class="title">cn</span>\<span class="title">demo</span>&gt;<span class="title">java</span> <span class="title">staticTest</span></span></span><br><span class="line"><span class="function">静态构造器</span></span><br><span class="line"><span class="function">这里是通用构造器</span></span><br><span class="line"><span class="function">构造方法</span></span><br></pre></td></tr></table></figure><p>在有继承的情况下，执行顺序为：<strong>父类静态代码块 &gt; 子类静态代码块 &gt; 父类构造代码块 &gt; 父类构造器 &gt; 子类构造代码块 &gt; 子类构造器</strong></p><p><strong>Java语言中，标准类（pojo类）</strong></p><p><code>POJO</code>的全称为<code>plain old java object</code>，可以翻译成：普通Java类。主要用于数据的临时传递，但它只能装载数据， 作为数据存储的载体，而不具有业务逻辑处理的能力，也就是说，<u><code>POJO</code>类中不允许有业务方法，也不能携带connection之类的方法</u>。</p><p>**<a name="标准类的四个必要条件">标准类的四个<u>必要</u>组成部分</a>**（四个必要条件）</p><ol><li>所有的成员<strong>变量</strong>都要使用 private 关键字进行修饰；</li><li>为每一个成员变量编写 set、get 方法；</li><li>创建一个无参数的构造方法；</li><li>创建一个有参数的构造方法。</li></ol><p><strong>pojo类和java bean的关系</strong></p><p><a href="https://blog.csdn.net/tiantangdizhibuxiang/article/details/81784873">博客</a></p><blockquote><p>按着Sun公司的定义，Java Bean是一个可重复使用的软件组件。实际上Java Bean是一种<a href="https://so.csdn.net/so/search?q=Java&spm=1001.2101.3001.7020">Java</a>类，通过封装属性和方法成为具有某种功能或者处理某个业务的对象，简称bean。</p><p><code>JavaBean</code> 是一种JAVA语言写成的可重用组件，不是一种技术，而是一种规范，它的方法命名，构造及行为必须符合特定的约定：</p><ol><li>这个类必须有一个公共的缺省构造函数；</li><li>这个类的属性使用getter和setter来访问，其他方法遵从标准命名规范;</li><li>这个类应是可<strong>序列化</strong>的（一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象——详见<a href="https://www.runoob.com/java/java-serialization.html">类的序列化</a>）。</li></ol><p><code>Java Bean</code>的任务可以概括为: “Write once, run anywhere, reuse everywhere”，即“一次性编写，任何地方执行，任何地方重用”。可分为两种：</p><ol><li>是有用户界面（UI，User Interface）的Java Bean；</li><li>没有用户界面，主要负责处理事务（如数据运算，操纵数据库）的Java Bean（部署于网络服务器上的<code>JSP</code>，又称<code>JavaServer Pages</code>，通常访问的是这一种Java Bean）。</li></ol><p>简而言之，当一个<code>PoJo</code>可序列化，有一个无参的构造函数，使用getter和setter方法来访问属性时，他就是一个Java Bean。</p></blockquote><p>然而，通常情况下，由于 Java Bean 是被容器所创建（如 Tomcat) 的，<strong>所以 Java Bean 应具有一个无参的构造器</strong>，另外，通常 <strong>Java Bean 还要实现 <code>Serializable</code> 接口用于实现 Bean 的持久性</strong>。 Java Bean 是不能被跨进程访问的。一般在web应用程序中建立一个数据库的映射对象时，我们只能称它为<code>POJO</code>——一个普通Java对象，而不是一个特殊的对象，其主要用来指代那些没有遵从特定的Java对象模型、约定或框架（如<code>EJB</code>）的Java对象。理想地讲，一个<code>POJO</code>是一个不受任何限制的Java对象（除了Java语言规范）</p><p>Java中还有很多特定类（<code>entity</code>、 <code>VO</code> 、<code>DTO</code>等）的概念和作用，我们详见好心人整理的<a href="https://www.pianshen.com/article/5933825452/">专栏</a>和<a href="https://www.cnblogs.com/feily/articles/14225139.html">博客</a>。</p><p><img src="/images/java%E5%90%84%E7%A7%8D%E7%B1%BB%E5%9C%A8%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8.png" alt="java各种类在实际项目中的运用"></p><p>我们再顺便了解另一个概念：<strong>entity(实体类)</strong></p><p>通常定义在model层里面，一个实体映射一张表，其中的<strong>属性</strong>对应数据表中的<strong>字段</strong>，，一般无业务逻辑代码。</p><p>entity类也要满足<a href="#标准类的四个必要条件">普通JavaBeans类的四个必要条件</a>，这篇<a href="https://blog.csdn.net/u012393192/article/details/80808237">博客</a>还介绍了entity的其他优点：</p><ol><li>对象实体的封装，体现<strong>OO(Object Oriented面向对象)思想</strong>——Java是面向对象的语言，由于面向对象有<strong>封装、继承、多态</strong>性的特性，可以设计出低耦合的系统，并使系统更加灵活和易于维护，缺点是性能比面向过程的低；</li><li>entity类中的属性可以对字段定义和状态进行判断和过滤；</li><li>一个数据库表映射成一个实体类，对数据库操作起来方便（在程序中可以把实体类作为参数传递），使程序员程序员在对数据库操作的时候不用写<code>SQL</code>语句,专注逻辑关系。换句话说，实体类就是把对某一个数据表（table）的操作全写在一个类里面：创建一个Entity Bean对象相当于创建一条记录，删除一个Entity Bean对象会同时从数据库中删除对应记录，修改一个Entity Bean时，容器会自动将Entity Bean的状态和数据库同步。</li></ol><p>另外，在Java开发中对于定义entity类的总结经验如下：</p><ul><li><p>实体类的名字尽量和数据库的表的名字对应相同；</p></li><li><p>实体类应该实现<code>java.io.Serializable</code>接口；</p></li><li><p>实体类应该有个无参的构造方法；</p></li><li><p>实体类应该至少有一个有参数的构造方法；</p></li><li><p>实体类有属性和方法，属性对应数据库中表的字段，主要有getter和setter方法。</p></li><li><p>实体类还应该有个属性<code>serialVersionUID</code>。例如：<code>private static final long serialVersionUID = -6125297654796395674L;</code></p></li><li><p>在实体类中，<strong>属性</strong>一般是<strong>private</strong>类型，而<strong>方法</strong>为<strong>public</strong>类型，对于数据库自动生成的ID字段对应的属性的<strong>set方法应为private</strong>。</p></li></ul><h2 id="引用和引用数据类型"><a href="#引用和引用数据类型" class="headerlink" title="引用和引用数据类型"></a>引用和引用数据类型</h2><p>Java中的数据类型可以分为两类，基本数据类型（只有八种），其他的都是**引用数据类型：类(class)、 接口类型(interface)、 数组类型(array)、 枚举类型(enum)、 注解类型(annotation)、 字符串型(string)**（这些都在<code>java.lang.*</code>下），如果我们不定义的话，这些都默认为强引用<br><a href="https://www.cnblogs.com/maskwolf/p/9972982.html">基本数据类型和引用数据类型区别</a>：</p><blockquote><ol><li><p>存储位置：</p><ul><li>基本变量类型：在方法中定义的非全局基本数据类型变量的具体内容是存储在栈中的</li><li>引用变量类型：具体内容都是存放在堆中的，而栈中存放的是其具体内容所在内存的地址（通过变量地址可以找到变量的具体内容，就如同通过房间号可以找到房间一般）</li></ul></li><li><p>传递方式：</p><ul><li>基本类型变量：在方法中定义的非全局基本数据类型变量，调用方法时作为参数是按数值传递的</li><li>引用类型变量：调用方法时作为参数是按引用传递的，传递的是引用的副本</li></ul></li></ol></blockquote><p><strong>包装类</strong></p><p>包装类：将基本数据类型封装成一个类，包含的方法基本相同。java中的包装类提供了将原始数据类型转换为对象，以及将对象转换为原始数据类型的机制。包装类属于<strong>引用数据类型</strong>， 其中6个包装类（Double、Float、Byte、Short、Integer 以及 Long）都是 Number 这一个<strong>抽象类</strong>（因此其不能直接实例化，而是必须实例化其具体的子类）的子类。<code>java.lang.Number</code>的父类是Object类。</p><p>Object 类存储在**java.lang.<em><strong>包中，是所有java类 (Object 类除外)的终极</strong>父类</em><em>。Java中规定：如果一个类没有显式声明它的父类，那么默认这个类的父类就是java.lang.Object 。注意，</em>子类是抽象类，父类也不一定是抽象类*（比如Object 是具体类，却是Number的父类，只要子类添加了自己的抽象方法，子类就必须是抽象类而无论其父类是不是。不过父类是具体类，而其唯一的子类是抽象类的情况没有使用的必要）</p><p>原始类型不能为<code>null</code>，但包装类可以为<code>null</code>，因此包装类可用于实现多态性。</p><table><thead><tr><th>基本数据类型</th><th>包装类型</th><th>该包装类的父类</th></tr></thead><tbody><tr><td>byte</td><td>java.lang.Byte</td><td>java.lang.Number</td></tr><tr><td>short</td><td>java.lang.Short</td><td>java.lang.Number</td></tr><tr><td>int</td><td>java.lang.Integer</td><td>java.lang.Number</td></tr><tr><td>long</td><td>java.lang.Long</td><td>java.lang.Number</td></tr><tr><td>float</td><td>java.lang.Float</td><td>java.lang.Number</td></tr><tr><td>double</td><td>java.lang.Double</td><td>java.lang.Number</td></tr><tr><td>boolean</td><td>java.lang.Boolean</td><td>java.lang.Object</td></tr><tr><td>char</td><td>java.lang.Character</td><td>java.lang.Object</td></tr></tbody></table><p>包装类的构造方法：</p><ol><li><p><code>Integer(int number);</code>传入一个int值.获取一个Integer类.来操作；</p></li><li><p><code>Integer(String str);</code> 传入一个字符串.用字符串来获取Integer对象<br>我们要注意两个名词：<a href="https://blog.csdn.net/xxyneymar/article/details/120223189">装箱和拆箱</a></p><blockquote><p><em>装箱</em>：基本数据类型–(转换为)–&gt;引用数据类型<br><em>拆箱</em>：引用数据类型–(转化为)–&gt;基本数据类型<br>在JDK1.5之后，支持<em>自动装箱和自动拆箱机制</em>了。<br>自动装箱：基本数据类型自动转换成包装类。<br>自动拆箱：包装类自动转换成基本数据类型。<br><img src="https://img-blog.csdnimg.cn/2021091016343182.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeHh5bmV5bWFy,size_20,color_FFFFFF,t_70,g_se,x_16" alt="转换"></p></blockquote></li></ol><p><strong>Java集合类</strong></p><p>Java集合类存放于 java.util 包中（需要收到<code>import</code>引入），是一个用来存放对象的容器。</p><p>注意：①、集合<strong>只能存放对象</strong>。比如你存一个 int 型数据 1放入集合中，其实它是<em>自动转换成 Integer 类</em>后存入的，Java中每一种基本类型都有对应的引用类型。</p><p>　　　②、集合存放的是多个对象的引用，对象本身还是放在堆内存中。</p><p>　　　③、集合可以存放不同类型，不限数量的数据类型。</p><p>定义集合的示例：<code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</code></p><p>Java中有四种引用——引用强度和生命周期长度依次为：强引用&gt;软引用＞弱引用＞虚引用。（JDK1.2之后的引用概念扩充）</p><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>默认声明的就是强引用，比如<code>Object obj = new Object()</code>，只要obj还指向Object对象（也就是强引用还存在），Object对象就不会被垃圾回收器回收。即使内存不足时，<code>JVM</code>也会直接抛出<code>OutOfMemoryError</code>而不会去回收。若想中断强引用与对象之间的联系，可以将强引用赋值为null。另外的，字符串<code>String str = new String();</code>也是强引用类型，不过使用时是默认导入了<code>java.lang.String</code>包（<code>java.lang.*</code>不用我们导入，编译器会自动导入）</p><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>描述一些非必需但仍有用的对象。<strong>在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常</strong>。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。在 JDK1.2 之后，用java.lang.ref.SoftReference类来表示软引用。</p><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了<strong>只具有弱引用</strong>的对象，不管当前内存空间足够与否，都会回收它的内存——也就是说，<strong>无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收</strong>。在 JDK1.2 之后，用 java.lang.ref.WeakReference 来表示弱引用。</p><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>又称为“幽灵引用”或“幻影引用”，最弱的一种引用关系，其存在与否，不会对对象的生存产生任何影响，且也无法通过虚引用来获得对象实例。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收。创建虚引用需要使用java.lang.ref.PhantomReference。这个类的源码中只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象。与软引用、弱引用不同的是，虚引用必须要和 ReferenceQueue 引用队列一起使用。</p><h3 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h3><p>引用队列可以与软引用、弱引用以及虚引用一起配合使用（强引用自然不行），当垃圾回收器准备回收一个对象时，如果发现它还有引用，那么就会在回收对象之前，把这个引用加入到与之关联的引用队列中去。程序可以通过判断引用队列中是否已经加入了引用，来判断被引用的对象是否将要被垃圾回收，这样就可以在对象被回收之前采取一些必要的措施。牢记：虚引用必须和引用队列一起使用。</p><h2 id="类与导包import"><a href="#类与导包import" class="headerlink" title="类与导包import"></a>类与导包import</h2><p>所有的类都需要导包才能使用，除了两种情况：</p><ol><li>要使用的目标类，和当前类位于同一个包（package）下；</li><li>要使用的目标类，位于<code>java.lang</code>包下，但是不包含子包内容（比如路径<code>C:\Program Files\Java\jdk-11.0.2\lib\src\java.base\java\lang\reflect</code>下的Field.java这一个类，就需要引用）</li></ol><p>我们使用的字符串对象，是String类，其实就属于第二种情况，在博主使用的JDK11版本中，我们可以在路径<code>C:\Program Files\Java\jdk-11.0.2\lib\src\java.base\java\lang</code>看到文件<code>String.java</code>。</p><p>字符串是对象，却可以原封不动打印出来，是因为<code>println</code>方法的判断逻辑：</p><ol><li>若是字符串类型，直接显示内容；</li><li>若不是字符串类型，就将其内部通过某些方法转换成字符串再显示（参考定义println方法的源码可知，比如int基本数据类型的会被String.valueOf方法转换为字符串类型）；</li><li>最终打印出来的一定是字符串类型。</li></ol><p>比方说，我们引入一个使用自定Employee类的程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo_println</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">Employee</span> <span class="variable">adc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;adcssss&quot;</span>);</span><br><span class="line">System.out.println(adc);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台中的打印结果：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>&gt;<span class="title">java</span> <span class="title">Demo_println</span></span></span><br><span class="line"><span class="function"><span class="title">Employee</span>@512<span class="title">ddf17</span></span></span><br><span class="line"><span class="function">#一般的对象都是使用“类型信息+@+地址值”来作为字符串内容</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java基础语法学习要注意的小细节&quot;&gt;&lt;a href=&quot;#Java基础语法学习要注意的小细节&quot; class=&quot;headerlink&quot; title=&quot;Java基础语法学习要注意的小细节&quot;&gt;&lt;/a&gt;Java基础语法学习要注意的小细节&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;最最</summary>
      
    
    
    
    <category term="Java" scheme="http://justskim.github.io/categories/Java/"/>
    
    
    <category term="java" scheme="http://justskim.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>tomcat下startup.bat启动报错详解</title>
    <link href="http://justskim.github.io/2022/03/01/tomcat%E4%B8%8Bstartup.bat%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99%E8%AF%A6%E8%A7%A3/"/>
    <id>http://justskim.github.io/2022/03/01/tomcat%E4%B8%8Bstartup.bat%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-03-01T03:10:04.038Z</published>
    <updated>2022-03-01T08:37:17.479Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tomcat下startup-bat启动报错详解"><a href="#tomcat下startup-bat启动报错详解" class="headerlink" title="tomcat下startup.bat启动报错详解"></a>tomcat下startup.bat启动报错详解</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>博主在tomcat服务器的安装启动时，遇到问题：在官网下载的tomcat10压缩包版本，解压后可以在bin文件夹中双击tomcat10.exe并成功运行，但是双击startup.bat会闪退。而在网上找到的博客所遇到的问题都跟博主的相反，都是tomcat.exe不能运行。在控制台运行该程序，会得到信息如下：</p><p><img src="/images/startup.bat%E9%97%AA%E9%80%80.PNG" alt="startup.bat闪退.PNG"></p><p>博主也检测了主机安装<code>java</code>的配置以及环境变量，<strong>使用命令<code>netstat -ano|findstr 8080</code>也没有发现占用端口的程序</strong>，在控制台中使用命令<code>java -version</code>打印结果也正常，因此查询tomcat相关资料，探究该问题。</p><h2 id="startup与catalina"><a href="#startup与catalina" class="headerlink" title="startup与catalina"></a>startup与catalina</h2><p>我们在tomcat安装目录的bin目录下，可以看到有四个文件：startup.bat，startup.sh，catalina.bat，catalina.sh。</p><p>这其中，sh格式的文件是linux系统下的脚本文件，在Windows系统下无需理会。我们只看另外两个bat文件就行——bat是<strong>dos下的批处理文件</strong>。我们要启动tomcat除了双击startup.bat和tomcat.exe，还有一种方式就是在该目录下的命令行中输入<code>catalina.bat run</code>或者<code>catalina run</code>。startup.bat在执行时也会在最后调用catalina.bat，并且传递了start参数，设置了CATALINA_HOME和CURRENT_DIR俩个临时环境变量，当然我们也可以在系统中自行添加这两个变量。这两个文件的另一个区别在于：startup是在新界面运行，而<code>catalina run</code>命令会使相关程序在当前界面运行，会有更多的报错信息：</p><p><img src="/images/catalina.bat%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF.png" alt="catalina.bat报错信息"></p><h2 id="原因查询"><a href="#原因查询" class="headerlink" title="原因查询"></a>原因查询</h2><p>原因可能是JDK版本过高（博主所用的JDK17）所导致的，AVA11以后大大简化了JAVA环境配置方式，也没有jre文件夹，不过我们可以在jdk目录下使用命令<code>bin\jlink.exe --module-path jmods --add-modules java.desktop --output jre</code>来自动生成。<code>JAVA_HOME/lib</code>目录下没有tool.jar, dt.jar这两个文件，因此我们需要在配置环境变量的时候，要写成:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH  ;%JAVA_HOME%\bin\;%JAVA_HOME%\jre\bin\; CLASSPATH=.;%JAVA_HOME%\lib;%JAVA_HOME%\jre\lib;</span><br></pre></td></tr></table></figure><p>即使如此，博主还是依然无法通过startup.bat或者catalina.bat来启动tomcat，依旧只能选择tomcat.exe的启动方式┓( ´∀&#96; )┏</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;tomcat下startup-bat启动报错详解&quot;&gt;&lt;a href=&quot;#tomcat下startup-bat启动报错详解&quot; class=&quot;headerlink&quot; title=&quot;tomcat下startup.bat启动报错详解&quot;&gt;&lt;/a&gt;tomcat下startup</summary>
      
    
    
    
    <category term="服务器" scheme="http://justskim.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="tomcat" scheme="http://justskim.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/tomcat/"/>
    
    
    <category term="服务器" scheme="http://justskim.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="java" scheme="http://justskim.github.io/tags/java/"/>
    
    <category term="tomcat" scheme="http://justskim.github.io/tags/tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Linux服务器上的nginx与apache</title>
    <link href="http://justskim.github.io/2022/02/26/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84nginx%E4%B8%8Eapache/"/>
    <id>http://justskim.github.io/2022/02/26/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84nginx%E4%B8%8Eapache/</id>
    <published>2022-02-26T11:00:54.169Z</published>
    <updated>2022-02-26T17:45:10.530Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux服务器上的nginx与apache"><a href="#Linux服务器上的nginx与apache" class="headerlink" title="Linux服务器上的nginx与apache"></a>Linux服务器上的nginx与apache</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>博主在进行<a href="https://www.byhy.net/tut/webdev/django/07/">django框架的web项目练习</a>时，参考<a href="https://www.byhy.net/tut/webdev/django/16/#%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4-nginx">相关教程</a>进行<code>django</code>项目在Linux云服务器上的部署。<code>nginx</code>无法启动服务，需要修改路径<code>/etc/nginx/nginx.conf</code>（使用命令<code>yum -y install nginx</code>默认安装）下的<code>nginx.conf</code>文件。而在浏览器上的web端阿里云控制台上，使用<code>linux</code>系统自带的<code>vim</code>编辑器，不像在桌面系统上编辑那么容易。因此打算使用第三方工具（如<code>win-scp</code>，<code>Xshell</code>），在本地编辑文件后直接拖拽进去替代。但是在这些终端模拟器上无法与阿里云服务器建立ssh连接，但却可以ping通云服务器的公网<code>ip</code>地址，如下图所示。因此博主决定深入探究，并解决该问题。</p><p><img src="/images/ssh%E8%BF%9E%E6%8E%A5%E6%8A%A5%E9%94%99.PNG" alt="ssh连接报错"></p><h2 id="没有公网ip地址-x3D-端口被屏蔽？"><a href="#没有公网ip地址-x3D-端口被屏蔽？" class="headerlink" title="没有公网ip地址&#x3D;端口被屏蔽？"></a>没有公网<code>ip</code>地址&#x3D;端口被屏蔽？</h2><p>博主遇到的这一个离谱的问题，当阿里云的服务器设置了白名单以及安全组等配置后，无法在家庭网络的三台主机中使用ssh命令或者第三方工具通过22端口进行连接。而在阿里云网页端的官方控制台可以远程连接。异地协助的朋友也可以在他的主机上直接使用<code>ssh</code>命令或者<code>Xshell</code>等第三方工具。</p><h3 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h3><ol><li><p>首先是一如既往地检查阿里云服务器的安全组设置，请求客服协助，均没有问题；</p></li><li><p>在<code>win10</code>系统的主机上打开防火墙高级设置，设置22端口的出站规则；</p></li><li><p>使用命令<code>netstat -ano|findstr 22</code>查看端口，22端口和80、443等端口均没有发生占用情况；</p></li><li><p>使用手机开启移动4G热点，主机连接该热点后竟然能够成功ssh连接阿里云远程服务器！</p></li></ol><h3 id="真正的问题所在"><a href="#真正的问题所在" class="headerlink" title="真正的问题所在"></a>真正的问题所在</h3><p>经过问题排查的过程后，博主将目标锁定在运营商的端口规则上。</p><p><code>ISP</code>的全称是<code>Internet Service Provider</code>，翻译为互联网服务提供商，即向广大用户综合提供互联网接入业务、信息业务、和增值业务的电信<strong>运营商</strong>。</p><p>为了了解我们的运营商屏蔽了哪些端口，我们使用<a href="https://www.sojson.com/zz/portscan.html">站长工具中的端口扫描工具</a>，或者<a href="https://gist.github.com/vfreex/32b7de2e36422dbee94454afc762305e">相关脚本</a>来扫描看看哪些端口可以代为使用。对博主主机扫描的结果是所有端口都被屏蔽，无法使用。。。</p><p>根据网络相关文章，这可能跟博主所用的主机并没有公网ip地址有关，以及运营商的屏蔽规则，导致正常无法使用端口。</p><p>最后，给你们介绍一下，博主家里使用的是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">宽带类型：广电</span><br><span class="line">宽带业务：高清电视(IPTV)业务</span><br><span class="line">接入方式：光纤接入(FTTH)</span><br></pre></td></tr></table></figure><h2 id="80端口与Nginx与Apache"><a href="#80端口与Nginx与Apache" class="headerlink" title="80端口与Nginx与Apache"></a>80端口与Nginx与Apache</h2><p>Apache和Nginx都属于Web服务器（也称为WWW(WORLD WIDE WEB)服务器，主要功能是提供网上信息浏览服务），都实现了HTTP 1.1协议。我们在具体工程项目中选择哪个，都是根据应用场景来决定的，关于这两个服务器的更多异同我们将在之后进行学习探讨。</p><p>80端口是为HTTP超文本传输协议开放的端口卡相关的限制。<code>Apache</code>与<code>nginx</code>都会使用到该端口。比如博主在启动<code>nginx</code>时遇到的一个报错：“<strong>Address already in use</strong>…”，就说明该端口已经被其他程序所占用（大多数情况下是Apache，可能是很多软件不注意间被我们设置开机自动启动了）因此，要么将其中一个的端口进行修改，要么至启动一个（正常生产环境下的操作，无需两个都使用，功能有重复的地方）</p><p>我们使用<code>systemctl  stop httpd</code>来结束apache服务，使用<code>systemctl start nginx</code>来启动<code>nginx</code>服务，反之亦然。</p><p>解决了<code>nginx</code>启动报错的问题后，我们得以部署成功，在浏览器上输入相关<code>ip</code>地址路由，可以成功访问到页面！</p><p><img src="/images/%E6%88%90%E5%8A%9F%E7%99%BB%E5%BD%95%E4%B8%8A%E8%87%AA%E5%B7%B1%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%A1%B9%E7%9B%AE.PNG" alt="成功登录上自己服务器的项目"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux服务器上的nginx与apache&quot;&gt;&lt;a href=&quot;#Linux服务器上的nginx与apache&quot; class=&quot;headerlink&quot; title=&quot;Linux服务器上的nginx与apache&quot;&gt;&lt;/a&gt;Linux服务器上的nginx与apac</summary>
      
    
    
    
    <category term="网络" scheme="http://justskim.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="http://justskim.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="nginx" scheme="http://justskim.github.io/tags/nginx/"/>
    
    <category term="apache" scheme="http://justskim.github.io/tags/apache/"/>
    
  </entry>
  
  <entry>
    <title>localhost与127.0.0.1与0.0.0.0以及端口</title>
    <link href="http://justskim.github.io/2022/02/22/localhost%E4%B8%8E127.0.0.1%E4%B8%8E0.0.0.0%E4%BB%A5%E5%8F%8A%E7%AB%AF%E5%8F%A3/"/>
    <id>http://justskim.github.io/2022/02/22/localhost%E4%B8%8E127.0.0.1%E4%B8%8E0.0.0.0%E4%BB%A5%E5%8F%8A%E7%AB%AF%E5%8F%A3/</id>
    <published>2022-02-21T17:43:42.599Z</published>
    <updated>2022-02-22T02:48:52.071Z</updated>
    
    <content type="html"><![CDATA[<h1 id="localhost与127-0-0-1与0-0-0-0以及端口"><a href="#localhost与127-0-0-1与0-0-0-0以及端口" class="headerlink" title="localhost与127.0.0.1与0.0.0.0以及端口"></a>localhost与127.0.0.1与0.0.0.0以及端口</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>博主在进行<a href="https://www.byhy.net/tut/webdev/django/07/">django框架的web项目练习</a>时，遇到的一个问题。当博主按照所需的操作编写代码后，在网页链接栏输入<code>http://localhost/mgr/index.html</code>或者<code>http://localhost/mgr/index.html#/</code>时，都会显示404的错误提示界面，如下所示：</p><p><img src="E:\JS练习\blog\Myblog\source\images\localhost下的404界面.PNG" alt="localhost下的404界面"></p><p>而只有在输入链接为<code>127.0.0.1:4000/mgr/index.html#/</code>时，才会出现正常界面：</p><p><img src="E:\JS练习\blog\Myblog\source\images\127.0.0.1下的正常显示界面.PNG" alt="127.0.0.1下的正常显示界面.PNG"></p><p>与教程中唯一不同的步骤在于，博主的django应用，是使用命令<code>python manage.py runserver 4000</code>运行在4000端口上而不是80端口上。原因在于80端口被其他应用所占用。</p><h2 id="如何查看端口是否被占用"><a href="#如何查看端口是否被占用" class="headerlink" title="如何查看端口是否被占用"></a>如何查看端口是否被占用</h2><p>在win 10 系统上，打开控制台，输入命令<code>netstat -ano</code>可以查看所有端口的占用情况。若要查看某一个端口的占用情况，则使用诸如<code>netstat -ano|findstr &quot;80&quot;</code>的命令形式，注意要加双引号。查到占用该端口的进程的PID后，可以使用<code>tasklist|find &quot;123&quot;</code>命令查看进程，这里的123是进程PID。或者打开任务管理器，在“详细信息”一栏查看</p><h2 id="80端口"><a href="#80端口" class="headerlink" title="80端口"></a>80端口</h2><p>80端口是为HTTP超文本传输协议开放的端口，主要用于WWW万维网进行传输信息。其中的具体情况如下：</p><p>80端口作为http协议的默认端口，在输入网站的时候其实浏览器（非IE）已经帮忙输入协议了。所以这样一来，如果输入<a href="http://baidu.com,其实就等于访问http//baidu.com:80%E3%80%82%E5%9B%A0%E6%AD%A4%E6%88%91%E4%BB%AC%E8%AE%BF%E9%97%AElocalhost%EF%BC%8C%E9%BB%98%E8%AE%A4%E6%98%AF%E8%AE%BF%E9%97%AElocalhost:80">http://baidu.com，其实就等于访问http://baidu.com:80。因此我们访问localhost，默认是访问localhost:80</a></p><h2 id="localhost与127-0-0-1的区别"><a href="#localhost与127-0-0-1的区别" class="headerlink" title="localhost与127.0.0.1的区别"></a>localhost与127.0.0.1的区别</h2><p>localhost也叫local ，正确的解释是：本地服务器</p><p>127.0.0.1在windows等系统的正确解释是：本机地址（本机服务器）</p><p>他们的解析通过本机的host文件，windows自动将localhost解析为127.0.0.1</p><p>localhost也叫local ，正确的解释是：本地服务器</p><p>127.0.0.1在windows等系统的正确解释是：本机地址（本机服务器）</p><p>他们的解析通过本机的host文件，windows自动将localhost解析为127.0.0.1</p><p>localhot（local）是不经网卡传输！这点很重要，它不受网络防火墙和网卡相关的的限制。</p><p>127.0.0.1是通过网卡传输，依赖网卡，并受到网络防火墙和网卡相关的限制。</p><p>一般设置程序时本地服务用localhost是最好的，localhost不会解析成ip，也不会占用网卡、网络资源。</p><p>有时候用localhost可以，但用127.0.0.1就不可以的情况就是在于此。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="解决方法1："><a href="#解决方法1：" class="headerlink" title="解决方法1："></a>解决方法1：</h3><p>修改host文件用记事本打开C:&#x2F;WINDOWS&#x2F;system32&#x2F;drivers&#x2F;etc&#x2F;hosts文件，看是否有127.0.0.1 localhost 。如果没有则将其添加进去，再查看能否访问localhost。博主使用此方法，即可访问<a href="http://localhost:4000/mgr/index.html#/">http://localhost:4000/mgr/index.html#/</a></p><h3 id="解决方法2："><a href="#解决方法2：" class="headerlink" title="解决方法2："></a>解决方法2：</h3><p>1、打开Internert信息管理查看IIS是否启动，且默认网站时候已经开启；<br>2、打开<a href="http://127.0.0.1/">http://127.0.0.1/</a> 看是否能访问IIS的默认网页，能访问则说明IIS已经成功安装到电脑上，可能是无法解析localhost；<br>3、开始–命令（cmd）–ping localhost，看是否能ping通，从127.0.0.1上返回信息，如果成功则说明可以解析localhost；<br>4、如果上一步不成功，则用记事本打开C:&#x2F;WINDOWS&#x2F;system32&#x2F;drivers&#x2F;etc&#x2F;hosts文件，看里面是否有包含：127.0.0.1 localhost ，如果没有则将其添加进去，再查看能否访问localhost。<br>5、尝试将网站的主目录指向另一个目录或新建一个虚拟目录，并在该新目录创建一个新的网页文件，如index.html，然后将其加到默认网站的”文档”项中作为默认访问的网页，重新输入网址：<a href="http://localhost/%EF%BC%8C%E7%9C%8B%E5%90%A6%E8%83%BD%E8%AE%BF%E9%97%AE%E3%80%82">http://localhost/，看否能访问。</a><br>6、还是不行的话将IIS卸载掉，重新再安装一次。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;localhost与127-0-0-1与0-0-0-0以及端口&quot;&gt;&lt;a href=&quot;#localhost与127-0-0-1与0-0-0-0以及端口&quot; class=&quot;headerlink&quot; title=&quot;localhost与127.0.0.1与0.0.0.0以及端</summary>
      
    
    
    
    <category term="网络" scheme="http://justskim.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="http://justskim.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Mysql安装的版本选择</title>
    <link href="http://justskim.github.io/2022/02/12/Mysql%E5%AE%89%E8%A3%85%E7%9A%84%E7%89%88%E6%9C%AC%E9%80%89%E6%8B%A9/"/>
    <id>http://justskim.github.io/2022/02/12/Mysql%E5%AE%89%E8%A3%85%E7%9A%84%E7%89%88%E6%9C%AC%E9%80%89%E6%8B%A9/</id>
    <published>2022-02-12T10:30:47.490Z</published>
    <updated>2022-02-17T15:09:38.844Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql安装的版本选择"><a href="#Mysql安装的版本选择" class="headerlink" title="Mysql安装的版本选择"></a>Mysql安装的版本选择</h1><h2 id="官网中的版本类别"><a href="#官网中的版本类别" class="headerlink" title="官网中的版本类别"></a>官网中的版本类别</h2><p>在<a href="https://www.mysql.com/downloads/">mysql官方下载页面</a>，可以看到有以下几个版本：</p><ol><li><p>MySQL Community Server 社区版本，由于开源免费因此是最常用的，但不提供官方技术支持。</p></li><li><p>MySQL Enterprise Edition 企业版本，需付费，可以试用30天。</p></li><li><p>MySQL Cluster 集群版，开源免费。可将几个MySQL Server封装成一个Server</p></li><li><p>MySQL Cluster CGE 高级集群版，需付费。</p></li><li><p>MySQL Workbench（GUI TOOL）一款专为MySQL设计的ER&#x2F;数据库建模工具。它是著名的数据库设计工具DBDesigner4的继任者。MySQL Workbench又分为两个版本，分别是社区版（MySQL Workbench OSS）、商用版（MySQL Workbench SE）。</p></li></ol><h2 id="Linux中安装MySQL"><a href="#Linux中安装MySQL" class="headerlink" title="Linux中安装MySQL"></a>Linux中安装MySQL</h2><p>这里为了方便，我们使用MySQL Community Server版本来进行安装示例。</p><h3 id="选择与Linux系统相配的安装版本"><a href="#选择与Linux系统相配的安装版本" class="headerlink" title="选择与Linux系统相配的安装版本"></a>选择与Linux系统相配的安装版本</h3><p>注意，<code>linux</code>内核版本和<code>linux</code>系统版本是不同的概念！内核是系统的心脏，也是运行程序和管理设备的核心程序，而我们平时所说的<code>Redhat</code>，<code>Ubuntu</code>及<code>Centos</code>是不同的<code>linux</code>发行版</p><p><strong>查看Linux内核版本命令</strong></p><ol><li><code>cat /proc/version</code>    这个文件只有一行内容, 说明正在运行的内核版本</li><li><code>uname -a</code>    Linux <code>uname</code>（英文全拼：unix name）命令用于显示系统信息。<code>uname</code> 可显示电脑以及操作系统的相关信息，语法：<code>uname [-amnrsv][--help][--version]</code>；其中-a或–all 　显示全部的信息。</li></ol><p><strong>查看Linux系统版本命令</strong></p><ol><li>使用命令<code>lsb_release -a</code>列出所有版本信息，如果提示未找到相关命令，则需要我们使用命令<code>yum install -y redhat-lsb</code>进行安装；</li><li><code>cat /etc/redhat-release</code>，这种方法只适合<code>RedHat</code>系的Linux；</li><li><code>cat /etc/issue</code>，<code>/etc/issue</code>、<code>/etc/issue</code>与 <code>/etc/motd</code> 作用一致，都是<strong>用于显示欢迎信息</strong>，可能包含Linux系统版本的信息。</li></ol><p>查找到的结果为：<code>CentOS Linux release 7.8.2003</code></p><p>我们在这里选择Linux genertic下x86_64的版本，复制相关链接，在远程服务器的Linux系统中使用wget进行下载安装。</p><p><img src="/images/linux%E4%B8%8Bmysql%E5%AE%89%E8%A3%85%E7%89%88%E6%9C%AC%E9%80%89%E6%8B%A9.png" alt="linux下mysql安装版本选择"></p><p>下载得到的是一个tar压缩包，我们可以在<a href="https://dev.mysql.com/doc/refman/8.0/en/binary-installation.html">MySQL官方提供的说明文档</a>（这里以8.0版本为例）中</p><p>对该安装包使用命令<code>tar -xvf</code>解压：</p><p><img src="/images/mysql%E7%9A%84xz%E5%AE%89%E8%A3%85%E5%8C%85%E8%A7%A3%E5%8E%8B.png" alt="mysql的xz安装包解压"></p><p>我们使用的系统是<code>Centos</code>，因此有yum工具而没有apt，如果是<code>ubuntu</code>要使用apt进行安装，操作如<a href="https://blog.jkdev.cn/index.php/archieves/125">相关教程博客</a>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt install numactl</span><br><span class="line"><span class="comment">#仅安装libaio库还不行，还要安装numactl库</span></span><br><span class="line"></span><br><span class="line">apt install libaio-dev</span><br></pre></td></tr></table></figure><p>在安装完相关库之后，我们使用以下的命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$<span class="operator">&gt;</span> groupadd mysql</span><br><span class="line">$<span class="operator">&gt;</span> useradd <span class="operator">-</span>r <span class="operator">-</span>g mysql <span class="operator">-</span>s <span class="operator">/</span>bin<span class="operator">/</span><span class="literal">false</span> mysql</span><br><span class="line">$<span class="operator">&gt;</span> cd mysql</span><br><span class="line">$<span class="operator">&gt;</span> mkdir mysql<span class="operator">-</span>files</span><br><span class="line">$<span class="operator">&gt;</span> chown mysql:mysql mysql<span class="operator">-</span>files</span><br><span class="line">$<span class="operator">&gt;</span> chmod <span class="number">750</span> mysql<span class="operator">-</span>files</span><br><span class="line">$<span class="operator">&gt;</span> bin<span class="operator">/</span>mysqld <span class="comment">--initialize --user=mysql</span></span><br><span class="line">$<span class="operator">&gt;</span> bin<span class="operator">/</span>mysql_ssl_rsa_setup</span><br><span class="line">$<span class="operator">&gt;</span> bin<span class="operator">/</span>mysqld_safe <span class="comment">--user=mysql &amp;</span></span><br><span class="line"># Next command <span class="keyword">is</span> optional</span><br><span class="line">$<span class="operator">&gt;</span> cp support<span class="operator">-</span>files<span class="operator">/</span>mysql.server <span class="operator">/</span>etc<span class="operator">/</span>init.d<span class="operator">/</span>mysql.server</span><br></pre></td></tr></table></figure><p>其中，如果赋相关目录<code>MySQL</code>用户权限的<code>chown</code>命令发生以下报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span>: invalid user: mysql:mysql</span><br></pre></td></tr></table></figure><p>我们需要再次通过添加执行用户名和组的方式解决：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd mysql</span><br><span class="line">useradd -g mysql mysql</span><br></pre></td></tr></table></figure><p>注意，初始化数据库时，如果提示<code>mysqld not found</code>错误，是由于 &#x2F;etc&#x2F;init.d&#x2F; 不存在 mysqld 这个命令</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Mysql安装的版本选择&quot;&gt;&lt;a href=&quot;#Mysql安装的版本选择&quot; class=&quot;headerlink&quot; title=&quot;Mysql安装的版本选择&quot;&gt;&lt;/a&gt;Mysql安装的版本选择&lt;/h1&gt;&lt;h2 id=&quot;官网中的版本类别&quot;&gt;&lt;a href=&quot;#官网中的版</summary>
      
    
    
    
    <category term="Mysql" scheme="http://justskim.github.io/categories/Mysql/"/>
    
    <category term="安装" scheme="http://justskim.github.io/categories/Mysql/%E5%AE%89%E8%A3%85/"/>
    
    
    <category term="mysql" scheme="http://justskim.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>win10上的代理服务器设置与127.0.0.1</title>
    <link href="http://justskim.github.io/2022/02/08/win10%E4%B8%8A%E7%9A%84%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE%E4%B8%8E127.0.0.1/"/>
    <id>http://justskim.github.io/2022/02/08/win10%E4%B8%8A%E7%9A%84%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE%E4%B8%8E127.0.0.1/</id>
    <published>2022-02-08T06:02:05.413Z</published>
    <updated>2022-02-08T07:13:50.206Z</updated>
    
    <content type="html"><![CDATA[<h1 id="win10上的代理服务器设置与127-0-0-1"><a href="#win10上的代理服务器设置与127-0-0-1" class="headerlink" title="win10上的代理服务器设置与127.0.0.1"></a>win10上的代理服务器设置与127.0.0.1</h1><h2 id="代理服务器的定义"><a href="#代理服务器的定义" class="headerlink" title="代理服务器的定义"></a>代理服务器的定义</h2><p>代理服务器（Proxy Server）是介于浏览器和Web服务器之间的一台服务器，可被用于代理网络用户去取得网络信息。可以说，代理服务器是网络信息的中转站，是个人网络和Internet服务商之间的中间代理机构，负责转发合法的网络信息，对转发进行控制和登记，工作在OSI模型的对话层。当你通过代理服务器上网浏览时，浏览器不是直接到Web服务器去取回网页，而是向代理服务器发出请求，由代理服务器来取回浏览器所需要的信息，并传送给你的浏览器。 </p><p>Win10系统提供<strong>系统级代理服务器设置，通过在Win10系统中设置代理服务器</strong>，系统中所有的软件都会通过我们设置的代理服务器访问网络，这样就不用一个一个软件设置代理服务器了，包括浏览器等应用，都会使用设定的系统代理服务器上网。</p><h2 id="环回地址127-0-0-1"><a href="#环回地址127-0-0-1" class="headerlink" title="环回地址127.0.0.1"></a>环回地址127.0.0.1</h2><p>127.0.0.1是回送地址主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，协议软件立即返回之，不进行任何网络传输。有时候当我们使用浏览器点击网页时，有时候会发现提示网页无法找到，建议我们检查代理服务器设置。而在win10系统的设置一栏，有一项“代理服务器”的设置，有时我们点开这里，会发现代理服务器被设置为127.0.0.1，原因不明，但将代理服务器关闭即可正常访问网络，检查host文件也没有发现异常。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;win10上的代理服务器设置与127-0-0-1&quot;&gt;&lt;a href=&quot;#win10上的代理服务器设置与127-0-0-1&quot; class=&quot;headerlink&quot; title=&quot;win10上的代理服务器设置与127.0.0.1&quot;&gt;&lt;/a&gt;win10上的代理服务器设置</summary>
      
    
    
    
    <category term="网络" scheme="http://justskim.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="服务器" scheme="http://justskim.github.io/categories/%E7%BD%91%E7%BB%9C/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
    <category term="网络" scheme="http://justskim.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="服务器" scheme="http://justskim.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>在vmware虚拟机中进行网络连接</title>
    <link href="http://justskim.github.io/2021/11/16/%E5%9C%A8vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5/"/>
    <id>http://justskim.github.io/2021/11/16/%E5%9C%A8vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5/</id>
    <published>2021-11-16T07:16:40.924Z</published>
    <updated>2022-02-12T10:13:06.192Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在vmware虚拟机中进行网络连接"><a href="#在vmware虚拟机中进行网络连接" class="headerlink" title="在vmware虚拟机中进行网络连接"></a>在<code>vmware</code>虚拟机中进行网络连接</h1><h2 id="四种网络模式"><a href="#四种网络模式" class="headerlink" title="四种网络模式"></a>四种网络模式</h2><p>点击<code>VMware Workstation</code>的导航栏，在“虚拟机-&gt;设置-&gt;硬件-&gt;网络设配器”中，可看到网络连接模式的选择（不能在虚拟机挂起的时候进行更改），<a href="https://docs.vmware.com/cn/VMware-Workstation-Pro/14.0/com.vmware.ws.using.doc/GUID-3B504F2F-7A0B-415F-AE01-62363A95D052.html">VMware的官方网站</a>中说明了四种网络模式的区别：</p><table><thead><tr><th align="left">设置</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><strong>使用桥接模式网络连接</strong></td><td align="left">为虚拟机配置桥接模式网络连接。使用桥接模式网络连接时，虚拟机将具有直接访问外部以太网网络的权限。虚拟机必须在外部网络中具有自己的 IP 地址。如果您的主机系统位于网络中，而且您拥有可用于虚拟机的单独 IP 地址（或者可以从 DHCP 服务器获得 IP 地址），请选择此设置。网络中的其他计算机将能够与该虚拟机直接通信。</td></tr><tr><td align="left"><strong>使用网络地址转换 (NAT)</strong></td><td align="left">为虚拟机配置 NAT 连接。利用 NAT，虚拟机和主机系统将共享一个网络标识，此标识在网络以外不可见。如果您没有可用于虚拟机的单独 IP 地址，但又希望能够连接到 Internet，请选择 NAT。</td></tr><tr><td align="left"><strong>使用仅主机模式网络连接</strong></td><td align="left">为虚拟机配置仅主机模式网络连接。仅主机模式网络连接使用对主机操作系统可见的虚拟网络适配器，在虚拟机和主机系统之间提供网络连接。使用仅主机模式网络连接时，虚拟机只能与主机系统以及仅主机模式网络中的其他虚拟机进行通信。要设置独立的虚拟网络，请选择仅主机模式网络连接。</td></tr><tr><td align="left"><strong>不使用网络连接</strong></td><td align="left">不为虚拟机配置网络连接。</td></tr><tr><td align="left"><strong>自定义</strong>（Windows 主机）或<strong>已命名的网络</strong>（Linux 主机）</td><td align="left">（仅限远程虚拟机）选择特定虚拟网络。从下拉菜单中选择一个自定义网络。尽管列表中有 <code>VMnet0</code>、<code>VMnet1 </code>和 <code>VMnet8</code>，但这些网络通常被用于桥接模式、仅主机模式和 NAT 模式网络。</td></tr></tbody></table><p>对于使用校园网或者公司网络的用户，NAT是最简单的方式。</p><h2 id="网络配置相关文件"><a href="#网络配置相关文件" class="headerlink" title="网络配置相关文件"></a>网络配置相关文件</h2><p><strong>eth0</strong></p><p>该文件一般位于路径“&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts”中</p><h2 id="网络配置相关命令"><a href="#网络配置相关命令" class="headerlink" title="网络配置相关命令"></a>网络配置相关命令</h2><p><strong><code>ifconfig</code></strong></p><p><strong>用于配置网卡的基本命令</strong>，注意不是<code>ipconfig</code>！<code>ifconfig</code>命令的英文全称是“network interfaces configuring”，即用于配置和显示Linux内核中网络接口的网络参数。用<code>ifconfig</code>命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。要想将上述的配置信息永远的存的电脑里，那就要修改网卡的配置文件了。</p><p><strong>常用参数：</strong></p><table><thead><tr><th>add &lt;地址&gt;</th><th>设置网络设备IPv6的IP地址</th></tr></thead><tbody><tr><td><code>del</code> &lt;地址&gt;</td><td>删除网络设备IPv6的IP地址</td></tr><tr><td>down</td><td>关闭指定的网络设备</td></tr><tr><td>up</td><td>启动指定的网络设备</td></tr><tr><td>IP地址</td><td>指定网络设备的IP地址</td></tr></tbody></table><p>一个与之相似的命令是windows系统下的<code>ipconfig</code>命令</p><p><strong>ethtool</strong></p><p>用于查询ethX网口基本设置、及设置网卡的参数</p><h2 id="以上步骤尝试过后，依然无法解决联网问题"><a href="#以上步骤尝试过后，依然无法解决联网问题" class="headerlink" title="以上步骤尝试过后，依然无法解决联网问题"></a>以上步骤尝试过后，依然无法解决联网问题</h2><p>如果在以上步骤尝试过后，依然无法解决联网问题，特别是最简单的NAT模式下，可以查看相关端口是否被杀毒软件禁止，以及服务是否成功启动。笔者在实际操作中遇到过这种情况，最后，根据<a href="https://www.cnblogs.com/hi3254014978/p/12668471.html">这篇博客</a>，将win10中的服务打开，手动启动或者重新启动<code>VMware DHCP Service</code>和<code>VMware NAT Service</code>两个服务即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;在vmware虚拟机中进行网络连接&quot;&gt;&lt;a href=&quot;#在vmware虚拟机中进行网络连接&quot; class=&quot;headerlink&quot; title=&quot;在vmware虚拟机中进行网络连接&quot;&gt;&lt;/a&gt;在&lt;code&gt;vmware&lt;/code&gt;虚拟机中进行网络连接&lt;/h1&gt;</summary>
      
    
    
    
    <category term="Linux" scheme="http://justskim.github.io/categories/Linux/"/>
    
    
    <category term="linux" scheme="http://justskim.github.io/tags/linux/"/>
    
    <category term="虚拟机" scheme="http://justskim.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    <category term="ubuntu" scheme="http://justskim.github.io/tags/ubuntu/"/>
    
    <category term="vmware" scheme="http://justskim.github.io/tags/vmware/"/>
    
  </entry>
  
  <entry>
    <title>python3中的运行命令与环境</title>
    <link href="http://justskim.github.io/2021/11/09/python3%E4%B8%AD%E7%9A%84%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4%E4%B8%8E%E7%8E%AF%E5%A2%83/"/>
    <id>http://justskim.github.io/2021/11/09/python3%E4%B8%AD%E7%9A%84%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4%E4%B8%8E%E7%8E%AF%E5%A2%83/</id>
    <published>2021-11-08T18:35:42.058Z</published>
    <updated>2021-11-08T18:36:09.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python3中的运行命令与环境"><a href="#python3中的运行命令与环境" class="headerlink" title="python3中的运行命令与环境"></a>python3中的运行命令与环境</h1><p>本机电脑仅安装python3，以下使用的均为python3环境配置</p><h2 id="镜像是什么？"><a href="#镜像是什么？" class="headerlink" title="镜像是什么？"></a>镜像是什么？</h2><p>镜像（Mirroring）是一种文件存储形式，是冗余的一种类型，一个磁盘上的数据在另一个磁盘上存在一个完全相同的副本即为镜像。</p><p>镜像源 就是把官<strong>方的源做一个镜像，你</strong>可以在这下载软件。 比如ubuntu官方源在国外，下载软件可能会很慢，这时候就需要换成国内的镜像源。 源 端口就是指本地端口 目的端口就是远程端口 一个数据包（pocket）被解封装成数据段（segment）后就会涉及到 连接上层协议的端口问题。</p><p>镜像网站（Mirror sites）又称之为镜像站点</p><h2 id="anaconda环境"><a href="#anaconda环境" class="headerlink" title="anaconda环境"></a>anaconda环境</h2><h2 id="命令行运行python程序，与idle中”Run-module“的区别"><a href="#命令行运行python程序，与idle中”Run-module“的区别" class="headerlink" title="命令行运行python程序，与idle中”Run module“的区别"></a>命令行运行python程序，与idle中”Run module“的区别</h2><p>笔者在学习<a href="https://gitee.com/daochenzha/rlcard?_from=gitee_search#/daochenzha/rlcard/blob/master/docs/toy-examples.md#playing-with-random-agents">RLCard——一款卡牌游戏强化学习工具包</a>的时候，发现了<a href="https://gitee.com/daochenzha/rlcard/blob/master/docs/toy-examples.md#playing-with-random-agents">范例</a>中的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> rlcard</span><br><span class="line"><span class="keyword">from</span> rlcard.agents <span class="keyword">import</span> RandomAgent</span><br><span class="line"><span class="keyword">from</span> rlcard.utils <span class="keyword">import</span> set_seed</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">args</span>):</span><br><span class="line">    <span class="comment"># Make environment</span></span><br><span class="line">    env = rlcard.make(args.env, config=&#123;<span class="string">&#x27;seed&#x27;</span>: <span class="number">42</span>&#125;)</span><br><span class="line">    num_episodes = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Seed numpy, torch, random</span></span><br><span class="line">    set_seed(<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set agents</span></span><br><span class="line">    agent = RandomAgent(num_actions=env.num_actions)</span><br><span class="line">    env.set_agents([agent <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(env.num_players)])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> episode <span class="keyword">in</span> <span class="built_in">range</span>(num_episodes):</span><br><span class="line">        <span class="comment"># Generate data from the environment</span></span><br><span class="line">        trajectories, player_wins = env.run(is_training=<span class="literal">False</span>)</span><br><span class="line">        <span class="comment"># Print out the trajectories</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\nEpisode &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(episode))</span><br><span class="line">        <span class="built_in">print</span>(trajectories)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    parser = argparse.ArgumentParser(<span class="string">&quot;Random example in RLCard&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--env&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;leduc-holdem&#x27;</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    run(args)</span><br></pre></td></tr></table></figure><p>这段代码在idle中无法被“Run module”运行，却可以在命令行中运行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在idle中无法被“Run module”运行</span></span><br><span class="line">============== RESTART: E:/python练习/RLCard/examples/run_random.py ==============</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;E:/python练习/RLCard/examples/run_random.py&quot;</span>, line <span class="number">4</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">from</span> rlcard.agents <span class="keyword">import</span> RandomAgent</span><br><span class="line">  File <span class="string">&quot;E:\python\lib\site-packages\rlcard\agents\__init__.py&quot;</span>, line <span class="number">5</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    reqs = subprocess.check_output([sys.executable, <span class="string">&#x27;-m&#x27;</span>, <span class="string">&#x27;pip&#x27;</span>, <span class="string">&#x27;freeze&#x27;</span>])</span><br><span class="line">  File <span class="string">&quot;E:\python\lib\subprocess.py&quot;</span>, line <span class="number">424</span>, <span class="keyword">in</span> check_output</span><br><span class="line">    <span class="keyword">return</span> run(*popenargs, stdout=PIPE, timeout=timeout, check=<span class="literal">True</span>,</span><br><span class="line">  File <span class="string">&quot;E:\python\lib\subprocess.py&quot;</span>, line <span class="number">528</span>, <span class="keyword">in</span> run</span><br><span class="line">    <span class="keyword">raise</span> CalledProcessError(retcode, process.args,</span><br><span class="line">subprocess.CalledProcessError: Command <span class="string">&#x27;[&#x27;</span>E:\\python\\pythonw.exe<span class="string">&#x27;, &#x27;</span>-m<span class="string">&#x27;, &#x27;</span>pip<span class="string">&#x27;, &#x27;</span>freeze<span class="string">&#x27;]&#x27;</span> returned non-zero exit status <span class="number">120.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#可以在命令行中运行</span></span><br><span class="line">$ python examples/run_random.py</span><br><span class="line">WARNING: Ignoring invalid distribution -ip (e:\python\lib\site-packages)</span><br><span class="line">WARNING: Ignoring invalid distribution -ip (e:\python\lib\site-packages)</span><br><span class="line"></span><br><span class="line">Episode <span class="number">0</span></span><br><span class="line">[[&#123;<span class="string">&#x27;legal_actions&#x27;</span>: OrderedDict([(<span class="number">1</span>, <span class="literal">None</span>), (<span class="number">2</span>, <span class="literal">None</span>), (<span class="number">3</span>, <span class="literal">None</span>)]), <span class="string">&#x27;obs&#x27;</span>: array([<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>,</span><br><span class="line">       <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>,</span><br><span class="line">       <span class="number">0.</span>, <span class="number">0.</span>]), <span class="string">&#x27;raw_obs&#x27;</span>: &#123;<span class="string">&#x27;hand&#x27;</span>: <span class="string">&#x27;HQ&#x27;</span>, <span class="string">&#x27;public_card&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;all_chips&#x27;</span>: [<span class="number">2</span>, <span class="number">1</span>], <span class="string">&#x27;my_chips&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;legal_actions&#x27;</span>: [<span class="string">&#x27;raise&#x27;</span>, <span class="string">&#x27;fold&#x27;</span>, <span class="string">&#x27;check&#x27;</span>], <span class="string">&#x27;current_player&#x27;</span>: <span class="number">0</span>&#125;, <span class="string">&#x27;raw_legal_actions&#x27;</span>: [<span class="string">&#x27;raise&#x27;</span>, <span class="string">&#x27;fold&#x27;</span>, <span class="string">&#x27;check&#x27;</span>], <span class="string">&#x27;action_record&#x27;</span>: [(<span class="number">1</span>, <span class="string">&#x27;fold&#x27;</span>)]&#125;], [&#123;<span class="string">&#x27;legal_actions&#x27;</span>: OrderedDict([(<span class="number">0</span>, <span class="literal">None</span>), (<span class="number">1</span>, <span class="literal">None</span>), (<span class="number">2</span>, <span class="literal">None</span>)]), <span class="string">&#x27;obs&#x27;</span>: array([<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>,</span><br><span class="line">       <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>,</span><br><span class="line">       <span class="number">0.</span>, <span class="number">0.</span>]), <span class="string">&#x27;raw_obs&#x27;</span>: &#123;<span class="string">&#x27;hand&#x27;</span>: <span class="string">&#x27;HJ&#x27;</span>, <span class="string">&#x27;public_card&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;all_chips&#x27;</span>: [<span class="number">2</span>, <span class="number">1</span>], <span class="string">&#x27;my_chips&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;legal_actions&#x27;</span>: [<span class="string">&#x27;call&#x27;</span>, <span class="string">&#x27;raise&#x27;</span>, <span class="string">&#x27;fold&#x27;</span>], <span class="string">&#x27;current_player&#x27;</span>: <span class="number">1</span>&#125;, <span class="string">&#x27;raw_legal_actions&#x27;</span>: [<span class="string">&#x27;call&#x27;</span>, <span class="string">&#x27;raise&#x27;</span>, <span class="string">&#x27;fold&#x27;</span>], <span class="string">&#x27;action_record&#x27;</span>: [(<span class="number">1</span>, <span class="string">&#x27;fold&#x27;</span>)]&#125;, <span class="number">2</span>, &#123;<span class="string">&#x27;legal_actions&#x27;</span>: OrderedDict([(<span class="number">1</span>, <span class="literal">None</span>), (<span class="number">2</span>, <span class="literal">None</span>), (<span class="number">3</span>, <span class="literal">None</span>)]), <span class="string">&#x27;obs&#x27;</span>: array([<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>,</span><br><span class="line">       <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>,</span><br><span class="line">       <span class="number">0.</span>, <span class="number">0.</span>]), <span class="string">&#x27;raw_obs&#x27;</span>: &#123;<span class="string">&#x27;hand&#x27;</span>: <span class="string">&#x27;HJ&#x27;</span>, <span class="string">&#x27;public_card&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;all_chips&#x27;</span>: [<span class="number">2</span>, <span class="number">1</span>], <span class="string">&#x27;my_chips&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;legal_actions&#x27;</span>: [<span class="string">&#x27;raise&#x27;</span>, <span class="string">&#x27;fold&#x27;</span>, <span class="string">&#x27;check&#x27;</span>], <span class="string">&#x27;current_player&#x27;</span>: <span class="number">0</span>&#125;, <span class="string">&#x27;raw_legal_actions&#x27;</span>: [<span class="string">&#x27;raise&#x27;</span>, <span class="string">&#x27;fold&#x27;</span>, <span class="string">&#x27;check&#x27;</span>], <span class="string">&#x27;action_record&#x27;</span>: [(<span class="number">1</span>, <span class="string">&#x27;fold&#x27;</span>)]&#125;]]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们试着来比较这两个命令的差别：</p><p><a href="https://zhuanlan.zhihu.com/p/150835014">这篇博客中介绍了sys模块的使用详情</a>，我们只讲两个下面会使用到的函数，</p><p><em>sys模块</em>提供了一系列有关<em>Python</em>运行环境的变量和函数，</p><p>sys.path<br>返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值</p><h3 id="sys-executable"><a href="#sys-executable" class="headerlink" title="sys.executable"></a><strong>sys.executable</strong></h3><p>该属性是一个字符串，在正常情况下，其值是当前运行的 Python 解释器对应的可执行程序所在的绝对路径。</p><p>比如在 Windows 上使用 Anaconda 安装的 Python，该属性的值就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.executable</span><br><span class="line"><span class="string">&#x27;E:\\Anaconda\\Anaconda\\python.exe&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="E:\JS练习\blog\Myblog\source\images\两个命令差别.png"></p><p>打印结果，我们可以发现二者的绝对路径不一样，在Idle中，python解释器对应的可执行程序为pythonw.exe，而在命令行中则是python.exe</p><p><strong>python.exe与pythonw.exe</strong></p><p>Windows系统搭建好Python的环境后，进入Python的安装目录，大家会发现目录中有python.exe和pythonw.exe两个程序。</p><p><a href="https://zhuanlan.zhihu.com/p/302384158">这两个程序的区别在于</a>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a）、python.exe在运行程序的时候，会弹出一个黑色的控制台窗口（也叫命令行窗口、DOS/CMD窗口）；</span><br><span class="line">   b）、pythonw.exe是无窗口的Python可执行程序，意思是在运行程序的时候，没有窗口，代码在后台执行</span><br><span class="line">   .py和.pyw文件的区别也来源于python.exe和pythonw.exe的区别：</span><br><span class="line">   安装视窗版 Python 时，扩展名为 .py 的文件被默认为用 python.exe 运行的文件，而 .pyw文件则被默认为用 pythonw.exe 运行。</span><br><span class="line">这里还要解释一个问题，如果.py文件直接用python.exe打开，文件被执行完成之后，视窗会立即关闭，如果想让视窗停留；给大家提供两个方法：</span><br><span class="line">① 可以在程序中import time模块，加入超长睡眠语句，如time.sleep(1800)，如果你不手动关闭视窗，视窗将会停留30min；</span><br><span class="line">② 可以调用sys和os模块，使用命令行语句pause</span><br><span class="line"></span><br><span class="line">  3、.pyw格式是被设计用来运行开发的纯图形界面程序的，纯图形界面程序的用户不需要看到控制台窗口。</span><br><span class="line">    在开发纯图形界面程序的时候，可以暂时把 .pyw 改成 .py ，运行时能调出控制台窗口，方便看到所有错误信息。</span><br><span class="line">    至于.pyc文件，是Python解释器运行程序的过程中产生的字节码文件（也就是中间文件）。</span><br></pre></td></tr></table></figure><p>总之，我们尽可能地使用命令行来执行.py格式程序。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;python3中的运行命令与环境&quot;&gt;&lt;a href=&quot;#python3中的运行命令与环境&quot; class=&quot;headerlink&quot; title=&quot;python3中的运行命令与环境&quot;&gt;&lt;/a&gt;python3中的运行命令与环境&lt;/h1&gt;&lt;p&gt;本机电脑仅安装python3</summary>
      
    
    
    
    <category term="Programming languages and projects" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/"/>
    
    <category term="Python3" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"/>
    
    
    <category term="python3" scheme="http://justskim.github.io/tags/python3/"/>
    
    <category term="anaconda" scheme="http://justskim.github.io/tags/anaconda/"/>
    
  </entry>
  
  <entry>
    <title>python3中的生成器与迭代器</title>
    <link href="http://justskim.github.io/2021/11/03/python3%E4%B8%AD%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>http://justskim.github.io/2021/11/03/python3%E4%B8%AD%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/</id>
    <published>2021-11-03T01:55:18.115Z</published>
    <updated>2021-11-03T08:39:09.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python3中的生成器与迭代器"><a href="#python3中的生成器与迭代器" class="headerlink" title="python3中的生成器与迭代器"></a>python3中的生成器与迭代器</h1><h2 id="生成器与迭代器"><a href="#生成器与迭代器" class="headerlink" title="生成器与迭代器"></a>生成器与迭代器</h2><p>在Python社区，生成器和迭代器被看作一种工具，生成器的本质就是迭代器。唯一的区别就是生成器是开发人员自己用Python代码构建的数据结构，而迭代器是Python内置提供或转化而来的。</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器是一种对象，该对象包含值的可计数数字。</p><p>迭代器是可迭代的对象，这意味着您可以遍历所有值。</p><p>从技术上讲，在 Python 中，迭代器是实现迭代器协议的对象，它包含方法<code>__iter__()</code>和 <code>__next__()</code>。<br>要把对象&#x2F;类创建为迭代器，必须为对象实现<code> __iter__()</code> 和 <code>__next__()</code> 方法。</p><p>正如您在 Python 类&#x2F;对象 一章中学到的，所有类都有名为 <code>__init__()</code> 的函数，它允许您在创建对象时进行一些初始化。</p><p><code>__iter__()</code>方法的作用相似，您可以执行操作（初始化等），但必须始终返回迭代器对象本身。</p><p><code>__next__()</code>方法也允许您执行操作，并且必须返回序列中的下一个项目。</p><h3 id="可迭代对象（Iterable）"><a href="#可迭代对象（Iterable）" class="headerlink" title="可迭代对象（Iterable）"></a>可迭代对象（Iterable）</h3><p>列表、元组、字典和集合、字符串都是可迭代的对象。它们是可迭代的容器，您可以从中获取迭代器（Iterator）。</p><p>所有这些对象都有用于获取迭代器的 iter() 方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mytuple = (<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>)</span><br><span class="line">myit = <span class="built_in">iter</span>(mytuple)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myit))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myit))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myit))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mytuple = (<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myit=<span class="built_in">iter</span>(mytuple)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(myit))</span><br><span class="line">apple</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(myit))</span><br><span class="line">banana</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(myit))</span><br><span class="line">cherry</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mytuple1=<span class="string">&quot;banana&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myit1=<span class="built_in">iter</span>(mytuple1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(myit))</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#54&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(myit))</span><br><span class="line">StopIteration<span class="comment">#序列的所有项目都被迭代过，因此迭代（iteration）停止，报错</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(myit1))</span><br><span class="line">b</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(myit1))</span><br><span class="line">a</span><br></pre></td></tr></table></figure><p>也可以使用 for 循环遍历可迭代对象</p><h3 id="StopIteration-异常的使用"><a href="#StopIteration-异常的使用" class="headerlink" title="StopIteration 异常的使用"></a><code>StopIteration</code> 异常的使用</h3><p><code>StopIteration</code>异常用于完成标识迭代，防止无限循环。</p><p><code>__next__()</code>函数完成指定循环次数后，会触发该异常结束迭代。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">it = <span class="built_in">iter</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        x = <span class="built_in">next</span>(it)</span><br><span class="line">        <span class="built_in">print</span>(x)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment">#如果不使用StopIteration，则会报错异常</span></span><br></pre></td></tr></table></figure><h3 id="将一个类当做迭代器使用"><a href="#将一个类当做迭代器使用" class="headerlink" title="将一个类当做迭代器使用"></a>将一个类当做迭代器使用</h3><p>把一个类作为一个迭代器使用需要在类中方法 <code>__iter__()0</code>与 <code>__next__()</code> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyNumbers</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">    self.a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">    x = self.a</span><br><span class="line">    self.a += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"> </span><br><span class="line">myclass = MyNumbers()</span><br><span class="line">myiter = <span class="built_in">iter</span>(myclass)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))<span class="comment">#1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))<span class="comment">#2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))<span class="comment">#3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))<span class="comment">#4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))<span class="comment">#5</span></span><br></pre></td></tr></table></figure><h2 id="python3生成器"><a href="#python3生成器" class="headerlink" title="python3生成器"></a><code>python3</code>生成器</h2><p>在 Python 中，使用了 yield 的函数被称为<strong>生成器（generator）</strong>。</p><p>跟普通函数不同的是，<strong>生成器</strong>是一个<strong>返回迭代器的函数</strong>，<strong>只能用于迭代操作</strong>，更简单点理解生成器就是一个迭代器。</p><p>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。</p><p>调用一个生成器函数，返回的是一个迭代器对象。</p><h3 id="yield关键字"><a href="#yield关键字" class="headerlink" title="yield关键字"></a>yield关键字</h3><p>我们先将yield看做return，执行下面的程序，看看结果如何？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;starting...&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">res=<span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;res:&quot;</span>,res)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g=foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br><span class="line">starting...</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line">********************</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br><span class="line">res: <span class="literal">None</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/mieleizhi0522/article/details/82142856">原文章</a>的博主对于执行顺序给出了以下解释：</p><blockquote><p>1.程序开始执行以后，因为<code>foo</code>函数中有yield关键字，所以<code>foo</code>函数并不会真的执行，而是先得到一个生成器g(相当于一个对象)</p><p>2.直到调用next方法，<code>foo</code>函数正式开始执行，先执行<code>foo</code>函数中的print方法，然后进入while循环</p><p>3.程序遇到yield关键字，然后把yield想象成return，return了一个4之后，程序停止，并没有执行赋值给res操作，此时next(g)语句执行完成，所以输出的前两行（第一行“starting…”是while上面的print的结果，第二行“4”是return出的结果）是执行print(next(g))的结果，<strong>注意并没有执行yield一句下一行的print(“res:”,res)语句</strong></p><p>4.程序执行print(“<code>*</code>“*20)，输出20个<code>*</code></p><p>5.又开始执行下面的<code>print(next(g))</code>，不同的是，这一次<strong>从刚才那个next程序停止的地方开始执行的</strong>，也就是要<strong>从yield语句的下一行语句开始</strong>，执行res的赋值操作，这时候要注意，这个时候赋值操作的右边是没有值的（因为刚才那个是return出去了，并没有给赋值操作的左边传参数），所以这个时候res赋值是None,所以接着下面的输出就是<code>res:None</code></p><p>6.程序会继续在while里执行，又一次碰到yield,这个时候同样return 出4，然后程序停止，print函数输出的4就是这次return出的4.</p></blockquote><p>带yield的函数是一个生成器，可以不再看做一个函数了。这个生成器有一个next函数，相当于“下一步”生成哪个数，<strong>这一次的next开始的地方是接着上一次的next停止的地方执行的</strong>，所以调用next的时候，生成器并不会从<code>foo</code>函数的开始执行，只是接着上一步停止的地方开始，然后遇到yield后，return出要生成的数，此步就结束。</p><p>我们接着上面的代码，继续输出next(g)，每一次的next开始的地方都是上一次的next停止的地方：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br><span class="line">res: <span class="literal">None</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br><span class="line">res: <span class="literal">None</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>也就是说，除了第一次next函数可能会特殊（循环体外的代码部分执行原因），<strong>每次我们使用next函数，都是从上一个yield停止的地方，开始跑代码，跑到下一个yield语句，return了值， 停止</strong>。下面的例子更加直观一些：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">fo</span>(<span class="params">n</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;fo start!&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:<span class="comment">#注意，因为下一次next函数执行在循环体中开始，因此要再接一轮while判断，而不会执行循环体外面的上一行print(&quot;fo start&quot;)语句</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;before yield, n = &quot;</span>,n)</span><br><span class="line">n = n + <span class="number">1</span></span><br><span class="line">res = <span class="keyword">yield</span> n<span class="comment">#跑到这里结束</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;after yield, n = &quot;</span>,n)<span class="comment">#从这里开始</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = fo(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(x))</span><br><span class="line">fo start!</span><br><span class="line">before <span class="keyword">yield</span>, n =  <span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(x))</span><br><span class="line">after <span class="keyword">yield</span>, n =  <span class="number">2</span></span><br><span class="line">before <span class="keyword">yield</span>, n =  <span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(x))</span><br><span class="line">after <span class="keyword">yield</span>, n =  <span class="number">3</span></span><br><span class="line">before <span class="keyword">yield</span>, n =  <span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(x))</span><br><span class="line">after <span class="keyword">yield</span>, n =  <span class="number">4</span></span><br><span class="line">before <span class="keyword">yield</span>, n =  <span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(x))</span><br><span class="line">after <span class="keyword">yield</span>, n =  <span class="number">5</span></span><br><span class="line">before <span class="keyword">yield</span>, n =  <span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;python3中的生成器与迭代器&quot;&gt;&lt;a href=&quot;#python3中的生成器与迭代器&quot; class=&quot;headerlink&quot; title=&quot;python3中的生成器与迭代器&quot;&gt;&lt;/a&gt;python3中的生成器与迭代器&lt;/h1&gt;&lt;h2 id=&quot;生成器与迭代器&quot;&gt;</summary>
      
    
    
    
    <category term="Programming languages and projects" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/"/>
    
    <category term="Python3" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"/>
    
    
    <category term="python3" scheme="http://justskim.github.io/tags/python3/"/>
    
  </entry>
  
  <entry>
    <title>python3中的一些常见语法糖整理</title>
    <link href="http://justskim.github.io/2021/10/31/python3%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    <id>http://justskim.github.io/2021/10/31/python3%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E8%AF%AD%E6%B3%95%E7%B3%96/</id>
    <published>2021-10-31T12:02:01.432Z</published>
    <updated>2021-11-08T18:11:54.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python3中的一些常见语法糖整理"><a href="#python3中的一些常见语法糖整理" class="headerlink" title="python3中的一些常见语法糖整理"></a>python3中的一些常见语法糖整理</h1><h2 id="输入输出的类型提示"><a href="#输入输出的类型提示" class="headerlink" title="输入输出的类型提示"></a>输入输出的类型提示</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addBinary</span>(<span class="params">self, a: <span class="built_in">str</span>, b: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span></span><br></pre></td></tr></table></figure><p>学过C语言的同学，都懂得，参数中a，b要求为str类型的输入参数</p><p>在定义函数时，在def那一行后面会加一个-&gt;。这个玩意儿有个专门的名词叫 <strong>type hint， 即类型提示</strong>。这里就是说返回的数据类型为<code>str</code>。</p><p>在Python中，<code>str</code> 表示字符串类 ，也可以是将变量强制转换为字符串的函数，写作<code>str ()</code> </p><p><strong>类型标注</strong></p><ul><li><code>int</code>,<code>long</code>,<code>float</code>: 整型,长整形,浮点型</li><li><code>bool</code>,<code>str</code>: 布尔型，字符串类型</li><li><code>List</code>, <code>Tuple</code>, <code>Dict</code>, <code>Set</code>:列表，元组，字典, 集合</li><li><code>Iterable</code>,<code>Iterator</code>:可迭代类型，迭代器类型</li><li><code>Generator</code>：生成器类型</li></ul><h2 id="限定函数参数类型及输出"><a href="#限定函数参数类型及输出" class="headerlink" title="限定函数参数类型及输出"></a>限定函数参数类型及输出</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">text:<span class="string">&#x27;str&#x27;</span>,<span class="built_in">max</span>:<span class="string">&#x27;int &gt; 0&#x27;</span> = <span class="number">100</span>,<span class="built_in">min</span>:<span class="string">&#x27;int &gt; 0&#x27;</span></span>)-&gt;<span class="built_in">str</span>:</span><br></pre></td></tr></table></figure><p>在限定函数参数类型的同时还可以限定参数的范围以及默认值。</p><p>注意！在函数定义时，第一个带有默认值的参数之后的所有参数都必须有默认值，否则，运行时报错</p><h2 id="函数定义时的和"><a href="#函数定义时的和" class="headerlink" title="函数定义时的和*"></a>函数定义时的<em>和</em>*</h2><p>在参数前面加上<code>*</code>号 ，意味着参数个数不止一个，而带一个星号<code>*</code>参数的函数传入的参数存储为一个元组（tuple），带两个<code>*</code>号则是表示字典（dict）。</p><p>*将参数按顺序一一赋值，而dict类型则是将字典的keys作为函数参数进行赋值。</p><p>**参数方式则要求输入必须是一个dict，而且变量名称要与函数定义的变量名称一致</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">a, *b</span>):</span><br><span class="line">  <span class="built_in">print</span>(a)</span><br><span class="line">  <span class="built_in">print</span>(b)</span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">type</span>(b))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">a, **b</span>):</span><br><span class="line">  <span class="built_in">print</span>(a)</span><br><span class="line">  <span class="built_in">print</span>(b)</span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">type</span>(b))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func3</span>(<span class="params">a, *b, **c</span>):</span><br><span class="line">  <span class="built_in">print</span>(a)</span><br><span class="line">  <span class="built_in">print</span>(b)</span><br><span class="line">  <span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func1(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func1(<span class="number">1111</span>,(<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="number">1111</span></span><br><span class="line">((<span class="number">2</span>, <span class="number">3</span>),)<span class="comment">#如果传入一个元组，该元组会被当成元组的第一个参数</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func2(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#17&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    func2(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">TypeError: func2() takes <span class="number">1</span> positional argument but <span class="number">3</span> were given</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func2(<span class="number">1</span>,x=<span class="number">1</span>,y=<span class="number">2</span>)    <span class="comment">#传入的字典参数必须有key和value</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">&#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func2(<span class="number">111</span>,&#123;x=<span class="number">22</span>,y=<span class="number">44</span>&#125;)<span class="comment">#注意是传入的参数作为字典，不能传入dict类型的参数！</span></span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func3(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,x=<span class="number">5</span>,y=<span class="number">6</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure><p>在调用时，*主要是用来解压参数列表，对于set、tuple、list、dict(会取其values的值)类型的数据都适用</p><p>另外一个值得注意的就是参数的顺序，我们知道，最正规的写法就是将这三个参数按<code>*</code>号从少到多排列，那换一种写法呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func4</span>(<span class="params">a,**b,*c</span>):</span><br><span class="line">SyntaxError: invalid syntax<span class="comment">#**参数方式在*参数方式之前，无效</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func5</span>(<span class="params">*b,a</span>):<span class="comment">#*参数方式在不带*的参数之前，可以定义，但注意输入！！</span></span><br><span class="line"><span class="built_in">print</span>(b,<span class="string">&#x27;\n&#x27;</span>,a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func5</span>(<span class="params">**b,a</span>):<span class="comment">#**参数方式在不带*参数方式之前，无效</span></span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func5</span>(<span class="params">**b,*c</span>):<span class="comment">#**参数方式在*参数方式之前，无效</span></span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func5</span>(<span class="params">*b,**c</span>):<span class="comment">#没有不带*的参数，*参数方式在**参数方式之前，有效</span></span><br><span class="line"><span class="built_in">print</span>(b,c)</span><br></pre></td></tr></table></figure><p>但是要注意的是，如果带<code>*</code>的参数在不带<code>*</code>的参数之前，输入的时候要进行明确参数赋值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func6</span>(<span class="params">*b,a</span>):</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a=&quot;</span>,a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func6(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="string">&#x27;222&#x27;</span>,<span class="number">333</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#38&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    func6(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="string">&#x27;222&#x27;</span>,<span class="number">333</span>)</span><br><span class="line">TypeError: func6() missing <span class="number">1</span> required keyword-only argument: <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func6(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="string">&#x27;222&#x27;</span>,a=<span class="number">333</span>)<span class="comment">#输入的时候要进行明确参数赋值</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="string">&#x27;222&#x27;</span>)</span><br><span class="line">a= <span class="number">333</span></span><br></pre></td></tr></table></figure><h2 id="函数参数中的self"><a href="#函数参数中的self" class="headerlink" title="函数参数中的self"></a>函数参数中的self</h2><p>Python类中规定，函数的第一个参数是实例对象本身，并且约定俗成，把其名字写为self。其作用相当于java中的this，表示当前类的对象，可以调用当前类中的属性和方法。</p><p>在<a href="https://www.runoob.com/python3/python3-class.html">菜鸟教程</a>中，对于python类有如下介绍：</p><blockquote><ul><li><strong>类(Class):</strong> 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</li><li><strong>方法：</strong>类中定义的函数。</li><li><strong>类变量：</strong>类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</li><li><strong>数据成员：</strong>类变量或者实例变量用于处理类及其实例对象的相关的数据。</li><li><strong>方法重写：</strong>如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</li><li><strong>局部变量：</strong>定义在方法中的变量，只作用于当前实例的类。</li><li><strong>实例变量：</strong>在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。</li><li><strong>继承：</strong>即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。</li><li><strong>实例化：</strong>创建一个类的实例，类的具体对象。</li><li><strong>对象：</strong>通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</li></ul></blockquote><p>class是面向对象的设计思想，instance（也即是 object，对象）是根据 class 创建的。<br>在类的内部，使用 <strong>def</strong> 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self, 且为第一个参数，self 代表的是类的实例而不是类！<br>self 代表的是类的实例，代表当前对象的地址，而 <code>self.class </code>则指向类。<br>self 不是 python 关键字，我们把他替换成合格的字符串形式参数也是可以正常执行的。</p><h2 id="类中的-init-方法"><a href="#类中的-init-方法" class="headerlink" title="类中的__init__方法"></a>类中的<code>__init__</code>方法</h2><p>类有一个名为·<code>__init__()</code> 的特殊方法（<strong>构造方法</strong>），该方法在类实例化时会自动调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, realpart, imagpart</span>):</span><br><span class="line">        self.r = realpart</span><br><span class="line">        self.i = imagpart</span><br><span class="line">x = Complex(<span class="number">3.0</span>, -<span class="number">4.5</span>)</span><br><span class="line"><span class="built_in">print</span>(x.r, x.i)   <span class="comment"># 输出结果：3.0 -4.5</span></span><br></pre></td></tr></table></figure><h2 id="python-类的继承"><a href="#python-类的继承" class="headerlink" title="python 类的继承"></a>python 类的继承</h2><p>Python 同样支持类的继承，<strong>如果一种语言不支持继承，类就没有什么意义</strong>。</p><p>子类（派生类 DerivedClassName）会继承父类（基类 BaseClassName）的属性和方法。</p><p><code>BaseClassName</code>（实例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment">#类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">people</span>:</span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义私有属性,私有属性在类外部无法直接进行访问</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义构造方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,n,a,w</span>):</span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s 说: 我 %d 岁。&quot;</span> %(self.name,self.age))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#单继承示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>(<span class="title class_ inherited__">people</span>):</span><br><span class="line">    grade = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,n,a,w,g</span>):</span><br><span class="line">        <span class="comment">#调用父类的构函</span></span><br><span class="line">        people.__init__(self,n,a,w)</span><br><span class="line">        self.grade = g</span><br><span class="line">    <span class="comment">#覆写父类的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;</span>%(self.name,self.age,self.grade))</span><br><span class="line">s = student(<span class="string">&#x27;ken&#x27;</span>,<span class="number">10</span>,<span class="number">60</span>,<span class="number">3</span>)</span><br><span class="line">s.speak()</span><br><span class="line"><span class="comment">#执行结果：ken 说: 我 10 岁了，我在读 3 年级</span></span><br></pre></td></tr></table></figure><p>python也支持多重继承</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">people</span>:</span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义私有属性,私有属性在类外部无法直接进行访问</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义构造方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,n,a,w</span>):</span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s 说: 我 %d 岁。&quot;</span> %(self.name,self.age))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#单继承示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>(<span class="title class_ inherited__">people</span>):</span><br><span class="line">    grade = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,n,a,w,g</span>):</span><br><span class="line">        <span class="comment">#调用父类的构函</span></span><br><span class="line">        people.__init__(self,n,a,w)</span><br><span class="line">        self.grade = g</span><br><span class="line">    <span class="comment">#覆写父类的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;</span>%(self.name,self.age,self.grade))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#另一个类，多重继承之前的准备</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">speaker</span>():</span><br><span class="line">    topic = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,n,t</span>):</span><br><span class="line">        self.name = n</span><br><span class="line">        self.topic = t</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;</span>%(self.name,self.topic))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#多重继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sample</span>(speaker,student):</span><br><span class="line">    a =<span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,n,a,w,g,t</span>):</span><br><span class="line">        student.__init__(self,n,a,w,g)</span><br><span class="line">        speaker.__init__(self,n,t)</span><br><span class="line"> </span><br><span class="line">test = sample(<span class="string">&quot;Tim&quot;</span>,<span class="number">25</span>,<span class="number">80</span>,<span class="number">4</span>,<span class="string">&quot;Python&quot;</span>)</span><br><span class="line">test.speak()   <span class="comment">#方法名同，默认调用的是在括号中排前地父类的方法</span></span><br><span class="line"><span class="comment">#执行结果：我叫 Tim，我是一个演说家，我演讲的主题是 Python</span></span><br></pre></td></tr></table></figure><h3 id="类的私有属性"><a href="#类的私有属性" class="headerlink" title="类的私有属性"></a>类的私有属性</h3><p><strong>__private_attrs</strong>：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 <strong>self.__private_attrs</strong>。</p><h3 id="类的方法"><a href="#类的方法" class="headerlink" title="类的方法"></a>类的方法</h3><p>在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 <strong>self</strong>，且<strong>必须</strong>为<strong>第一个</strong>参数，<strong>self</strong> 代表的是类的实例。</p><p><strong>self</strong> 的名字并不是规定死的，也可以使用 <strong>this</strong>，但是最好还是按照约定使用 <strong>self</strong>。</p><h3 id="类的私有方法"><a href="#类的私有方法" class="headerlink" title="类的私有方法"></a>类的私有方法</h3><p><strong>__private_method</strong>：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。<strong>self.__private_methods</strong>。</p><h2 id="lambda表达式（匿名函数）"><a href="#lambda表达式（匿名函数）" class="headerlink" title="lambda表达式（匿名函数）"></a>lambda表达式（匿名函数）</h2><p>如果一个函数的函数体<strong>仅有 1 行</strong>，那么该函数就可以用 lambda 表达式来代替，下面两个函数在表达效果上是相等的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">arg1,...argn</span>):</span><br><span class="line">    <span class="keyword">return</span> 表达式</span><br><span class="line">name = <span class="keyword">lambda</span>  [arg1 [,arg2,.....argn]]: 表达式</span><br></pre></td></tr></table></figure><p>定义 lambda 表达式，必须使用 lambda 关键字，注意冒号前是<strong>参数</strong>，可以有<strong>多个</strong>，用<strong>逗号隔开</strong>，冒号右边的为表达式（只能为一个）。其实lambda返回值是一个函数的地址，也就是函数对象。</p><p>注意传入的参数必须用逗号隔开，下面这么定义是错误的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>add = <span class="keyword">lambda</span> [x,y]:x+y</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add = <span class="keyword">lambda</span> x,y:x+y</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="python中的5种下划线形式"><a href="#python中的5种下划线形式" class="headerlink" title="python中的5种下划线形式"></a>python中的5种下划线形式</h2><ul><li>单前导下划线：**_var**</li><li>单末尾下划线：<strong>var_</strong></li><li>双前导下划线：**__var**</li><li>双前导和末尾下划线：<code>__var__</code></li><li>单下划线：**_**</li></ul><h3 id="单前导下划线：-var"><a href="#单前导下划线：-var" class="headerlink" title="单前导下划线：**_var**"></a>单前导下划线：**_var**</h3><p>，前置单下划线只有约定含义。它对于程序员而言是一种提示——Python社区约定好单下划线表达的是某种意思，其本身并不会影响程序的行为。</p><p>前置下划线的意思是<strong>提示</strong>其他程序员，以单下划线开头的变量或方法只在内部使用。PEP 8中定义了这个约定（PEP 8是最常用的Python代码风格指南。</p><p>详见PEP 8：“Style Guide for Python Code”。</p><p>不过，这个约定对Python解释器并没有特殊含义。与Java不同，Python在“私有”和“公共”变量之间并没有很强的区别。在变量名之前添加一个下划线更像是有人挂出了一个小小的下划线警告标志：“<strong>注意，这并不是这个类的公共接口。最好不要使用它</strong>。”</p><p>我们实例化一个类，并为其添加一个使用单前导下划线的属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.foo = <span class="number">11</span></span><br><span class="line">        self._bar = <span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = Test()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.foo</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t._bar</span><br><span class="line"><span class="number">23</span></span><br></pre></td></tr></table></figure><p><code>_bar</code>前面的单下划线并没有阻止我们“进入”这个类访问变量的值。</p><p>这是因为Python中的前置单下划线只是一个公认的约定，至少在涉及变量名和方法名时是这样的。</p><p><strong>使用单前导下划线需要注意的是</strong>，前置下划线会影响从模块中导入名称的方式，如果使用<strong>通配符<code>*</code>导入</strong>从这个模块中导入所有名称，Python<strong>不会</strong>导入带有前置单下划线的名称（除非模块中定义了<code>__all__</code>列表覆盖了这个行为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在my_module.py中这么定义：</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">external_func</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">23</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_internal_func</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在idle或另一个py文件中导入</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> my_module <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>external_func()</span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_internal_func()</span><br><span class="line">NameError: <span class="string">&quot;name &#x27;_internal_func&#x27; is not defined&quot;</span></span><br></pre></td></tr></table></figure><p>值得注意的是：要<strong>尽可能避免使用通配符<code>*</code>导入</strong>，因为这样就不清楚当前名称空间中存在哪些名称了。为了清楚起见，最好坚持使用常规导入方法。与通配符导入不同，常规导入不受前置单下划线命名约定的影响.</p><p>遵循PEP 8的建议不使用通配符导入，那么真正需要记住的只有下面这一条。<br>以单下划线开头的名称只是Python命名中的约定，表示供内部使用。它通常对Python解释器没有特殊含义，仅仅作为对程序员的提示。</p><h3 id="单末尾下划线：var"><a href="#单末尾下划线：var" class="headerlink" title="单末尾下划线：var_"></a>单末尾下划线：<strong>var_</strong></h3><p>有时某个变量最合适的名称已被Python语言中的关键字占用。因此，诸如<code>class</code>或<code>def</code>的名称不能用作Python中的变量名。在这种情况下，可以追加一个下划线来绕过命名冲突。PEP 8中定义并解释了这个用一个单末尾下划线来避免与python关键字冲突的约定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">name,<span class="keyword">class</span></span>):</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">name,class_</span>):</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>上面介绍的单下划线（无论放在前边还是末尾），都只是约定的作用。</p><h3 id="双前导下划线：-var"><a href="#双前导下划线：-var" class="headerlink" title="双前导下划线：**__var**"></a>双前导下划线：**__var**</h3><p>上面介绍的单下划线（无论放在前边还是末尾），都只是约定的作用。</p><p>但使用以双下划线开头的Python类属性（变量和方法）就不一样了。</p><p>双下划线前缀会让Python解释器重写属性名称，以避免子类中的命名冲突。</p><p>这也称为<strong>名称改写</strong>（name mangling），即解释器会更改变量的名称，以便在稍后扩展这个类时避免命名冲突。</p><h3 id="双前导和末尾下划线：-var"><a href="#双前导和末尾下划线：-var" class="headerlink" title="双前导和末尾下划线：__var__"></a>双前导和末尾下划线：<code>__var__</code></h3><p><strong>一些特殊的双前导和末尾下划线</strong></p><ol><li><p><code>__all__</code></p><p>不像 Ruby 或者 Java，Python 没有语言原生的可见性控制，而是靠一套需要大家自觉遵守的”约定“下工作。比如下划线开头的应该对外部不可见。同样，<code>__all__</code> 也是对于模块公开接口的一种约定，比起下划线，<code>__all__</code> 提供了暴露接口用的”白名单“。一些不以下划线开头的变量（比如从其他地方 <code>import</code> 到当前模块的成员）可以同样被排除出去。</p><p>当我们向文件导入某个模块时，导入的是该模块中那些<strong>名称不以下划线（单下划线“_”或者双下划线“__”）开头</strong>的变量、函数和类。因此，如果我们不想模块文件中的某个成员被引入到其它文件中使用，有两种方法：</p><ol><li>在其名称前添加单下划线。</li><li>借助模块提供的__all__ 变量，该变量的值是一个列表，存储的是当前模块中一些成员（变量、函数或者类）的名称。</li></ol><p>通过在模块文件中设置__all__变量，当其它文件以“from 模块名 import *”的形式导入该模块时，该文件中只能使用__all__ 列表中指定的成员。__all__也是对于模块公开接口的一种约定，比起下划线，__all__提供了暴露接口用的“白名单”。<br>       ————————————————<br>      版权声明：本文为CSDN博主「-徐徐图之-」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>      原文链接：<a href="https://blog.csdn.net/zylooooooooong/article/details/115564782">https://blog.csdn.net/zylooooooooong/article/details/115564782</a></p></li><li><p><code>__init__</code></p><p>在创建类时，我们可以手动添加一个<code>__init__()</code>方法，该方法是一个特殊的类实例方法，称为构造方法（或构造函数）。</p><p>构造方法用于创建对象时使用，每当创建一个类的实例对象时，<a href="http://c.biancheng.net/python/">Python</a> 解释器都会自动调用它。</p><p><code>__init__() </code>方法可以包含多个参数，但必须包含一个名为 self 的参数，且必须作为第一个参数。</p><p>即便不手动为类添加任何构造方法，Python 也会自动为类添加一个仅包含 self 参数的构造方法。</p><p>如果子类中不重写<code>__init__</code>，实例化子类时，就会调用父类中定义的<code>__init__</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        <span class="built_in">print</span> ( <span class="string">&quot;name: %s&quot;</span> %( self.name) )</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getName</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Father &#x27;</span> + self.name</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>(<span class="title class_ inherited__">Father</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getName</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Son &#x27;</span>+self.name</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    son=Son(<span class="string">&#x27;runoob&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span> ( son.getName() )</span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line">name: runoob</span><br><span class="line">Son runoob</span><br></pre></td></tr></table></figure><p>如果重写了**<strong>init</strong>** 时，实例化子类，就不会调用父类已经定义的 **<strong>init</strong>**，语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        <span class="built_in">print</span> ( <span class="string">&quot;name: %s&quot;</span> %( self.name) )</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getName</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Father &#x27;</span> + self.name</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>(<span class="title class_ inherited__">Father</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">print</span> ( <span class="string">&quot;hi&quot;</span> )</span><br><span class="line">        self.name =  name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getName</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Son &#x27;</span>+self.name</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    son=Son(<span class="string">&#x27;runoob&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span> ( son.getName() )</span><br><span class="line"><span class="comment">#输出结果：</span></span><br><span class="line">hi</span><br><span class="line">Son runoob</span><br></pre></td></tr></table></figure><p>若重写了<code>__init__</code>，还要继承父类的构造方法，可以使用<code>super</code>关键字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        <span class="built_in">print</span> ( <span class="string">&quot;name: %s&quot;</span> %( self.name))</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getName</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Father &#x27;</span> + self.name</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>(<span class="title class_ inherited__">Father</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">super</span>(Son, self).__init__(name)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;hi&quot;</span>)</span><br><span class="line">        self.name =  name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getName</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Son &#x27;</span>+self.name</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    son=Son(<span class="string">&#x27;runoob&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span> ( son.getName() )</span><br><span class="line">    </span><br><span class="line"><span class="comment">#输出结果如下：</span></span><br><span class="line">name: runoob</span><br><span class="line">hi</span><br><span class="line">Son runoob</span><br></pre></td></tr></table></figure><p>也可以直接调用父类的<code>__init__</code>类方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dad = Father(<span class="string">&#x27;luo&#x27;</span>)</span><br><span class="line">name: luo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dad.__init__()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#10&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    dad.__init__()</span><br><span class="line">TypeError: __init__() missing <span class="number">1</span> required positional argument: <span class="string">&#x27;name&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dad.__init__(<span class="string">&quot;WHALE&quot;</span>)</span><br><span class="line">name: WHALE</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dad.name</span><br><span class="line"><span class="string">&#x27;WHALE&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><code>__name__</code></p><p>一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用<code>__name__</code>属性来使该程序块仅在该模块自身运行时执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># Filename: using_name.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;程序自身在运行&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;我来自另一模块&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#以下是程序运行结果</span></span><br><span class="line">$ python using_name.py<span class="comment">#在模块自身运行时</span></span><br><span class="line">程序自身在运行</span><br><span class="line">$ python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> using_name<span class="comment">#在模块被引用时</span></span><br><span class="line">我来自另一模块</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>注意：每个模块都有一个<code>__name__</code>属性，当其值是<code>__main__</code>时，表明该模块自身在运行，否则是被引入。</p></li><li></li></ol><h3 id="单下划线："><a href="#单下划线：" class="headerlink" title="单下划线：**_**"></a>单下划线：**_**</h3><p>有时候单个独立下划线是用作一个名字，来表示某个变量是临时的或无关紧要的。</p><p>例如，在下面的循环中，我们不需要访问正在运行的索引，我们可以使用”_”来表示它只是一个临时值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line"><span class="meta">... </span>   <span class="built_in">print</span>(<span class="string">&#x27;Hello, World.&#x27;</span>)</span><br></pre></td></tr></table></figure><p>你也可以在拆分(unpacking)表达式中将单个下划线用作”不关心的”变量，以忽略特定的值。 同样，这个含义只是”依照约定”，并不会在Python解释器中触发特殊的行为。 单个下划线仅仅是一个有效的变量名称，会有这个用途而已。</p><p>在下面的代码示例中，我将汽车元组拆分为单独的变量，但我只对颜色和里程值感兴趣。 但是，为了使拆分表达式成功运行，我需要将包含在元组中的所有值分配给变量。 在这种情况下，”_”作为占位符变量可以派上用场：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>car = (<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;auto&#x27;</span>, <span class="number">12</span>, <span class="number">3812.4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>color, _, _, mileage = car</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>color</span><br><span class="line"><span class="string">&#x27;red&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mileage</span><br><span class="line"><span class="number">3812.4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><p>除了用作临时变量之外，”_”是大多数Python REPL中的一个特殊变量，它表示由解释器评估的最近一个表达式的结果。</p><p>这样就很方便了，比如你可以在一个解释器会话中访问先前计算的结果，或者，你是在动态构建多个对象并与它们交互，无需事先给这些对象分配名字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">20</span> + <span class="number">3</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_</span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(_)</span><br><span class="line"><span class="number">23</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>()</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_.append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_.append(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_.append(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>对于上面五种类型的下划线，<a href="https://www.runoob.com/w3cnote/python-5-underline.html">菜鸟教程的小结</a>可以很好的帮助我们：</p><p><img src="E:\JS练习\blog\Myblog\source\images\python下划线类型小结.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;python3中的一些常见语法糖整理&quot;&gt;&lt;a href=&quot;#python3中的一些常见语法糖整理&quot; class=&quot;headerlink&quot; title=&quot;python3中的一些常见语法糖整理&quot;&gt;&lt;/a&gt;python3中的一些常见语法糖整理&lt;/h1&gt;&lt;h2 id=&quot;输</summary>
      
    
    
    
    <category term="Programming languages and projects" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/"/>
    
    <category term="Python3" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"/>
    
    
    <category term="python3" scheme="http://justskim.github.io/tags/python3/"/>
    
  </entry>
  
  <entry>
    <title>linux的进程优先级与进程调度策略</title>
    <link href="http://justskim.github.io/2021/10/23/linux%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%8E%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/"/>
    <id>http://justskim.github.io/2021/10/23/linux%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%8E%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/</id>
    <published>2021-10-23T12:38:09.488Z</published>
    <updated>2021-10-25T07:05:02.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux的进程优先级与进程调度策略"><a href="#linux的进程优先级与进程调度策略" class="headerlink" title="linux的进程优先级与进程调度策略"></a>linux的进程优先级与进程调度策略</h1><h2 id="linux中的进程调度策略"><a href="#linux中的进程调度策略" class="headerlink" title="linux中的进程调度策略"></a>linux中的进程调度策略</h2><p>FIFO，RR，OTHER</p><p>实时进程会抢占普通进程，FIFO会导致同优先级实时进程始终占用CPU，RR会保证同优先级实时进程按时间片轮流执行。</p><p>上面说的很通俗易懂，那么，两个同等优先级的FIFO实时进程，是不是谁先占据了cpu，另一个就只能等待它完成了让出CPU呢？</p><p>其实不尽然，即使是在单核cpu的linux系统中，FIFO实时进程也会被调度。</p><p>具体可见博客：</p><p>cnblogs.com&#x2F;tongye&#x2F;p&#x2F;9575602.html</p><p>blog.csdn.net&#x2F;qq_37451250&#x2F;article&#x2F;details&#x2F;104807725</p><h2 id="C语言中的进程优先级设置"><a href="#C语言中的进程优先级设置" class="headerlink" title="C语言中的进程优先级设置"></a>C语言中的进程优先级设置</h2><p>创建实时进程与普通进程略有区别——在创建普通进程的基础上，将调度类从CFS（completely fair完全公平调度类）转向RT类（实时调度类型，包括RR和FIFO）</p><p>常见的几个进程优先级设置与取得函数（位于头文件sched.h中）：</p><p>sched_get_priority_max()  取得静态优先级的上限</p><p>sched_get_priority_min()  取得静态优先级的下限</p><p>sched_getparam()取得进程的调度参数</p><p>sched_setparam()设置进程的调度参数</p><p>sched_getscheduler()取得指定进程的调度类</p><p>sched_setscheduler()设置指定进程的调度类</p><blockquote><p>int sched_getscheduler(pid_t pid, int policy, const struct sched_param *param)</p><p>第一个参数是进程号（0表示本进程），第二个参数为调度类（SCHED_RR为2、SCHED_FIFO为1、SCHED_OTHER为0，三个之一） ，第三个参数是一个struct sched_param 类型的调度参数——其sched_priority成员可以指定优先级。</p></blockquote><p>sched_rr_get_interval()取得按RR算法调度的实时进程的时间片长度</p><p>sched_yield()进程主动让出处理器并将自己挂入等候调度队列的队尾</p><p>sched文件</p><p><strong>C语言system函数</strong></p><p>执行 dos(windows系统) 或 shell(Linux&#x2F;Unix系统) 命令，参数字符串command为命令名。另，在windows系统下参数字符串不区分大小写。</p><p>说明：在windows系统中，system函数直接在控制台调用一个command命令。<br>在Linux&#x2F;Unix系统中，system函数会调用fork函数产生子进程，由子进程来执行command命令，命令执行完后随即返回原调用的进程。</p><p>函数返回值<br>命令执行成功返回0，执行失败返回-1。</p><p><strong>C语言sprintf函数</strong></p><p>int sprintf( char *buffer, const char *format, [ argument] … )；</p><p>这个函数包含三个部分的参数：</p><p>buffer：char型指针，指向将要写入的字符串的缓冲区。format：格式化字符串。即可选参数的想要输入的数据类型。[argument]…：可选参数，可以是任何类型的数据。</p><p>这个函数就是把第三部分的数据，按照第二部分格式化字符的格式，把第三部分的数据进行”格式化“，然后在<strong>把格式化后的数据类型，存储到字符串</strong>的缓存区间里去。</p><p>通过查看&#x2F; proc &#x2F;&lt; PID&gt; &#x2F; sched中的调度统计信息(scheduling stats in <code>/proc/&lt;PID&gt;/sched</code>),您可以获得如下输出（仅限进程运行着的时候）</p><p>为了在进程退出后依然能看到这些调度统计信息，我们可以使用以上代码将其存储至本目录的sched-pid文件中</p><p>&gt; nr_switches：上下文切换次数.<br>&gt; nr_voluntary_switches：自愿切换的数量,即线程被阻塞,因此拾取另一个线程.<br>&gt; nr_involuntary_switches：调度程序将线程踢出,因为有另一个饥饿的线程已准备好运行.</p><h2 id="C语言中的进程调度函数"><a href="#C语言中的进程调度函数" class="headerlink" title="C语言中的进程调度函数"></a>C语言中的进程调度函数</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;linux的进程优先级与进程调度策略&quot;&gt;&lt;a href=&quot;#linux的进程优先级与进程调度策略&quot; class=&quot;headerlink&quot; title=&quot;linux的进程优先级与进程调度策略&quot;&gt;&lt;/a&gt;linux的进程优先级与进程调度策略&lt;/h1&gt;&lt;h2 id=&quot;l</summary>
      
    
    
    
    <category term="Linux" scheme="http://justskim.github.io/categories/Linux/"/>
    
    
    <category term="linux" scheme="http://justskim.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>在vmware中“/mnt/hgfs”路径下共享文件夹的挂载</title>
    <link href="http://justskim.github.io/2021/10/23/%E5%9C%A8vmware%E4%B8%AD%E2%80%9Cmnthgfs%E2%80%9D%E8%B7%AF%E5%BE%84%E4%B8%8B%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E6%8C%82%E8%BD%BD/"/>
    <id>http://justskim.github.io/2021/10/23/%E5%9C%A8vmware%E4%B8%AD%E2%80%9Cmnthgfs%E2%80%9D%E8%B7%AF%E5%BE%84%E4%B8%8B%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E6%8C%82%E8%BD%BD/</id>
    <published>2021-10-23T12:13:05.314Z</published>
    <updated>2021-10-23T12:28:45.188Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在vmware中“-x2F-mnt-x2F-hgfs”路径下共享文件夹的挂载"><a href="#在vmware中“-x2F-mnt-x2F-hgfs”路径下共享文件夹的挂载" class="headerlink" title="在vmware中“&#x2F;mnt&#x2F;hgfs”路径下共享文件夹的挂载"></a>在vmware中“&#x2F;mnt&#x2F;hgfs”路径下共享文件夹的挂载</h1><p>在之前的博客中，我们已经讲过如何在vmware虚拟机中设置共享文件夹，mnt目录是挂接光驱、USB设备的目录，在其中进行文件操作需要有root权限。linux系统中一定会有&#x2F;mnt目录，但其下不一定有hgfs目录，在我们成功安装完VMWare tools后会出现hgfs文件夹，但一些情况下hgfs文件夹中可能不存在我们之前在虚拟机中设置的共享文件夹名称，下面是解决办法</p><h2 id="x2F-mnt路径下有hgfs但却没有共享文件夹"><a href="#x2F-mnt路径下有hgfs但却没有共享文件夹" class="headerlink" title="&#x2F;mnt路径下有hgfs但却没有共享文件夹"></a>&#x2F;mnt路径下有hgfs但却没有共享文件夹</h2><p>先进入到root权限下，使用命令<code>vmware-hgfsclient</code>来查看当前有哪些共享的目录，如果未能成功安装VMWare tools则该命令会导致报错。</p><p>然后使用命令<code>mount -t vmhgfs .host:/你所设置的共享文件夹名称 /mnt/hgfs</code>来挂载共享文件夹即可。</p><p>以上设置后每次重新开机都要重复设置一次共享文件夹，我们使用在文件<code>/etc/fstab</code>中进行修改来设置开机后自动挂载：</p><p>在文件<code>/etc/fstab</code>中添加以下一行：<code>.host:/mnt/hgfs vmhgfs defaults 0 0</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;在vmware中“-x2F-mnt-x2F-hgfs”路径下共享文件夹的挂载&quot;&gt;&lt;a href=&quot;#在vmware中“-x2F-mnt-x2F-hgfs”路径下共享文件夹的挂载&quot; class=&quot;headerlink&quot; title=&quot;在vmware中“&amp;#x2F;m</summary>
      
    
    
    
    <category term="Linux" scheme="http://justskim.github.io/categories/Linux/"/>
    
    
    <category term="linux" scheme="http://justskim.github.io/tags/linux/"/>
    
    <category term="虚拟机" scheme="http://justskim.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    <category term="ubuntu" scheme="http://justskim.github.io/tags/ubuntu/"/>
    
    <category term="vmware" scheme="http://justskim.github.io/tags/vmware/"/>
    
  </entry>
  
  <entry>
    <title>linux的权限与隐藏权限</title>
    <link href="http://justskim.github.io/2021/09/27/linux%E7%9A%84%E6%9D%83%E9%99%90%E4%B8%8E%E9%9A%90%E8%97%8F%E6%9D%83%E9%99%90/"/>
    <id>http://justskim.github.io/2021/09/27/linux%E7%9A%84%E6%9D%83%E9%99%90%E4%B8%8E%E9%9A%90%E8%97%8F%E6%9D%83%E9%99%90/</id>
    <published>2021-09-27T12:26:36.587Z</published>
    <updated>2021-09-29T02:11:21.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux的权限与隐藏权限"><a href="#linux的权限与隐藏权限" class="headerlink" title="linux的权限与隐藏权限"></a>linux的权限与隐藏权限</h1><h2 id="linux的权限"><a href="#linux的权限" class="headerlink" title="linux的权限"></a>linux的权限</h2><h3 id="linux中的文件类型"><a href="#linux中的文件类型" class="headerlink" title="linux中的文件类型"></a>linux中的文件类型</h3><p>　　linux一共有7种文件类型,分别如下:</p><p>​    　　 -：普通文件</p><p>​     　d：目录文件</p><p>​     　l： 软链接（类似Windows的快捷方式）</p><p>​    　　(<strong>下面四种是特殊文件)</strong></p><p>​     　b：块设备文件（例如硬盘、光驱等）</p><p>​    　　 p：管道文件</p><p>​     　c：字符设备文件（例如猫等串口设备）</p><p>​     　s：套接口文件&#x2F;数据接口文件（例如启动一个MySql服务器时会产生一个mysql.sock文件）</p><h2 id="linux的隐藏权限"><a href="#linux的隐藏权限" class="headerlink" title="linux的隐藏权限"></a>linux的隐藏权限</h2><p>除了文件的读写,执行权限外,linux还有一种隐藏权限,设置隐藏权限可以防止一些其他用户的误操作或者恶意操作,当我们配置了<code>nginx</code>的放跨站攻击或其他安全措施后,相应的会在项目的根目录下生成一个隐藏文件<code>.user.ini</code>,当删除整个项目时会阻止操作完成.我们使用<code>ls</code>命令并使用<code>chmod chown</code>等命令设置了文件权限后会发现还是无法删除.这就是因为这个文件有隐藏的权限。</p><p>linux系统的隐藏权限总共有以下十三种类型：</p><ul><li><p>A：即Atime，告诉系统不要修改对这个文件的最后访问时间；</p></li><li><p>S：即Sync，一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘；</p></li><li><p>a：即Append Only，系统只允许在这个文件之后追加数据，不允许任何进程覆盖或截断这个文件。如果目录具有这个属性，系统将只允许在这个目录下建立和修改文件，而不允许删除任何文件；</p></li><li><p>b：不更新文件或目录的最后存取时间；</p></li><li><p>c：将文件或目录压缩后存放；</p></li><li><p>d：当dump程序执行时，该文件或目录不会被dump备份；</p></li><li><p>D:检查压缩文件中的错误；</p></li><li><p>i：即Immutable，系统不允许对这个文件进行任何的修改。如果目录具有这个属性，那么任何的进程只能修改目录之下的文件，不允许建立和删除文件；</p></li><li><p>s：彻底删除文件，不可恢复，因为是从磁盘上删除，然后用0填充文件所在区域；</p></li><li><p>u：当一个应用程序请求删除这个文件，系统会保留其数据块以便以后能够恢复删除这个文件，用来防止意外删除文件或目录；</p></li><li><p>t:文件系统支持尾部合并（tail-merging）；</p></li><li><p>X：可以直接访问压缩文件的内容 </p></li><li><p>e: 表示文件以ext4 extents存储的，ext4上新建文件的默认属性，<strong>不可用chattr修改</strong>。</p></li></ul><p>使用命令<code>chattr +权限类型</code>和<code>chattr -权限类型</code>可以为文件添加或删除隐藏权限</p><h2 id="chattr命令"><a href="#chattr命令" class="headerlink" title="chattr命令"></a>chattr命令</h2><p>提到文件权限的修改，必然绕不过这一命令，根据<a href="http://c.biancheng.net/view/874.html">C语言中文网</a>（这个网站怎么啥都有）：</p><blockquote><p>chattr 命令，专门用来修改文件或目录的隐藏属性，只有 root 用户可以使用。该命令的基本格式为：</p><p>[root@localhost ~]# chattr [+-&#x3D;] [属性] 文件或目录名</p></blockquote><p>下面是常用chattr命令来授予&#x2F;删除的一些属性：</p><table><thead><tr><th>属性选项</th><th>功能</th></tr></thead><tbody><tr><td>i</td><td>如果对文件设置 i 属性，那么不允许对文件进行删除、改名，也不能添加和修改数据； 如果对目录设置 i 属性，那么只能修改目录下文件中的数据，但不允许建立和删除文件；</td></tr><tr><td>a</td><td>如果对文件设置 a 属性，那么只能在文件中増加数据，但是不能删除和修改数据； 如果对目录设置 a 属性，那么只允许在目录中建立和修改文件，但是不允许删除文件；</td></tr><tr><td>u</td><td>设置此属性的文件或目录，在删除时，其内容会被保存，以保证后期能够恢复，常用来防止意外删除文件或目录。</td></tr><tr><td>s</td><td>和 u 相反，删除文件或目录时，会被彻底删除（直接从硬盘上删除，然后用 0 填充所占用的区域），不可恢复。</td></tr><tr><td>b</td><td>不更新文件或目录的最后存取时间。</td></tr><tr><td>c</td><td>将文件或目录压缩后存放。</td></tr><tr><td>d</td><td>将文件或目录排除在倾倒操作之外</td></tr><tr><td>S</td><td>即时更新文件或目录</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;linux的权限与隐藏权限&quot;&gt;&lt;a href=&quot;#linux的权限与隐藏权限&quot; class=&quot;headerlink&quot; title=&quot;linux的权限与隐藏权限&quot;&gt;&lt;/a&gt;linux的权限与隐藏权限&lt;/h1&gt;&lt;h2 id=&quot;linux的权限&quot;&gt;&lt;a href=&quot;#l</summary>
      
    
    
    
    <category term="Linux" scheme="http://justskim.github.io/categories/Linux/"/>
    
    
    <category term="linux" scheme="http://justskim.github.io/tags/linux/"/>
    
  </entry>
  
</feed>
