<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://justskim.github.io/atom.xml" rel="self"/>
  
  <link href="http://justskim.github.io/"/>
  <updated>2022-03-05T09:59:52.900Z</updated>
  <id>http://justskim.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Windows系统下环境变量配置与计算机重启</title>
    <link href="http://justskim.github.io/2022/03/05/Windows%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E5%90%AF/"/>
    <id>http://justskim.github.io/2022/03/05/Windows%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E5%90%AF/</id>
    <published>2022-03-05T08:50:11.668Z</published>
    <updated>2022-03-05T09:59:52.900Z</updated>
    
    <content type="html"><![CDATA[<p>我们来看一下<a href="https://blog.csdn.net/shuixin536/article/details/8084612">对于Windows不重启使环境变量修改生效的解释</a>：</p><blockquote><p>一个程序启动时，环境变量被复制到该程序所在的环境中，在该程序执行过程中不会被除该程序以外的其他程序所改变。也就是说，假设我们启动了一个cmd程序，然后通过控制面板修改了环境变量设置，但是已经启动了的cmd所拥有的环境变量并不会被改变。如果我们在修改环境变量之后启动cmd程序，则该程序将拥有新的环境变量。<br>那么结论就很明显了：修改环境变量之后，如果受影响的是应用程序，那么只要简单地重新启动此应用程序，环境变量的修改就会反映到该程序中，而不必重新启动计算机；但是，如果受影响的是系统服务，就必须重新启动才能将环境变量的修改反映到系统服务中（因为没有办法在不重启计算机的情况下重新启动系统服务管理器）</p></blockquote><p>那么有没有什么办法可以不重启就使一切修改的环境变量配置生效呢？有，当我们很不想重启windows系统时可以尝试这么做：</p><blockquote><p>以修改环境变量“PATH”为例，修改完成后，进入DOS命令提示符，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set PATH=C: 1</span><br></pre></td></tr></table></figure><p>关闭DOS窗口。再次打开DOS窗口，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo %PATH% 1</span><br></pre></td></tr></table></figure><p>可以发现“我的电脑”-&gt;“属性”-&gt;“高级”-&gt;“环境变量”中设置的 PATH 值已经生效。<br>不用担心DOS窗口中的修改会影响环境变量的值，DOS窗口中的环境变量只是Windows环境变量的一个副本而已。但是对副本的修改却会引发Windows环境变量的刷新，这正是我们想要的！</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们来看一下&lt;a href=&quot;https://blog.csdn.net/shuixin536/article/details/8084612&quot;&gt;对于Windows不重启使环境变量修改生效的解释&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个程序启动时，环境变量被复</summary>
      
    
    
    
    <category term="Windows" scheme="http://justskim.github.io/categories/Windows/"/>
    
    
    <category term="windows" scheme="http://justskim.github.io/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>Java基础语法学习要注意的小细节</title>
    <link href="http://justskim.github.io/2022/03/02/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%B0%8F%E7%BB%86%E8%8A%82/"/>
    <id>http://justskim.github.io/2022/03/02/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%B0%8F%E7%BB%86%E8%8A%82/</id>
    <published>2022-03-01T19:38:13.360Z</published>
    <updated>2022-03-05T12:15:47.550Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java基础语法学习要注意的小细节"><a href="#Java基础语法学习要注意的小细节" class="headerlink" title="Java基础语法学习要注意的小细节"></a>Java基础语法学习要注意的小细节</h1><p><strong>最最基本的</strong></p><p><code>Java</code><strong>8</strong>和11是两个最常用的版本，也是推荐新手起步安装的版本，博主一开始使用最新的JDK17，但很多文件位置和环境配置都不同，看使用旧版本的开发教程时很麻烦。Java平台包括Java se(J2SE，标准版)  Java ee(J2EE，企业版，J2SE是其子集) Java me(J2ME，用于嵌入式的，比较少)。普通用户只需安装JER(Java Runtime Environment)来运行Java程序，而开发者必须安装JDK来对程序进行编译调试。版本的关系对应为：Java X &#x3D; Java SE X &#x3D; JDK 1.X 。</p><p>对于Java SE，<a href="https://www.huoxiaoqiang.com/experience/javae/2381.html">各大厂商的JDK</a>有所区别。官网的下载速度很慢还要注册账号，我们可以在<a href="https://blog.csdn.net/wanghao72214/article/details/109720371">推荐的三家国内jdk镜像站</a>中下载相应的JDK。其中，<a href="https://mirrors.tuna.tsinghua.edu.cn/AdoptOpenJDK/11/jdk/x64/windows/">清华大学开源软件镜像站</a>的<code>JDK</code>为Eclipse Temurin Java SE，由Eclipse基金会发布，即OpenJDK的”生产就绪“构建，免费试用，且所有版本都通过了Oracle的Java SE技术兼容性工具包测试以及Eclipse AQAvit互操作性和性能测试。不过博主还是选择了传统的OpenJDK11版本，在之后可能会再使用探究（尽可能省去麻烦）。安装<code>JDK</code>时，路径中不能有中文和空格，并且要单独取消外部公共<code>JRE</code>的安装。</p><p>虚拟机 <code>JVM</code> ⫋ 运行环境 <code>JRE</code> ⫋ 开发工具 <code>JDK </code></p><p><strong>编译的编码与修改环境变量</strong></p><p>使用命令<code>javac </code>编译<code>java</code>文件，可能会出现中文信息乱码的情况，我们首先选择添加参数<code>-encoding UTF8</code>来解决问题。但博主在卸载Java11，转而安装Java9后出现的乱码问题却无法通过此方式解决。但是博主看到在一大堆的乱码报错信息前有这么一条：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF-<span class="number">8</span></span><br></pre></td></tr></table></figure><p>这可能是博主先前想通过startup.bat文件来启动tomcat10，而千方百计设置Java11环境变量遗留下来的，于是博主在环境变量中将此系统变量移除。</p><p><img src="/images/%E5%88%A0%E9%99%A4JAVA_TOOL_OPTIONS%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%90%8E%E9%87%8D%E5%90%AF.png" alt="删除JAVA_TOOL_OPTIONS环境变量后重启"></p><p>重新打开一个<code>cmd</code>窗口，执行编译命令依然乱码。只好在重启后重来一次，才成功编译。</p><p><strong>文件名和类名</strong></p><p>一个<code>java</code>文件中可以有很多类，但最多只能有一个类的类名和文件名相同——如果该类被<code>public</code>修饰，那么其类名必须和文件名相同，<strong>一个<code>java</code>文件中也最多只有一个类被public修饰</strong>。</p><p>尽管windows系统下文件名不区分大小写，但为了方便起见，以及在Linux操作系统下文件能被顺利编译执行，我们所有的<code>java</code>文件名及public修饰类，以及在windows控制台下运行时输入的文件名，都要保持一致的大小写！</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>&gt;<span class="title">javac</span>  <span class="title">DEMOCONST.java</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>&gt;<span class="title">java</span>  <span class="title">DEMOCONST</span></span></span><br><span class="line"><span class="function">错误: 找不到或无法加载主类 <span class="title">DEMOCONST</span></span></span><br><span class="line"><span class="function">原因: <span class="title">java.lang.NoClassDefFoundError</span>: <span class="title">DemoConst</span> (<span class="title">wrong</span> <span class="title">name</span>: <span class="title">DEMOCONST</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>&gt;<span class="title">java</span>  <span class="title">DemoConst</span></span></span><br><span class="line"><span class="function"><span class="title">the</span> <span class="title">name</span> <span class="title">of</span> <span class="title">class</span> <span class="title">is</span> <span class="title">democonst</span></span></span><br><span class="line"><span class="function"><span class="title">true</span></span></span><br><span class="line"><span class="function"><span class="title">false</span></span></span><br><span class="line"><span class="function">#可以看到，对于文件<span class="title">Democonst.java</span>，大小写不一致情况下<span class="title">javac</span>命令能编译，但<span class="title">java</span>命令不能执行</span></span><br></pre></td></tr></table></figure><p><strong>引用路径和包</strong><br>在学习类和对象的时候，博主定义了两个程序，并将其放在同一个文件夹(cn)下，首先是定义一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//package cn;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="comment">//成员变量</span></span><br><span class="line">String name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="comment">//成员方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;eat now!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;sleep now!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;study now!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，是在另一个Java程序中使用这个类创建对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//package cn;</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;<span class="comment">//这一行可以让我们引用同一个目标文件夹下的java类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demoStudent</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line"><span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">System.out.println(<span class="string">&quot;student&#x27;s name is &quot;</span>+stu.name);</span><br><span class="line">System.out.println(<span class="string">&quot;student&#x27;s age is &quot;</span>+stu.age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们在控制台可以编译后执行程序，注意，声明后<strong>没有被赋值的成员变量会有一个默认值（但是Java中局部变量未赋值将无法通过编译）</strong></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>\<span class="title">cn</span>&gt;<span class="title">javac</span> -<span class="title">encoding</span> <span class="title">UTF</span>-8 <span class="title">demoStudent.java</span></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>\<span class="title">cn</span>&gt;<span class="title">java</span> <span class="title">demoStudent</span></span></span><br><span class="line"><span class="function"><span class="title">student</span>&#x27;<span class="title">s</span> <span class="title">name</span> <span class="title">is</span> <span class="title">null</span></span></span><br><span class="line"><span class="function"><span class="title">student</span>&#x27;<span class="title">s</span> <span class="title">age</span> <span class="title">is</span> 0</span></span><br></pre></td></tr></table></figure><p>而如果我们取消注释的代码，并将<code>import java.io.*;</code>这一行注释掉，会发现，第二个程序编译时会报错：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>\<span class="title">cn.itcast.demo</span>&gt;<span class="title">javac</span> -<span class="title">encoding</span> <span class="title">UTF</span>-8 <span class="title">demoStudent.java</span></span></span><br><span class="line"><span class="function"><span class="title">demoStudent.java</span>:5: 错误: 无法访问<span class="title">Student</span></span></span><br><span class="line"><span class="function">                <span class="title">Student</span> <span class="title">stu</span> = <span class="title">new</span> <span class="title">Student</span>();</span></span><br><span class="line"><span class="function">                ^</span></span><br><span class="line"><span class="function">  错误的源文件: .\<span class="title">Student.java</span></span></span><br><span class="line"><span class="function">    文件不包含类<span class="title">Student</span></span></span><br><span class="line"><span class="function">    请删除该文件或确保该文件位于正确的源路径子目录中。</span></span><br><span class="line"><span class="function">1 个错误</span></span><br></pre></td></tr></table></figure><p>但是这样的写法在Eclipse软件的Java项目中又是能正常运行的，因此，博主决定探究一下Java的package机制，以及其在Windows系统下的编译机制，来确定我们命令语句该怎么输入（Eclipse和IDEA这类软件肯定是把这个步骤封装好的，不过我还是要了解这个原理）。</p><p>类是Java中一种引用数据类型（Java中除了八种基本数据类型，其它的都是<strong>对象，也就是引用类型，包括数组</strong>和字符串），对其使用以下三步走：</p><ol><li>导包：<ul><li>如果要使用的目标类，和当前类（含有main方法）位于<strong>同一个包</strong>下，可以省略导包不写；</li><li>否则需要使用<code>import</code>导包语句。</li></ul></li><li>创建对象：类名称 对象名 &#x3D; new 类名称();</li><li>使用。</li></ol><p>最后，我们根据该<a href="https://blog.csdn.net/scgaliguodong123_/article/details/41804667">博客</a>提出的方法，能在命令行中正确编译并执行以上的Java文件——配置参数，编译后，<strong>返回到包名父目录</strong>，运行程序。</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>\<span class="title">cn</span>&gt;<span class="title">javac</span> -<span class="title">encoding</span> <span class="title">UTF</span>-8 -<span class="title">sourcepath</span> <span class="title">E</span>:/<span class="title">Java_practice</span> <span class="title">demoStudent.java</span></span></span><br><span class="line"><span class="function">#注意！<span class="title">sourcepath</span>参数这里不能带上任何一级的包名，就能正确编译</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>\<span class="title">cn</span>&gt;<span class="title">java</span> <span class="title">demoStudent</span></span></span><br><span class="line"><span class="function">错误: 找不到或无法加载主类 <span class="title">demoStudent</span></span></span><br><span class="line"><span class="function">原因: <span class="title">java.lang.NoClassDefFoundError</span>: <span class="title">cn</span>/<span class="title">demoStudent</span> (<span class="title">wrong</span> <span class="title">name</span>: <span class="title">demoStudent</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>\<span class="title">cn</span>&gt;<span class="title">java</span> <span class="title">cn.demoStudent</span></span></span><br><span class="line"><span class="function">错误: 找不到或无法加载主类 <span class="title">cn.demoStudent</span></span></span><br><span class="line"><span class="function">原因: <span class="title">java.lang.ClassNotFoundException</span>: <span class="title">cn.demoStudent</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>\<span class="title">cn</span>&gt;<span class="title">cd</span> ..</span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>&gt;<span class="title">java</span> <span class="title">cn.demoStudent</span></span></span><br><span class="line"><span class="function"><span class="title">student</span>&#x27;<span class="title">s</span> <span class="title">name</span> <span class="title">is</span> <span class="title">null</span></span></span><br><span class="line"><span class="function"><span class="title">student</span>&#x27;<span class="title">s</span> <span class="title">age</span> <span class="title">is</span> 0</span></span><br><span class="line"><span class="function">#在控制台编译运行，使用<span class="title">java</span>命令运行时要加上包名：<span class="title">java</span> 包名.类名</span></span><br></pre></td></tr></table></figure><p>我们重新写一下两个文件，这次弄的复杂点，我们两个文件是在多级包(<code>cn.demo</code>)下的：</p><p><img src="/images/%E5%90%8C%E4%B8%80%E4%B8%AA%E5%8C%85%E4%B8%8B%E7%9A%84%E4%B8%A4%E4%B8%AAjava%E6%96%87%E4%BB%B6.png" alt="同一个包下的两个java文件"></p><p>在控制台中使用<code>tree</code>命令查看目录结构树，可以看到，这两个文件都放在demo文件夹下：</p><p><img src="/images/%E5%8C%85cn.demo%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E6%A0%91.png" alt="包cn.demo的目录结构树"></p><p>在控制台中的正确编译运行命令如下：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>\<span class="title">cn</span>\<span class="title">demo</span>&gt;<span class="title">javac</span> -<span class="title">encoding</span> <span class="title">UTF</span>-8 -<span class="title">classpath</span> <span class="title">E</span>:/<span class="title">Java_practice</span> <span class="title">Student.java</span></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>\<span class="title">cn</span>\<span class="title">demo</span>&gt;<span class="title">javac</span> -<span class="title">encoding</span> <span class="title">UTF</span>-8 -<span class="title">classpath</span> <span class="title">E</span>:/<span class="title">Java_practice</span> <span class="title">demoStudent.java</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>\<span class="title">cn</span>\<span class="title">demo</span>&gt;<span class="title">cd</span> ..</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>\<span class="title">cn</span>&gt;<span class="title">java</span> <span class="title">demo.demoStudent</span></span></span><br><span class="line"><span class="function">错误: 找不到或无法加载主类 <span class="title">demo.demoStudent</span></span></span><br><span class="line"><span class="function">原因: <span class="title">java.lang.NoClassDefFoundError</span>: <span class="title">cn</span>/<span class="title">demo</span>/<span class="title">demoStudent</span> (<span class="title">wrong</span> <span class="title">name</span>: <span class="title">demo</span>/<span class="title">demoStudent</span>)</span></span><br><span class="line"><span class="function">#注意，是要在最顶级包的父文件夹下才能运行</span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>\<span class="title">cn</span>&gt;<span class="title">cd</span> ..</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>&gt;<span class="title">java</span> <span class="title">cn.demo.demoStudent</span></span></span><br><span class="line"><span class="function"><span class="title">student</span>&#x27;<span class="title">s</span> <span class="title">name</span> <span class="title">is</span> <span class="title">null</span></span></span><br><span class="line"><span class="function"><span class="title">student</span>&#x27;<span class="title">s</span> <span class="title">age</span> <span class="title">is</span> 0</span></span><br></pre></td></tr></table></figure><p><strong>main方法的参数<code>args[]</code></strong></p><p>所有的 Java 程序，都由 <strong>public static void main(String[] args)</strong> 方法开始执行，在一般情况下我们不会用到main方法的这个形参，但一定要加上！否则可以通过编译，但在运行时会报错：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误: 在类 mainFunction 中找不到 main 方法, 请将 main 方法定义为:</span><br><span class="line">   public static void main(String[] args)</span><br><span class="line">否则 JavaFX 应用程序类必须扩展javafx.application.Application</span><br></pre></td></tr></table></figure><p>我们下面来尝试下这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainFunction</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;打印main方法中的输入参数：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(String element: args)&#123;</span><br><span class="line">System.out.println(element);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>&gt;<span class="title">java</span> <span class="title">mainFunction</span> <span class="title">gogoing</span>,<span class="title">ukr</span>,<span class="title">xibanya</span>...<span class="title">ufo</span> -<span class="title">sss</span> <span class="title">STK1</span></span></span><br><span class="line"><span class="function">打印<span class="title">main</span>方法中的输入参数：</span></span><br><span class="line"><span class="function"><span class="title">gogoing</span>,<span class="title">ukr</span>,<span class="title">xibanya</span>...<span class="title">ufo</span></span></span><br><span class="line"><span class="function">-<span class="title">sss</span></span></span><br><span class="line"><span class="function"><span class="title">STK1</span></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>&gt;<span class="title">java</span> <span class="title">mainFunction</span> <span class="title">gogo</span>--|<span class="title">ukr</span> &quot;<span class="title">xibanya</span>&quot; &#x27;<span class="title">s</span>&#x27; <span class="title">ufo</span> -<span class="title">sss</span> <span class="title">STK1</span></span></span><br><span class="line"><span class="function">&#x27;<span class="title">ukr</span>&#x27; 不是内部或外部命令，也不是可运行的程序</span></span><br><span class="line"><span class="function">或批处理文件。</span></span><br><span class="line"><span class="function">#注意这里，符号“|”会被<span class="title">windows</span>控制台识别为过滤命令！所以报错</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>&gt;<span class="title">java</span> <span class="title">mainFunction</span> <span class="title">gogo</span>-- <span class="title">ukr</span> &quot;<span class="title">xibanya</span>&quot; &#x27;<span class="title">s</span>&#x27; <span class="title">ufo</span> -<span class="title">sss</span> <span class="title">STK1</span></span></span><br><span class="line"><span class="function">打印<span class="title">main</span>方法中的输入参数：</span></span><br><span class="line"><span class="function"><span class="title">gogo</span>--</span></span><br><span class="line"><span class="function"><span class="title">ukr</span></span></span><br><span class="line"><span class="function">0<span class="title">xibanya</span></span></span><br><span class="line"><span class="function">&#x27;<span class="title">s</span>&#x27;</span></span><br><span class="line"><span class="function"><span class="title">ufo</span></span></span><br><span class="line"><span class="function">-<span class="title">sss</span></span></span><br><span class="line"><span class="function"><span class="title">STK1</span></span></span><br><span class="line"><span class="function">#我们可以看到，输入字符串参数，是按照空格来隔开的，注意双引号的使用，单引号会正常打印</span></span><br></pre></td></tr></table></figure><p><strong>编译并执行程序</strong></p><p><code>javac</code> 可以将<code>java</code>格式源文件编译为class字节码文件，也就是把我们写的<code>java</code>代码编译成计算机能识别的内部代码；<code>java</code>则可以运行该class字节码文件。</p><p>在命令行中输入<code>javac -help</code>可以看到其<a href="https://www.cnblogs.com/wangpei/p/7084341.html">用法</a>：</p><blockquote><p>用法: javac <options> <source files></p><p><code>options</code>命令行选项。<code>sourcefiles</code>一个或多个要编译的源文件（例如 MyClass.java）</p><ul><li>如果源文件数量少，在命令行上列出文件名即可。</li><li>如果源文件数量多，则将源文件名列在一个文件中，名称间用空格或回车行来进行分隔。然后在 javac 命令行中使用该列表文件名，文件名前冠以 @ 字符</li></ul></blockquote><p>其中，**-encoding**，设置源文件编码名称，不设置则默认为操作系统默认的字符编码（windows下为<code>GBK</code>），因此我们常常发现有关编码的报错信息，我们可以使用命令<code>javac -encoding UTF8 myclass.java</code>来成功编译。</p><p><strong>能为空的，是字符串（String）还是字符（Character）</strong>?</p><blockquote><p>Java语言提供了八种基本类型：六种数字类型（四个整数型，两个浮点型），一种字符类型（<strong>char</strong>），还有一种是布尔型。</p><p>和C语言类似，Java中的char 类型是一个<strong>单一</strong>的 16 位 Unicode 字符，最小值是 **<code>\u0000</code>**（十进制等效值为 0），最大值是 **<code>\uffff</code>**（十进制下等效于 65535）；</p></blockquote><p>Character 类用于对单个字符进行操作，在对象中包装一个基本类型 char 的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="comment">// Unicode 字符表示形式</span></span><br><span class="line"><span class="type">char</span> <span class="variable">uniChar</span> <span class="operator">=</span> <span class="string">&#x27;\u039A&#x27;</span></span><br><span class="line"><span class="comment">//Character类提供了一系列方法来操纵字符，我们可以使用Character的构造方法创建一个Character类对象</span></span><br><span class="line"><span class="type">Character</span> <span class="variable">ch_object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Character</span>(<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。有两种方法：使用关键字或者构造方法来创建 String 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;SKT&quot;</span>;</span><br><span class="line">String str2=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;SSW&quot;</span>);</span><br></pre></td></tr></table></figure><p>这两种方法的区别在于：<u>String 创建的字符串存储在公共池中，而 new 创建的字符串对象在堆上</u>。</p><p>关于这一点我们日后再进行深入探究，并和<strong>JavaScript中String()与new String()的区别</strong>做对比。</p><p>我们要注意，<u>单个字符的char类型不能为空，但String对象可以为一个空字符串</u>。我们在程序中依次对下面几行进行注释，然后将<code>java</code>文件编译执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;&quot;</span>);<span class="comment">//输出一行空行</span></span><br><span class="line">System.out.println(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="comment">/*编译时就无法通过，会报错</span></span><br><span class="line"><span class="comment">DEMOCONST.java:5: 错误: 空字符文字</span></span><br><span class="line"><span class="comment">                System.out.println(&#x27;&#x27;);</span></span><br><span class="line"><span class="comment">                                   ^</span></span><br><span class="line"><span class="comment">1 个错误</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">System.out.println(<span class="literal">true</span>);<span class="comment">//输出字符串true</span></span><br><span class="line">System.out.println(<span class="literal">false</span>);<span class="comment">//输出字符串false</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="literal">null</span>); <span class="comment">//null代表空，什么都没有</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">DemoConst.java:8: 错误: 对println的引用不明确</span></span><br><span class="line"><span class="comment">                System.out.println(null);</span></span><br><span class="line"><span class="comment">                          ^</span></span><br><span class="line"><span class="comment">  PrintStream 中的方法 println(char[]) 和 PrintStream 中的方法 println(String) 都匹配</span></span><br><span class="line"><span class="comment">1 个错误</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>for-each循环</strong></p><p><code>JDK</code>1.5 中引进的一种新的循环类型，能在不使用下标的情况下遍历数组，在Python和JavaScript中也有类似语法。注意，数组索引从0开始，不能像Python那样使用负数索引！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">team</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">double</span>[] teamList = &#123;<span class="number">1.2</span>, <span class="number">3.4</span>, <span class="number">9.3</span>, <span class="number">5.5</span>&#125;;</span><br><span class="line">      <span class="comment">// 打印所有数组元素，这里的i只是一个指代其中任一元素的作用</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">double</span> i: teamList) &#123;</span><br><span class="line">         System.out.println(i);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(teamList.length);<span class="comment">//打印数组长度</span></span><br><span class="line">       System.out.println(teamList[<span class="number">99</span>]);<span class="comment">//数组越界，编译不会报错，但运行时会报错</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法重载</strong></p><p>类似于C语言，Java也有方法重载的效果，允许在一个类中,存在多个方法拥有不同的参数（无论是参数的个数还是类型、顺序），而却有相同的名字。比如我们要想用一个函数来实现数字相加和字符串拼接两个功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainFunction</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> sum(<span class="number">100</span>,<span class="number">200</span>);<span class="comment">//注意！！变量的名称可以跟方法的一样，但不推荐这么写！</span></span><br><span class="line"><span class="comment">//不必像c语言中声明方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;sum(100+200) = &quot;</span>+sum);</span><br><span class="line">System.out.println(sum(<span class="string">&quot;ssudi&quot;</span>,<span class="string">&quot;+ jhderhyiu&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a,<span class="type">double</span> b)</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> a+b;<span class="comment">//注意！！要运算的数据类型不一样时，结果为数据范围大的那一个类型！！</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">sum</span><span class="params">(String a,String b)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后，运行结果为：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>&gt;<span class="title">java</span> <span class="title">mainFunction</span></span></span><br><span class="line"><span class="function"><span class="title">sum</span>(100+200) = 300</span></span><br><span class="line"><span class="function"><span class="title">ssudi</span>+ <span class="title">jhderhyiu</span></span></span><br></pre></td></tr></table></figure><p>在其他编程语言中，Python由于可以接受任何类型的参数，对于缺少的参数也可以设置为缺省参数，因此不需要也不支持函数重载。而在JavaScript中，同一个作用域内，两个名称相同的函数，后来居上——后面的函数会覆盖前面的，这是因为<strong>声明提升</strong>——函数声明和变量声明总会被解释器提升到作用域的最顶端去执行。不过，<a href="https://segmentfault.com/a/1190000015602959">我们可以在JavaScript中实现模拟重载的效果</a>。</p><p><strong>局部变量和成员变量</strong></p><p>不同之处：</p><ol><li>定义的位置不同：局部变量定义在方法内部；成员变量直接定义在类当中，在方法外面；</li><li>内存中的位置不一样：局部变量在栈内存中，成员变量在堆内存中；</li><li>生命周期不同：局部变量随着方法的进栈而出现，方法出栈时消失；成员变量当对象被创建时出现，在对象被<code>JVM</code>回收，也就是垃圾回收时消失;</li><li>默认值不同：局部变量没有默认值，必须赋值后才可使用，成员变量声明后自动有一个默认值。</li></ol><h2 id="类方法，static修饰符"><a href="#类方法，static修饰符" class="headerlink" title="类方法，static修饰符"></a>类方法，static修饰符</h2><ul><li><p>变量，可以按照两种方式划分：</p><ol><li><p>按位置来分：成员变量——类中方法外的变量（有默认值），局部变量——类中方法内的变量；</p></li><li><p>按是否使用<code>static</code>关键字声明来分：</p><ul><li><p>类变量(静态变量)：在类中<strong>使用static关键字声明</strong>，但位于方法、构造函数、块之外。为了加以区分，我们用static声明的局部变量称之为静态局部变量；</p></li><li><p>实例变量：由类生成对象时，才分配存储空间。各对象间的实例变量互不干扰，能通过对象的引用来访问实例变量。但在Java多线程中，实例变量是多个线程共享资源，要注意同步访问时可能出现的问题。</p></li></ul></li><li><p>注意：static修饰的成员（字段和方法）应该使用<strong>类名.成员名</strong>访问，也可以使用对象名.成员名，但是不推荐。</p></li></ol></li><li><p>成员方法：类中的方法，包含：</p><ul><li>静态方法：被static修饰的成员方法；</li><li>实例方法：没有用关键字static修饰的成员方法。</li></ul></li><li><p>静态变量：static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。</p></li><li><p>静态方法：<strong>static</strong> 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。</p></li><li><p>构造方法：类中专门用来创建对象的方法，通过<code>new</code>关键字创建对象时就是在调用构造方法，注意一下两点：</p><ol><li>构造方法<strong>不能写返回值类型！包括void也不能写！</strong></li><li>构造方法的名称必须和所在的类名称完全一致（包括大小写一致）</li></ol></li></ul><p><strong>被static修饰的成员变量和成员方法独立于该类的任何对象</strong>。也就是说，它不依赖类特定的实例，<strong>被类的所有实例共享</strong>。只要这个类被加载，Java虚拟机就能根据类名在运行时数据区或者方法区内找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。 而用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它类的对象时，不生成static变量的副本，而是类的所有实例共享同一个static变量。 </p><p>我们来看一下，<code>static</code>修饰符在类中的应用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">String name;String address;<span class="type">int</span> age;</span><br><span class="line"><span class="keyword">static</span> <span class="type">String</span> <span class="variable">country</span> <span class="operator">=</span> <span class="string">&quot;大清&quot;</span>;<span class="comment">//被static修饰的静态变量</span></span><br><span class="line"><span class="comment">//构造方法的名称必须跟类名称相同！</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name,String address)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="built_in">this</span>.address = address;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;北平&quot;</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;南昌&quot;</span>);</span><br><span class="line"><span class="comment">//下面我们对数值分别进行更改</span></span><br><span class="line">p1.country = <span class="string">&quot;民国&quot;</span>;<span class="comment">//不推荐这样使用静态变量</span></span><br><span class="line">p1.address = <span class="string">&quot;北京&quot;</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;p1.country = &quot;</span>+p1.country+<span class="string">&quot;\np1.address = &quot;</span>+p1.address+<span class="string">&quot;\np1.age = &quot;</span>+p1.age);</span><br><span class="line">System.out.println(<span class="string">&quot;p2.country = &quot;</span>+p2.country+<span class="string">&quot;\np2.address = &quot;</span>+p2.address+<span class="string">&quot;\np2.age = &quot;</span>+p2.age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>\<span class="title">cn</span>\<span class="title">demo</span>&gt;<span class="title">java</span> <span class="title">Person</span></span></span><br><span class="line"><span class="function"><span class="title">p1.country</span> = 民国</span></span><br><span class="line"><span class="function"><span class="title">p1.address</span> = 北京</span></span><br><span class="line"><span class="function"><span class="title">p1.age</span> = 0#<span class="title">int</span>类型的成员变量默认值为0</span></span><br><span class="line"><span class="function"><span class="title">p2.country</span> = 民国</span></span><br><span class="line"><span class="function"><span class="title">p2.address</span> = 南昌</span></span><br><span class="line"><span class="function"><span class="title">p2.age</span> = 0</span></span><br></pre></td></tr></table></figure><p>可以看到，我们只更改了对象<code>p1</code>中的country属性，但因为这是个被<code>static</code>修饰的静态变量，因此所有由<code>Person</code>类所构造的对象中，这一项属性都改变了。</p><h3 id="静态变量与实例化"><a href="#静态变量与实例化" class="headerlink" title="静态变量与实例化"></a>静态变量与实例化</h3><p>我们首先写一个程序，这里有静态变量和静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">staticFunction</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//实例变量</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">99</span>;<span class="comment">//静态变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printCountpublic</span><span class="params">()</span>&#123;</span><br><span class="line">count++; </span><br><span class="line">System.out.println(<span class="string">&quot;Now,count = &quot;</span>+count+age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printCountstatic</span><span class="params">()</span>&#123;</span><br><span class="line">count+=<span class="number">10</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;Now,count = &quot;</span>+count);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序将无法编译通过，并报错：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>\<span class="title">cn</span>\<span class="title">demo</span>&gt;<span class="title">javac</span> -<span class="title">encoding</span> <span class="title">UTF</span>-8 <span class="title">staticFunction.java</span></span></span><br><span class="line"><span class="function"><span class="title">staticFunction.java</span>:9: 错误: 无法从静态上下文中引用非静态变量 <span class="title">count</span></span></span><br><span class="line"><span class="function">                <span class="title">count</span>+=10;</span></span><br><span class="line"><span class="function">                ^</span></span><br><span class="line"><span class="function"><span class="title">staticFunction.java</span>:10: 错误: 无法从静态上下文中引用非静态变量 <span class="title">count</span></span></span><br><span class="line"><span class="function">                <span class="title">System.out.println</span>(&quot;<span class="title">Now</span>,<span class="title">count</span> = &quot;+<span class="title">count</span>);</span></span><br><span class="line"><span class="function">                                                  ^</span></span><br><span class="line"><span class="function">2 个错误</span></span><br></pre></td></tr></table></figure><p>报错原因是：静态方法只能访问静态变量；如果<strong>要让静态方法访问动态变量</strong>，<strong>必须将动态变量实例化</strong>。</p><h3 id="静态构造器"><a href="#静态构造器" class="headerlink" title="静态构造器"></a>静态构造器</h3><p>又称静态构造函数，是实现对一个类进行初始化的方法成员，一般用于对静态数据的初始化（<strong>静态变量也是最先初始化的</strong>）。静态构造函数不能有参数，不能有修饰符，不能被调用。当类被加载时，类的静态构造函数自动被调用。因此，在一个程序的执行过程中，静态构造器<strong>最多执行一次</strong>。注意执行顺序：</p><ol><li><p>静态构造器在任何类的静态成员被引用之前执行；</p></li><li><p>静态构造器在任何类的实例变量被分配之前执行；</p></li><li><p>静态构造器在类的静态成员初始化之后执行，或者说编译器会将静态成员初始化语句转换成赋值语句放在静态构造器执行的最开始。</p></li></ol><p>我们用下面这个例子来实践一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">staticTest</span>&#123;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;这里是通用构造器&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;静态构造器&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">staticTest</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;构造方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="comment">//在主方法中调用构造方法，创建一个对象，就不用再写一个java程序来验证了</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">staticTest</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，可以看到，静态构造器是最先被执行的。</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>\<span class="title">cn</span>\<span class="title">demo</span>&gt;<span class="title">java</span> <span class="title">staticTest</span></span></span><br><span class="line"><span class="function">静态构造器</span></span><br><span class="line"><span class="function">这里是通用构造器</span></span><br><span class="line"><span class="function">构造方法</span></span><br></pre></td></tr></table></figure><p>在有继承的情况下，执行顺序为：<strong>父类静态代码块 &gt; 子类静态代码块 &gt; 父类构造代码块 &gt; 父类构造器 &gt; 子类构造代码块 &gt; 子类构造器</strong></p><p><strong>Java语言中，标准类（pojo类）</strong></p><p><code>POJO</code>的全称为<code>plain old java object</code>，可以翻译成：普通Java类。主要用于数据的临时传递，但它只能装载数据， 作为数据存储的载体，而不具有业务逻辑处理的能力，也就是说，<u><code>POJO</code>类中不允许有业务方法，也不能携带connection之类的方法</u>。</p><p>**<a name="标准类的四个必要条件">标准类的四个<u>必要</u>组成部分</a>**（四个必要条件）</p><ol><li>所有的成员<strong>变量</strong>都要使用 private 关键字进行修饰；</li><li>为每一个成员变量编写 set、get 方法；</li><li>创建一个无参数的构造方法；</li><li>创建一个有参数的构造方法。</li></ol><p><strong>pojo类和java bean的关系</strong></p><p><a href="https://blog.csdn.net/tiantangdizhibuxiang/article/details/81784873">博客</a></p><blockquote><p>按着Sun公司的定义，Java Bean是一个可重复使用的软件组件。实际上Java Bean是一种<a href="https://so.csdn.net/so/search?q=Java&spm=1001.2101.3001.7020">Java</a>类，通过封装属性和方法成为具有某种功能或者处理某个业务的对象，简称bean。</p><p><code>JavaBean</code> 是一种JAVA语言写成的可重用组件，不是一种技术，而是一种规范，它的方法命名，构造及行为必须符合特定的约定：</p><ol><li>这个类必须有一个公共的缺省构造函数；</li><li>这个类的属性使用getter和setter来访问，其他方法遵从标准命名规范;</li><li>这个类应是可<strong>序列化</strong>的（一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象——详见<a href="https://www.runoob.com/java/java-serialization.html">类的序列化</a>）。</li></ol><p><code>Java Bean</code>的任务可以概括为: “Write once, run anywhere, reuse everywhere”，即“一次性编写，任何地方执行，任何地方重用”。可分为两种：</p><ol><li>是有用户界面（UI，User Interface）的Java Bean；</li><li>没有用户界面，主要负责处理事务（如数据运算，操纵数据库）的Java Bean（部署于网络服务器上的<code>JSP</code>，又称<code>JavaServer Pages</code>，通常访问的是这一种Java Bean）。</li></ol><p>简而言之，当一个<code>PoJo</code>可序列化，有一个无参的构造函数，使用getter和setter方法来访问属性时，他就是一个Java Bean。</p></blockquote><p>然而，通常情况下，由于 Java Bean 是被容器所创建（如 Tomcat) 的，<strong>所以 Java Bean 应具有一个无参的构造器</strong>，另外，通常 <strong>Java Bean 还要实现 <code>Serializable</code> 接口用于实现 Bean 的持久性</strong>。 Java Bean 是不能被跨进程访问的。一般在web应用程序中建立一个数据库的映射对象时，我们只能称它为<code>POJO</code>——一个普通Java对象，而不是一个特殊的对象，其主要用来指代那些没有遵从特定的Java对象模型、约定或框架（如<code>EJB</code>）的Java对象。理想地讲，一个<code>POJO</code>是一个不受任何限制的Java对象（除了Java语言规范）</p><p>Java中还有很多特定类（<code>entity</code>、 <code>VO</code> 、<code>DTO</code>等）的概念和作用，我们详见好心人整理的<a href="https://www.pianshen.com/article/5933825452/">专栏</a>和<a href="https://www.cnblogs.com/feily/articles/14225139.html">博客</a>。</p><p><img src="/images/java%E5%90%84%E7%A7%8D%E7%B1%BB%E5%9C%A8%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8.png" alt="java各种类在实际项目中的运用"></p><p>我们再顺便了解另一个概念：<strong>entity(实体类)</strong></p><p>通常定义在model层里面，一个实体映射一张表，其中的<strong>属性</strong>对应数据表中的<strong>字段</strong>，，一般无业务逻辑代码。</p><p>entity类也要满足<a href="#标准类的四个必要条件">普通JavaBeans类的四个必要条件</a>，这篇<a href="https://blog.csdn.net/u012393192/article/details/80808237">博客</a>还介绍了entity的其他优点：</p><ol><li>对象实体的封装，体现<strong>OO(Object Oriented面向对象)思想</strong>——Java是面向对象的语言，由于面向对象有<strong>封装、继承、多态</strong>性的特性，可以设计出低耦合的系统，并使系统更加灵活和易于维护，缺点是性能比面向过程的低；</li><li>entity类中的属性可以对字段定义和状态进行判断和过滤；</li><li>一个数据库表映射成一个实体类，对数据库操作起来方便（在程序中可以把实体类作为参数传递），使程序员程序员在对数据库操作的时候不用写<code>SQL</code>语句,专注逻辑关系。换句话说，实体类就是把对某一个数据表（table）的操作全写在一个类里面：创建一个Entity Bean对象相当于创建一条记录，删除一个Entity Bean对象会同时从数据库中删除对应记录，修改一个Entity Bean时，容器会自动将Entity Bean的状态和数据库同步。</li></ol><p>另外，在Java开发中对于定义entity类的总结经验如下：</p><ul><li>实体类的名字尽量和数据库的表的名字对应相同；</li><li>实体类应该实现<code>java.io.Serializable</code>接口；</li><li>实体类应该有个无参的构造方法；</li><li>实体类应该至少有一个有参数的构造方法；</li><li>实体类有属性和方法，属性对应数据库中表的字段，主要有getter和setter方法。</li><li>实体类还应该有个属性<code>serialVersionUID</code>。例如：<code>private static final long serialVersionUID = -6125297654796395674L;</code></li><li>在实体类中，<strong>属性</strong>一般是<strong>private</strong>类型，而<strong>方法</strong>为<strong>public</strong>类型，对于数据库自动生成的ID字段对应的属性的<strong>set方法应为private</strong>。</li></ul><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>Java中的数据类型分为：基本数据类型（八种），引用类型——引用强度和生命周期长度依次为：强引用&gt;软引用＞弱引用＞虚引用。（JDK1.2之后的引用概念扩充）</p><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>默认声明的就是强引用，比如<code>Object obj = new Object()</code>，只要obj还指向Object对象（也就是强引用还存在），Object对象就不会被垃圾回收器回收。即使内存不足时，<code>JVM</code>也会直接抛出<code>OutOfMemoryError</code>而不会去回收。若想中断强引用与对象之间的联系，可以将强引用赋值为null。</p><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>描述一些非必需但仍有用的对象。<strong>在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常</strong>。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。在 JDK1.2 之后，用java.lang.ref.SoftReference类来表示软引用。</p><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了<strong>只具有弱引用</strong>的对象，不管当前内存空间足够与否，都会回收它的内存——也就是说，<strong>无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收</strong>。在 JDK1.2 之后，用 java.lang.ref.WeakReference 来表示弱引用。</p><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>又称为“幽灵引用”或“幻影引用”，最弱的一种引用关系，其存在与否，不会对对象的生存产生任何影响，且也无法通过虚引用来获得对象实例。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收。创建虚引用需要使用java.lang.ref.PhantomReference。这个类的源码中只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象。与软引用、弱引用不同的是，虚引用必须要和 ReferenceQueue 引用队列一起使用。</p><h3 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h3><p>引用队列可以与软引用、弱引用以及虚引用一起配合使用（强引用自然不行），当垃圾回收器准备回收一个对象时，如果发现它还有引用，那么就会在回收对象之前，把这个引用加入到与之关联的引用队列中去。程序可以通过判断引用队列中是否已经加入了引用，来判断被引用的对象是否将要被垃圾回收，这样就可以在对象被回收之前采取一些必要的措施。牢记：虚引用必须和引用队列一起使用。</p><h2 id="类与导包import"><a href="#类与导包import" class="headerlink" title="类与导包import"></a>类与导包import</h2><p>所有的类都需要导包才能使用，除了两种情况：</p><ol><li>要使用的目标类，和当前类位于同一个包（package）下；</li><li>要使用的目标类，位于<code>java.lang</code>包下，但是不包含子包内容（比如路径<code>C:\Program Files\Java\jdk-11.0.2\lib\src\java.base\java\lang\reflect</code>下的Field.java这一个类，就需要引用）</li></ol><p>我们使用的字符串对象，是String类，其实就属于第二种情况，在博主使用的JDK11版本中，我们可以在路径<code>C:\Program Files\Java\jdk-11.0.2\lib\src\java.base\java\lang</code>看到文件<code>String.java</code>。</p><p>字符串是对象，却可以原封不动打印出来，是因为<code>println</code>方法的判断逻辑：</p><ol><li>若是字符串类型，直接显示内容；</li><li>若不是字符串类型，就将其内部通过某些方法转换成字符串再显示（参考定义println方法的源码可知，比如int基本数据类型的会被String.valueOf方法转换为字符串类型）；</li><li>最终打印出来的一定是字符串类型。</li></ol><p>比方说，我们引入一个使用自定Employee类的程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo_println</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">Employee</span> <span class="variable">adc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;adcssss&quot;</span>);</span><br><span class="line">System.out.println(adc);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台中的打印结果：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>&gt;<span class="title">java</span> <span class="title">Demo_println</span></span></span><br><span class="line"><span class="function"><span class="title">Employee</span>@512<span class="title">ddf17</span></span></span><br><span class="line"><span class="function">#一般的对象都是使用“类型信息+@+地址值”来作为字符串内容</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java基础语法学习要注意的小细节&quot;&gt;&lt;a href=&quot;#Java基础语法学习要注意的小细节&quot; class=&quot;headerlink&quot; title=&quot;Java基础语法学习要注意的小细节&quot;&gt;&lt;/a&gt;Java基础语法学习要注意的小细节&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;最最</summary>
      
    
    
    
    <category term="Java" scheme="http://justskim.github.io/categories/Java/"/>
    
    
    <category term="java" scheme="http://justskim.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>tomcat下startup.bat启动报错详解</title>
    <link href="http://justskim.github.io/2022/03/01/tomcat%E4%B8%8Bstartup.bat%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99%E8%AF%A6%E8%A7%A3/"/>
    <id>http://justskim.github.io/2022/03/01/tomcat%E4%B8%8Bstartup.bat%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-03-01T03:10:04.038Z</published>
    <updated>2022-03-01T08:37:17.479Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tomcat下startup-bat启动报错详解"><a href="#tomcat下startup-bat启动报错详解" class="headerlink" title="tomcat下startup.bat启动报错详解"></a>tomcat下startup.bat启动报错详解</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>博主在tomcat服务器的安装启动时，遇到问题：在官网下载的tomcat10压缩包版本，解压后可以在bin文件夹中双击tomcat10.exe并成功运行，但是双击startup.bat会闪退。而在网上找到的博客所遇到的问题都跟博主的相反，都是tomcat.exe不能运行。在控制台运行该程序，会得到信息如下：</p><p><img src="/images/startup.bat%E9%97%AA%E9%80%80.PNG" alt="startup.bat闪退.PNG"></p><p>博主也检测了主机安装<code>java</code>的配置以及环境变量，<strong>使用命令<code>netstat -ano|findstr 8080</code>也没有发现占用端口的程序</strong>，在控制台中使用命令<code>java -version</code>打印结果也正常，因此查询tomcat相关资料，探究该问题。</p><h2 id="startup与catalina"><a href="#startup与catalina" class="headerlink" title="startup与catalina"></a>startup与catalina</h2><p>我们在tomcat安装目录的bin目录下，可以看到有四个文件：startup.bat，startup.sh，catalina.bat，catalina.sh。</p><p>这其中，sh格式的文件是linux系统下的脚本文件，在Windows系统下无需理会。我们只看另外两个bat文件就行——bat是<strong>dos下的批处理文件</strong>。我们要启动tomcat除了双击startup.bat和tomcat.exe，还有一种方式就是在该目录下的命令行中输入<code>catalina.bat run</code>或者<code>catalina run</code>。startup.bat在执行时也会在最后调用catalina.bat，并且传递了start参数，设置了CATALINA_HOME和CURRENT_DIR俩个临时环境变量，当然我们也可以在系统中自行添加这两个变量。这两个文件的另一个区别在于：startup是在新界面运行，而<code>catalina run</code>命令会使相关程序在当前界面运行，会有更多的报错信息：</p><p><img src="/images/catalina.bat%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF.png" alt="catalina.bat报错信息"></p><h2 id="原因查询"><a href="#原因查询" class="headerlink" title="原因查询"></a>原因查询</h2><p>原因可能是JDK版本过高（博主所用的JDK17）所导致的，AVA11以后大大简化了JAVA环境配置方式，也没有jre文件夹，不过我们可以在jdk目录下使用命令<code>bin\jlink.exe --module-path jmods --add-modules java.desktop --output jre</code>来自动生成。<code>JAVA_HOME/lib</code>目录下没有tool.jar, dt.jar这两个文件，因此我们需要在配置环境变量的时候，要写成:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH  ;%JAVA_HOME%\bin\;%JAVA_HOME%\jre\bin\; CLASSPATH=.;%JAVA_HOME%\lib;%JAVA_HOME%\jre\lib;</span><br></pre></td></tr></table></figure><p>即使如此，博主还是依然无法通过startup.bat或者catalina.bat来启动tomcat，依旧只能选择tomcat.exe的启动方式┓( ´∀&#96; )┏</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;tomcat下startup-bat启动报错详解&quot;&gt;&lt;a href=&quot;#tomcat下startup-bat启动报错详解&quot; class=&quot;headerlink&quot; title=&quot;tomcat下startup.bat启动报错详解&quot;&gt;&lt;/a&gt;tomcat下startup</summary>
      
    
    
    
    <category term="服务器" scheme="http://justskim.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="tomcat" scheme="http://justskim.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/tomcat/"/>
    
    
    <category term="服务器" scheme="http://justskim.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="java" scheme="http://justskim.github.io/tags/java/"/>
    
    <category term="tomcat" scheme="http://justskim.github.io/tags/tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Linux服务器上的nginx与apache</title>
    <link href="http://justskim.github.io/2022/02/26/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84nginx%E4%B8%8Eapache/"/>
    <id>http://justskim.github.io/2022/02/26/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84nginx%E4%B8%8Eapache/</id>
    <published>2022-02-26T11:00:54.169Z</published>
    <updated>2022-02-26T17:45:10.530Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux服务器上的nginx与apache"><a href="#Linux服务器上的nginx与apache" class="headerlink" title="Linux服务器上的nginx与apache"></a>Linux服务器上的nginx与apache</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>博主在进行<a href="https://www.byhy.net/tut/webdev/django/07/">django框架的web项目练习</a>时，参考<a href="https://www.byhy.net/tut/webdev/django/16/#%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4-nginx">相关教程</a>进行<code>django</code>项目在Linux云服务器上的部署。<code>nginx</code>无法启动服务，需要修改路径<code>/etc/nginx/nginx.conf</code>（使用命令<code>yum -y install nginx</code>默认安装）下的<code>nginx.conf</code>文件。而在浏览器上的web端阿里云控制台上，使用<code>linux</code>系统自带的<code>vim</code>编辑器，不像在桌面系统上编辑那么容易。因此打算使用第三方工具（如<code>win-scp</code>，<code>Xshell</code>），在本地编辑文件后直接拖拽进去替代。但是在这些终端模拟器上无法与阿里云服务器建立ssh连接，但却可以ping通云服务器的公网<code>ip</code>地址，如下图所示。因此博主决定深入探究，并解决该问题。</p><p><img src="/images/ssh%E8%BF%9E%E6%8E%A5%E6%8A%A5%E9%94%99.PNG" alt="ssh连接报错"></p><h2 id="没有公网ip地址-x3D-端口被屏蔽？"><a href="#没有公网ip地址-x3D-端口被屏蔽？" class="headerlink" title="没有公网ip地址&#x3D;端口被屏蔽？"></a>没有公网<code>ip</code>地址&#x3D;端口被屏蔽？</h2><p>博主遇到的这一个离谱的问题，当阿里云的服务器设置了白名单以及安全组等配置后，无法在家庭网络的三台主机中使用ssh命令或者第三方工具通过22端口进行连接。而在阿里云网页端的官方控制台可以远程连接。异地协助的朋友也可以在他的主机上直接使用<code>ssh</code>命令或者<code>Xshell</code>等第三方工具。</p><h3 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h3><ol><li><p>首先是一如既往地检查阿里云服务器的安全组设置，请求客服协助，均没有问题；</p></li><li><p>在<code>win10</code>系统的主机上打开防火墙高级设置，设置22端口的出站规则；</p></li><li><p>使用命令<code>netstat -ano|findstr 22</code>查看端口，22端口和80、443等端口均没有发生占用情况；</p></li><li><p>使用手机开启移动4G热点，主机连接该热点后竟然能够成功ssh连接阿里云远程服务器！</p></li></ol><h3 id="真正的问题所在"><a href="#真正的问题所在" class="headerlink" title="真正的问题所在"></a>真正的问题所在</h3><p>经过问题排查的过程后，博主将目标锁定在运营商的端口规则上。</p><p><code>ISP</code>的全称是<code>Internet Service Provider</code>，翻译为互联网服务提供商，即向广大用户综合提供互联网接入业务、信息业务、和增值业务的电信<strong>运营商</strong>。</p><p>为了了解我们的运营商屏蔽了哪些端口，我们使用<a href="https://www.sojson.com/zz/portscan.html">站长工具中的端口扫描工具</a>，或者<a href="https://gist.github.com/vfreex/32b7de2e36422dbee94454afc762305e">相关脚本</a>来扫描看看哪些端口可以代为使用。对博主主机扫描的结果是所有端口都被屏蔽，无法使用。。。</p><p>根据网络相关文章，这可能跟博主所用的主机并没有公网ip地址有关，以及运营商的屏蔽规则，导致正常无法使用端口。</p><p>最后，给你们介绍一下，博主家里使用的是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">宽带类型：广电</span><br><span class="line">宽带业务：高清电视(IPTV)业务</span><br><span class="line">接入方式：光纤接入(FTTH)</span><br></pre></td></tr></table></figure><h2 id="80端口与Nginx与Apache"><a href="#80端口与Nginx与Apache" class="headerlink" title="80端口与Nginx与Apache"></a>80端口与Nginx与Apache</h2><p>Apache和Nginx都属于Web服务器（也称为WWW(WORLD WIDE WEB)服务器，主要功能是提供网上信息浏览服务），都实现了HTTP 1.1协议。我们在具体工程项目中选择哪个，都是根据应用场景来决定的，关于这两个服务器的更多异同我们将在之后进行学习探讨。</p><p>80端口是为HTTP超文本传输协议开放的端口卡相关的限制。<code>Apache</code>与<code>nginx</code>都会使用到该端口。比如博主在启动<code>nginx</code>时遇到的一个报错：“<strong>Address already in use</strong>…”，就说明该端口已经被其他程序所占用（大多数情况下是Apache，可能是很多软件不注意间被我们设置开机自动启动了）因此，要么将其中一个的端口进行修改，要么至启动一个（正常生产环境下的操作，无需两个都使用，功能有重复的地方）</p><p>我们使用<code>systemctl  stop httpd</code>来结束apache服务，使用<code>systemctl start nginx</code>来启动<code>nginx</code>服务，反之亦然。</p><p>解决了<code>nginx</code>启动报错的问题后，我们得以部署成功，在浏览器上输入相关<code>ip</code>地址路由，可以成功访问到页面！</p><p><img src="/images/%E6%88%90%E5%8A%9F%E7%99%BB%E5%BD%95%E4%B8%8A%E8%87%AA%E5%B7%B1%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%A1%B9%E7%9B%AE.PNG" alt="成功登录上自己服务器的项目"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux服务器上的nginx与apache&quot;&gt;&lt;a href=&quot;#Linux服务器上的nginx与apache&quot; class=&quot;headerlink&quot; title=&quot;Linux服务器上的nginx与apache&quot;&gt;&lt;/a&gt;Linux服务器上的nginx与apac</summary>
      
    
    
    
    <category term="网络" scheme="http://justskim.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="http://justskim.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="nginx" scheme="http://justskim.github.io/tags/nginx/"/>
    
    <category term="apache" scheme="http://justskim.github.io/tags/apache/"/>
    
  </entry>
  
  <entry>
    <title>localhost与127.0.0.1与0.0.0.0以及端口</title>
    <link href="http://justskim.github.io/2022/02/22/localhost%E4%B8%8E127.0.0.1%E4%B8%8E0.0.0.0%E4%BB%A5%E5%8F%8A%E7%AB%AF%E5%8F%A3/"/>
    <id>http://justskim.github.io/2022/02/22/localhost%E4%B8%8E127.0.0.1%E4%B8%8E0.0.0.0%E4%BB%A5%E5%8F%8A%E7%AB%AF%E5%8F%A3/</id>
    <published>2022-02-21T17:43:42.599Z</published>
    <updated>2022-02-22T02:48:52.071Z</updated>
    
    <content type="html"><![CDATA[<h1 id="localhost与127-0-0-1与0-0-0-0以及端口"><a href="#localhost与127-0-0-1与0-0-0-0以及端口" class="headerlink" title="localhost与127.0.0.1与0.0.0.0以及端口"></a>localhost与127.0.0.1与0.0.0.0以及端口</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>博主在进行<a href="https://www.byhy.net/tut/webdev/django/07/">django框架的web项目练习</a>时，遇到的一个问题。当博主按照所需的操作编写代码后，在网页链接栏输入<code>http://localhost/mgr/index.html</code>或者<code>http://localhost/mgr/index.html#/</code>时，都会显示404的错误提示界面，如下所示：</p><p><img src="E:\JS练习\blog\Myblog\source\images\localhost下的404界面.PNG" alt="localhost下的404界面"></p><p>而只有在输入链接为<code>127.0.0.1:4000/mgr/index.html#/</code>时，才会出现正常界面：</p><p><img src="E:\JS练习\blog\Myblog\source\images\127.0.0.1下的正常显示界面.PNG" alt="127.0.0.1下的正常显示界面.PNG"></p><p>与教程中唯一不同的步骤在于，博主的django应用，是使用命令<code>python manage.py runserver 4000</code>运行在4000端口上而不是80端口上。原因在于80端口被其他应用所占用。</p><h2 id="如何查看端口是否被占用"><a href="#如何查看端口是否被占用" class="headerlink" title="如何查看端口是否被占用"></a>如何查看端口是否被占用</h2><p>在win 10 系统上，打开控制台，输入命令<code>netstat -ano</code>可以查看所有端口的占用情况。若要查看某一个端口的占用情况，则使用诸如<code>netstat -ano|findstr &quot;80&quot;</code>的命令形式，注意要加双引号。查到占用该端口的进程的PID后，可以使用<code>tasklist|find &quot;123&quot;</code>命令查看进程，这里的123是进程PID。或者打开任务管理器，在“详细信息”一栏查看</p><h2 id="80端口"><a href="#80端口" class="headerlink" title="80端口"></a>80端口</h2><p>80端口是为HTTP超文本传输协议开放的端口，主要用于WWW万维网进行传输信息。其中的具体情况如下：</p><p>80端口作为http协议的默认端口，在输入网站的时候其实浏览器（非IE）已经帮忙输入协议了。所以这样一来，如果输入<a href="http://baidu.com,其实就等于访问http//baidu.com:80%E3%80%82%E5%9B%A0%E6%AD%A4%E6%88%91%E4%BB%AC%E8%AE%BF%E9%97%AElocalhost%EF%BC%8C%E9%BB%98%E8%AE%A4%E6%98%AF%E8%AE%BF%E9%97%AElocalhost:80">http://baidu.com，其实就等于访问http://baidu.com:80。因此我们访问localhost，默认是访问localhost:80</a></p><h2 id="localhost与127-0-0-1的区别"><a href="#localhost与127-0-0-1的区别" class="headerlink" title="localhost与127.0.0.1的区别"></a>localhost与127.0.0.1的区别</h2><p>localhost也叫local ，正确的解释是：本地服务器</p><p>127.0.0.1在windows等系统的正确解释是：本机地址（本机服务器）</p><p>他们的解析通过本机的host文件，windows自动将localhost解析为127.0.0.1</p><p>localhost也叫local ，正确的解释是：本地服务器</p><p>127.0.0.1在windows等系统的正确解释是：本机地址（本机服务器）</p><p>他们的解析通过本机的host文件，windows自动将localhost解析为127.0.0.1</p><p>localhot（local）是不经网卡传输！这点很重要，它不受网络防火墙和网卡相关的的限制。</p><p>127.0.0.1是通过网卡传输，依赖网卡，并受到网络防火墙和网卡相关的限制。</p><p>一般设置程序时本地服务用localhost是最好的，localhost不会解析成ip，也不会占用网卡、网络资源。</p><p>有时候用localhost可以，但用127.0.0.1就不可以的情况就是在于此。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="解决方法1："><a href="#解决方法1：" class="headerlink" title="解决方法1："></a>解决方法1：</h3><p>修改host文件用记事本打开C:&#x2F;WINDOWS&#x2F;system32&#x2F;drivers&#x2F;etc&#x2F;hosts文件，看是否有127.0.0.1 localhost 。如果没有则将其添加进去，再查看能否访问localhost。博主使用此方法，即可访问<a href="http://localhost:4000/mgr/index.html#/">http://localhost:4000/mgr/index.html#/</a></p><h3 id="解决方法2："><a href="#解决方法2：" class="headerlink" title="解决方法2："></a>解决方法2：</h3><p>1、打开Internert信息管理查看IIS是否启动，且默认网站时候已经开启；<br>2、打开<a href="http://127.0.0.1/">http://127.0.0.1/</a> 看是否能访问IIS的默认网页，能访问则说明IIS已经成功安装到电脑上，可能是无法解析localhost；<br>3、开始–命令（cmd）–ping localhost，看是否能ping通，从127.0.0.1上返回信息，如果成功则说明可以解析localhost；<br>4、如果上一步不成功，则用记事本打开C:&#x2F;WINDOWS&#x2F;system32&#x2F;drivers&#x2F;etc&#x2F;hosts文件，看里面是否有包含：127.0.0.1 localhost ，如果没有则将其添加进去，再查看能否访问localhost。<br>5、尝试将网站的主目录指向另一个目录或新建一个虚拟目录，并在该新目录创建一个新的网页文件，如index.html，然后将其加到默认网站的”文档”项中作为默认访问的网页，重新输入网址：<a href="http://localhost/%EF%BC%8C%E7%9C%8B%E5%90%A6%E8%83%BD%E8%AE%BF%E9%97%AE%E3%80%82">http://localhost/，看否能访问。</a><br>6、还是不行的话将IIS卸载掉，重新再安装一次。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;localhost与127-0-0-1与0-0-0-0以及端口&quot;&gt;&lt;a href=&quot;#localhost与127-0-0-1与0-0-0-0以及端口&quot; class=&quot;headerlink&quot; title=&quot;localhost与127.0.0.1与0.0.0.0以及端</summary>
      
    
    
    
    <category term="网络" scheme="http://justskim.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="http://justskim.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Mysql安装的版本选择</title>
    <link href="http://justskim.github.io/2022/02/12/Mysql%E5%AE%89%E8%A3%85%E7%9A%84%E7%89%88%E6%9C%AC%E9%80%89%E6%8B%A9/"/>
    <id>http://justskim.github.io/2022/02/12/Mysql%E5%AE%89%E8%A3%85%E7%9A%84%E7%89%88%E6%9C%AC%E9%80%89%E6%8B%A9/</id>
    <published>2022-02-12T10:30:47.490Z</published>
    <updated>2022-02-17T15:09:38.844Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql安装的版本选择"><a href="#Mysql安装的版本选择" class="headerlink" title="Mysql安装的版本选择"></a>Mysql安装的版本选择</h1><h2 id="官网中的版本类别"><a href="#官网中的版本类别" class="headerlink" title="官网中的版本类别"></a>官网中的版本类别</h2><p>在<a href="https://www.mysql.com/downloads/">mysql官方下载页面</a>，可以看到有以下几个版本：</p><ol><li><p>MySQL Community Server 社区版本，由于开源免费因此是最常用的，但不提供官方技术支持。</p></li><li><p>MySQL Enterprise Edition 企业版本，需付费，可以试用30天。</p></li><li><p>MySQL Cluster 集群版，开源免费。可将几个MySQL Server封装成一个Server</p></li><li><p>MySQL Cluster CGE 高级集群版，需付费。</p></li><li><p>MySQL Workbench（GUI TOOL）一款专为MySQL设计的ER&#x2F;数据库建模工具。它是著名的数据库设计工具DBDesigner4的继任者。MySQL Workbench又分为两个版本，分别是社区版（MySQL Workbench OSS）、商用版（MySQL Workbench SE）。</p></li></ol><h2 id="Linux中安装MySQL"><a href="#Linux中安装MySQL" class="headerlink" title="Linux中安装MySQL"></a>Linux中安装MySQL</h2><p>这里为了方便，我们使用MySQL Community Server版本来进行安装示例。</p><h3 id="选择与Linux系统相配的安装版本"><a href="#选择与Linux系统相配的安装版本" class="headerlink" title="选择与Linux系统相配的安装版本"></a>选择与Linux系统相配的安装版本</h3><p>注意，<code>linux</code>内核版本和<code>linux</code>系统版本是不同的概念！内核是系统的心脏，也是运行程序和管理设备的核心程序，而我们平时所说的<code>Redhat</code>，<code>Ubuntu</code>及<code>Centos</code>是不同的<code>linux</code>发行版</p><p><strong>查看Linux内核版本命令</strong></p><ol><li><code>cat /proc/version</code>    这个文件只有一行内容, 说明正在运行的内核版本</li><li><code>uname -a</code>    Linux <code>uname</code>（英文全拼：unix name）命令用于显示系统信息。<code>uname</code> 可显示电脑以及操作系统的相关信息，语法：<code>uname [-amnrsv][--help][--version]</code>；其中-a或–all 　显示全部的信息。</li></ol><p><strong>查看Linux系统版本命令</strong></p><ol><li>使用命令<code>lsb_release -a</code>列出所有版本信息，如果提示未找到相关命令，则需要我们使用命令<code>yum install -y redhat-lsb</code>进行安装；</li><li><code>cat /etc/redhat-release</code>，这种方法只适合<code>RedHat</code>系的Linux；</li><li><code>cat /etc/issue</code>，<code>/etc/issue</code>、<code>/etc/issue</code>与 <code>/etc/motd</code> 作用一致，都是<strong>用于显示欢迎信息</strong>，可能包含Linux系统版本的信息。</li></ol><p>查找到的结果为：<code>CentOS Linux release 7.8.2003</code></p><p>我们在这里选择Linux genertic下x86_64的版本，复制相关链接，在远程服务器的Linux系统中使用wget进行下载安装。</p><p><img src="/images/linux%E4%B8%8Bmysql%E5%AE%89%E8%A3%85%E7%89%88%E6%9C%AC%E9%80%89%E6%8B%A9.png" alt="linux下mysql安装版本选择"></p><p>下载得到的是一个tar压缩包，我们可以在<a href="https://dev.mysql.com/doc/refman/8.0/en/binary-installation.html">MySQL官方提供的说明文档</a>（这里以8.0版本为例）中</p><p>对该安装包使用命令<code>tar -xvf</code>解压：</p><p><img src="/images/mysql%E7%9A%84xz%E5%AE%89%E8%A3%85%E5%8C%85%E8%A7%A3%E5%8E%8B.png" alt="mysql的xz安装包解压"></p><p>我们使用的系统是<code>Centos</code>，因此有yum工具而没有apt，如果是<code>ubuntu</code>要使用apt进行安装，操作如<a href="https://blog.jkdev.cn/index.php/archieves/125">相关教程博客</a>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt install numactl</span><br><span class="line"><span class="comment">#仅安装libaio库还不行，还要安装numactl库</span></span><br><span class="line"></span><br><span class="line">apt install libaio-dev</span><br></pre></td></tr></table></figure><p>在安装完相关库之后，我们使用以下的命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$<span class="operator">&gt;</span> groupadd mysql</span><br><span class="line">$<span class="operator">&gt;</span> useradd <span class="operator">-</span>r <span class="operator">-</span>g mysql <span class="operator">-</span>s <span class="operator">/</span>bin<span class="operator">/</span><span class="literal">false</span> mysql</span><br><span class="line">$<span class="operator">&gt;</span> cd mysql</span><br><span class="line">$<span class="operator">&gt;</span> mkdir mysql<span class="operator">-</span>files</span><br><span class="line">$<span class="operator">&gt;</span> chown mysql:mysql mysql<span class="operator">-</span>files</span><br><span class="line">$<span class="operator">&gt;</span> chmod <span class="number">750</span> mysql<span class="operator">-</span>files</span><br><span class="line">$<span class="operator">&gt;</span> bin<span class="operator">/</span>mysqld <span class="comment">--initialize --user=mysql</span></span><br><span class="line">$<span class="operator">&gt;</span> bin<span class="operator">/</span>mysql_ssl_rsa_setup</span><br><span class="line">$<span class="operator">&gt;</span> bin<span class="operator">/</span>mysqld_safe <span class="comment">--user=mysql &amp;</span></span><br><span class="line"># Next command <span class="keyword">is</span> optional</span><br><span class="line">$<span class="operator">&gt;</span> cp support<span class="operator">-</span>files<span class="operator">/</span>mysql.server <span class="operator">/</span>etc<span class="operator">/</span>init.d<span class="operator">/</span>mysql.server</span><br></pre></td></tr></table></figure><p>其中，如果赋相关目录<code>MySQL</code>用户权限的<code>chown</code>命令发生以下报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span>: invalid user: mysql:mysql</span><br></pre></td></tr></table></figure><p>我们需要再次通过添加执行用户名和组的方式解决：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd mysql</span><br><span class="line">useradd -g mysql mysql</span><br></pre></td></tr></table></figure><p>注意，初始化数据库时，如果提示<code>mysqld not found</code>错误，是由于 &#x2F;etc&#x2F;init.d&#x2F; 不存在 mysqld 这个命令</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Mysql安装的版本选择&quot;&gt;&lt;a href=&quot;#Mysql安装的版本选择&quot; class=&quot;headerlink&quot; title=&quot;Mysql安装的版本选择&quot;&gt;&lt;/a&gt;Mysql安装的版本选择&lt;/h1&gt;&lt;h2 id=&quot;官网中的版本类别&quot;&gt;&lt;a href=&quot;#官网中的版</summary>
      
    
    
    
    <category term="Mysql" scheme="http://justskim.github.io/categories/Mysql/"/>
    
    <category term="安装" scheme="http://justskim.github.io/categories/Mysql/%E5%AE%89%E8%A3%85/"/>
    
    
    <category term="mysql" scheme="http://justskim.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>win10上的代理服务器设置与127.0.0.1</title>
    <link href="http://justskim.github.io/2022/02/08/win10%E4%B8%8A%E7%9A%84%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE%E4%B8%8E127.0.0.1/"/>
    <id>http://justskim.github.io/2022/02/08/win10%E4%B8%8A%E7%9A%84%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE%E4%B8%8E127.0.0.1/</id>
    <published>2022-02-08T06:02:05.413Z</published>
    <updated>2022-02-08T07:13:50.206Z</updated>
    
    <content type="html"><![CDATA[<h1 id="win10上的代理服务器设置与127-0-0-1"><a href="#win10上的代理服务器设置与127-0-0-1" class="headerlink" title="win10上的代理服务器设置与127.0.0.1"></a>win10上的代理服务器设置与127.0.0.1</h1><h2 id="代理服务器的定义"><a href="#代理服务器的定义" class="headerlink" title="代理服务器的定义"></a>代理服务器的定义</h2><p>代理服务器（Proxy Server）是介于浏览器和Web服务器之间的一台服务器，可被用于代理网络用户去取得网络信息。可以说，代理服务器是网络信息的中转站，是个人网络和Internet服务商之间的中间代理机构，负责转发合法的网络信息，对转发进行控制和登记，工作在OSI模型的对话层。当你通过代理服务器上网浏览时，浏览器不是直接到Web服务器去取回网页，而是向代理服务器发出请求，由代理服务器来取回浏览器所需要的信息，并传送给你的浏览器。 </p><p>Win10系统提供<strong>系统级代理服务器设置，通过在Win10系统中设置代理服务器</strong>，系统中所有的软件都会通过我们设置的代理服务器访问网络，这样就不用一个一个软件设置代理服务器了，包括浏览器等应用，都会使用设定的系统代理服务器上网。</p><h2 id="环回地址127-0-0-1"><a href="#环回地址127-0-0-1" class="headerlink" title="环回地址127.0.0.1"></a>环回地址127.0.0.1</h2><p>127.0.0.1是回送地址主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，协议软件立即返回之，不进行任何网络传输。有时候当我们使用浏览器点击网页时，有时候会发现提示网页无法找到，建议我们检查代理服务器设置。而在win10系统的设置一栏，有一项“代理服务器”的设置，有时我们点开这里，会发现代理服务器被设置为127.0.0.1，原因不明，但将代理服务器关闭即可正常访问网络，检查host文件也没有发现异常。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;win10上的代理服务器设置与127-0-0-1&quot;&gt;&lt;a href=&quot;#win10上的代理服务器设置与127-0-0-1&quot; class=&quot;headerlink&quot; title=&quot;win10上的代理服务器设置与127.0.0.1&quot;&gt;&lt;/a&gt;win10上的代理服务器设置</summary>
      
    
    
    
    <category term="网络" scheme="http://justskim.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="服务器" scheme="http://justskim.github.io/categories/%E7%BD%91%E7%BB%9C/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
    <category term="网络" scheme="http://justskim.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="服务器" scheme="http://justskim.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>在vmware虚拟机中进行网络连接</title>
    <link href="http://justskim.github.io/2021/11/16/%E5%9C%A8vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5/"/>
    <id>http://justskim.github.io/2021/11/16/%E5%9C%A8vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5/</id>
    <published>2021-11-16T07:16:40.924Z</published>
    <updated>2022-02-12T10:13:06.192Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在vmware虚拟机中进行网络连接"><a href="#在vmware虚拟机中进行网络连接" class="headerlink" title="在vmware虚拟机中进行网络连接"></a>在<code>vmware</code>虚拟机中进行网络连接</h1><h2 id="四种网络模式"><a href="#四种网络模式" class="headerlink" title="四种网络模式"></a>四种网络模式</h2><p>点击<code>VMware Workstation</code>的导航栏，在“虚拟机-&gt;设置-&gt;硬件-&gt;网络设配器”中，可看到网络连接模式的选择（不能在虚拟机挂起的时候进行更改），<a href="https://docs.vmware.com/cn/VMware-Workstation-Pro/14.0/com.vmware.ws.using.doc/GUID-3B504F2F-7A0B-415F-AE01-62363A95D052.html">VMware的官方网站</a>中说明了四种网络模式的区别：</p><table><thead><tr><th align="left">设置</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><strong>使用桥接模式网络连接</strong></td><td align="left">为虚拟机配置桥接模式网络连接。使用桥接模式网络连接时，虚拟机将具有直接访问外部以太网网络的权限。虚拟机必须在外部网络中具有自己的 IP 地址。如果您的主机系统位于网络中，而且您拥有可用于虚拟机的单独 IP 地址（或者可以从 DHCP 服务器获得 IP 地址），请选择此设置。网络中的其他计算机将能够与该虚拟机直接通信。</td></tr><tr><td align="left"><strong>使用网络地址转换 (NAT)</strong></td><td align="left">为虚拟机配置 NAT 连接。利用 NAT，虚拟机和主机系统将共享一个网络标识，此标识在网络以外不可见。如果您没有可用于虚拟机的单独 IP 地址，但又希望能够连接到 Internet，请选择 NAT。</td></tr><tr><td align="left"><strong>使用仅主机模式网络连接</strong></td><td align="left">为虚拟机配置仅主机模式网络连接。仅主机模式网络连接使用对主机操作系统可见的虚拟网络适配器，在虚拟机和主机系统之间提供网络连接。使用仅主机模式网络连接时，虚拟机只能与主机系统以及仅主机模式网络中的其他虚拟机进行通信。要设置独立的虚拟网络，请选择仅主机模式网络连接。</td></tr><tr><td align="left"><strong>不使用网络连接</strong></td><td align="left">不为虚拟机配置网络连接。</td></tr><tr><td align="left"><strong>自定义</strong>（Windows 主机）或<strong>已命名的网络</strong>（Linux 主机）</td><td align="left">（仅限远程虚拟机）选择特定虚拟网络。从下拉菜单中选择一个自定义网络。尽管列表中有 <code>VMnet0</code>、<code>VMnet1 </code>和 <code>VMnet8</code>，但这些网络通常被用于桥接模式、仅主机模式和 NAT 模式网络。</td></tr></tbody></table><p>对于使用校园网或者公司网络的用户，NAT是最简单的方式。</p><h2 id="网络配置相关文件"><a href="#网络配置相关文件" class="headerlink" title="网络配置相关文件"></a>网络配置相关文件</h2><p><strong>eth0</strong></p><p>该文件一般位于路径“&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts”中</p><h2 id="网络配置相关命令"><a href="#网络配置相关命令" class="headerlink" title="网络配置相关命令"></a>网络配置相关命令</h2><p><strong><code>ifconfig</code></strong></p><p><strong>用于配置网卡的基本命令</strong>，注意不是<code>ipconfig</code>！<code>ifconfig</code>命令的英文全称是“network interfaces configuring”，即用于配置和显示Linux内核中网络接口的网络参数。用<code>ifconfig</code>命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。要想将上述的配置信息永远的存的电脑里，那就要修改网卡的配置文件了。</p><p><strong>常用参数：</strong></p><table><thead><tr><th>add &lt;地址&gt;</th><th>设置网络设备IPv6的IP地址</th></tr></thead><tbody><tr><td><code>del</code> &lt;地址&gt;</td><td>删除网络设备IPv6的IP地址</td></tr><tr><td>down</td><td>关闭指定的网络设备</td></tr><tr><td>up</td><td>启动指定的网络设备</td></tr><tr><td>IP地址</td><td>指定网络设备的IP地址</td></tr></tbody></table><p>一个与之相似的命令是windows系统下的<code>ipconfig</code>命令</p><p><strong>ethtool</strong></p><p>用于查询ethX网口基本设置、及设置网卡的参数</p><h2 id="以上步骤尝试过后，依然无法解决联网问题"><a href="#以上步骤尝试过后，依然无法解决联网问题" class="headerlink" title="以上步骤尝试过后，依然无法解决联网问题"></a>以上步骤尝试过后，依然无法解决联网问题</h2><p>如果在以上步骤尝试过后，依然无法解决联网问题，特别是最简单的NAT模式下，可以查看相关端口是否被杀毒软件禁止，以及服务是否成功启动。笔者在实际操作中遇到过这种情况，最后，根据<a href="https://www.cnblogs.com/hi3254014978/p/12668471.html">这篇博客</a>，将win10中的服务打开，手动启动或者重新启动<code>VMware DHCP Service</code>和<code>VMware NAT Service</code>两个服务即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;在vmware虚拟机中进行网络连接&quot;&gt;&lt;a href=&quot;#在vmware虚拟机中进行网络连接&quot; class=&quot;headerlink&quot; title=&quot;在vmware虚拟机中进行网络连接&quot;&gt;&lt;/a&gt;在&lt;code&gt;vmware&lt;/code&gt;虚拟机中进行网络连接&lt;/h1&gt;</summary>
      
    
    
    
    <category term="Linux" scheme="http://justskim.github.io/categories/Linux/"/>
    
    
    <category term="linux" scheme="http://justskim.github.io/tags/linux/"/>
    
    <category term="虚拟机" scheme="http://justskim.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    <category term="ubuntu" scheme="http://justskim.github.io/tags/ubuntu/"/>
    
    <category term="vmware" scheme="http://justskim.github.io/tags/vmware/"/>
    
  </entry>
  
  <entry>
    <title>python3中的运行命令与环境</title>
    <link href="http://justskim.github.io/2021/11/09/python3%E4%B8%AD%E7%9A%84%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4%E4%B8%8E%E7%8E%AF%E5%A2%83/"/>
    <id>http://justskim.github.io/2021/11/09/python3%E4%B8%AD%E7%9A%84%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4%E4%B8%8E%E7%8E%AF%E5%A2%83/</id>
    <published>2021-11-08T18:35:42.058Z</published>
    <updated>2021-11-08T18:36:09.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python3中的运行命令与环境"><a href="#python3中的运行命令与环境" class="headerlink" title="python3中的运行命令与环境"></a>python3中的运行命令与环境</h1><p>本机电脑仅安装python3，以下使用的均为python3环境配置</p><h2 id="镜像是什么？"><a href="#镜像是什么？" class="headerlink" title="镜像是什么？"></a>镜像是什么？</h2><p>镜像（Mirroring）是一种文件存储形式，是冗余的一种类型，一个磁盘上的数据在另一个磁盘上存在一个完全相同的副本即为镜像。</p><p>镜像源 就是把官<strong>方的源做一个镜像，你</strong>可以在这下载软件。 比如ubuntu官方源在国外，下载软件可能会很慢，这时候就需要换成国内的镜像源。 源 端口就是指本地端口 目的端口就是远程端口 一个数据包（pocket）被解封装成数据段（segment）后就会涉及到 连接上层协议的端口问题。</p><p>镜像网站（Mirror sites）又称之为镜像站点</p><h2 id="anaconda环境"><a href="#anaconda环境" class="headerlink" title="anaconda环境"></a>anaconda环境</h2><h2 id="命令行运行python程序，与idle中”Run-module“的区别"><a href="#命令行运行python程序，与idle中”Run-module“的区别" class="headerlink" title="命令行运行python程序，与idle中”Run module“的区别"></a>命令行运行python程序，与idle中”Run module“的区别</h2><p>笔者在学习<a href="https://gitee.com/daochenzha/rlcard?_from=gitee_search#/daochenzha/rlcard/blob/master/docs/toy-examples.md#playing-with-random-agents">RLCard——一款卡牌游戏强化学习工具包</a>的时候，发现了<a href="https://gitee.com/daochenzha/rlcard/blob/master/docs/toy-examples.md#playing-with-random-agents">范例</a>中的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> rlcard</span><br><span class="line"><span class="keyword">from</span> rlcard.agents <span class="keyword">import</span> RandomAgent</span><br><span class="line"><span class="keyword">from</span> rlcard.utils <span class="keyword">import</span> set_seed</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">args</span>):</span><br><span class="line">    <span class="comment"># Make environment</span></span><br><span class="line">    env = rlcard.make(args.env, config=&#123;<span class="string">&#x27;seed&#x27;</span>: <span class="number">42</span>&#125;)</span><br><span class="line">    num_episodes = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Seed numpy, torch, random</span></span><br><span class="line">    set_seed(<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set agents</span></span><br><span class="line">    agent = RandomAgent(num_actions=env.num_actions)</span><br><span class="line">    env.set_agents([agent <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(env.num_players)])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> episode <span class="keyword">in</span> <span class="built_in">range</span>(num_episodes):</span><br><span class="line">        <span class="comment"># Generate data from the environment</span></span><br><span class="line">        trajectories, player_wins = env.run(is_training=<span class="literal">False</span>)</span><br><span class="line">        <span class="comment"># Print out the trajectories</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\nEpisode &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(episode))</span><br><span class="line">        <span class="built_in">print</span>(trajectories)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    parser = argparse.ArgumentParser(<span class="string">&quot;Random example in RLCard&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--env&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;leduc-holdem&#x27;</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    run(args)</span><br></pre></td></tr></table></figure><p>这段代码在idle中无法被“Run module”运行，却可以在命令行中运行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在idle中无法被“Run module”运行</span></span><br><span class="line">============== RESTART: E:/python练习/RLCard/examples/run_random.py ==============</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;E:/python练习/RLCard/examples/run_random.py&quot;</span>, line <span class="number">4</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">from</span> rlcard.agents <span class="keyword">import</span> RandomAgent</span><br><span class="line">  File <span class="string">&quot;E:\python\lib\site-packages\rlcard\agents\__init__.py&quot;</span>, line <span class="number">5</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    reqs = subprocess.check_output([sys.executable, <span class="string">&#x27;-m&#x27;</span>, <span class="string">&#x27;pip&#x27;</span>, <span class="string">&#x27;freeze&#x27;</span>])</span><br><span class="line">  File <span class="string">&quot;E:\python\lib\subprocess.py&quot;</span>, line <span class="number">424</span>, <span class="keyword">in</span> check_output</span><br><span class="line">    <span class="keyword">return</span> run(*popenargs, stdout=PIPE, timeout=timeout, check=<span class="literal">True</span>,</span><br><span class="line">  File <span class="string">&quot;E:\python\lib\subprocess.py&quot;</span>, line <span class="number">528</span>, <span class="keyword">in</span> run</span><br><span class="line">    <span class="keyword">raise</span> CalledProcessError(retcode, process.args,</span><br><span class="line">subprocess.CalledProcessError: Command <span class="string">&#x27;[&#x27;</span>E:\\python\\pythonw.exe<span class="string">&#x27;, &#x27;</span>-m<span class="string">&#x27;, &#x27;</span>pip<span class="string">&#x27;, &#x27;</span>freeze<span class="string">&#x27;]&#x27;</span> returned non-zero exit status <span class="number">120.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#可以在命令行中运行</span></span><br><span class="line">$ python examples/run_random.py</span><br><span class="line">WARNING: Ignoring invalid distribution -ip (e:\python\lib\site-packages)</span><br><span class="line">WARNING: Ignoring invalid distribution -ip (e:\python\lib\site-packages)</span><br><span class="line"></span><br><span class="line">Episode <span class="number">0</span></span><br><span class="line">[[&#123;<span class="string">&#x27;legal_actions&#x27;</span>: OrderedDict([(<span class="number">1</span>, <span class="literal">None</span>), (<span class="number">2</span>, <span class="literal">None</span>), (<span class="number">3</span>, <span class="literal">None</span>)]), <span class="string">&#x27;obs&#x27;</span>: array([<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>,</span><br><span class="line">       <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>,</span><br><span class="line">       <span class="number">0.</span>, <span class="number">0.</span>]), <span class="string">&#x27;raw_obs&#x27;</span>: &#123;<span class="string">&#x27;hand&#x27;</span>: <span class="string">&#x27;HQ&#x27;</span>, <span class="string">&#x27;public_card&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;all_chips&#x27;</span>: [<span class="number">2</span>, <span class="number">1</span>], <span class="string">&#x27;my_chips&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;legal_actions&#x27;</span>: [<span class="string">&#x27;raise&#x27;</span>, <span class="string">&#x27;fold&#x27;</span>, <span class="string">&#x27;check&#x27;</span>], <span class="string">&#x27;current_player&#x27;</span>: <span class="number">0</span>&#125;, <span class="string">&#x27;raw_legal_actions&#x27;</span>: [<span class="string">&#x27;raise&#x27;</span>, <span class="string">&#x27;fold&#x27;</span>, <span class="string">&#x27;check&#x27;</span>], <span class="string">&#x27;action_record&#x27;</span>: [(<span class="number">1</span>, <span class="string">&#x27;fold&#x27;</span>)]&#125;], [&#123;<span class="string">&#x27;legal_actions&#x27;</span>: OrderedDict([(<span class="number">0</span>, <span class="literal">None</span>), (<span class="number">1</span>, <span class="literal">None</span>), (<span class="number">2</span>, <span class="literal">None</span>)]), <span class="string">&#x27;obs&#x27;</span>: array([<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>,</span><br><span class="line">       <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>,</span><br><span class="line">       <span class="number">0.</span>, <span class="number">0.</span>]), <span class="string">&#x27;raw_obs&#x27;</span>: &#123;<span class="string">&#x27;hand&#x27;</span>: <span class="string">&#x27;HJ&#x27;</span>, <span class="string">&#x27;public_card&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;all_chips&#x27;</span>: [<span class="number">2</span>, <span class="number">1</span>], <span class="string">&#x27;my_chips&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;legal_actions&#x27;</span>: [<span class="string">&#x27;call&#x27;</span>, <span class="string">&#x27;raise&#x27;</span>, <span class="string">&#x27;fold&#x27;</span>], <span class="string">&#x27;current_player&#x27;</span>: <span class="number">1</span>&#125;, <span class="string">&#x27;raw_legal_actions&#x27;</span>: [<span class="string">&#x27;call&#x27;</span>, <span class="string">&#x27;raise&#x27;</span>, <span class="string">&#x27;fold&#x27;</span>], <span class="string">&#x27;action_record&#x27;</span>: [(<span class="number">1</span>, <span class="string">&#x27;fold&#x27;</span>)]&#125;, <span class="number">2</span>, &#123;<span class="string">&#x27;legal_actions&#x27;</span>: OrderedDict([(<span class="number">1</span>, <span class="literal">None</span>), (<span class="number">2</span>, <span class="literal">None</span>), (<span class="number">3</span>, <span class="literal">None</span>)]), <span class="string">&#x27;obs&#x27;</span>: array([<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>,</span><br><span class="line">       <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>,</span><br><span class="line">       <span class="number">0.</span>, <span class="number">0.</span>]), <span class="string">&#x27;raw_obs&#x27;</span>: &#123;<span class="string">&#x27;hand&#x27;</span>: <span class="string">&#x27;HJ&#x27;</span>, <span class="string">&#x27;public_card&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;all_chips&#x27;</span>: [<span class="number">2</span>, <span class="number">1</span>], <span class="string">&#x27;my_chips&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;legal_actions&#x27;</span>: [<span class="string">&#x27;raise&#x27;</span>, <span class="string">&#x27;fold&#x27;</span>, <span class="string">&#x27;check&#x27;</span>], <span class="string">&#x27;current_player&#x27;</span>: <span class="number">0</span>&#125;, <span class="string">&#x27;raw_legal_actions&#x27;</span>: [<span class="string">&#x27;raise&#x27;</span>, <span class="string">&#x27;fold&#x27;</span>, <span class="string">&#x27;check&#x27;</span>], <span class="string">&#x27;action_record&#x27;</span>: [(<span class="number">1</span>, <span class="string">&#x27;fold&#x27;</span>)]&#125;]]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们试着来比较这两个命令的差别：</p><p><a href="https://zhuanlan.zhihu.com/p/150835014">这篇博客中介绍了sys模块的使用详情</a>，我们只讲两个下面会使用到的函数，</p><p><em>sys模块</em>提供了一系列有关<em>Python</em>运行环境的变量和函数，</p><p>sys.path<br>返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值</p><h3 id="sys-executable"><a href="#sys-executable" class="headerlink" title="sys.executable"></a><strong>sys.executable</strong></h3><p>该属性是一个字符串，在正常情况下，其值是当前运行的 Python 解释器对应的可执行程序所在的绝对路径。</p><p>比如在 Windows 上使用 Anaconda 安装的 Python，该属性的值就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.executable</span><br><span class="line"><span class="string">&#x27;E:\\Anaconda\\Anaconda\\python.exe&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="E:\JS练习\blog\Myblog\source\images\两个命令差别.png"></p><p>打印结果，我们可以发现二者的绝对路径不一样，在Idle中，python解释器对应的可执行程序为pythonw.exe，而在命令行中则是python.exe</p><p><strong>python.exe与pythonw.exe</strong></p><p>Windows系统搭建好Python的环境后，进入Python的安装目录，大家会发现目录中有python.exe和pythonw.exe两个程序。</p><p><a href="https://zhuanlan.zhihu.com/p/302384158">这两个程序的区别在于</a>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a）、python.exe在运行程序的时候，会弹出一个黑色的控制台窗口（也叫命令行窗口、DOS/CMD窗口）；</span><br><span class="line">   b）、pythonw.exe是无窗口的Python可执行程序，意思是在运行程序的时候，没有窗口，代码在后台执行</span><br><span class="line">   .py和.pyw文件的区别也来源于python.exe和pythonw.exe的区别：</span><br><span class="line">   安装视窗版 Python 时，扩展名为 .py 的文件被默认为用 python.exe 运行的文件，而 .pyw文件则被默认为用 pythonw.exe 运行。</span><br><span class="line">这里还要解释一个问题，如果.py文件直接用python.exe打开，文件被执行完成之后，视窗会立即关闭，如果想让视窗停留；给大家提供两个方法：</span><br><span class="line">① 可以在程序中import time模块，加入超长睡眠语句，如time.sleep(1800)，如果你不手动关闭视窗，视窗将会停留30min；</span><br><span class="line">② 可以调用sys和os模块，使用命令行语句pause</span><br><span class="line"></span><br><span class="line">  3、.pyw格式是被设计用来运行开发的纯图形界面程序的，纯图形界面程序的用户不需要看到控制台窗口。</span><br><span class="line">    在开发纯图形界面程序的时候，可以暂时把 .pyw 改成 .py ，运行时能调出控制台窗口，方便看到所有错误信息。</span><br><span class="line">    至于.pyc文件，是Python解释器运行程序的过程中产生的字节码文件（也就是中间文件）。</span><br></pre></td></tr></table></figure><p>总之，我们尽可能地使用命令行来执行.py格式程序。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;python3中的运行命令与环境&quot;&gt;&lt;a href=&quot;#python3中的运行命令与环境&quot; class=&quot;headerlink&quot; title=&quot;python3中的运行命令与环境&quot;&gt;&lt;/a&gt;python3中的运行命令与环境&lt;/h1&gt;&lt;p&gt;本机电脑仅安装python3</summary>
      
    
    
    
    <category term="Programming languages and projects" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/"/>
    
    <category term="Python3" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"/>
    
    
    <category term="python3" scheme="http://justskim.github.io/tags/python3/"/>
    
    <category term="anaconda" scheme="http://justskim.github.io/tags/anaconda/"/>
    
  </entry>
  
  <entry>
    <title>python3中的生成器与迭代器</title>
    <link href="http://justskim.github.io/2021/11/03/python3%E4%B8%AD%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>http://justskim.github.io/2021/11/03/python3%E4%B8%AD%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/</id>
    <published>2021-11-03T01:55:18.115Z</published>
    <updated>2021-11-03T08:39:09.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python3中的生成器与迭代器"><a href="#python3中的生成器与迭代器" class="headerlink" title="python3中的生成器与迭代器"></a>python3中的生成器与迭代器</h1><h2 id="生成器与迭代器"><a href="#生成器与迭代器" class="headerlink" title="生成器与迭代器"></a>生成器与迭代器</h2><p>在Python社区，生成器和迭代器被看作一种工具，生成器的本质就是迭代器。唯一的区别就是生成器是开发人员自己用Python代码构建的数据结构，而迭代器是Python内置提供或转化而来的。</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器是一种对象，该对象包含值的可计数数字。</p><p>迭代器是可迭代的对象，这意味着您可以遍历所有值。</p><p>从技术上讲，在 Python 中，迭代器是实现迭代器协议的对象，它包含方法<code>__iter__()</code>和 <code>__next__()</code>。<br>要把对象&#x2F;类创建为迭代器，必须为对象实现<code> __iter__()</code> 和 <code>__next__()</code> 方法。</p><p>正如您在 Python 类&#x2F;对象 一章中学到的，所有类都有名为 <code>__init__()</code> 的函数，它允许您在创建对象时进行一些初始化。</p><p><code>__iter__()</code>方法的作用相似，您可以执行操作（初始化等），但必须始终返回迭代器对象本身。</p><p><code>__next__()</code>方法也允许您执行操作，并且必须返回序列中的下一个项目。</p><h3 id="可迭代对象（Iterable）"><a href="#可迭代对象（Iterable）" class="headerlink" title="可迭代对象（Iterable）"></a>可迭代对象（Iterable）</h3><p>列表、元组、字典和集合、字符串都是可迭代的对象。它们是可迭代的容器，您可以从中获取迭代器（Iterator）。</p><p>所有这些对象都有用于获取迭代器的 iter() 方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mytuple = (<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>)</span><br><span class="line">myit = <span class="built_in">iter</span>(mytuple)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myit))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myit))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myit))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mytuple = (<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myit=<span class="built_in">iter</span>(mytuple)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(myit))</span><br><span class="line">apple</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(myit))</span><br><span class="line">banana</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(myit))</span><br><span class="line">cherry</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mytuple1=<span class="string">&quot;banana&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myit1=<span class="built_in">iter</span>(mytuple1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(myit))</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#54&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(myit))</span><br><span class="line">StopIteration<span class="comment">#序列的所有项目都被迭代过，因此迭代（iteration）停止，报错</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(myit1))</span><br><span class="line">b</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(myit1))</span><br><span class="line">a</span><br></pre></td></tr></table></figure><p>也可以使用 for 循环遍历可迭代对象</p><h3 id="StopIteration-异常的使用"><a href="#StopIteration-异常的使用" class="headerlink" title="StopIteration 异常的使用"></a><code>StopIteration</code> 异常的使用</h3><p><code>StopIteration</code>异常用于完成标识迭代，防止无限循环。</p><p><code>__next__()</code>函数完成指定循环次数后，会触发该异常结束迭代。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">it = <span class="built_in">iter</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        x = <span class="built_in">next</span>(it)</span><br><span class="line">        <span class="built_in">print</span>(x)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment">#如果不使用StopIteration，则会报错异常</span></span><br></pre></td></tr></table></figure><h3 id="将一个类当做迭代器使用"><a href="#将一个类当做迭代器使用" class="headerlink" title="将一个类当做迭代器使用"></a>将一个类当做迭代器使用</h3><p>把一个类作为一个迭代器使用需要在类中方法 <code>__iter__()0</code>与 <code>__next__()</code> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyNumbers</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">    self.a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">    x = self.a</span><br><span class="line">    self.a += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"> </span><br><span class="line">myclass = MyNumbers()</span><br><span class="line">myiter = <span class="built_in">iter</span>(myclass)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))<span class="comment">#1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))<span class="comment">#2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))<span class="comment">#3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))<span class="comment">#4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))<span class="comment">#5</span></span><br></pre></td></tr></table></figure><h2 id="python3生成器"><a href="#python3生成器" class="headerlink" title="python3生成器"></a><code>python3</code>生成器</h2><p>在 Python 中，使用了 yield 的函数被称为<strong>生成器（generator）</strong>。</p><p>跟普通函数不同的是，<strong>生成器</strong>是一个<strong>返回迭代器的函数</strong>，<strong>只能用于迭代操作</strong>，更简单点理解生成器就是一个迭代器。</p><p>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。</p><p>调用一个生成器函数，返回的是一个迭代器对象。</p><h3 id="yield关键字"><a href="#yield关键字" class="headerlink" title="yield关键字"></a>yield关键字</h3><p>我们先将yield看做return，执行下面的程序，看看结果如何？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;starting...&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">res=<span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;res:&quot;</span>,res)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g=foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br><span class="line">starting...</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line">********************</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br><span class="line">res: <span class="literal">None</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/mieleizhi0522/article/details/82142856">原文章</a>的博主对于执行顺序给出了以下解释：</p><blockquote><p>1.程序开始执行以后，因为<code>foo</code>函数中有yield关键字，所以<code>foo</code>函数并不会真的执行，而是先得到一个生成器g(相当于一个对象)</p><p>2.直到调用next方法，<code>foo</code>函数正式开始执行，先执行<code>foo</code>函数中的print方法，然后进入while循环</p><p>3.程序遇到yield关键字，然后把yield想象成return，return了一个4之后，程序停止，并没有执行赋值给res操作，此时next(g)语句执行完成，所以输出的前两行（第一行“starting…”是while上面的print的结果，第二行“4”是return出的结果）是执行print(next(g))的结果，<strong>注意并没有执行yield一句下一行的print(“res:”,res)语句</strong></p><p>4.程序执行print(“<code>*</code>“*20)，输出20个<code>*</code></p><p>5.又开始执行下面的<code>print(next(g))</code>，不同的是，这一次<strong>从刚才那个next程序停止的地方开始执行的</strong>，也就是要<strong>从yield语句的下一行语句开始</strong>，执行res的赋值操作，这时候要注意，这个时候赋值操作的右边是没有值的（因为刚才那个是return出去了，并没有给赋值操作的左边传参数），所以这个时候res赋值是None,所以接着下面的输出就是<code>res:None</code></p><p>6.程序会继续在while里执行，又一次碰到yield,这个时候同样return 出4，然后程序停止，print函数输出的4就是这次return出的4.</p></blockquote><p>带yield的函数是一个生成器，可以不再看做一个函数了。这个生成器有一个next函数，相当于“下一步”生成哪个数，<strong>这一次的next开始的地方是接着上一次的next停止的地方执行的</strong>，所以调用next的时候，生成器并不会从<code>foo</code>函数的开始执行，只是接着上一步停止的地方开始，然后遇到yield后，return出要生成的数，此步就结束。</p><p>我们接着上面的代码，继续输出next(g)，每一次的next开始的地方都是上一次的next停止的地方：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br><span class="line">res: <span class="literal">None</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br><span class="line">res: <span class="literal">None</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>也就是说，除了第一次next函数可能会特殊（循环体外的代码部分执行原因），<strong>每次我们使用next函数，都是从上一个yield停止的地方，开始跑代码，跑到下一个yield语句，return了值， 停止</strong>。下面的例子更加直观一些：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">fo</span>(<span class="params">n</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;fo start!&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:<span class="comment">#注意，因为下一次next函数执行在循环体中开始，因此要再接一轮while判断，而不会执行循环体外面的上一行print(&quot;fo start&quot;)语句</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;before yield, n = &quot;</span>,n)</span><br><span class="line">n = n + <span class="number">1</span></span><br><span class="line">res = <span class="keyword">yield</span> n<span class="comment">#跑到这里结束</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;after yield, n = &quot;</span>,n)<span class="comment">#从这里开始</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = fo(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(x))</span><br><span class="line">fo start!</span><br><span class="line">before <span class="keyword">yield</span>, n =  <span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(x))</span><br><span class="line">after <span class="keyword">yield</span>, n =  <span class="number">2</span></span><br><span class="line">before <span class="keyword">yield</span>, n =  <span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(x))</span><br><span class="line">after <span class="keyword">yield</span>, n =  <span class="number">3</span></span><br><span class="line">before <span class="keyword">yield</span>, n =  <span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(x))</span><br><span class="line">after <span class="keyword">yield</span>, n =  <span class="number">4</span></span><br><span class="line">before <span class="keyword">yield</span>, n =  <span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(x))</span><br><span class="line">after <span class="keyword">yield</span>, n =  <span class="number">5</span></span><br><span class="line">before <span class="keyword">yield</span>, n =  <span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;python3中的生成器与迭代器&quot;&gt;&lt;a href=&quot;#python3中的生成器与迭代器&quot; class=&quot;headerlink&quot; title=&quot;python3中的生成器与迭代器&quot;&gt;&lt;/a&gt;python3中的生成器与迭代器&lt;/h1&gt;&lt;h2 id=&quot;生成器与迭代器&quot;&gt;</summary>
      
    
    
    
    <category term="Programming languages and projects" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/"/>
    
    <category term="Python3" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"/>
    
    
    <category term="python3" scheme="http://justskim.github.io/tags/python3/"/>
    
  </entry>
  
  <entry>
    <title>python3中的一些常见语法糖整理</title>
    <link href="http://justskim.github.io/2021/10/31/python3%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    <id>http://justskim.github.io/2021/10/31/python3%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E8%AF%AD%E6%B3%95%E7%B3%96/</id>
    <published>2021-10-31T12:02:01.432Z</published>
    <updated>2021-11-08T18:11:54.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python3中的一些常见语法糖整理"><a href="#python3中的一些常见语法糖整理" class="headerlink" title="python3中的一些常见语法糖整理"></a>python3中的一些常见语法糖整理</h1><h2 id="输入输出的类型提示"><a href="#输入输出的类型提示" class="headerlink" title="输入输出的类型提示"></a>输入输出的类型提示</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addBinary</span>(<span class="params">self, a: <span class="built_in">str</span>, b: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span></span><br></pre></td></tr></table></figure><p>学过C语言的同学，都懂得，参数中a，b要求为str类型的输入参数</p><p>在定义函数时，在def那一行后面会加一个-&gt;。这个玩意儿有个专门的名词叫 <strong>type hint， 即类型提示</strong>。这里就是说返回的数据类型为<code>str</code>。</p><p>在Python中，<code>str</code> 表示字符串类 ，也可以是将变量强制转换为字符串的函数，写作<code>str ()</code> </p><p><strong>类型标注</strong></p><ul><li><code>int</code>,<code>long</code>,<code>float</code>: 整型,长整形,浮点型</li><li><code>bool</code>,<code>str</code>: 布尔型，字符串类型</li><li><code>List</code>, <code>Tuple</code>, <code>Dict</code>, <code>Set</code>:列表，元组，字典, 集合</li><li><code>Iterable</code>,<code>Iterator</code>:可迭代类型，迭代器类型</li><li><code>Generator</code>：生成器类型</li></ul><h2 id="限定函数参数类型及输出"><a href="#限定函数参数类型及输出" class="headerlink" title="限定函数参数类型及输出"></a>限定函数参数类型及输出</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">text:<span class="string">&#x27;str&#x27;</span>,<span class="built_in">max</span>:<span class="string">&#x27;int &gt; 0&#x27;</span> = <span class="number">100</span>,<span class="built_in">min</span>:<span class="string">&#x27;int &gt; 0&#x27;</span></span>)-&gt;<span class="built_in">str</span>:</span><br></pre></td></tr></table></figure><p>在限定函数参数类型的同时还可以限定参数的范围以及默认值。</p><p>注意！在函数定义时，第一个带有默认值的参数之后的所有参数都必须有默认值，否则，运行时报错</p><h2 id="函数定义时的和"><a href="#函数定义时的和" class="headerlink" title="函数定义时的和*"></a>函数定义时的<em>和</em>*</h2><p>在参数前面加上<code>*</code>号 ，意味着参数个数不止一个，而带一个星号<code>*</code>参数的函数传入的参数存储为一个元组（tuple），带两个<code>*</code>号则是表示字典（dict）。</p><p>*将参数按顺序一一赋值，而dict类型则是将字典的keys作为函数参数进行赋值。</p><p>**参数方式则要求输入必须是一个dict，而且变量名称要与函数定义的变量名称一致</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">a, *b</span>):</span><br><span class="line">  <span class="built_in">print</span>(a)</span><br><span class="line">  <span class="built_in">print</span>(b)</span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">type</span>(b))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">a, **b</span>):</span><br><span class="line">  <span class="built_in">print</span>(a)</span><br><span class="line">  <span class="built_in">print</span>(b)</span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">type</span>(b))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func3</span>(<span class="params">a, *b, **c</span>):</span><br><span class="line">  <span class="built_in">print</span>(a)</span><br><span class="line">  <span class="built_in">print</span>(b)</span><br><span class="line">  <span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func1(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func1(<span class="number">1111</span>,(<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="number">1111</span></span><br><span class="line">((<span class="number">2</span>, <span class="number">3</span>),)<span class="comment">#如果传入一个元组，该元组会被当成元组的第一个参数</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func2(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#17&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    func2(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">TypeError: func2() takes <span class="number">1</span> positional argument but <span class="number">3</span> were given</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func2(<span class="number">1</span>,x=<span class="number">1</span>,y=<span class="number">2</span>)    <span class="comment">#传入的字典参数必须有key和value</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">&#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func2(<span class="number">111</span>,&#123;x=<span class="number">22</span>,y=<span class="number">44</span>&#125;)<span class="comment">#注意是传入的参数作为字典，不能传入dict类型的参数！</span></span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func3(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,x=<span class="number">5</span>,y=<span class="number">6</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure><p>在调用时，*主要是用来解压参数列表，对于set、tuple、list、dict(会取其values的值)类型的数据都适用</p><p>另外一个值得注意的就是参数的顺序，我们知道，最正规的写法就是将这三个参数按<code>*</code>号从少到多排列，那换一种写法呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func4</span>(<span class="params">a,**b,*c</span>):</span><br><span class="line">SyntaxError: invalid syntax<span class="comment">#**参数方式在*参数方式之前，无效</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func5</span>(<span class="params">*b,a</span>):<span class="comment">#*参数方式在不带*的参数之前，可以定义，但注意输入！！</span></span><br><span class="line"><span class="built_in">print</span>(b,<span class="string">&#x27;\n&#x27;</span>,a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func5</span>(<span class="params">**b,a</span>):<span class="comment">#**参数方式在不带*参数方式之前，无效</span></span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func5</span>(<span class="params">**b,*c</span>):<span class="comment">#**参数方式在*参数方式之前，无效</span></span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func5</span>(<span class="params">*b,**c</span>):<span class="comment">#没有不带*的参数，*参数方式在**参数方式之前，有效</span></span><br><span class="line"><span class="built_in">print</span>(b,c)</span><br></pre></td></tr></table></figure><p>但是要注意的是，如果带<code>*</code>的参数在不带<code>*</code>的参数之前，输入的时候要进行明确参数赋值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func6</span>(<span class="params">*b,a</span>):</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a=&quot;</span>,a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func6(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="string">&#x27;222&#x27;</span>,<span class="number">333</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#38&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    func6(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="string">&#x27;222&#x27;</span>,<span class="number">333</span>)</span><br><span class="line">TypeError: func6() missing <span class="number">1</span> required keyword-only argument: <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func6(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="string">&#x27;222&#x27;</span>,a=<span class="number">333</span>)<span class="comment">#输入的时候要进行明确参数赋值</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="string">&#x27;222&#x27;</span>)</span><br><span class="line">a= <span class="number">333</span></span><br></pre></td></tr></table></figure><h2 id="函数参数中的self"><a href="#函数参数中的self" class="headerlink" title="函数参数中的self"></a>函数参数中的self</h2><p>Python类中规定，函数的第一个参数是实例对象本身，并且约定俗成，把其名字写为self。其作用相当于java中的this，表示当前类的对象，可以调用当前类中的属性和方法。</p><p>在<a href="https://www.runoob.com/python3/python3-class.html">菜鸟教程</a>中，对于python类有如下介绍：</p><blockquote><ul><li><strong>类(Class):</strong> 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</li><li><strong>方法：</strong>类中定义的函数。</li><li><strong>类变量：</strong>类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</li><li><strong>数据成员：</strong>类变量或者实例变量用于处理类及其实例对象的相关的数据。</li><li><strong>方法重写：</strong>如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</li><li><strong>局部变量：</strong>定义在方法中的变量，只作用于当前实例的类。</li><li><strong>实例变量：</strong>在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。</li><li><strong>继承：</strong>即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。</li><li><strong>实例化：</strong>创建一个类的实例，类的具体对象。</li><li><strong>对象：</strong>通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</li></ul></blockquote><p>class是面向对象的设计思想，instance（也即是 object，对象）是根据 class 创建的。<br>在类的内部，使用 <strong>def</strong> 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self, 且为第一个参数，self 代表的是类的实例而不是类！<br>self 代表的是类的实例，代表当前对象的地址，而 <code>self.class </code>则指向类。<br>self 不是 python 关键字，我们把他替换成合格的字符串形式参数也是可以正常执行的。</p><h2 id="类中的-init-方法"><a href="#类中的-init-方法" class="headerlink" title="类中的__init__方法"></a>类中的<code>__init__</code>方法</h2><p>类有一个名为·<code>__init__()</code> 的特殊方法（<strong>构造方法</strong>），该方法在类实例化时会自动调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, realpart, imagpart</span>):</span><br><span class="line">        self.r = realpart</span><br><span class="line">        self.i = imagpart</span><br><span class="line">x = Complex(<span class="number">3.0</span>, -<span class="number">4.5</span>)</span><br><span class="line"><span class="built_in">print</span>(x.r, x.i)   <span class="comment"># 输出结果：3.0 -4.5</span></span><br></pre></td></tr></table></figure><h2 id="python-类的继承"><a href="#python-类的继承" class="headerlink" title="python 类的继承"></a>python 类的继承</h2><p>Python 同样支持类的继承，<strong>如果一种语言不支持继承，类就没有什么意义</strong>。</p><p>子类（派生类 DerivedClassName）会继承父类（基类 BaseClassName）的属性和方法。</p><p><code>BaseClassName</code>（实例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment">#类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">people</span>:</span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义私有属性,私有属性在类外部无法直接进行访问</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义构造方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,n,a,w</span>):</span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s 说: 我 %d 岁。&quot;</span> %(self.name,self.age))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#单继承示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>(<span class="title class_ inherited__">people</span>):</span><br><span class="line">    grade = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,n,a,w,g</span>):</span><br><span class="line">        <span class="comment">#调用父类的构函</span></span><br><span class="line">        people.__init__(self,n,a,w)</span><br><span class="line">        self.grade = g</span><br><span class="line">    <span class="comment">#覆写父类的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;</span>%(self.name,self.age,self.grade))</span><br><span class="line">s = student(<span class="string">&#x27;ken&#x27;</span>,<span class="number">10</span>,<span class="number">60</span>,<span class="number">3</span>)</span><br><span class="line">s.speak()</span><br><span class="line"><span class="comment">#执行结果：ken 说: 我 10 岁了，我在读 3 年级</span></span><br></pre></td></tr></table></figure><p>python也支持多重继承</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">people</span>:</span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义私有属性,私有属性在类外部无法直接进行访问</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义构造方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,n,a,w</span>):</span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s 说: 我 %d 岁。&quot;</span> %(self.name,self.age))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#单继承示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>(<span class="title class_ inherited__">people</span>):</span><br><span class="line">    grade = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,n,a,w,g</span>):</span><br><span class="line">        <span class="comment">#调用父类的构函</span></span><br><span class="line">        people.__init__(self,n,a,w)</span><br><span class="line">        self.grade = g</span><br><span class="line">    <span class="comment">#覆写父类的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;</span>%(self.name,self.age,self.grade))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#另一个类，多重继承之前的准备</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">speaker</span>():</span><br><span class="line">    topic = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,n,t</span>):</span><br><span class="line">        self.name = n</span><br><span class="line">        self.topic = t</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;</span>%(self.name,self.topic))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#多重继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sample</span>(speaker,student):</span><br><span class="line">    a =<span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,n,a,w,g,t</span>):</span><br><span class="line">        student.__init__(self,n,a,w,g)</span><br><span class="line">        speaker.__init__(self,n,t)</span><br><span class="line"> </span><br><span class="line">test = sample(<span class="string">&quot;Tim&quot;</span>,<span class="number">25</span>,<span class="number">80</span>,<span class="number">4</span>,<span class="string">&quot;Python&quot;</span>)</span><br><span class="line">test.speak()   <span class="comment">#方法名同，默认调用的是在括号中排前地父类的方法</span></span><br><span class="line"><span class="comment">#执行结果：我叫 Tim，我是一个演说家，我演讲的主题是 Python</span></span><br></pre></td></tr></table></figure><h3 id="类的私有属性"><a href="#类的私有属性" class="headerlink" title="类的私有属性"></a>类的私有属性</h3><p><strong>__private_attrs</strong>：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 <strong>self.__private_attrs</strong>。</p><h3 id="类的方法"><a href="#类的方法" class="headerlink" title="类的方法"></a>类的方法</h3><p>在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 <strong>self</strong>，且<strong>必须</strong>为<strong>第一个</strong>参数，<strong>self</strong> 代表的是类的实例。</p><p><strong>self</strong> 的名字并不是规定死的，也可以使用 <strong>this</strong>，但是最好还是按照约定使用 <strong>self</strong>。</p><h3 id="类的私有方法"><a href="#类的私有方法" class="headerlink" title="类的私有方法"></a>类的私有方法</h3><p><strong>__private_method</strong>：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。<strong>self.__private_methods</strong>。</p><h2 id="lambda表达式（匿名函数）"><a href="#lambda表达式（匿名函数）" class="headerlink" title="lambda表达式（匿名函数）"></a>lambda表达式（匿名函数）</h2><p>如果一个函数的函数体<strong>仅有 1 行</strong>，那么该函数就可以用 lambda 表达式来代替，下面两个函数在表达效果上是相等的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">arg1,...argn</span>):</span><br><span class="line">    <span class="keyword">return</span> 表达式</span><br><span class="line">name = <span class="keyword">lambda</span>  [arg1 [,arg2,.....argn]]: 表达式</span><br></pre></td></tr></table></figure><p>定义 lambda 表达式，必须使用 lambda 关键字，注意冒号前是<strong>参数</strong>，可以有<strong>多个</strong>，用<strong>逗号隔开</strong>，冒号右边的为表达式（只能为一个）。其实lambda返回值是一个函数的地址，也就是函数对象。</p><p>注意传入的参数必须用逗号隔开，下面这么定义是错误的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>add = <span class="keyword">lambda</span> [x,y]:x+y</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add = <span class="keyword">lambda</span> x,y:x+y</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="python中的5种下划线形式"><a href="#python中的5种下划线形式" class="headerlink" title="python中的5种下划线形式"></a>python中的5种下划线形式</h2><ul><li>单前导下划线：**_var**</li><li>单末尾下划线：<strong>var_</strong></li><li>双前导下划线：**__var**</li><li>双前导和末尾下划线：<code>__var__</code></li><li>单下划线：**_**</li></ul><h3 id="单前导下划线：-var"><a href="#单前导下划线：-var" class="headerlink" title="单前导下划线：**_var**"></a>单前导下划线：**_var**</h3><p>，前置单下划线只有约定含义。它对于程序员而言是一种提示——Python社区约定好单下划线表达的是某种意思，其本身并不会影响程序的行为。</p><p>前置下划线的意思是<strong>提示</strong>其他程序员，以单下划线开头的变量或方法只在内部使用。PEP 8中定义了这个约定（PEP 8是最常用的Python代码风格指南。</p><p>详见PEP 8：“Style Guide for Python Code”。</p><p>不过，这个约定对Python解释器并没有特殊含义。与Java不同，Python在“私有”和“公共”变量之间并没有很强的区别。在变量名之前添加一个下划线更像是有人挂出了一个小小的下划线警告标志：“<strong>注意，这并不是这个类的公共接口。最好不要使用它</strong>。”</p><p>我们实例化一个类，并为其添加一个使用单前导下划线的属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.foo = <span class="number">11</span></span><br><span class="line">        self._bar = <span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = Test()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.foo</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t._bar</span><br><span class="line"><span class="number">23</span></span><br></pre></td></tr></table></figure><p><code>_bar</code>前面的单下划线并没有阻止我们“进入”这个类访问变量的值。</p><p>这是因为Python中的前置单下划线只是一个公认的约定，至少在涉及变量名和方法名时是这样的。</p><p><strong>使用单前导下划线需要注意的是</strong>，前置下划线会影响从模块中导入名称的方式，如果使用<strong>通配符<code>*</code>导入</strong>从这个模块中导入所有名称，Python<strong>不会</strong>导入带有前置单下划线的名称（除非模块中定义了<code>__all__</code>列表覆盖了这个行为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在my_module.py中这么定义：</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">external_func</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">23</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_internal_func</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在idle或另一个py文件中导入</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> my_module <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>external_func()</span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_internal_func()</span><br><span class="line">NameError: <span class="string">&quot;name &#x27;_internal_func&#x27; is not defined&quot;</span></span><br></pre></td></tr></table></figure><p>值得注意的是：要<strong>尽可能避免使用通配符<code>*</code>导入</strong>，因为这样就不清楚当前名称空间中存在哪些名称了。为了清楚起见，最好坚持使用常规导入方法。与通配符导入不同，常规导入不受前置单下划线命名约定的影响.</p><p>遵循PEP 8的建议不使用通配符导入，那么真正需要记住的只有下面这一条。<br>以单下划线开头的名称只是Python命名中的约定，表示供内部使用。它通常对Python解释器没有特殊含义，仅仅作为对程序员的提示。</p><h3 id="单末尾下划线：var"><a href="#单末尾下划线：var" class="headerlink" title="单末尾下划线：var_"></a>单末尾下划线：<strong>var_</strong></h3><p>有时某个变量最合适的名称已被Python语言中的关键字占用。因此，诸如<code>class</code>或<code>def</code>的名称不能用作Python中的变量名。在这种情况下，可以追加一个下划线来绕过命名冲突。PEP 8中定义并解释了这个用一个单末尾下划线来避免与python关键字冲突的约定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">name,<span class="keyword">class</span></span>):</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">name,class_</span>):</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>上面介绍的单下划线（无论放在前边还是末尾），都只是约定的作用。</p><h3 id="双前导下划线：-var"><a href="#双前导下划线：-var" class="headerlink" title="双前导下划线：**__var**"></a>双前导下划线：**__var**</h3><p>上面介绍的单下划线（无论放在前边还是末尾），都只是约定的作用。</p><p>但使用以双下划线开头的Python类属性（变量和方法）就不一样了。</p><p>双下划线前缀会让Python解释器重写属性名称，以避免子类中的命名冲突。</p><p>这也称为<strong>名称改写</strong>（name mangling），即解释器会更改变量的名称，以便在稍后扩展这个类时避免命名冲突。</p><h3 id="双前导和末尾下划线：-var"><a href="#双前导和末尾下划线：-var" class="headerlink" title="双前导和末尾下划线：__var__"></a>双前导和末尾下划线：<code>__var__</code></h3><p><strong>一些特殊的双前导和末尾下划线</strong></p><ol><li><p><code>__all__</code></p><p>不像 Ruby 或者 Java，Python 没有语言原生的可见性控制，而是靠一套需要大家自觉遵守的”约定“下工作。比如下划线开头的应该对外部不可见。同样，<code>__all__</code> 也是对于模块公开接口的一种约定，比起下划线，<code>__all__</code> 提供了暴露接口用的”白名单“。一些不以下划线开头的变量（比如从其他地方 <code>import</code> 到当前模块的成员）可以同样被排除出去。</p><p>当我们向文件导入某个模块时，导入的是该模块中那些<strong>名称不以下划线（单下划线“_”或者双下划线“__”）开头</strong>的变量、函数和类。因此，如果我们不想模块文件中的某个成员被引入到其它文件中使用，有两种方法：</p><ol><li>在其名称前添加单下划线。</li><li>借助模块提供的__all__ 变量，该变量的值是一个列表，存储的是当前模块中一些成员（变量、函数或者类）的名称。</li></ol><p>通过在模块文件中设置__all__变量，当其它文件以“from 模块名 import *”的形式导入该模块时，该文件中只能使用__all__ 列表中指定的成员。__all__也是对于模块公开接口的一种约定，比起下划线，__all__提供了暴露接口用的“白名单”。<br>       ————————————————<br>      版权声明：本文为CSDN博主「-徐徐图之-」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>      原文链接：<a href="https://blog.csdn.net/zylooooooooong/article/details/115564782">https://blog.csdn.net/zylooooooooong/article/details/115564782</a></p></li><li><p><code>__init__</code></p><p>在创建类时，我们可以手动添加一个<code>__init__()</code>方法，该方法是一个特殊的类实例方法，称为构造方法（或构造函数）。</p><p>构造方法用于创建对象时使用，每当创建一个类的实例对象时，<a href="http://c.biancheng.net/python/">Python</a> 解释器都会自动调用它。</p><p><code>__init__() </code>方法可以包含多个参数，但必须包含一个名为 self 的参数，且必须作为第一个参数。</p><p>即便不手动为类添加任何构造方法，Python 也会自动为类添加一个仅包含 self 参数的构造方法。</p><p>如果子类中不重写<code>__init__</code>，实例化子类时，就会调用父类中定义的<code>__init__</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        <span class="built_in">print</span> ( <span class="string">&quot;name: %s&quot;</span> %( self.name) )</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getName</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Father &#x27;</span> + self.name</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>(<span class="title class_ inherited__">Father</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getName</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Son &#x27;</span>+self.name</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    son=Son(<span class="string">&#x27;runoob&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span> ( son.getName() )</span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line">name: runoob</span><br><span class="line">Son runoob</span><br></pre></td></tr></table></figure><p>如果重写了**<strong>init</strong>** 时，实例化子类，就不会调用父类已经定义的 **<strong>init</strong>**，语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        <span class="built_in">print</span> ( <span class="string">&quot;name: %s&quot;</span> %( self.name) )</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getName</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Father &#x27;</span> + self.name</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>(<span class="title class_ inherited__">Father</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">print</span> ( <span class="string">&quot;hi&quot;</span> )</span><br><span class="line">        self.name =  name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getName</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Son &#x27;</span>+self.name</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    son=Son(<span class="string">&#x27;runoob&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span> ( son.getName() )</span><br><span class="line"><span class="comment">#输出结果：</span></span><br><span class="line">hi</span><br><span class="line">Son runoob</span><br></pre></td></tr></table></figure><p>若重写了<code>__init__</code>，还要继承父类的构造方法，可以使用<code>super</code>关键字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        <span class="built_in">print</span> ( <span class="string">&quot;name: %s&quot;</span> %( self.name))</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getName</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Father &#x27;</span> + self.name</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>(<span class="title class_ inherited__">Father</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">super</span>(Son, self).__init__(name)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;hi&quot;</span>)</span><br><span class="line">        self.name =  name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getName</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Son &#x27;</span>+self.name</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    son=Son(<span class="string">&#x27;runoob&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span> ( son.getName() )</span><br><span class="line">    </span><br><span class="line"><span class="comment">#输出结果如下：</span></span><br><span class="line">name: runoob</span><br><span class="line">hi</span><br><span class="line">Son runoob</span><br></pre></td></tr></table></figure><p>也可以直接调用父类的<code>__init__</code>类方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dad = Father(<span class="string">&#x27;luo&#x27;</span>)</span><br><span class="line">name: luo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dad.__init__()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#10&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    dad.__init__()</span><br><span class="line">TypeError: __init__() missing <span class="number">1</span> required positional argument: <span class="string">&#x27;name&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dad.__init__(<span class="string">&quot;WHALE&quot;</span>)</span><br><span class="line">name: WHALE</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dad.name</span><br><span class="line"><span class="string">&#x27;WHALE&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><code>__name__</code></p><p>一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用<code>__name__</code>属性来使该程序块仅在该模块自身运行时执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># Filename: using_name.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;程序自身在运行&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;我来自另一模块&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#以下是程序运行结果</span></span><br><span class="line">$ python using_name.py<span class="comment">#在模块自身运行时</span></span><br><span class="line">程序自身在运行</span><br><span class="line">$ python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> using_name<span class="comment">#在模块被引用时</span></span><br><span class="line">我来自另一模块</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>注意：每个模块都有一个<code>__name__</code>属性，当其值是<code>__main__</code>时，表明该模块自身在运行，否则是被引入。</p></li><li></li></ol><h3 id="单下划线："><a href="#单下划线：" class="headerlink" title="单下划线：**_**"></a>单下划线：**_**</h3><p>有时候单个独立下划线是用作一个名字，来表示某个变量是临时的或无关紧要的。</p><p>例如，在下面的循环中，我们不需要访问正在运行的索引，我们可以使用”_”来表示它只是一个临时值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line"><span class="meta">... </span>   <span class="built_in">print</span>(<span class="string">&#x27;Hello, World.&#x27;</span>)</span><br></pre></td></tr></table></figure><p>你也可以在拆分(unpacking)表达式中将单个下划线用作”不关心的”变量，以忽略特定的值。 同样，这个含义只是”依照约定”，并不会在Python解释器中触发特殊的行为。 单个下划线仅仅是一个有效的变量名称，会有这个用途而已。</p><p>在下面的代码示例中，我将汽车元组拆分为单独的变量，但我只对颜色和里程值感兴趣。 但是，为了使拆分表达式成功运行，我需要将包含在元组中的所有值分配给变量。 在这种情况下，”_”作为占位符变量可以派上用场：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>car = (<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;auto&#x27;</span>, <span class="number">12</span>, <span class="number">3812.4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>color, _, _, mileage = car</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>color</span><br><span class="line"><span class="string">&#x27;red&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mileage</span><br><span class="line"><span class="number">3812.4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><p>除了用作临时变量之外，”_”是大多数Python REPL中的一个特殊变量，它表示由解释器评估的最近一个表达式的结果。</p><p>这样就很方便了，比如你可以在一个解释器会话中访问先前计算的结果，或者，你是在动态构建多个对象并与它们交互，无需事先给这些对象分配名字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">20</span> + <span class="number">3</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_</span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(_)</span><br><span class="line"><span class="number">23</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>()</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_.append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_.append(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_.append(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>对于上面五种类型的下划线，<a href="https://www.runoob.com/w3cnote/python-5-underline.html">菜鸟教程的小结</a>可以很好的帮助我们：</p><p><img src="E:\JS练习\blog\Myblog\source\images\python下划线类型小结.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;python3中的一些常见语法糖整理&quot;&gt;&lt;a href=&quot;#python3中的一些常见语法糖整理&quot; class=&quot;headerlink&quot; title=&quot;python3中的一些常见语法糖整理&quot;&gt;&lt;/a&gt;python3中的一些常见语法糖整理&lt;/h1&gt;&lt;h2 id=&quot;输</summary>
      
    
    
    
    <category term="Programming languages and projects" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/"/>
    
    <category term="Python3" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"/>
    
    
    <category term="python3" scheme="http://justskim.github.io/tags/python3/"/>
    
  </entry>
  
  <entry>
    <title>linux的进程优先级与进程调度策略</title>
    <link href="http://justskim.github.io/2021/10/23/linux%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%8E%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/"/>
    <id>http://justskim.github.io/2021/10/23/linux%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%8E%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/</id>
    <published>2021-10-23T12:38:09.488Z</published>
    <updated>2021-10-25T07:05:02.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux的进程优先级与进程调度策略"><a href="#linux的进程优先级与进程调度策略" class="headerlink" title="linux的进程优先级与进程调度策略"></a>linux的进程优先级与进程调度策略</h1><h2 id="linux中的进程调度策略"><a href="#linux中的进程调度策略" class="headerlink" title="linux中的进程调度策略"></a>linux中的进程调度策略</h2><p>FIFO，RR，OTHER</p><p>实时进程会抢占普通进程，FIFO会导致同优先级实时进程始终占用CPU，RR会保证同优先级实时进程按时间片轮流执行。</p><p>上面说的很通俗易懂，那么，两个同等优先级的FIFO实时进程，是不是谁先占据了cpu，另一个就只能等待它完成了让出CPU呢？</p><p>其实不尽然，即使是在单核cpu的linux系统中，FIFO实时进程也会被调度。</p><p>具体可见博客：</p><p>cnblogs.com&#x2F;tongye&#x2F;p&#x2F;9575602.html</p><p>blog.csdn.net&#x2F;qq_37451250&#x2F;article&#x2F;details&#x2F;104807725</p><h2 id="C语言中的进程优先级设置"><a href="#C语言中的进程优先级设置" class="headerlink" title="C语言中的进程优先级设置"></a>C语言中的进程优先级设置</h2><p>创建实时进程与普通进程略有区别——在创建普通进程的基础上，将调度类从CFS（completely fair完全公平调度类）转向RT类（实时调度类型，包括RR和FIFO）</p><p>常见的几个进程优先级设置与取得函数（位于头文件sched.h中）：</p><p>sched_get_priority_max()  取得静态优先级的上限</p><p>sched_get_priority_min()  取得静态优先级的下限</p><p>sched_getparam()取得进程的调度参数</p><p>sched_setparam()设置进程的调度参数</p><p>sched_getscheduler()取得指定进程的调度类</p><p>sched_setscheduler()设置指定进程的调度类</p><blockquote><p>int sched_getscheduler(pid_t pid, int policy, const struct sched_param *param)</p><p>第一个参数是进程号（0表示本进程），第二个参数为调度类（SCHED_RR为2、SCHED_FIFO为1、SCHED_OTHER为0，三个之一） ，第三个参数是一个struct sched_param 类型的调度参数——其sched_priority成员可以指定优先级。</p></blockquote><p>sched_rr_get_interval()取得按RR算法调度的实时进程的时间片长度</p><p>sched_yield()进程主动让出处理器并将自己挂入等候调度队列的队尾</p><p>sched文件</p><p><strong>C语言system函数</strong></p><p>执行 dos(windows系统) 或 shell(Linux&#x2F;Unix系统) 命令，参数字符串command为命令名。另，在windows系统下参数字符串不区分大小写。</p><p>说明：在windows系统中，system函数直接在控制台调用一个command命令。<br>在Linux&#x2F;Unix系统中，system函数会调用fork函数产生子进程，由子进程来执行command命令，命令执行完后随即返回原调用的进程。</p><p>函数返回值<br>命令执行成功返回0，执行失败返回-1。</p><p><strong>C语言sprintf函数</strong></p><p>int sprintf( char *buffer, const char *format, [ argument] … )；</p><p>这个函数包含三个部分的参数：</p><p>buffer：char型指针，指向将要写入的字符串的缓冲区。format：格式化字符串。即可选参数的想要输入的数据类型。[argument]…：可选参数，可以是任何类型的数据。</p><p>这个函数就是把第三部分的数据，按照第二部分格式化字符的格式，把第三部分的数据进行”格式化“，然后在<strong>把格式化后的数据类型，存储到字符串</strong>的缓存区间里去。</p><p>通过查看&#x2F; proc &#x2F;&lt; PID&gt; &#x2F; sched中的调度统计信息(scheduling stats in <code>/proc/&lt;PID&gt;/sched</code>),您可以获得如下输出（仅限进程运行着的时候）</p><p>为了在进程退出后依然能看到这些调度统计信息，我们可以使用以上代码将其存储至本目录的sched-pid文件中</p><p>&gt; nr_switches：上下文切换次数.<br>&gt; nr_voluntary_switches：自愿切换的数量,即线程被阻塞,因此拾取另一个线程.<br>&gt; nr_involuntary_switches：调度程序将线程踢出,因为有另一个饥饿的线程已准备好运行.</p><h2 id="C语言中的进程调度函数"><a href="#C语言中的进程调度函数" class="headerlink" title="C语言中的进程调度函数"></a>C语言中的进程调度函数</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;linux的进程优先级与进程调度策略&quot;&gt;&lt;a href=&quot;#linux的进程优先级与进程调度策略&quot; class=&quot;headerlink&quot; title=&quot;linux的进程优先级与进程调度策略&quot;&gt;&lt;/a&gt;linux的进程优先级与进程调度策略&lt;/h1&gt;&lt;h2 id=&quot;l</summary>
      
    
    
    
    <category term="Linux" scheme="http://justskim.github.io/categories/Linux/"/>
    
    
    <category term="linux" scheme="http://justskim.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>在vmware中“/mnt/hgfs”路径下共享文件夹的挂载</title>
    <link href="http://justskim.github.io/2021/10/23/%E5%9C%A8vmware%E4%B8%AD%E2%80%9Cmnthgfs%E2%80%9D%E8%B7%AF%E5%BE%84%E4%B8%8B%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E6%8C%82%E8%BD%BD/"/>
    <id>http://justskim.github.io/2021/10/23/%E5%9C%A8vmware%E4%B8%AD%E2%80%9Cmnthgfs%E2%80%9D%E8%B7%AF%E5%BE%84%E4%B8%8B%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E6%8C%82%E8%BD%BD/</id>
    <published>2021-10-23T12:13:05.314Z</published>
    <updated>2021-10-23T12:28:45.188Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在vmware中“-x2F-mnt-x2F-hgfs”路径下共享文件夹的挂载"><a href="#在vmware中“-x2F-mnt-x2F-hgfs”路径下共享文件夹的挂载" class="headerlink" title="在vmware中“&#x2F;mnt&#x2F;hgfs”路径下共享文件夹的挂载"></a>在vmware中“&#x2F;mnt&#x2F;hgfs”路径下共享文件夹的挂载</h1><p>在之前的博客中，我们已经讲过如何在vmware虚拟机中设置共享文件夹，mnt目录是挂接光驱、USB设备的目录，在其中进行文件操作需要有root权限。linux系统中一定会有&#x2F;mnt目录，但其下不一定有hgfs目录，在我们成功安装完VMWare tools后会出现hgfs文件夹，但一些情况下hgfs文件夹中可能不存在我们之前在虚拟机中设置的共享文件夹名称，下面是解决办法</p><h2 id="x2F-mnt路径下有hgfs但却没有共享文件夹"><a href="#x2F-mnt路径下有hgfs但却没有共享文件夹" class="headerlink" title="&#x2F;mnt路径下有hgfs但却没有共享文件夹"></a>&#x2F;mnt路径下有hgfs但却没有共享文件夹</h2><p>先进入到root权限下，使用命令<code>vmware-hgfsclient</code>来查看当前有哪些共享的目录，如果未能成功安装VMWare tools则该命令会导致报错。</p><p>然后使用命令<code>mount -t vmhgfs .host:/你所设置的共享文件夹名称 /mnt/hgfs</code>来挂载共享文件夹即可。</p><p>以上设置后每次重新开机都要重复设置一次共享文件夹，我们使用在文件<code>/etc/fstab</code>中进行修改来设置开机后自动挂载：</p><p>在文件<code>/etc/fstab</code>中添加以下一行：<code>.host:/mnt/hgfs vmhgfs defaults 0 0</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;在vmware中“-x2F-mnt-x2F-hgfs”路径下共享文件夹的挂载&quot;&gt;&lt;a href=&quot;#在vmware中“-x2F-mnt-x2F-hgfs”路径下共享文件夹的挂载&quot; class=&quot;headerlink&quot; title=&quot;在vmware中“&amp;#x2F;m</summary>
      
    
    
    
    <category term="Linux" scheme="http://justskim.github.io/categories/Linux/"/>
    
    
    <category term="linux" scheme="http://justskim.github.io/tags/linux/"/>
    
    <category term="虚拟机" scheme="http://justskim.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    <category term="ubuntu" scheme="http://justskim.github.io/tags/ubuntu/"/>
    
    <category term="vmware" scheme="http://justskim.github.io/tags/vmware/"/>
    
  </entry>
  
  <entry>
    <title>linux的权限与隐藏权限</title>
    <link href="http://justskim.github.io/2021/09/27/linux%E7%9A%84%E6%9D%83%E9%99%90%E4%B8%8E%E9%9A%90%E8%97%8F%E6%9D%83%E9%99%90/"/>
    <id>http://justskim.github.io/2021/09/27/linux%E7%9A%84%E6%9D%83%E9%99%90%E4%B8%8E%E9%9A%90%E8%97%8F%E6%9D%83%E9%99%90/</id>
    <published>2021-09-27T12:26:36.587Z</published>
    <updated>2021-09-29T02:11:21.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux的权限与隐藏权限"><a href="#linux的权限与隐藏权限" class="headerlink" title="linux的权限与隐藏权限"></a>linux的权限与隐藏权限</h1><h2 id="linux的权限"><a href="#linux的权限" class="headerlink" title="linux的权限"></a>linux的权限</h2><h3 id="linux中的文件类型"><a href="#linux中的文件类型" class="headerlink" title="linux中的文件类型"></a>linux中的文件类型</h3><p>　　linux一共有7种文件类型,分别如下:</p><p>​    　　 -：普通文件</p><p>​     　d：目录文件</p><p>​     　l： 软链接（类似Windows的快捷方式）</p><p>​    　　(<strong>下面四种是特殊文件)</strong></p><p>​     　b：块设备文件（例如硬盘、光驱等）</p><p>​    　　 p：管道文件</p><p>​     　c：字符设备文件（例如猫等串口设备）</p><p>​     　s：套接口文件&#x2F;数据接口文件（例如启动一个MySql服务器时会产生一个mysql.sock文件）</p><h2 id="linux的隐藏权限"><a href="#linux的隐藏权限" class="headerlink" title="linux的隐藏权限"></a>linux的隐藏权限</h2><p>除了文件的读写,执行权限外,linux还有一种隐藏权限,设置隐藏权限可以防止一些其他用户的误操作或者恶意操作,当我们配置了<code>nginx</code>的放跨站攻击或其他安全措施后,相应的会在项目的根目录下生成一个隐藏文件<code>.user.ini</code>,当删除整个项目时会阻止操作完成.我们使用<code>ls</code>命令并使用<code>chmod chown</code>等命令设置了文件权限后会发现还是无法删除.这就是因为这个文件有隐藏的权限。</p><p>linux系统的隐藏权限总共有以下十三种类型：</p><ul><li><p>A：即Atime，告诉系统不要修改对这个文件的最后访问时间；</p></li><li><p>S：即Sync，一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘；</p></li><li><p>a：即Append Only，系统只允许在这个文件之后追加数据，不允许任何进程覆盖或截断这个文件。如果目录具有这个属性，系统将只允许在这个目录下建立和修改文件，而不允许删除任何文件；</p></li><li><p>b：不更新文件或目录的最后存取时间；</p></li><li><p>c：将文件或目录压缩后存放；</p></li><li><p>d：当dump程序执行时，该文件或目录不会被dump备份；</p></li><li><p>D:检查压缩文件中的错误；</p></li><li><p>i：即Immutable，系统不允许对这个文件进行任何的修改。如果目录具有这个属性，那么任何的进程只能修改目录之下的文件，不允许建立和删除文件；</p></li><li><p>s：彻底删除文件，不可恢复，因为是从磁盘上删除，然后用0填充文件所在区域；</p></li><li><p>u：当一个应用程序请求删除这个文件，系统会保留其数据块以便以后能够恢复删除这个文件，用来防止意外删除文件或目录；</p></li><li><p>t:文件系统支持尾部合并（tail-merging）；</p></li><li><p>X：可以直接访问压缩文件的内容 </p></li><li><p>e: 表示文件以ext4 extents存储的，ext4上新建文件的默认属性，<strong>不可用chattr修改</strong>。</p></li></ul><p>使用命令<code>chattr +权限类型</code>和<code>chattr -权限类型</code>可以为文件添加或删除隐藏权限</p><h2 id="chattr命令"><a href="#chattr命令" class="headerlink" title="chattr命令"></a>chattr命令</h2><p>提到文件权限的修改，必然绕不过这一命令，根据<a href="http://c.biancheng.net/view/874.html">C语言中文网</a>（这个网站怎么啥都有）：</p><blockquote><p>chattr 命令，专门用来修改文件或目录的隐藏属性，只有 root 用户可以使用。该命令的基本格式为：</p><p>[root@localhost ~]# chattr [+-&#x3D;] [属性] 文件或目录名</p></blockquote><p>下面是常用chattr命令来授予&#x2F;删除的一些属性：</p><table><thead><tr><th>属性选项</th><th>功能</th></tr></thead><tbody><tr><td>i</td><td>如果对文件设置 i 属性，那么不允许对文件进行删除、改名，也不能添加和修改数据； 如果对目录设置 i 属性，那么只能修改目录下文件中的数据，但不允许建立和删除文件；</td></tr><tr><td>a</td><td>如果对文件设置 a 属性，那么只能在文件中増加数据，但是不能删除和修改数据； 如果对目录设置 a 属性，那么只允许在目录中建立和修改文件，但是不允许删除文件；</td></tr><tr><td>u</td><td>设置此属性的文件或目录，在删除时，其内容会被保存，以保证后期能够恢复，常用来防止意外删除文件或目录。</td></tr><tr><td>s</td><td>和 u 相反，删除文件或目录时，会被彻底删除（直接从硬盘上删除，然后用 0 填充所占用的区域），不可恢复。</td></tr><tr><td>b</td><td>不更新文件或目录的最后存取时间。</td></tr><tr><td>c</td><td>将文件或目录压缩后存放。</td></tr><tr><td>d</td><td>将文件或目录排除在倾倒操作之外</td></tr><tr><td>S</td><td>即时更新文件或目录</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;linux的权限与隐藏权限&quot;&gt;&lt;a href=&quot;#linux的权限与隐藏权限&quot; class=&quot;headerlink&quot; title=&quot;linux的权限与隐藏权限&quot;&gt;&lt;/a&gt;linux的权限与隐藏权限&lt;/h1&gt;&lt;h2 id=&quot;linux的权限&quot;&gt;&lt;a href=&quot;#l</summary>
      
    
    
    
    <category term="Linux" scheme="http://justskim.github.io/categories/Linux/"/>
    
    
    <category term="linux" scheme="http://justskim.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>在vmware中实现共享文件夹以及安装vmware-tools</title>
    <link href="http://justskim.github.io/2021/09/27/%E5%9C%A8vmware%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85vmware-tools/"/>
    <id>http://justskim.github.io/2021/09/27/%E5%9C%A8vmware%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85vmware-tools/</id>
    <published>2021-09-27T11:27:13.351Z</published>
    <updated>2021-10-01T01:46:47.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在vmware中实现共享文件夹以及安装vmware-tools"><a href="#在vmware中实现共享文件夹以及安装vmware-tools" class="headerlink" title="在vmware中实现共享文件夹以及安装vmware-tools"></a>在vmware中实现共享文件夹以及安装vmware-tools</h1><p>原因：想要设置共享文件夹，而ubuntu16.04版本系统中，只有文件夹mnt，其中没有文件夹hgfs，而按照网上教程操作，需要重新安装vmware-tools才能使得该选项可以点击，然而虚拟机菜单栏中，“重新安装vmware-tool”的选项为灰色不可点击</p><p>首先使用命令<code>su root</code>跳转至超级用户权限，</p><p>然后，使用命令<code>apt-get install open-vmware-tools</code>安装，</p><p>注意，完成之后，在文件夹<code>media</code>下面会有以下的文件</p><p><img src="E:\JS练习\blog\Myblog\source\images\media文件夹下的vmwareTools.png" alt="media文件夹下的vmwareTools"></p><p>我们如果在media文件夹中使用tar命令对 文件 进行解压缩，会发现出错，大量的报错语句：</p><p><code>tar: vmware-tools-distrib: Cannot mkdir: Read only file system</code></p><p>然后我们使用命令<code>su root</code>输入密码进入超级用户权限，再次尝试解压缩，依然出错！</p><p>原因在于<a href="https://zhidao.baidu.com/question/367521394739288804.html">linux系统对我们的贴心</a>：</p><blockquote><p>我们知道<strong>root用户</strong>是linux执行<strong>权限最高</strong>的管理者用户，他可以进行任何的权限操作；<strong>然而</strong>我们的<strong>操作系统</strong>同样也考虑过这样的弊端，就是当我们使用者并不了解文件属性和重要性时会给予我们使用者提示；</p><p>  举个例子，当我们在linux下打开磁盘文件时，想要直接修改磁盘中的文件属性，一般会提示为只读文件，这时我们可以将其从磁盘中移动到本地目录下，这样就可以进行权限操作了；</p><p>  实例如图显示，我的操作是试图对DVD中的文件进行权限修改，这是不被允许的；</p></blockquote><p>如果我们在media文件夹目录下使用<code>lsattr</code>命令：可以发现：</p><p><img src="/"></p><p>注意，<code>e</code>是linux文件的隐藏权限类型！！</p><p>在linux操作系统中，有这么几个特殊的文件夹：</p><blockquote><p>&#x2F;mnt：一般是挂在镜像和硬盘一类的目录；&#x2F;media:是挂在多媒体设备的目录，如默认情况下的光盘、优盘、硬盘等设备都挂在在此目录；&#x2F;misc即各种其它杂七杂八东西</p><p>otp 是第三方软件的存放目录<br>selinux 是linux 下强制存取控制的实现 一般用来保护apache<br>srv 是存放系统提供服务站点的数据<br>media 是存放即插即用 设备的 挂载点。 比如USB 设备 自动在这个目录下创建一个目录</p><p>因为你没有对 文件所对应的内容进行操作 所以他是空的 </p></blockquote><p>在<a href="https://www.howtogeek.com/117435/htg-explains-the-linux-directory-structure-explained/">How-To-Geek上对Linux系统的目录结构说明文档</a>中，关于media文件夹有这样的解释：</p><blockquote><h2 id="x2F-media-—-Removable-Media"><a href="#x2F-media-—-Removable-Media" class="headerlink" title="&#x2F;media — Removable Media"></a>&#x2F;media — Removable Media</h2><p>The &#x2F;media directory contains subdirectories where removable media devices inserted into the computer are mounted. For example, when you insert a CD into your Linux system, a directory will automatically be created inside the &#x2F;media directory. You can access the contents of the CD inside this directory.</p></blockquote><p>在我们使用apt-get下载了相关tar.gz格式的压缩文件后，这一篇<a href="https://blog.csdn.net/a1219532602/article/details/110071982">博客</a>介绍了之后的步骤：</p><p>当然，作者也遇到了media文件夹中不能解压缩的问题，给出了下面的解答步骤：</p><p>于是，我们使用命令<code>cp VMwaretools.tar.gz /home/user/Desktop</code>将其拷贝一份至桌面进行解压缩</p><p><code>tar -zxvf VMwareTools.tar.gz</code></p><p>然后跳转到解压后的文件夹 <code>cd vmware-tools-distrib/</code></p><p>执行命令<code>sudo ./vmware-install.pl</code>。</p><p>完成，成功解压缩。</p><p>然后我们重新启动虚拟机，可以看到，&#x2F;mnt文件夹下已经有了hgfs文件夹</p><p>在<a href="https://www.linuxcool.com/">中文的一个方便网站上</a>，我们可以搜索到<strong>上面几个重要命令的讲解：</strong></p><ul><li><p><code>cp</code> </p><p>CoPy，功能为复制文件或目录，可以将多个文件复制到一个具体的文件名或一个已经存在的目录下，也可以同时复制多个文件到一个指定的目录中。</p><p><code>cp [参数] [文件] [路径]</code></p></li><li><p><code>tar</code></p><p>TARball，根据<a href="https://www.runoob.com/linux/linux-comm-tar.html">菜鸟教程中的描述</a>：</p><blockquote><p>tar 是用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件。</p></blockquote></li></ul><p>必要参数如下：<br>  <strong>A</strong>   新增压缩文件到已存在的压缩<br>  <strong>c</strong>    建立新的压缩文件<br>  <strong>d</strong>   记录文件的差别<br>  <strong>r</strong>    添加文件到已经压缩的文件<br>  <strong>u</strong>   添加改变了和现有的文件到已经存在的压缩文件<br>  <strong>x</strong>   从压缩的文件中提取文件<br>  <strong>t</strong>   显示压缩文件的内容<br>  <strong>z</strong>   支持<code>gzip</code>解压文件<br>  <strong>j</strong>    支持<code>bzip2</code>解压文件<br>  <strong>Z</strong>   支持compress解压文件<br>  <strong>v</strong>   显示操作过程<br>  <strong>l</strong>    文件系统边界设置<br>  <strong>k</strong>   保留原有文件不覆盖<br>  <strong>m</strong>  保留文件不被覆盖<br>  <strong>W</strong>  确认压缩文件的正确性</p><ul><li><p><code>cd</code></p><p>Change Directory，切换目录</p><p><code>cd [参数] [目录名]</code></p><p>一些特殊的目录表示：</p><p>“ <strong>~</strong> ”表示为<strong>用户目录</strong>的意思；</p><p>“ <strong>. <strong>”则是表示</strong>目前所在的目录</strong>；</p><p>“ <strong>..</strong> ”则表示<strong>当前目录位置的上一级目录</strong>。</p><p>常用参数</p><table><thead><tr><th>-P</th><th>如果切换的目标目录是一个符号链接，则直接切换到符号链接指向的目标目录</th></tr></thead><tbody><tr><td>-L</td><td>如果切换的目标目录是一个符号链接，则直接切换到符号链接名所在的目录</td></tr><tr><td>–</td><td>仅使用”-“选项时，当前目录将被切换到环境变量”OLDPWD”对应值的目录</td></tr><tr><td>~</td><td>切换至当前用户目录</td></tr><tr><td>..</td><td>切换至当前目录位置的上一级目录</td></tr></tbody></table></li><li><p><code>sudo</code></p><p>SuperUser DO</p><p>sudo 是一种权限管理机制，管理员可以授权于一些普通用户去执行一些 root 执行的操作，而不需要知道 root 的密码。</p><p>sudo 允许一个已授权用户以超级用户或者其它用户的角色运行一个命令。当然，能做什么不能做什么都是通过安全策略来指定的。sudo 支持插件架构的安全策略，并能把输入输出写入日志。第三方可以开发并发布自己的安全策略和输入输出日志插件，并让它们无缝的和 sudo 一起工作。默认的安全策略记录在 &#x2F;etc&#x2F;sudoers 文件中。而安全策略可能需要用户通过密码来验证他们自己。也就是在用户执行 sudo 命令时要求用户输入自己账号的密码。如果验证失败，sudo 命令将会退出。</p><p><strong>语法格式：</strong>sudo [参数]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-v</th><th>因为 sudo 在第一次执行时或是在 N分钟内没有执行（N 预设为五）会问密码，这个参数是重新做一次确认，如果超过N分钟，也会问密码</th></tr></thead><tbody><tr><td>-k</td><td>强迫使用者在下一次执行 sudo 时问密码（不论有没有超过 N 分钟）</td></tr><tr><td>-b</td><td>将要执行的指令放在背景执行</td></tr><tr><td>-p</td><td>prompt 可以更改问密码的提示语，其中 %u 会代换为使用者的帐号名称，%h 会显示主机名称</td></tr><tr><td>-s</td><td>执行环境变数中的SHELL 所指定的shell ，或是 &#x2F;etc&#x2F;passwd 里所指定的 shell</td></tr><tr><td>command</td><td>要以系统管理者身份（或以 -u 更改为其他人）执行的指令</td></tr></tbody></table></li></ul><p>例如我们要切换到root用户，需要使用命令<code>sudo su</code></p><h2 id="一个小插曲——如何在ubuntu中启用中英文输入法"><a href="#一个小插曲——如何在ubuntu中启用中英文输入法" class="headerlink" title="一个小插曲——如何在ubuntu中启用中英文输入法"></a>一个小插曲——如何在ubuntu中启用中英文输入法</h2><p>按照<a href="https://blog.csdn.net/qq_45797116/article/details/114260047">这一篇教程</a>安装搜狗输入法的linux版本，并进行相关配置。</p><p>当我们在linux桌面系统的终端或编辑器中启用输入的时候，只要记得右上角linux图标点击切换输入法即可。</p><p>当我们在Linux系统启用搜狗输入法时，记得用”shift”键切换中英文即可，对于大写的启用键与windows系统中一致。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;在vmware中实现共享文件夹以及安装vmware-tools&quot;&gt;&lt;a href=&quot;#在vmware中实现共享文件夹以及安装vmware-tools&quot; class=&quot;headerlink&quot; title=&quot;在vmware中实现共享文件夹以及安装vmware-tool</summary>
      
    
    
    
    <category term="Linux" scheme="http://justskim.github.io/categories/Linux/"/>
    
    
    <category term="linux" scheme="http://justskim.github.io/tags/linux/"/>
    
    <category term="虚拟机" scheme="http://justskim.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    <category term="ubuntu" scheme="http://justskim.github.io/tags/ubuntu/"/>
    
    <category term="vmware" scheme="http://justskim.github.io/tags/vmware/"/>
    
  </entry>
  
  <entry>
    <title>在linux系统创建父子进程及相关操作</title>
    <link href="http://justskim.github.io/2021/09/26/%E5%9C%A8linux%E7%B3%BB%E7%BB%9F%E5%88%9B%E5%BB%BA%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
    <id>http://justskim.github.io/2021/09/26/%E5%9C%A8linux%E7%B3%BB%E7%BB%9F%E5%88%9B%E5%BB%BA%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</id>
    <published>2021-09-26T02:16:56.153Z</published>
    <updated>2021-10-01T01:46:43.533Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在linux系统创建父子进程及相关操作"><a href="#在linux系统创建父子进程及相关操作" class="headerlink" title="在linux系统创建父子进程及相关操作"></a>在linux系统创建父子进程及相关操作</h1><h2 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h2><p><code>fork</code>这一词，在英文中有两个意思：</p><ul><li>n. 叉(挖掘用的园艺工具); 餐叉; (道路、河流等的)分岔处; 岔路;</li><li>v. 分岔出分支，走岔路中的一条。</li></ul><p><em>fork</em>函数是基本上只在Linux环境中会使用到的C语言函数，在使用时需要调用<code>unistd.h</code>这个头文件，我们在Linux环境下举例讲解<a href="https://www.jianshu.com/p/586300fdb1ce">C语言的fork()函数</a>用法：</p><blockquote><p>一个进程，包括代码、数据和分配给进程的资源。fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。</p><p><strong>一个进程调用fork（）函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。</strong></p><p>由<strong>fork函数创建的新进程</strong>被称为<strong>子进程</strong>。fork函数<strong>被调用一次</strong>，但是<strong>返回两次</strong>。父进程返回的值是<strong>新进程的进程ID</strong>，而子进程返回的值是0。</p><h4 id="fork函数返回值的三种情况"><a href="#fork函数返回值的三种情况" class="headerlink" title="fork函数返回值的三种情况"></a>fork函数返回值的三种情况</h4><ul><li>返回<strong>子进程标识符，即PID</strong>给父进程（在父进程中，fork返回新创建子进程的进程ID）<ul><li>因为一个进程的子进程可能有多个，并且<strong>没有一个函数可以获得一个进程的所有子进程ID</strong>。</li></ul></li><li>返回0给子进程（在子进程中，fork返回值为0）<ul><li>一个进程只会有一个父进程，所以子进程总是可以调用<strong>getpid</strong>以获得<strong>当前进程Id</strong>以及调用<strong>getppid</strong>获得<strong>父进程Id</strong>.</li></ul></li><li>出现错误，返回负值<ul><li>当前进程数已经达到系统规定的上限，这时errno的值被设置为EAGAIN</li><li>系统内存不足，这时errno的值被设置为ENOMEM</li></ul></li></ul><p>创建新进程成功后，系统中出现两个基本完全相同的进程，这两个进程执行没有固定的先后顺序，哪个进程先执行要看系统的进程调度策略</p></blockquote><p><a href="https://blog.csdn.net/wangww631/article/details/78413815">更加形象的解释</a>：</p><blockquote><p>“ 其实就相当于<strong>链表</strong>，进程形成了链表，<strong>父进程的fork函数返回的值指向子进程的进程id</strong>, 因为<strong>子进程没有子进程</strong>，所以其<strong>fork函数返回的值为0</strong> .</p><pre><code>调用fork之后，数据、堆、栈有两份，代码仍然为一份但是这个代码段成为两个进程的共享代码段都从fork函数中返回。当父子进程有一个想要修改数据或者堆栈时，两个进程真正分裂。</code></pre></blockquote><p>注意！子进程代码是<strong>从fork处开始执行</strong>的， 为什么不是从<code>#include</code>处开始复制代码的？这是因为fork是把 <strong>进程当前的情况拷贝一份</strong> ，执行fork时，进程已经执行完了int count&#x3D;0;fork只拷贝下一个要执行的代码到新的进程。</p><h2 id="fork函数被调用一次，返回两次，详解"><a href="#fork函数被调用一次，返回两次，详解" class="headerlink" title="fork函数被调用一次，返回两次，详解"></a>fork函数被调用一次，返回两次，详解</h2><p>来自<a href="https://blog.csdn.net/jason314/article/details/5640969">这篇博客的例子</a>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span><span class="comment">//引入pid_t类型的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="type">pid_t</span> fpid; <span class="comment">//fpid表示fork函数返回的值</span></span><br><span class="line"><span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">fpid=fork(); </span><br><span class="line"><span class="keyword">if</span> (fpid &lt; <span class="number">0</span>) </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;error in fork!&quot;</span>); <span class="comment">//fork函数返回的第一种情况，为负数，错误处理</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (fpid == <span class="number">0</span>) &#123;<span class="comment">//fork函数返回的第二种情况，在子进程中返回0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i am the child process, my process id is %d/n&quot;</span>,getpid()); </span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//fork函数返回的第三种情况，在父进程中，fork返回新创建子进程的进程ID</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i am the parent process, my process id is %d/n&quot;</span>,getpid());</span><br><span class="line">        <span class="comment">//这里因为已经在父进程中了，getpid()函数返回的是当前进程（elseif语句中进程的父进程）的进程ID</span></span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;统计结果是: %d/n&quot;</span>,count);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后运行的结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i am the child process, my process <span class="built_in">id</span> is 5574</span><br><span class="line">统计结果是: 1</span><br><span class="line">i am the parent process, my process <span class="built_in">id</span> is 5573</span><br><span class="line">统计结果是: 1</span><br></pre></td></tr></table></figure><p>借用一张图解释一下<strong>为什么同一个if else语句会执行两次，并且count的值为1而不是2</strong>：</p><p><img src="E:\JS练习\blog\Myblog\source\images\fork中的父子进程.jpg"></p><p>上面的代码都是位于语句<code>fpid=fork()</code>之后，进程1的变量为<code>count=0，fpid！=0（父进程）</code>。进程2的变量为<code>count=0，fpid=0（子进程）</code>，这两个进程的变量都是独立的，存在不同的地址中，不是共用的，这点要注意。可以说，我们就是通过<code>fpid</code>来识别和操作父子进程的。<br> 如果疑惑为什么不是从<code>#include</code>处开始复制代码的，这是因为fork是把进程当前的情况拷贝一份，执行fork时，进程已经执行完了<code>int count=0;</code>，正如我们上面所说的，<strong>子进程代码</strong>是<strong>从fork处开始执行</strong>的，fork只拷贝下一个要执行的代码到新的进程。</p><p>所以，其实执行的是两个if…else语句，输出的两个count也不是同一个。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;i son/pa ppid pid  fpid/n&quot;</span>);<span class="comment">//打印表头</span></span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">       <span class="type">pid_t</span> fpid=fork();</span><br><span class="line">       <span class="keyword">if</span>(fpid==<span class="number">0</span>)</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%d child  %4d %4d %4d/n&quot;</span>,i,getppid(),getpid(),fpid);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%d parent %4d %4d %4d/n&quot;</span>,i,getppid(),getpid(),fpid);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">    i son/pa ppid pid  fpid</span></span><br><span class="line"><span class="comment">    0 parent 2043 3224 3225     这里是最开始的那个父进程id3224，它的ppid2043我们不用管</span></span><br><span class="line"><span class="comment">    0 child  3224 3225    0子进程3225的ppid是父进程的pid</span></span><br><span class="line"><span class="comment">    1 parent 2043 3224 3226仍然是父进程id3224，又用fork创建了一个子进程3226</span></span><br><span class="line"><span class="comment">    1 parent 3224 3225 3227在这里fork返回了子进程3225创建的孙子进程3227</span></span><br><span class="line"><span class="comment">    1 child     1 3227    0</span></span><br><span class="line"><span class="comment">    1 child     1 3226    0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>从上面，我们可以看到，每次都是先执行父进程中的语句，再执行子进程中拷贝的代码语句，正如博主所说：</p><blockquote><ol><li>第一步：在父进程中，指令执行到for循环中，i&#x3D;0，接着执行fork，fork执行完后，系统中出现两个进程，分别是p3224和p3225（后面我都用pxxxx表示进程id为xxxx的进程）。可以看到父进程p3224的父进程是p2043，子进程p3225的父进程正好是p3224。我们用一个链表来表示这个关系：<br> <code>p2043-&gt;p3224-&gt;p3225</code><br> 第一次fork后，p3224（父进程）的变量为i&#x3D;0，fpid&#x3D;3225（fork函数在父进程中返向子进程id）<br> p3225（子进程）的变量为i&#x3D;0，fpid&#x3D;0（fork函数在子进程中返回0），打印出结果：<br> 0 parent 2043 3224 3225<br> 0 child  3224 3225    0</li><li>第二步：假设父进程p3224先执行，当进入下一个循环时，i&#x3D;1，接着执行fork，系统中又新增一个进程p3226，对于此时的父进程，p2043-&gt;p3224（当前进程）-&gt;p3226（被创建的子进程）。<br> 对于子进程p3225，执行完第一次循环后，i&#x3D;1，接着执行fork，系统中新增一个进程p3227，对于此进程，p3224-&gt;p3225（当前进程）-&gt;p3227（被创建的子进程）。从输出可以看到p3225原来是p3224的子进程，现在变成p3227的父进程。父子是相对的，这个大家应该容易理解。只要当前进程执行了fork，该进程就变成了父进程了，就打印出了parent。<br> 所以打印出结果是：<br> 1 parent 2043 3224 3226<br> 1 parent 3224 3225 3227 </li><li>第三步：第二步创建了两个进程p3226，p3227，这两个进程执行完printf函数后就结束了，因为这两个进程无法进入第三次循环，无法fork，该执行return 0;了，其他进程也是如此。<br> 以下是p3226，p3227打印出的结果：<br> 1 child     1 3227    0<br> 1 child     1 3226    0</li><li>细心的读者可能注意到p3226，p3227的父进程难道不该是p3224和p3225吗，怎么会是1呢？这里得讲到进程的创建和死亡的过程，在p3224和p3225执行完第二个循环后，main函数就该退出了，也即进程该死亡了，因为它已经做完所有事情了。p3224和p3225死亡后，p3226，p3227就没有父进程了，这在操作系统是不被允许的，所以p3226，p3227的父进程就被置为p1了，p1是永远不会死亡的，至于为什么，这里先不介绍。</li></ol></blockquote><p><img src="E:\JS练习\blog\Myblog\source\images\fork中的父子进程2.jpg" alt="fork中的父子进程进阶"></p><p>最后，用博主的这段打印祖孙三代关系的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">       <span class="type">pid_t</span> fpid=fork();</span><br><span class="line">       <span class="keyword">if</span>(fpid==<span class="number">0</span>)</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;son/n&quot;</span>);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;father/n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    for        i=0         1           2</span></span><br><span class="line"><span class="comment">              father     father     father</span></span><br><span class="line"><span class="comment">                                        son</span></span><br><span class="line"><span class="comment">                            son       father</span></span><br><span class="line"><span class="comment">                                        son</span></span><br><span class="line"><span class="comment">               son       father     father</span></span><br><span class="line"><span class="comment">                                        son</span></span><br><span class="line"><span class="comment">                            son       father</span></span><br><span class="line"><span class="comment">                                        son</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="pid-t类型"><a href="#pid-t类型" class="headerlink" title="pid_t类型"></a>pid_t类型</h2><p>pid_t类型是Linux下的<strong>进程号类型</strong>，在Linux环境编程中用于定义进程ID，需要引入头文件<code>&lt;sys/types.h&gt;</code>，否则会报错：<code>error:&#39;pid_t&#39; was not declared in this  scope</code>。</p><p><a href="https://blog.csdn.net/shanshu12/article/details/7896331">使用fork函数时，为什么使用pid_t而不用int</a>:</p><blockquote><p>pid_t是一个typedef定义类型，<br>sys&#x2F;types.h中的定义:<br>typedef short       pid_t;     &#x2F;* used for process ids *&#x2F;</p><p>pid_t就是一个short类型变量，实际表示的是内核中的进程表的索引</p><p>可以看到，头文件里也不过是个typedef而已.<br>使用pid_t而不使用int只是为了可移植性好一些.<br>因为在不同的平台上有可能这么定义：<br><code>typedef int pid_t</code><br>也有可能：<br><code>typedef long pid_t</code></p></blockquote><p>但是，在和fork函数配合使用时，由于进程很多时，fork函数返回的pid_t类型的子进程id，可能长度超过了int类型，需要用long int类型来存储，这时候就使用pid_t来存储子进程PID比较便于使用和移植。</p><h2 id="PID-PPID-PGID与SID"><a href="#PID-PPID-PGID与SID" class="headerlink" title="PID PPID PGID与SID"></a>PID PPID PGID与SID</h2><p>详见<a href="https://blog.csdn.net/Justdoit123_/article/details/101347971">博客</a>，在Linux中，进程都拥有以下的ID</p><ul><li><strong>Process ID</strong>(<strong>PID</strong>，也称之为<strong>进程标识</strong>)<br>Linux中标识进程的一个数字，它的值是不确定的，是由系统分配的（但是有一个例外，启动阶段,kernel运行的第一个进程是init，它的PID是1，是所有进程的最原始的父进程），每个进程都有唯一PID，当进程退出运行之后，PID就会回收，可能之后创建的进程会分配这个PID</li><li><strong>Parent</strong> Process ID(<strong>P</strong>PID)<br>字面意思，父进程的PID</li><li>Process <strong>Group</strong> ID(P<strong>G</strong>ID)<br>PGID就是进程所属的Group的Leader的PID，如果PGID&#x3D;PID，那么该进程是Group Leader</li><li><strong>Session</strong> ID(<strong>S</strong>ID)<br>和PGID非常相似，SID就是进程所属的Session Leader的PID，如果SID&#x3D;&#x3D;PID，那么该进程是session leader</li></ul><blockquote><p>Session和Group都是管理多个进程的方式，同一个Group的进程属于同一个Session，一个Session里可以包含多个Group</p></blockquote><p>注意，父进程也有<code>ppid</code>（爸爸的爸爸叫爷爷(～￣▽￣)～ ），<code>ppid</code>为<code>1</code>的进程被称之为<strong>僵尸进程</strong>，这是因为<code>linux</code>下有3个特殊的进程，<code>idle</code>进程(<code>PID = 0</code>), <code>init</code>进程(<code>PID = 1</code>)和<code>kthreadd(PID = 2</code>)。</p><p>在<code>terminal</code>中使用默认的ps命令输出的信息值包括和当前终端会话相关的进程信息，自然看不到<code>id</code>很短的进程：</p><p><img src="E:\JS练习\blog\Myblog\source\images\默认ps命令.png" alt="使用ps命令"></p><p>我们可以使用命令<code>ps --help</code>获取帮助，然后使用命令<code>ps -A</code>或<code>ps -e</code>来获取全部进程（all process）<br>![查看全部进程](E:\JS练习\blog\Myblog\source\images\ps -A命令.png)</p><h2 id="getpid和getppid函数，与fork函数产生的pid"><a href="#getpid和getppid函数，与fork函数产生的pid" class="headerlink" title="getpid和getppid函数，与fork函数产生的pid"></a>getpid和getppid函数，与fork函数产生的pid</h2><p><code>getpid</code>返回当前进程标识（也就是<code>PID</code>），<code>getppid</code>返回当前进程的父进程标识，使用这两个函数需要引入头文件<code>&lt;unistd.h&gt;</code>。</p><blockquote><p>每个进程都有一个独特（互不相同）的进程标识符（<code>process ID</code>），可以通过<code>getpid()</code>函数获得，还有一个记录父进程<code>pid</code>的变量，可以通过<code>getppid()</code>函数获得变量的值。</p></blockquote><p>这两个函数<strong>在调用中都不能返回错误</strong>，注意，返回值的<code>pid_t</code>类型 能够放进 int类型中去，返回值被转为<code>long</code> 整型输出。</p><p>！！注意，我们常用到命令<code>pid_t pid = fork()</code>产生的<code>pid</code>根据所处分支是在子进程还是在父进程而具有不同的值，同时要注意，这个<code>pid</code>的值，是<code>getpid()</code>返回的进程id刚创建的子进程<code>id</code>（没有则为0），从祖宗关系上，是<code>getppid()</code>返回的id所属的进程的孙子进程的<code>id</code>，例如下面这一段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">fencha</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> num)</span>;</span><br><span class="line">    fencha(<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fencha</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="type">int</span> pid = fork;</span><br><span class="line">    <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">&quot;ERROR\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;num)</span><br><span class="line">            fencha(i+<span class="number">1</span>,num);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;现在在父进程中&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;由fork函数产生的pid是 %d,&quot;</span>,pid)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;用getpid函数获取的值为%d，用getppid函数获取的值为%d\n&quot;</span>,getpid(),getppid());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到代码结果如下，这是一个十层的子进程递归创建，祖宗总共十代：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>注意，在上面的代码中，我们使用了sleep()函数，这是为了确保在子进程代码运行的过程中，父进程不会执行完所有代码而被内核释放掉所有资源，如果我们不使用sleep函数，如下面的代码，会导致<strong>孤儿进程（没有父进程的进程，那么照顾他的重任就落到了init进程身上）</strong>的产生。</p><p>想想看，为什么我们的代码已经执行完毕，但是id为6666的进程依然可以在ps命令中被查询到，tty为一个问号?说明该进程不是通过tty&#x2F;console启动，自然与终端terminal无关。</p><h3 id="孤儿进程与僵尸进程"><a href="#孤儿进程与僵尸进程" class="headerlink" title="孤儿进程与僵尸进程"></a>孤儿进程与僵尸进程</h3><p>这篇博客中提到了一个区别：</p><p><strong>孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</strong></p><p><strong>僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</strong></p><p>值得注意的是，照顾孤儿进程的进程id在不同版本的Linux系统中是不一样的，笔者所用的ubuntu16.04版本中由id为6666的进程负责收养孤儿进程。</p><p>虽然孤儿进程并没有危害，<strong>任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。</strong>这是每个 子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。  如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;在linux系统创建父子进程及相关操作&quot;&gt;&lt;a href=&quot;#在linux系统创建父子进程及相关操作&quot; class=&quot;headerlink&quot; title=&quot;在linux系统创建父子进程及相关操作&quot;&gt;&lt;/a&gt;在linux系统创建父子进程及相关操作&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="Linux" scheme="http://justskim.github.io/categories/Linux/"/>
    
    
    <category term="linux" scheme="http://justskim.github.io/tags/linux/"/>
    
    <category term="虚拟机" scheme="http://justskim.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    <category term="ubuntu" scheme="http://justskim.github.io/tags/ubuntu/"/>
    
    <category term="c语言" scheme="http://justskim.github.io/tags/c%E8%AF%AD%E8%A8%80/"/>
    
    <category term="进程" scheme="http://justskim.github.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>在linux系统中编写并执行C语言程序</title>
    <link href="http://justskim.github.io/2021/09/24/%E5%9C%A8linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%BC%96%E5%86%99%E5%B9%B6%E6%89%A7%E8%A1%8CC%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F/"/>
    <id>http://justskim.github.io/2021/09/24/%E5%9C%A8linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%BC%96%E5%86%99%E5%B9%B6%E6%89%A7%E8%A1%8CC%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F/</id>
    <published>2021-09-24T12:07:36.765Z</published>
    <updated>2021-09-27T02:26:49.095Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在linux系统中编写并执行C语言程序"><a href="#在linux系统中编写并执行C语言程序" class="headerlink" title="在linux系统中编写并执行C语言程序"></a>在linux系统中编写并执行C语言程序</h1><h2 id="1-按照教程使用Vmware创建虚拟机"><a href="#1-按照教程使用Vmware创建虚拟机" class="headerlink" title="1. 按照教程使用Vmware创建虚拟机"></a>1. 按照<a href="https://blog.csdn.net/weixin_44232795/article/details/104556174">教程</a>使用Vmware创建虚拟机</h2><p>值得注意的两点是，vmware15的激活码无法适用于vmware16的虚拟机，ubuntu的iso映像文件可以在官方网站中下载，使用最新（20版本）的即可。版本名称中带有desktop字段的意味着自带图形界面系统。</p><h2 id="2-linux系统下的C语言编译执行"><a href="#2-linux系统下的C语言编译执行" class="headerlink" title="2. linux系统下的C语言编译执行"></a>2. linux系统下的C语言编译执行</h2><p>我们按照教程的步骤配置编译程序环境：</p><blockquote><p>找到命令行窗口输入：<br>（1）、sudo apt-get install gcc<br>（2）、sudo apt-get install build-essential &#x2F;&#x2F;编写c所用到的库<br>（3）、gedit [文件名].c &#x2F;&#x2F;创建一个c文件，并且会自动打开，即可开始编写<br>（4）、gcc [文件名].c -o [自定义程序名] &#x2F;&#x2F;创建可执行文件<br>（5）、.&#x2F; [自定义程序名] &#x2F;&#x2F;即可运行</p></blockquote><p>然后写了第一个简单的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行，报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">user@ubuntu:~$ <span class="built_in">cd</span> Desktop</span><br><span class="line"><span class="comment">#因为是在桌面上直接创建的cpp程序，因此要从home/user文件夹中跳到子文件夹Desktop中</span></span><br><span class="line"></span><br><span class="line">user@ubuntu:~/Desktop$ ./hello.cpp</span><br><span class="line">bash: ./hello.cpp: Permission denied</span><br></pre></td></tr></table></figure><p>根据<a href="https://blog.csdn.net/mch2869253130/article/details/89403626">博客</a>的讲解：</p><blockquote><p>出现这个问题的原因是由于权限不够。解决办法就是改变可执行文件的权限。</p><p>对于单个的可执行文件使用命令：<code>chmod 777 file-name</code><br>若需要将一个目录下的所有可执行文件的权限都升级，可使用命令：<code>chmod -R 777 directory-name</code></p><p>其中：<br>-R 是指级联应用到目录里的所有子目录和文件<br>777 是所有用户都拥有最高权限</p></blockquote><p>如果我们不对cpp文件创建可执行文件，而是直接运行cpp文件，会导致报错如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">user@ubuntu:~/Desktop$ ./hello.cpp</span><br><span class="line">./hello.cpp: line 2: syntax error near unexpected token `(<span class="string">&#x27;</span></span><br><span class="line"><span class="string">./hello.cpp: line 2: `int main()&#123;&#x27;</span></span><br></pre></td></tr></table></figure><p>只有执行gcc编译命令后，再执行相关可执行文件，才可正确输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">user@ubuntu:~/Desktop$ gcc hello.cpp -o hello</span><br><span class="line">user@ubuntu:~/Desktop$ ./hello</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>除此之外，我们还可以在ubuntu的页面上看到一个hello可执行文件：</p><p><img src="E:\JS练习\blog\Myblog\source\images\C可执行文件.png" alt="hello可执行文件"></p><p>可以看到，文件的类型其实就是executable，简称exe可执行文件。</p><h2 id="3-GCC编译"><a href="#3-GCC编译" class="headerlink" title="3. GCC编译"></a>3. GCC编译</h2><p>在配置好的windows系统中，C程序执行步骤如下所示：</p><blockquote><ol><li>打开一个文本编辑器，添加上述代码。</li><li>保存文件为 <em>hello.c</em>。</li><li>打开命令提示符，进入到保存文件所在的目录。</li><li>键入 <em>gcc hello.c</em>，输入回车，编译代码。</li><li>如果代码中没有错误，命令提示符会跳到下一行，并生成 <em>a.out</em> 可执行文件。</li><li>现在，键入 <em>a.out</em> 来执行程序。</li><li>您可以看到屏幕上显示 *”Hello World”*。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc hello.c</span><br><span class="line">$ ./a.out</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure></blockquote><p>在C语言中，一个源程序如果不编译是绝对无法运行的。一个源程序必须经过编译生成后缀为.obj目标程序，然后连接生成后缀为.exe的可执行文件，方能运行。如果编译没有问题，只能说明没有语法错误，但可能会存在一些逻辑错误导致程序不能运行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;在linux系统中编写并执行C语言程序&quot;&gt;&lt;a href=&quot;#在linux系统中编写并执行C语言程序&quot; class=&quot;headerlink&quot; title=&quot;在linux系统中编写并执行C语言程序&quot;&gt;&lt;/a&gt;在linux系统中编写并执行C语言程序&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="Linux" scheme="http://justskim.github.io/categories/Linux/"/>
    
    
    <category term="linux" scheme="http://justskim.github.io/tags/linux/"/>
    
    <category term="虚拟机" scheme="http://justskim.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    <category term="ubuntu" scheme="http://justskim.github.io/tags/ubuntu/"/>
    
    <category term="c语言" scheme="http://justskim.github.io/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>几个常用的vue名词详解</title>
    <link href="http://justskim.github.io/2021/09/19/%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84vue%E5%90%8D%E8%AF%8D%E8%AF%A6%E8%A7%A3/"/>
    <id>http://justskim.github.io/2021/09/19/%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84vue%E5%90%8D%E8%AF%8D%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-09-19T02:25:01.014Z</published>
    <updated>2021-09-19T12:19:51.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="几个常用的vue名词详解"><a href="#几个常用的vue名词详解" class="headerlink" title="几个常用的vue名词详解"></a>几个常用的vue名词详解</h1><h2 id="vue是什么？"><a href="#vue是什么？" class="headerlink" title="vue是什么？"></a>vue是什么？</h2><p>没有比<a href="https://v3.cn.vuejs.org/guide/introduction.html#vue-js-%E6%98%AF%E4%BB%80%E4%B9%88">官网</a>更好的解释了：</p><blockquote><p>Vue (读音 &#x2F;vjuː&#x2F;，类似于 <strong>view</strong>) 是一套用于构建用户界面的<strong>渐进式框架</strong>。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与<a href="https://cn.vuejs.org/v2/guide/single-file-components.html">现代化的工具链</a>以及各种<a href="https://github.com/vuejs/awesome-vue#libraries--plugins">支持类库</a>结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p></blockquote><p>官方文档中还提供提供了<a href="https://cn.vuejs.org/v2/guide/comparison.html">vue2与其他几个常见框架的对比</a>。</p><p>相比传统的<code>html</code>、<code>css</code>、<code>javascript</code>使用<code>vue</code>的优势在于我们不必手动操作DOM，而是可以直接将js变量放到html页面当中，数据会自动绑定。开发者只需将重点放到对数据的处理上即可，代码也更加精简。当页面元素很多的时候，使用vue组件（如<code>v-for</code>列表渲染），可以让我们不必再一味复制粘贴html标签。</p><p>但是，以上操作只是将html和js组合在一起，并解决了html的复用问题，但css样式依然需要复制粘贴。为了解决这个问题，我们要使用单文件的vue组件，将html，css，javascript代码放到同一个.vue文件中。然后，使用webpack这一构建工具将代码进行分离，并分别与其他同类型的代码打包到一起。在基础阶段不必熟知webpack的具体原理，只需会用即可。</p><p><strong>使用webpack打包有以下几个好处</strong>：</p><ol><li>将许多碎小文件打包成一个整体，减少单页面内的衍生请求次数，提高网站效率。</li><li>将ES6的高级语法进行转换编译，以兼容老版本的浏览器。</li><li>将代码打包的同时进行混淆，提高代码的安全性。</li></ol><h2 id="webpack模板"><a href="#webpack模板" class="headerlink" title="webpack模板"></a>webpack模板</h2><p><a href="https://www.webpackjs.com/concepts/">webpack官方文档</a>对此有解释：</p><blockquote><p>本质上，<em>webpack</em> 是一个现代 JavaScript 应用程序的*静态模块打包器(module bundler)<em>。当 webpack 处理应用程序时，它会递归地构建一个</em>依赖关系图(dependency graph)*，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 <em>bundle</em>。</p></blockquote><p><a href="https://www.jianshu.com/p/a2c6ec809b28">这篇简书文章</a>中也有提到：</p><blockquote><p>Webpack是一个模块化打包工具，专注于构建模块化项目，在Webpack眼里一切文件都是模块，通过Loader转换翻译文件，通过Plugin注入钩子，最后输出由多个模块组合成的文件。</p><p>之所以一切文件皆模块，如：JavaScript、CSS、SCSS以及图片等资源，在Webpack眼中都是模块，因为这样可以更好的理清描述各个模块之间的依赖关系，方便Webpack对模块进行打包组合，输出浏览器使用的静态资源。</p></blockquote><p>目前，大部分的教程和大型项目都推荐使用webpack对vue进行打包。</p><h2 id="为什么要使用vue-cli"><a href="#为什么要使用vue-cli" class="headerlink" title="为什么要使用vue-cli?"></a>为什么要使用vue-cli?</h2><p>Vue 提供了一个官方的 CLI，为单页面应用 (SPA) 快速搭建繁杂的脚手架。它为现代前端工作流提供了开箱即用的构建设置。只需要几分钟的时间就可以运行起来并带有热重载、保存时 lint 校验，以及生产环境可用的构建版本。更多详情可查阅 <a href="https://cli.vuejs.org/zh/guide/">vue cli官方文档</a>对vue-cli的定义：</p><blockquote><p>Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统，提供：</p><ul><li><p>通过 <code>@vue/cli</code> 实现的交互式的项目脚手架。</p></li><li><p>通过 <code>@vue/cli</code> + <code>@vue/cli-service-global</code> 实现的零配置原型开发。</p></li><li><p>一个运行时依赖 (</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@vue/cli-service</span><br></pre></td></tr></table></figure><p>)，该依赖：</p><ul><li>可升级；</li><li>基于 webpack 构建，并带有合理的默认配置；</li><li>可以通过项目内的配置文件进行配置；</li><li>可以通过插件进行扩展。</li></ul></li><li><p>一个丰富的官方插件集合，集成了前端生态中最好的工具。</p></li><li><p>一套完全图形化的创建和管理 Vue.js 项目的用户界面。</p></li></ul><p>Vue CLI 致力于将 Vue 生态中的工具基础标准化。它确保了各种构建工具能够基于智能的默认配置即可平稳衔接，这样你可以专注在撰写应用上，而不必花好几天去纠结配置的问题。与此同时，它也为每个工具提供了调整配置的灵活性，无需 eject。</p></blockquote><p>这篇<a href="https://juejin.cn/post/6844903954346688520">掘金文章</a>中，讲到了使用命令<code>vue init webpack myproject</code>来创建项目时候的信息填写与选择：</p><ul><li><p>Project name (baoge)： —–项目名称，直接回车，按照括号中默认名字（<strong>注意这里的名字不能有大写字母</strong>，否则会报错：<code>Sorry, name can no longer contain capital letters</code>）</p></li><li><p>Project description (A Vue.js project)： —-项目描述，也可直接点击回车，使用默认名字</p></li><li><p>Author ()： —-作者</p></li></ul><p><strong>接下来是用户可以进行选择的项</strong>：</p><ul><li><p>Runtime + Compiler: recommended for most users 运行加编译，既然已经说了推荐，就选它了<br>Runtime-only: about 6KB lighter min+gzip, but templates (or any Vue-specificHTML) are ONLY allowed in .vue files - render functions are required elsewhere 仅运行时，已经有推荐了就选择第一个了</p></li><li><p>Install vue-router? (Y&#x2F;n) 是否安装vue-router，这是官方的路由，大多数情况下都使用，这里就输入“y”后回车即可。</p></li><li><p>Use ESLint to lint your code? (Y&#x2F;n) 是否使用ESLint管理代码，ESLint是个代码风格管理工具，是用来统一代码风格的，一般项目中都会使用。<br>接下来也是选择题Pick an ESLint preset (Use arrow keys) 选择一个ESLint预设，编写vue项目时的代码风格，直接y回车</p></li><li><p>Setup unit tests with Karma + Mocha? (Y&#x2F;n) 是否安装单元测试，选择安装y回车</p></li><li><p>Setup e2e tests with Nightwatch(Y&#x2F;n)? 是否安装e2e测试 ，选择安装y回车</p></li></ul><h2 id="不使用vue-cli的情况下搭建vue项目"><a href="#不使用vue-cli的情况下搭建vue项目" class="headerlink" title="不使用vue-cli的情况下搭建vue项目"></a>不使用vue-cli的情况下搭建vue项目</h2><p>首先，我们在DOS窗口中使用<code>npm init</code>来初始化一个项目。</p><blockquote><p>在node开发中使用npm  init会生成一个pakeage.json文件，这个文件主要是用来记录这个项目的详细信息的，它会将我们在项目开发中所要用到的包，以及项目的详细信息等记录在这个项目中。方便在以后的版本迭代和项目移植的时候会更加的方便。也是防止在后期的项目维护中误删除了一个包导致的项目不能够正常运行。使用npm init初始化项目还有一个好处就是在进行项目传递的时候不需要将项目依赖包一起发送给对方，对方在接受到你的项目之后再执行npm  install就可以将项目依赖全部下载到项目里。话不多说我们就直接开始进行操作。</p></blockquote><p>执行该命令后，DOS窗口中询问选项的含义如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package name:                    你的项目名字叫啥</span><br><span class="line">version:                         版本号</span><br><span class="line">description:                     对项目的描述</span><br><span class="line">entry point:                     项目的入口文件（一般你要用那个js文件作为node服务，就填写那个文件，旧的版本默认为app.js，在14.15.5版本的node中默认为index.js）</span><br><span class="line">test command:                    项目启动的时候要用什么命令来执行脚本文件</span><br><span class="line">git repository:                  如果你要将项目上传到git中的话，那么就需要填写git的仓库地址</span><br><span class="line">keywords：                       项目关键字</span><br><span class="line">author:                         作者的名字</span><br><span class="line">license:                        发行项目需要的证书，默认为ISC</span><br></pre></td></tr></table></figure><p><a href="https://www.npmjs.cn/files/package.json/">npmjs的官方网站</a>上有对这几个名词的解释，中文方面的翻译欠缺。</p><p>对于任何项目，<strong>Entry point</strong>是执行开始的文件。它取决于正在使用的技术的项目配置和运行时环境。</p><p>示例：对于node.js项目，使用<strong>app.js</strong>初始化应用程序并将所有内容粘合在一起。</p><p>在我们生成的package.json中，也有一个名为<code>main</code>的属性，官方解释：</p><blockquote><p> The main field is a module ID that is the primary entry point to your program.</p></blockquote><p>对于属性<code>keywords</code>的解释：</p><blockquote><p>Put keywords in it.  It’s an array of strings.  This helps people discover your package as it’s listed in <code>npm search</code>.</p></blockquote><p>想省事的话，可以使用命令<code>npm init -y</code>来代替，该命令会采用所有默认的配置。</p><p>项目会生成一个<code>package.json</code>文件，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;vue_test&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;keywords&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;几个常用的vue名词详解&quot;&gt;&lt;a href=&quot;#几个常用的vue名词详解&quot; class=&quot;headerlink&quot; title=&quot;几个常用的vue名词详解&quot;&gt;&lt;/a&gt;几个常用的vue名词详解&lt;/h1&gt;&lt;h2 id=&quot;vue是什么？&quot;&gt;&lt;a href=&quot;#vue是什么</summary>
      
    
    
    
    <category term="Programming languages and projects" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/"/>
    
    <category term="JavaScript" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/JavaScript/"/>
    
    <category term="Vue" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/JavaScript/Vue/"/>
    
    
    <category term="vue" scheme="http://justskim.github.io/tags/vue/"/>
    
    <category term="vue-cli" scheme="http://justskim.github.io/tags/vue-cli/"/>
    
    <category term="webpack" scheme="http://justskim.github.io/tags/webpack/"/>
    
    <category term="store" scheme="http://justskim.github.io/tags/store/"/>
    
    <category term="router" scheme="http://justskim.github.io/tags/router/"/>
    
  </entry>
  
  <entry>
    <title>创建vue项目的两个命令：vue create myproject与vue init webpack 详解</title>
    <link href="http://justskim.github.io/2021/09/19/%E5%88%9B%E5%BB%BAvue%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%91%BD%E4%BB%A4%EF%BC%9Avue-create-myproject%E4%B8%8Evue-init-webpack-%E8%AF%A6%E8%A7%A3/"/>
    <id>http://justskim.github.io/2021/09/19/%E5%88%9B%E5%BB%BAvue%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%91%BD%E4%BB%A4%EF%BC%9Avue-create-myproject%E4%B8%8Evue-init-webpack-%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-09-19T02:11:56.099Z</published>
    <updated>2021-09-22T03:01:21.593Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建vue项目的两个命令：vue-create-myproject与vue-init-webpack-详解"><a href="#创建vue项目的两个命令：vue-create-myproject与vue-init-webpack-详解" class="headerlink" title="创建vue项目的两个命令：vue create myproject与vue init webpack 详解"></a>创建vue项目的两个命令：vue create myproject与vue init webpack 详解</h1><h2 id="两个不同方法的来源"><a href="#两个不同方法的来源" class="headerlink" title="两个不同方法的来源"></a>两个不同方法的来源</h2><p>vue create 是vue-cli3.x（包括现在最新的vue-cli4.x）的初始化方式，目前模板是固定的，模板选项可自由配置，创建出来的是vue-cli3的项目，与cue-cli2项目结构不同，配置方法不同，具体配置方法参考官方文档网页链接。</p><p>vue init 则是vue-cli2.x的初始化方式，可以使用github上面的一些模板来初始化项目，webpack是官方推荐的标准模板名。vue-cli2.x项目向3.x迁移只需要把static目录复制到public目录下，老项目的src目录覆盖3.x的src目录(如果修改了配置，可以查看文档，用cli3的方法进行配置)</p><h2 id="vue-init-webpack-详解"><a href="#vue-init-webpack-详解" class="headerlink" title="vue init webpack 详解"></a>vue init webpack 详解</h2><p><a href="https://www.jianshu.com/p/6788ff700e5a">简书文章</a>中对DOS窗口中各个选择题的解释：</p><blockquote><ul><li><p>Project name (my-project): #项目名称，如果不需要就直接回车。注：此处项目名不能使用大写。</p></li><li><p>Project description (A Vue.js project): #项目描述，如果不需要就直接回车。</p></li><li><p>Author (xxx)：#项目作者，默认计算机用户名</p></li><li><p>vue build (Use arrow keys)</p></li></ul><p> &gt; Runtime + Compiler:recommended for most users </p><p> #译：运行+编译：被推荐为大多数用户的默认选择</p><p> &gt; Runtime-only:about 6KB lighter min+gzip,but templates (or any Vue-specific HTML) are ONLY allowed in .vue files-render functions are required elsewhere </p><p> #译：只运行大约6KB比较轻量的压缩文件，但只允许模板（或任何VUE特定HTML，VUE文件需要在其他地方呈现函数。翻译不精准，意思大概是选择该构建方式对文件大小有要求</p><ul><li><p>install vue-router? #安装vue的路由插件，需要就选y，否则就n [建议Y]</p></li><li><p>Use ESLint to lint your code? #是否使用ESLint检测你的代码？[ESLint 是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。建议选择 ‘N’ 因为选择 ‘Y’ 在做调试项目时,控制台会有很多 黄色警告 提示格式不规范,但其实并不影响项目]</p></li><li><p>Setup unit tests? #是否安装单元测试(国内其实为了追求开发速度这一块很少安装，但后续添加麻烦)</p></li><li><p>Setup e2e tests with Nightwatch(Y&#x2F;n)? #是否安装E2E测试框架NightWatch（E2E，也就是End To End，就是所谓的“用户真实场景” [建议N]</p></li><li><p>Should we run ‘npm install’ for you after the project has been created?        #项目创建后是否要为你运行“npm install”?这里选择包管理工具 [建议yes,use npm]</p></li></ul><p> yes,use npm        #使用npm</p><p> yes,use yarn    #使用yarn</p><p> no,I will handle that myself    #自己操作</p></blockquote><p><strong>Run time complier和Run time only的区别</strong></p><p>二者区别主要在main.js文件上：<br><code>Run time complier</code>中注册了App在使用，而在<code>Run time only中</code>，直接是一个render函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">productionTip</span> = <span class="literal">false</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">components</span>:&#123; <span class="title class_">App</span> &#125;,</span><br><span class="line">    <span class="attr">template</span>:<span class="string">&#x27;&lt;App/&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>Run time only</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">productionTip</span> = <span class="literal">false</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/d3823a5a0592">二者区别的原因在于运行原理</a></p><blockquote><p>在run time comliper中，将template传进给Vue时，会将<strong>template</strong>保存在Vue实例中的potions中，然后<strong>解析成ast 结构</strong>（ast是abstrct syntax trees英文的简称，译为抽象语法树）进而，<strong>将ast 编译成render函数</strong>；render函数又会将对应的tempalet<strong>转换成虚拟的dom节点元素</strong>，这些虚拟的节点元素就会构成一课虚拟dom树，最后再转化成真实的dom元素，也是就<strong>UI</strong>。<br> 这就是run time comliper 的原理，总结起来就是<strong>：template –&gt; ast –&gt; render –&gt;virtual dom –&gt; UI。</strong></p><p>run time only 中没有template 而只有函数，所以它的原理就是比 run time compiler 少了template –&gt; ast 的步骤。直接从render函数开始，转换成虚拟的dom最后变成真实的UI。</p></blockquote><h3 id="全部选择y的情况"><a href="#全部选择y的情况" class="headerlink" title="全部选择y的情况"></a>全部选择y的情况</h3><p>文件目录结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">project</span><br><span class="line">|README.md</span><br><span class="line">|.editorconfig</span><br><span class="line">|.eslintignore</span><br><span class="line">|.eslintrc.js</span><br><span class="line">|.gitignore</span><br><span class="line">|.postcssrc.js</span><br><span class="line">|.babelrc</span><br><span class="line">|package.json</span><br><span class="line">|package-lock.json</span><br><span class="line">|index.html</span><br><span class="line">└---node_modules</span><br><span class="line">└---config</span><br><span class="line">|  |---dev.env.js</span><br><span class="line">|  |---index.js</span><br><span class="line">|  |---prod.env.js</span><br><span class="line">└---build</span><br><span class="line">|  |---build.js</span><br><span class="line">|  |---check-versions.js</span><br><span class="line">|  |---logo.png</span><br><span class="line">|  |---utils.js</span><br><span class="line">|  |---vue-loader.conf.js</span><br><span class="line">|  |---webpack.base.conf.js</span><br><span class="line">|  |---webpack.dev.conf.js</span><br><span class="line">|  |---webpack.prod.conf.js</span><br><span class="line">└---static</span><br><span class="line">|  |---.gitkeep</span><br><span class="line">└---src</span><br><span class="line">  |---App.vue</span><br><span class="line">  |---main.js</span><br><span class="line">  └---router</span><br><span class="line">  ||---index.js</span><br><span class="line">  └---components</span><br><span class="line">  ||---HelloWorld.vue</span><br><span class="line">  └---assets</span><br><span class="line">  |---logo.png</span><br></pre></td></tr></table></figure><p>简易说明一下其中几个文件和文件夹的说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">node_modules：安装的依赖代码库</span><br><span class="line">.babelrc：babel相关配置（babel的作用在于将es6语法转换成浏览器支持的es5语法）</span><br><span class="line">.editorconfig：编辑器的配置，可以在此修改代码、缩进等</span><br><span class="line">.eslintrc.js：eslint的配置文件</span><br><span class="line">.gitignore：git忽略里面设定的这些文件的提交</span><br><span class="line">src：项目源码</span><br><span class="line">static：存放静态资源</span><br><span class="line">index.html：入口html文件</span><br><span class="line">package.json：项目的配置文件，用于描述该项目，包括初始化时的设置、环境、依赖包、版本等信息</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/kunmomo/p/14987319.html">.eslintignore文件</a>：</p><blockquote><p>当 ESLint 运行时，在确定哪些文件要检测之前，它会在当前工作目录中查找一个 <code>.eslintignore</code> 文件。如果发现了这个文件，当遍历目录时，将会应用这些偏好设置。一次只有一个 <code>.eslintignore</code> 文件会被使用，所以，不是当前工作目录下的 <code>.eslintignore</code> 文件将不会被用到。</p></blockquote><p><a href="https://www.cnblogs.com/QFKing/p/11869347.html">static文件夹中的.gitkeep文件</a>：</p><blockquote><p>git无法追踪一个空<em>文件夹</em>,当用户需要追踪(track)一个空<em>文件夹</em>的时候,按照惯例,大家会把一个称为.<em>gitkeep</em>的<em>文件</em>放在这些<em>文件夹</em>里</p></blockquote><p><strong><a href="https://blog.csdn.net/luwenze/article/details/89430527">build文件夹</a></strong><br>build文件夹中的文件对 <strong>webpack 开发</strong>和<strong>打包</strong>进行相关设置，包括入口文件、输出文件、使用的模块等。<br><code>build.js</code>构建环境下的配置:loading动画、删除创建目标文件夹、webpack编译、输出信息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./check-versions&#x27;</span>)()  <span class="comment">//请求同级目录下的check-versions.js文件，进行node和npm的版本检查</span></span><br><span class="line">process.<span class="property">env</span>.<span class="property">NODE_ENV</span> = <span class="string">&#x27;production&#x27;</span><span class="comment">//设置环境变量为生产环境</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ora = <span class="built_in">require</span>(<span class="string">&#x27;ora&#x27;</span>)<span class="comment">//主要用来实现node.js命令行环境的loading效果,和显示各种状态的图标等</span></span><br><span class="line"><span class="keyword">const</span> rm = <span class="built_in">require</span>(<span class="string">&#x27;rimraf&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">&#x27;chalk&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&#x27;../config&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> webpackConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.prod.conf&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> spinner = <span class="title function_">ora</span>(<span class="string">&#x27;building for production...&#x27;</span>)</span><br><span class="line">spinner.<span class="title function_">start</span>()<span class="comment">//启动Loading动画</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除dist/static文件夹</span></span><br><span class="line"><span class="title function_">rm</span>(path.<span class="title function_">join</span>(config.<span class="property">build</span>.<span class="property">assetsRoot</span>, config.<span class="property">build</span>.<span class="property">assetsSubDirectory</span>), <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line">  <span class="title function_">webpack</span>(webpackConfig, <span class="function">(<span class="params">err, stats</span>) =&gt;</span> &#123;</span><br><span class="line">    spinner.<span class="title function_">stop</span>()<span class="comment">//结束Loading动画</span></span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line">    process.<span class="property">stdout</span>.<span class="title function_">write</span>(stats.<span class="title function_">toString</span>(&#123;<span class="comment">//标准输出流，类似于console.log</span></span><br><span class="line">      <span class="attr">colors</span>: <span class="literal">true</span>,<span class="comment">//增加控制台颜色开关</span></span><br><span class="line">      <span class="attr">modules</span>: <span class="literal">false</span>,<span class="comment">//是否增加内置模块信息</span></span><br><span class="line">      <span class="attr">children</span>: <span class="literal">false</span>, <span class="comment">// If you are using ts-loader, setting this to true will make TypeScript errors show up during build.</span></span><br><span class="line">      <span class="attr">chunks</span>: <span class="literal">false</span>,<span class="comment">//是否允许较少的输出</span></span><br><span class="line">      <span class="attr">chunkModules</span>: <span class="literal">false</span><span class="comment">//是否在编译过程中持续打印</span></span><br><span class="line">    &#125;) + <span class="string">&#x27;\n\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编译出错的信息</span></span><br><span class="line">    <span class="keyword">if</span> (stats.<span class="title function_">hasErrors</span>()) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(chalk.<span class="title function_">red</span>(<span class="string">&#x27;  Build failed with errors.\n&#x27;</span>))</span><br><span class="line">      process.<span class="title function_">exit</span>(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//编译成功的信息</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(chalk.<span class="title function_">cyan</span>(<span class="string">&#x27;  Build complete.\n&#x27;</span>))</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(chalk.<span class="title function_">yellow</span>(</span><br><span class="line">      <span class="string">&#x27;  Tip: built files are meant to be served over an HTTP server.\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;  Opening index.html over file:// won\&#x27;t work.\n&#x27;</span></span><br><span class="line">    ))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>check-versions.js</code>文件负责node和npm的版本检查</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">&#x27;chalk&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> semver = <span class="built_in">require</span>(<span class="string">&#x27;semver&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> packageConfig = <span class="built_in">require</span>(<span class="string">&#x27;../package.json&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> shell = <span class="built_in">require</span>(<span class="string">&#x27;shelljs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">脚本跨域通过child_process模块新建子进程，从而执行unix系统命令</span></span><br><span class="line"><span class="comment">将cmd参数传递的值转换成前后没有空格的字符串，即版本号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">exec</span> (cmd) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>).<span class="title function_">execSync</span>(cmd).<span class="title function_">toString</span>().<span class="title function_">trim</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明常量数组，数组内容为有关node相关信息的对象</span></span><br><span class="line"><span class="keyword">const</span> versionRequirements = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;node&#x27;</span>,<span class="comment">//对象名称</span></span><br><span class="line">    <span class="attr">currentVersion</span>: semver.<span class="title function_">clean</span>(process.<span class="property">version</span>),</span><br><span class="line">    <span class="comment">//使用semver插件，将版本信息转换成规定格式</span></span><br><span class="line">    <span class="attr">versionRequirement</span>: packageConfig.<span class="property">engines</span>.<span class="property">node</span></span><br><span class="line">    <span class="comment">//规定package.json中engines选项的node版本信息</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (shell.<span class="title function_">which</span>(<span class="string">&#x27;npm&#x27;</span>)) &#123;<span class="comment">//linux指令</span></span><br><span class="line">  versionRequirements.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;npm&#x27;</span>,</span><br><span class="line">    <span class="attr">currentVersion</span>: <span class="title function_">exec</span>(<span class="string">&#x27;npm --version&#x27;</span>),</span><br><span class="line">    <span class="attr">versionRequirement</span>: packageConfig.<span class="property">engines</span>.<span class="property">npm</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> warnings = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; versionRequirements.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> mod = versionRequirements[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!semver.<span class="title function_">satisfies</span>(mod.<span class="property">currentVersion</span>, mod.<span class="property">versionRequirement</span>)) &#123;</span><br><span class="line">      warnings.<span class="title function_">push</span>(mod.<span class="property">name</span> + <span class="string">&#x27;: &#x27;</span> +</span><br><span class="line">        chalk.<span class="title function_">red</span>(mod.<span class="property">currentVersion</span>) + <span class="string">&#x27; should be &#x27;</span> +</span><br><span class="line">        chalk.<span class="title function_">green</span>(mod.<span class="property">versionRequirement</span>)</span><br><span class="line">        <span class="comment">//若版本号用红色标识，则要求改用绿色标识</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//为真则打印提示用户升级新版本</span></span><br><span class="line">  <span class="keyword">if</span> (warnings.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(chalk.<span class="title function_">yellow</span>(<span class="string">&#x27;To use this template, you must update following to modules:&#x27;</span>))</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; warnings.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> warning = warnings[i]</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;  &#x27;</span> + warning)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>()</span><br><span class="line">    process.<span class="title function_">exit</span>(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>util.js文件配置静态资源路径，生成cssLoaders用于加载.vue文件中的样式，生成styleLoaders用于加载不在.vue文件中的单独存在的样式文件（被引入的css文件）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&#x27;../config&#x27;</span>)<span class="comment">//！引入的是config文件夹下的index.js文件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ExtractTextPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;extract-text-webpack-plugin&#x27;</span>)<span class="comment">//该插件抽离css样式</span></span><br><span class="line"><span class="keyword">const</span> packageConfig = <span class="built_in">require</span>(<span class="string">&#x27;../package.json&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">assetsPath</span> = <span class="keyword">function</span> (<span class="params">_path</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> assetsSubDirectory = process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span></span><br><span class="line">    ? config.<span class="property">build</span>.<span class="property">assetsSubDirectory</span></span><br><span class="line">    : config.<span class="property">dev</span>.<span class="property">assetsSubDirectory</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> path.<span class="property">posix</span>.<span class="title function_">join</span>(assetsSubDirectory, _path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">cssLoaders</span> = <span class="keyword">function</span> (<span class="params">options</span>) &#123;</span><br><span class="line">  options = options || &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> cssLoader = &#123;</span><br><span class="line">    <span class="attr">loader</span>: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">    <span class="attr">options</span>: &#123;</span><br><span class="line">      <span class="attr">sourceMap</span>: options.<span class="property">sourceMap</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> postcssLoader = &#123;</span><br><span class="line">    <span class="attr">loader</span>: <span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">    <span class="attr">options</span>: &#123;</span><br><span class="line">      <span class="attr">sourceMap</span>: options.<span class="property">sourceMap</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// generate loader string to be used with extract text plugin</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">generateLoaders</span> (loader, loaderOptions) &#123;</span><br><span class="line">    <span class="keyword">const</span> loaders = options.<span class="property">usePostCSS</span> ? [cssLoader, postcssLoader] : [cssLoader]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loader) &#123;</span><br><span class="line">      loaders.<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="attr">loader</span>: loader + <span class="string">&#x27;-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, loaderOptions, &#123;</span><br><span class="line">          <span class="attr">sourceMap</span>: options.<span class="property">sourceMap</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Extract CSS when that option is specified</span></span><br><span class="line">    <span class="comment">// (which is the case during production build)</span></span><br><span class="line">    <span class="keyword">if</span> (options.<span class="property">extract</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">ExtractTextPlugin</span>.<span class="title function_">extract</span>(&#123;</span><br><span class="line">        <span class="attr">use</span>: loaders,</span><br><span class="line">        <span class="attr">fallback</span>: <span class="string">&#x27;vue-style-loader&#x27;</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> [<span class="string">&#x27;vue-style-loader&#x27;</span>].<span class="title function_">concat</span>(loaders)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// https://vue-loader.vuejs.org/en/configurations/extract-css.html</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">css</span>: <span class="title function_">generateLoaders</span>(),</span><br><span class="line">    <span class="attr">postcss</span>: <span class="title function_">generateLoaders</span>(),</span><br><span class="line">    <span class="attr">less</span>: <span class="title function_">generateLoaders</span>(<span class="string">&#x27;less&#x27;</span>),</span><br><span class="line">    <span class="attr">sass</span>: <span class="title function_">generateLoaders</span>(<span class="string">&#x27;sass&#x27;</span>, &#123; <span class="attr">indentedSyntax</span>: <span class="literal">true</span> &#125;),</span><br><span class="line">    <span class="attr">scss</span>: <span class="title function_">generateLoaders</span>(<span class="string">&#x27;sass&#x27;</span>),</span><br><span class="line">    <span class="attr">stylus</span>: <span class="title function_">generateLoaders</span>(<span class="string">&#x27;stylus&#x27;</span>),</span><br><span class="line">    <span class="attr">styl</span>: <span class="title function_">generateLoaders</span>(<span class="string">&#x27;stylus&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate loaders for standalone style files (outside of .vue)</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">styleLoaders</span> = <span class="keyword">function</span> (<span class="params">options</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> output = []</span><br><span class="line">  <span class="keyword">const</span> loaders = <span class="built_in">exports</span>.<span class="title function_">cssLoaders</span>(options)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> extension <span class="keyword">in</span> loaders) &#123;</span><br><span class="line">    <span class="keyword">const</span> loader = loaders[extension]</span><br><span class="line">    output.<span class="title function_">push</span>(&#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;\\.&#x27;</span> + extension + <span class="string">&#x27;$&#x27;</span>),</span><br><span class="line">      <span class="attr">use</span>: loader</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> output</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">createNotifierCallback</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> notifier = <span class="built_in">require</span>(<span class="string">&#x27;node-notifier&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">severity, errors</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (severity !== <span class="string">&#x27;error&#x27;</span>) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> error = errors[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">const</span> filename = error.<span class="property">file</span> &amp;&amp; error.<span class="property">file</span>.<span class="title function_">split</span>(<span class="string">&#x27;!&#x27;</span>).<span class="title function_">pop</span>()</span><br><span class="line"></span><br><span class="line">    notifier.<span class="title function_">notify</span>(&#123;</span><br><span class="line">      <span class="attr">title</span>: packageConfig.<span class="property">name</span>,</span><br><span class="line">      <span class="attr">message</span>: severity + <span class="string">&#x27;: &#x27;</span> + error.<span class="property">name</span>,</span><br><span class="line">      <span class="attr">subtitle</span>: filename || <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      <span class="attr">icon</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;logo.png&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>vue-loader.config.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">const</span> utils = <span class="built_in">require</span>(<span class="string">&#x27;./utils&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&#x27;../config&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> isProduction = process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span><span class="comment">//判断是否为生产环境</span></span><br><span class="line"><span class="comment">//根据环境来获取相应的productionSourceMap或者cssSourceMap</span></span><br><span class="line"><span class="keyword">const</span> sourceMapEnabled = isProduction</span><br><span class="line">  ? config.<span class="property">build</span>.<span class="property">productionSourceMap</span></span><br><span class="line">  : config.<span class="property">dev</span>.<span class="property">cssSourceMap</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">loaders</span>: utils.<span class="title function_">cssLoaders</span>(&#123;</span><br><span class="line">    <span class="attr">sourceMap</span>: sourceMapEnabled,<span class="comment">//是否开始sourceMap用来调试</span></span><br><span class="line">    <span class="attr">extract</span>: isProduction<span class="comment">//是否单独提取抽离CSS</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">cssSourceMap</span>: sourceMapEnabled,<span class="comment">//纪录压缩的代码，用来找到源码位置</span></span><br><span class="line">  <span class="attr">cacheBusting</span>: config.<span class="property">dev</span>.<span class="property">cacheBusting</span>,<span class="comment">//是否缓存破坏</span></span><br><span class="line">  <span class="comment">//在模块编译的过程中，将某些属性转换并调用</span></span><br><span class="line">  <span class="attr">transformToRequire</span>: &#123;</span><br><span class="line">    <span class="attr">video</span>: [<span class="string">&#x27;src&#x27;</span>, <span class="string">&#x27;poster&#x27;</span>],</span><br><span class="line">    <span class="attr">source</span>: <span class="string">&#x27;src&#x27;</span>,</span><br><span class="line">    <span class="attr">img</span>: <span class="string">&#x27;src&#x27;</span>,</span><br><span class="line">    <span class="attr">image</span>: <span class="string">&#x27;xlink:href&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="webpack-base-conf-js文件"><a href="#webpack-base-conf-js文件" class="headerlink" title="webpack.base.conf.js文件"></a>webpack.base.conf.js文件</h4><p>基本的webpack配置<br>   配置webpack编译入口<br>   配置webpack输出路径和命名规则<br>   配置模块resolve规则<br>   配置不同类型模块的处理规则</p><h4 id="webpack-dev-conf-js文件"><a href="#webpack-dev-conf-js文件" class="headerlink" title="webpack.dev.conf.js文件"></a>webpack.dev.conf.js文件</h4><p>开发环境配置<br>   在base.conf基础进一步完善<br>   将hot-reload相关的代码添加到entry chunks<br>   使用styleLoaders<br>   配置Source Maps<br>   配置webpack插件</p><h4 id="webpack-prod-conf-js文件"><a href="#webpack-prod-conf-js文件" class="headerlink" title="webpack.prod.conf.js文件"></a>webpack.prod.conf.js文件</h4><p>生产环境配置<br>  在base.conf基础进一步完善<br>  合并基础webpack配置<br>  使用styleLoaders<br>  配置webpack输出<br>  配置webpack插件<br>  gzip模式下的webpack插件配置<br>  webpack-bundle分析</p><p><strong>config文件夹</strong></p><p>config文件夹下有三个文件&#96;&#96;dev.env.js<code>、</code>index.js<code>、</code>prod.env.js&#96;。</p><p>prod.env.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">NODE_ENV</span>: <span class="string">&#x27;&quot;production&quot;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//内容非常简单，仅仅是导出了一个对象，里面写明了执行环境是“production（生产环境）”；</span></span><br><span class="line"><span class="comment">//注意，严格模式是es5的保留字，但不推荐在es6语法下使用！</span></span><br></pre></td></tr></table></figure><p>dev.env.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> prodEnv = <span class="built_in">require</span>(<span class="string">&#x27;./prod.env&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">merge</span>(prodEnv, &#123;</span><br><span class="line">  <span class="attr">NODE_ENV</span>: <span class="string">&#x27;&quot;development&quot;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//在“dev.env.js”中，先引入了webpack-merge这个模块。这个模块的作用是来合并两个配置文件对象并生成一个新的配置文件，有点儿类似于es6的object.assign();</span></span><br></pre></td></tr></table></figure><p>index.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="comment">// Template version: 1.3.1</span></span><br><span class="line"><span class="comment">// see http://vuejs-templates.github.io/webpack for documentation.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">dev</span>: &#123;</span><br><span class="line">    <span class="comment">// Paths</span></span><br><span class="line">    <span class="attr">assetsSubDirectory</span>: <span class="string">&#x27;static&#x27;</span>, <span class="comment">//静态资源文件夹，默认“static”</span></span><br><span class="line">    <span class="attr">assetsPublicPath</span>: <span class="string">&#x27;/&#x27;</span>,<span class="comment">//发布路径</span></span><br><span class="line">    <span class="attr">proxyTable</span>: &#123;&#125;,<span class="comment">//设置代理API，常用于解决跨域问题</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Various Dev Server settings</span></span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;localhost&#x27;</span>, <span class="comment">// can be overwritten by process.env.HOST</span></span><br><span class="line">    <span class="attr">port</span>: <span class="number">8080</span>, <span class="comment">// can be overwritten by process.env.PORT, if port is in use, a free one will be determined</span></span><br><span class="line">    <span class="attr">autoOpenBrowser</span>: <span class="literal">false</span>,<span class="comment">//是否自动打开浏览器</span></span><br><span class="line">    <span class="attr">errorOverlay</span>: <span class="literal">true</span>,<span class="comment">//查询错误</span></span><br><span class="line">    <span class="attr">notifyOnErrors</span>: <span class="literal">true</span>,<span class="comment">//通知错误</span></span><br><span class="line">    </span><br><span class="line">      <span class="attr">poll</span>: <span class="literal">false</span>, <span class="comment">// https://webpack.js.org/configuration/dev-server/#devserver-watchoptions-</span></span><br><span class="line">      <span class="comment">//poll是跟devserver相关的一个配置，webpack为我们提供的devserver是可以监控文件改动的，但在有些情况下却不能工作，我们可以设置一个轮询（poll）来解决</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use Eslint Loader?</span></span><br><span class="line">    <span class="comment">// If true, your code will be linted during bundling and</span></span><br><span class="line">    <span class="comment">// linting errors and warnings will be shown in the console.</span></span><br><span class="line">    <span class="attr">useEslint</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// If true, eslint errors and warnings will also be shown in the error overlay</span></span><br><span class="line">    <span class="comment">// in the browser.</span></span><br><span class="line">    <span class="attr">showEslintErrorsInOverlay</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="comment">//上面这两个是跟eslint相关的属性</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Source Maps</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">devtool</span>: <span class="string">&#x27;cheap-module-eval-source-map&#x27;</span>,</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    webpack提供的用来方便调试的配置，它有四种模式，</span></span><br><span class="line"><span class="comment">    详见https://webpack.js.org/configuration/devtool/#development</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// If you have problems debugging vue-files in devtools,</span></span><br><span class="line">    <span class="comment">// set this to false - it *may* help</span></span><br><span class="line">    <span class="comment">// https://vue-loader.vuejs.org/en/options.html#cachebusting</span></span><br><span class="line">    <span class="attr">cacheBusting</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">//一个配合devtool的配置，当给文件名插入新的hash导致清楚缓存时是否生成souce maps，默认在开发环境下为true</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">cssSourceMap</span>: <span class="literal">true</span>   <span class="comment">//是否开启cssSourceMap</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">build</span>: &#123;</span><br><span class="line">    <span class="comment">// Template for index.html</span></span><br><span class="line">    <span class="attr">index</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../dist/index.html&#x27;</span>),</span><br><span class="line">    <span class="comment">//编译后index.html的路径</span></span><br><span class="line">    <span class="comment">//Node.js 中,__dirname总是指向被执行 js 文件的绝对路径,比如你在/d1/d2/myscript.js文件中写了__dirname, 它的值就是/d1/d2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Paths</span></span><br><span class="line">    <span class="attr">assetsRoot</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../dist&#x27;</span>),<span class="comment">//打包后的文件根路径</span></span><br><span class="line">    <span class="attr">assetsSubDirectory</span>: <span class="string">&#x27;static&#x27;</span>,</span><br><span class="line">    <span class="attr">assetsPublicPath</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Source Maps</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">productionSourceMap</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// https://webpack.js.org/configuration/devtool/#production</span></span><br><span class="line">    <span class="attr">devtool</span>: <span class="string">&#x27;#source-map&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Gzip off by default as many popular static hosts such as</span></span><br><span class="line">    <span class="comment">// Surge or Netlify already gzip all static assets for you.</span></span><br><span class="line">    <span class="comment">// Before setting to `true`, make sure to:</span></span><br><span class="line">    <span class="comment">// npm install --save-dev compression-webpack-plugin</span></span><br><span class="line">    <span class="attr">productionGzip</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">productionGzipExtensions</span>: [<span class="string">&#x27;js&#x27;</span>, <span class="string">&#x27;css&#x27;</span>],</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run the build command with an extra argument to</span></span><br><span class="line">    <span class="comment">// View the bundle analyzer report after build finishes:</span></span><br><span class="line">    <span class="comment">// `npm run build --report`</span></span><br><span class="line">    <span class="comment">// Set to `true` or `false` to always turn it on or off</span></span><br><span class="line">    <span class="attr">bundleAnalyzerReport</span>: process.<span class="property">env</span>.<span class="property">npm_config_report</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>package.json中的情况：</p><p>参照<a href="https://blog.csdn.net/u011486491/article/details/101800764">这一篇CSDN博客</a>为各个属性名添加了注释</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;helloworld&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;A Vue.js project&quot;</span>,</span><br><span class="line">  <span class="string">&quot;author&quot;</span>: <span class="string">&quot;your name&lt;your email&gt;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;private&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;start&quot;</span>: <span class="string">&quot;npm run dev&quot;</span>,</span><br><span class="line">    <span class="string">&quot;lint&quot;</span>: <span class="string">&quot;eslint --ext .js,.vue src&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build&quot;</span>: <span class="string">&quot;node build/build.js&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;vue&quot;</span>: <span class="string">&quot;^2.5.2&quot;</span>,  <span class="comment">//该属性介绍了vue的版本</span></span><br><span class="line">    <span class="string">&quot;vue-router&quot;</span>: <span class="string">&quot;^3.0.1&quot;</span><span class="comment">//该属性介绍了vue-router的版本</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;autoprefixer&quot;</span>: <span class="string">&quot;^7.1.2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;babel-core&quot;</span>: <span class="string">&quot;^6.22.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;babel-eslint&quot;</span>: <span class="string">&quot;^8.2.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;babel-helper-vue-jsx-merge-props&quot;</span>: <span class="string">&quot;^2.0.3&quot;</span>,</span><br><span class="line">    <span class="string">&quot;babel-loader&quot;</span>: <span class="string">&quot;^7.1.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;babel-plugin-syntax-jsx&quot;</span>: <span class="string">&quot;^6.18.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;babel-plugin-transform-runtime&quot;</span>: <span class="string">&quot;^6.22.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;babel-plugin-transform-vue-jsx&quot;</span>: <span class="string">&quot;^3.5.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;babel-preset-env&quot;</span>: <span class="string">&quot;^1.3.2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;babel-preset-stage-2&quot;</span>: <span class="string">&quot;^6.22.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;chalk&quot;</span>: <span class="string">&quot;^2.0.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;copy-webpack-plugin&quot;</span>: <span class="string">&quot;^4.0.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;css-loader&quot;</span>: <span class="string">&quot;^0.28.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;eslint&quot;</span>: <span class="string">&quot;^4.15.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;eslint-config-airbnb-base&quot;</span>: <span class="string">&quot;^11.3.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;eslint-friendly-formatter&quot;</span>: <span class="string">&quot;^3.0.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;eslint-import-resolver-webpack&quot;</span>: <span class="string">&quot;^0.8.3&quot;</span>,</span><br><span class="line">    <span class="string">&quot;eslint-loader&quot;</span>: <span class="string">&quot;^1.7.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;eslint-plugin-import&quot;</span>: <span class="string">&quot;^2.7.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;eslint-plugin-vue&quot;</span>: <span class="string">&quot;^4.0.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;extract-text-webpack-plugin&quot;</span>: <span class="string">&quot;^3.0.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;file-loader&quot;</span>: <span class="string">&quot;^1.1.4&quot;</span>,</span><br><span class="line">    <span class="string">&quot;friendly-errors-webpack-plugin&quot;</span>: <span class="string">&quot;^1.6.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;html-webpack-plugin&quot;</span>: <span class="string">&quot;^2.30.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;node-notifier&quot;</span>: <span class="string">&quot;^5.1.2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;optimize-css-assets-webpack-plugin&quot;</span>: <span class="string">&quot;^3.2.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ora&quot;</span>: <span class="string">&quot;^1.2.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;portfinder&quot;</span>: <span class="string">&quot;^1.0.13&quot;</span>,</span><br><span class="line">    <span class="string">&quot;postcss-import&quot;</span>: <span class="string">&quot;^11.0.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;postcss-loader&quot;</span>: <span class="string">&quot;^2.0.8&quot;</span>,</span><br><span class="line">    <span class="string">&quot;postcss-url&quot;</span>: <span class="string">&quot;^7.2.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;rimraf&quot;</span>: <span class="string">&quot;^2.6.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;semver&quot;</span>: <span class="string">&quot;^5.3.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;shelljs&quot;</span>: <span class="string">&quot;^0.7.6&quot;</span>,</span><br><span class="line">    <span class="string">&quot;uglifyjs-webpack-plugin&quot;</span>: <span class="string">&quot;^1.1.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;url-loader&quot;</span>: <span class="string">&quot;^0.5.8&quot;</span>,</span><br><span class="line">    <span class="string">&quot;vue-loader&quot;</span>: <span class="string">&quot;^13.3.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;vue-style-loader&quot;</span>: <span class="string">&quot;^3.0.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;vue-template-compiler&quot;</span>: <span class="string">&quot;^2.5.2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;webpack&quot;</span>: <span class="string">&quot;^3.6.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;webpack-bundle-analyzer&quot;</span>: <span class="string">&quot;^2.9.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;webpack-dev-server&quot;</span>: <span class="string">&quot;^2.9.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;webpack-merge&quot;</span>: <span class="string">&quot;^4.1.0&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;engines&quot;</span>: &#123;<span class="comment">//引擎相关的内容</span></span><br><span class="line">    <span class="string">&quot;node&quot;</span>: <span class="string">&quot;&gt;= 6.0.0&quot;</span>,<span class="comment">//node版本要求</span></span><br><span class="line">    <span class="string">&quot;npm&quot;</span>: <span class="string">&quot;&gt;= 3.0.0&quot;</span><span class="comment">//npm版本要求</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;browserslist&quot;</span>: [<span class="comment">//配置浏览器的信息查询范围，这些信息将给Autoprefixer babel-env-preset eslint-plugin-compat这些组件来使用</span></span><br><span class="line">    <span class="string">&quot;&gt; 1%&quot;</span>,</span><br><span class="line">    <span class="string">&quot;last 2 versions&quot;</span>, <span class="comment">//每种浏览器的最近两个版本</span></span><br><span class="line">    <span class="string">&quot;not ie &lt;= 8&quot;</span>   <span class="comment">//IE8及之前的旧版本不查询</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面的很多字段我们之前已经提到过，下面介绍几个重要的名词。</p><h3 id="dependencies和devDependencies"><a href="#dependencies和devDependencies" class="headerlink" title="dependencies和devDependencies"></a>dependencies和devDependencies</h3><p>使用<code>npm install</code>安装模块，有以下四个常用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install moduleName <span class="comment"># 安装模块到项目目录下</span></span><br><span class="line">npm install -g moduleName <span class="comment"># -g 的意思是将模块安装到全局，具体安装到磁盘哪个位置，要看 npm config prefix 的位置。</span></span><br><span class="line">npm install -save moduleName <span class="comment"># -save 的意思是将模块安装到项目目录下，并在package文件的dependencies节点写入依赖。</span></span><br><span class="line">npm install -save-dev moduleName <span class="comment"># -save-dev 的意思是将模块安装到项目目录下，并在package文件的devDependencies节点写入依赖。</span></span><br></pre></td></tr></table></figure><p>简单的来说，安装在dependencies中的库是在生产环境中使用的，而安装在devDependencies中的库是在开发环境中使用的（记住develop有发展的意思）。</p><blockquote><p>例如：<code>webpack</code>，<code>gulp</code>等打包工具，这些都是我们开发阶段使用的，代码提交线上时，不需要这些工具，所以我们将它放入<code>devDependencies</code>即可，但是像<code>jquery</code>这类插件库，是我们生产环境所使用的，所以如要放入<code>dependencies</code>，如果未将<code>jquery</code>安装到<code>dependencies</code>，那么项目就可能报错，无法运行，所以类似这种项目必须依赖的插件库，我们则必须打入<code>dependencies</code>中，这下子都明白了吧。<br>链接：<a href="https://www.jianshu.com/p/afb171cac890">https://www.jianshu.com/p/afb171cac890</a></p></blockquote><p>我们可以在上面的package.json文件中看到，devDependencies中有一个模块autoprefixer，<a href="https://www.jianshu.com/p/cc57bca79a8b">简书文章</a>中对此解释：</p><blockquote><p>Autoprefixer是一个后处理程序，不象Sass以及Stylus之类的预处理器。它适用于普通的CSS，可以实现css3代码自动补全。也可以轻松跟Sass，LESS及Stylus集成，在CSS编译前或编译后运行。</p><p>Autoprefixer 同样会清理过期的前缀</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#清理前的<span class="variable constant_">CSS</span>样式</span><br><span class="line">a &#123;</span><br><span class="line">    -webkit-border-radius : 5px;</span><br><span class="line">    border-radius : 5px</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;#清理后的<span class="variable constant_">CSS</span>样式</span><br><span class="line">a &#123;</span><br><span class="line"> border-radius : 5px</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure></blockquote><h3 id="private属性"><a href="#private属性" class="headerlink" title="private属性"></a>private属性</h3><blockquote><p>If you set <code>&quot;private&quot;: true</code> in your package.json, then npm will refuse to publish it.</p><p>This is a way to prevent accidental publication of private repositories. If you would like to ensure that a given package is only ever published to a specific registry (for example, an internal registry), then use the <code>publishConfig</code> dictionary described below to override the <code>registry</code> config param at publish-time.</p></blockquote><p>在项目的package.json文件中，直接将该属性设置为true即可。</p><h3 id="package-lock-json文件"><a href="#package-lock-json文件" class="headerlink" title="package-lock.json文件"></a><a href="https://www.cnblogs.com/kugeliu/p/9153775.html">package-lock.json文件</a></h3><blockquote><ol><li><p>安装之后锁定包的版本，手动更改package.json文件安装将不会更新包，想要更新只能使用 npm install <a href="mailto:&#x78;&#x78;&#120;&#64;&#49;&#x2e;&#48;&#x2e;&#x30;">&#x78;&#x78;&#120;&#64;&#49;&#x2e;&#48;&#x2e;&#x30;</a> –save 这种方式来进行版本更新package-lock.json 文件才可以</p></li><li><p>加快了npm install 的速度，因为 package-lock.json 文件中已经记录了整个 node_modules 文件夹的树状结构，甚至连模块的下载地址都记录了，如果删除了nodel_modules模块，再重新安装的时候只需要直接下载文件即可</p></li></ol></blockquote><h3 id="如果我们全部选择’n’，就形成了更简单的文件目录结构"><a href="#如果我们全部选择’n’，就形成了更简单的文件目录结构" class="headerlink" title="如果我们全部选择’n’，就形成了更简单的文件目录结构"></a>如果我们全部选择’n’，就形成了更简单的文件目录结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">project</span><br><span class="line">|README.md</span><br><span class="line">|.editorconfig</span><br><span class="line">|.gitignore</span><br><span class="line">|.postcssrc.js</span><br><span class="line">|.babelrc</span><br><span class="line">|package.json</span><br><span class="line">|package-lock.json</span><br><span class="line">|index.html</span><br><span class="line">└---node_modules</span><br><span class="line">└---config</span><br><span class="line">|  |---dev.env.js</span><br><span class="line">|  |---index.js</span><br><span class="line">|  |---prod.env.js</span><br><span class="line">└---build</span><br><span class="line">|  |---build.js</span><br><span class="line">|  |---check-versions.js</span><br><span class="line">|  |---logo.png</span><br><span class="line">|  |---utils.js</span><br><span class="line">|  |---vue-loader.conf.js</span><br><span class="line">|  |---webpack.base.conf.js</span><br><span class="line">|  |---webpack.dev.conf.js</span><br><span class="line">|  |---webpack.prod.conf.js</span><br><span class="line">└---static</span><br><span class="line">|  |---.gitkeep</span><br><span class="line">└---src</span><br><span class="line">  |---App.vue</span><br><span class="line">  |---main.js</span><br><span class="line">  └---router</span><br><span class="line">  ||---index.js</span><br><span class="line">  └---components</span><br><span class="line">  ||---HelloWorld.vue</span><br><span class="line">  └---assets</span><br><span class="line">  |---logo.png</span><br></pre></td></tr></table></figure><h2 id="vue-create-详解"><a href="#vue-create-详解" class="headerlink" title="vue create 详解"></a>vue create 详解</h2><p>我们使用版本为4.5.13的vue-cli脚手架，选定vue3版本模板创建一个项目，项目文件目录结构如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">project</span><br><span class="line">|README.md</span><br><span class="line">|.gitignore</span><br><span class="line">|babel.config.js</span><br><span class="line">|package.json</span><br><span class="line">|package-lock.json</span><br><span class="line">└---node_modules</span><br><span class="line">└---public</span><br><span class="line">|  |---favicon.ico</span><br><span class="line">|  |---index.html</span><br><span class="line">└---src</span><br><span class="line">  |---App.vue</span><br><span class="line">  |---main.js</span><br><span class="line">  └---components</span><br><span class="line">  ||---HelloWorld.vue</span><br><span class="line">  └---assets</span><br><span class="line">  |---logo.png</span><br></pre></td></tr></table></figure><p>可以看到，使用vue-cli3之后版本脚手架的命令来创建的项目文件目录结构变得简单了许多。</p><p><strong>babel.config.js</strong></p><p>我们前面已经说过，babel是一个编译器，主要作用是将es5之后的语法转换成浏览器支持的es5语法。该文件存在于vue3.0根目录中，详见<a href="https://babeljs.io/docs/en/config-files#project-wide-configuration">https://babeljs.io/docs/en/config-files#project-wide-configuration</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">presets</span>: [</span><br><span class="line">    <span class="string">&#x27;@vue/cli-plugin-babel/preset&#x27;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看一下新版脚手架创建的package.json文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;vue_create&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.1.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;private&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;serve&quot;</span>: <span class="string">&quot;vue-cli-service serve&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build&quot;</span>: <span class="string">&quot;vue-cli-service build&quot;</span>,</span><br><span class="line">    <span class="string">&quot;lint&quot;</span>: <span class="string">&quot;vue-cli-service lint&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;core-js&quot;</span>: <span class="string">&quot;^3.6.5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;vue&quot;</span>: <span class="string">&quot;^3.0.0&quot;</span><span class="comment">//vue版本</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">//脚手架部分插件的版本</span></span><br><span class="line">    <span class="string">&quot;@vue/cli-plugin-babel&quot;</span>: <span class="string">&quot;~4.5.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@vue/cli-plugin-eslint&quot;</span>: <span class="string">&quot;~4.5.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@vue/cli-service&quot;</span>: <span class="string">&quot;~4.5.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@vue/compiler-sfc&quot;</span>: <span class="string">&quot;^3.0.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;babel-eslint&quot;</span>: <span class="string">&quot;^10.1.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;eslint&quot;</span>: <span class="string">&quot;^6.7.2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;eslint-plugin-vue&quot;</span>: <span class="string">&quot;^7.0.0&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;eslintConfig&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;root&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;env&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;node&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;extends&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;plugin:vue/vue3-essential&quot;</span>,</span><br><span class="line">      <span class="string">&quot;eslint:recommended&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;parserOptions&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;parser&quot;</span>: <span class="string">&quot;babel-eslint&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;rules&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;browserslist&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;&gt; 1%&quot;</span>,</span><br><span class="line">    <span class="string">&quot;last 2 versions&quot;</span>,</span><br><span class="line">    <span class="string">&quot;not dead&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;创建vue项目的两个命令：vue-create-myproject与vue-init-webpack-详解&quot;&gt;&lt;a href=&quot;#创建vue项目的两个命令：vue-create-myproject与vue-init-webpack-详解&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="Programming languages and projects" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/"/>
    
    <category term="JavaScript" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/JavaScript/"/>
    
    <category term="Vue" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/JavaScript/Vue/"/>
    
    
    <category term="vue" scheme="http://justskim.github.io/tags/vue/"/>
    
    <category term="vue-cli" scheme="http://justskim.github.io/tags/vue-cli/"/>
    
  </entry>
  
  <entry>
    <title>对于github.io的访问</title>
    <link href="http://justskim.github.io/2021/09/16/%E5%AF%B9%E4%BA%8Egithub.io%E7%9A%84%E8%AE%BF%E9%97%AE/"/>
    <id>http://justskim.github.io/2021/09/16/%E5%AF%B9%E4%BA%8Egithub.io%E7%9A%84%E8%AE%BF%E9%97%AE/</id>
    <published>2021-09-16T09:51:57.773Z</published>
    <updated>2021-09-16T09:58:47.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对于github-io的访问"><a href="#对于github-io的访问" class="headerlink" title="对于github.io的访问"></a>对于github.io的访问</h1><hr><p>当我们写完一篇博客，想要到自己的github.io界面看一看效果时，在谷歌浏览器中可能会遇到下面的情况：</p><p><img src="/images/%E6%82%A8%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8D%E6%98%AF%E7%A7%81%E5%AF%86%E8%BF%9E%E6%8E%A5.png" alt="您的连接不是私密连接"></p><p>产生的原因可能是<a href="https://blog.csdn.net/qq_29283569/article/details/107501508">这一篇博客</a>讲到的证书问题，我们后续再进行探究。</p><hr><p>对于这个问题，网上有很多千篇一律的解决方案，这里就不一一赘述了，我们这里介绍一下<a href="https://blog.csdn.net/zhuxuemin1991/article/details/106251232">这篇博客分享的一个小技巧</a>：</p><blockquote><p> 在当前页面用键盘输入 <code>thisisunsafe</code>，注意这一个字符串没有空格，而且并不是在地址栏输入，直接敲键盘即可（页面中不会显示输入内容），页面即会自动刷新进入网页。</p></blockquote><p>但实际上，使用这一个方法是有缺陷的，其原理和不足可以见<a href="https://www.codenong.com/35274659/">码农家园对该绕过chrome证书&#x2F;HSTS错误的讲解</a>，我们后续会再探究。</p><hr><p>如果输入之后，github.io博客页面的报错信息发生变化，变成：</p><blockquote><p>…无法访问此网站…<code>github.io</code> 请求遭到拒绝 … 未获授权 …</p></blockquote><p>产生的原因和解决方案见<a href="">这一篇博客中的说法</a>：</p><blockquote><p>因为github.com是外网，我们连接的时候IP地址需要转接地址，一层一层转接下来，就出现了上面的情况。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;对于github-io的访问&quot;&gt;&lt;a href=&quot;#对于github-io的访问&quot; class=&quot;headerlink&quot; title=&quot;对于github.io的访问&quot;&gt;&lt;/a&gt;对于github.io的访问&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;当我们写完一篇博客，想要到自己的g</summary>
      
    
    
    
    <category term="Git" scheme="http://justskim.github.io/categories/Git/"/>
    
    <category term="Github" scheme="http://justskim.github.io/categories/Git/Github/"/>
    
    
    <category term="安全证书" scheme="http://justskim.github.io/tags/%E5%AE%89%E5%85%A8%E8%AF%81%E4%B9%A6/"/>
    
  </entry>
  
</feed>
