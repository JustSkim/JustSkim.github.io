<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://justskim.github.io/atom.xml" rel="self"/>
  
  <link href="http://justskim.github.io/"/>
  <updated>2022-03-07T02:05:47.908Z</updated>
  <id>http://justskim.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>visual studio code中无法切换Python版本的解决</title>
    <link href="http://justskim.github.io/2022/03/07/visual-studio-code%E4%B8%AD%E6%97%A0%E6%B3%95%E5%88%87%E6%8D%A2Python%E7%89%88%E6%9C%AC%E7%9A%84%E8%A7%A3%E5%86%B3/"/>
    <id>http://justskim.github.io/2022/03/07/visual-studio-code%E4%B8%AD%E6%97%A0%E6%B3%95%E5%88%87%E6%8D%A2Python%E7%89%88%E6%9C%AC%E7%9A%84%E8%A7%A3%E5%86%B3/</id>
    <published>2022-03-07T01:50:49.323Z</published>
    <updated>2022-03-07T02:05:47.908Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>使用Python进行机器学习，需要引入<code>sklearn</code>模块，因此在我们建立的<code>anaconda</code>环境（名称<code>py378</code>，用的Python 3.7.8的版本）中activate该环境，并安装<code>scikit-learn</code>库（安装的模块名和导入的库名称不一样，这个见网上详细解释，<code>scikit-learn</code>其实就是其工具包）。但来到软件<code>visual studio code</code>界面中却发现无法正常切换Python版本，工作区也未能生成<code>.vscode</code>文件夹：</p><p>![visual studio code无法切换python环境](&#x2F;images&#x2F;visual studio code无法切换python环境.PNG)</p><p>我们可以看到，在左下角并没有加载出Python Interpreter，终端中手动输入命令切换环境也依然无法奏效。</p><h2 id="尝试步骤"><a href="#尝试步骤" class="headerlink" title="尝试步骤"></a>尝试步骤</h2><ol><li><p>按住<code>ctrl+shift+p</code>，输入<code>Python Interpreter</code>切换环境，发现已经被切换到<code>py378</code></p></li><li><p>打开<code>Preferences</code>中的设置，在<code>settings.json</code>中找到<code>python.defaultInterpreterPath</code>，由于之前博主为了能像<code>anaconda</code>那般切换环境，在<code>visual studio code</code>进行配置，此项为<code>anaconda</code>下的<code>python.exe</code>文件，博主手动将其修改为<code>C:\\Users\\YourUserName\\Anaconda3\\envs\\py378\\python.exe</code></p></li><li><p>在上边的设置中，搜索<code>cmd</code>，查看终端<code>terminal</code>是否为<code>cmd</code>而不是<code>powershell</code>（据网上说法<code>powershell较不稳定</code>），但博主这里的设置无误：</p><p><img src="/images/visual-studio-code%E4%B8%ADterminal%E8%AE%BE%E7%BD%AE.PNG" alt="visual-studio-code中terminal设置"></p></li></ol><p>经过以上步骤依然无效</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;使用Python进行机器学习，需要引入&lt;code&gt;sklearn&lt;/code&gt;模块，因此在我们建立的&lt;code&gt;anaconda&lt;/code</summary>
      
    
    
    
    <category term="Programming languages and projects" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/"/>
    
    <category term="Python3" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"/>
    
    
    <category term="python" scheme="http://justskim.github.io/tags/python/"/>
    
    <category term="visual studio code" scheme="http://justskim.github.io/tags/visual-studio-code/"/>
    
  </entry>
  
  <entry>
    <title>Eclipse web 工程的项目目录结构</title>
    <link href="http://justskim.github.io/2022/03/06/Eclipse-web-%E5%B7%A5%E7%A8%8B%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
    <id>http://justskim.github.io/2022/03/06/Eclipse-web-%E5%B7%A5%E7%A8%8B%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</id>
    <published>2022-03-06T10:10:07.896Z</published>
    <updated>2022-03-06T14:14:59.757Z</updated>
    
    <content type="html"><![CDATA[<p>在使用Eclipse学习Java开发的过程中，发现我自己新建<code>dynamic web project</code>的项目目录结构和视频中演示的不同，最明显的区别是没有Java Resources和JavaScript Resources这两个文件夹：</p><p><img src="/images/%E6%96%B0%E5%BB%BAweb%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="新建web项目目录结构"></p><p>查阅多方资料显示，这种项目结构的不同对于程序执行并没有大问题，要参考项目中各个文件和目录的功能，可以见以下三篇博客：</p><ol><li><a href="https://blog.csdn.net/yyuanxiwen/article/details/94600630">https://blog.csdn.net/yyuanxiwen/article/details/94600630</a></li><li><a href="https://blog.csdn.net/Alan_Wdd/article/details/90514928">https://blog.csdn.net/Alan_Wdd/article/details/90514928</a></li><li><a href="https://www.cnblogs.com/jetdl/p/9724651.html">https://www.cnblogs.com/jetdl/p/9724651.html</a></li></ol><p>在webapp下有一个WEB-INF文件夹。该目录是一个专用区域， 容器不能把此目录中的内容提供给用户。这个目录下的文件只供容器使用，里面包含不应该由客户直接下载的资源。<strong>Web 容器要求在你的应用程序中必须有 WEB-INF 目录。WEB-INF 中包含着发布描述符（也就是 web.xml 文件）, 一个 classes 目录和一个 lib目录, 以及其它内容。注意： 如果你的 Web 应用程序中没有包含这个目录, 它可能将无法工作 。</strong></p><p>web.xml文件在 J2EE Web 应用程序发布之后帮助管理 Web 应用程序的配置。在web.xml文件中会设置welcome-file标签，这是因为&#x2F;WEB-INF目录下的文件本来是不允许直接访问的，但如果在web.xml中配置了如上欢迎页面，并且在&#x2F;WEB-INF目录下放置了index.html，那么在浏览器地址栏输入<a href="http://127.0.0.1:8080/myWeb%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AEindex.html%E9%A1%B5%E9%9D%A2%EF%BC%8C%E8%B7%AF%E5%BE%84%E4%B8%AD%E7%9A%84myWeb%E6%98%AF%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E5%90%8D%E3%80%82">http://127.0.0.1:8080/myWeb可以访问index.html页面，路径中的myWeb是项目文件名。</a></p><p>在web.xml文件下需要添加约束，约束文件可以在我们tomcat安装目录下的<code>/conf</code>子文件夹中的web.xml文件中拷贝。</p><p>我们打开eclipse时，会要求我们设定workspace。在我们设定workspace的那个文件夹下，我们可以发现一个**隐藏文件夹<code>.metadata</code>**，它存在于eclipse第一次启动时指定的workspace目录下， project name 和 workspace 分别对应的目录不能是同一个目录，否则无法建立project name。</p><p>当我们通过<a href="https://so.csdn.net/so/search?q=eclipse&spm=1001.2101.3001.7020">eclipse</a>启动tomcat运行工程时，eclipse会将工程发布到org.eclipse.wst.server.core中，就像发布到tomcat中一样。使用tomcat服务器的话，默认的部署路径为<code>.metadata/.plugins/org.eclipse.wst.server.core/tmp0</code>，可以看到有一个server.xml，可以看到<code>deployDir=&quot;wtpwebapps&quot;</code>。</p><p>因此在该路径下的wtpwebapps文件夹（注意最后不是webapps）下可以看到发布的项目。</p><p>当我们为Eclipse配置默认使用的本机tomcat服务器后，我们可以在Project Explorer窗口中找到一个Servers目录，其中有一个server.xml。Service标签代表包含着一个服务（默认情况下name&#x3D;”Catalina”)，一个服务器可以包含多个服务，就对应着多个Service标签。因为是web项目，我们这里的服务要给浏览器使用，因此需要用到连接器Connector，并在其中配置端口号（默认为port&#x3D;”8080”）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在使用Eclipse学习Java开发的过程中，发现我自己新建&lt;code&gt;dynamic web project&lt;/code&gt;的项目目录结构和视频中演示的不同，最明显的区别是没有Java Resources和JavaScript Resources这两个文件夹：&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="Java" scheme="http://justskim.github.io/categories/Java/"/>
    
    <category term="Eclipse" scheme="http://justskim.github.io/categories/Java/Eclipse/"/>
    
    
    <category term="java" scheme="http://justskim.github.io/tags/java/"/>
    
    <category term="eclipse" scheme="http://justskim.github.io/tags/eclipse/"/>
    
  </entry>
  
  <entry>
    <title>重新安装JDK后Eclipse更改配置</title>
    <link href="http://justskim.github.io/2022/03/06/%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85JDK%E5%90%8EEclipse%E6%9B%B4%E6%94%B9%E9%85%8D%E7%BD%AE/"/>
    <id>http://justskim.github.io/2022/03/06/%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85JDK%E5%90%8EEclipse%E6%9B%B4%E6%94%B9%E9%85%8D%E7%BD%AE/</id>
    <published>2022-03-06T00:42:59.456Z</published>
    <updated>2022-03-06T09:16:31.632Z</updated>
    
    <content type="html"><![CDATA[<p>博主在将原先的JDK卸载，又重新安装JDK11后，发现了Eclipse软件无法正常打开的情况：</p><p><img src="/images/%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85Java%E5%90%8EEclipse%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80.PNG" alt="重新安装Java后Eclipse无法打开"></p><p>这种情况下我们一般先检查环境变量，通过命令行和系统环境的Java变量配置查看均无异常。我们查询当时Eclipse的安装教程，看是否有Eclipse软件相关的环境变量需要重新配置，结果的no。</p><p>那么，问题很明显，Eclipse软件会在第一次使用的时候获取系统的Java相关环境变量，然后将其存入自己的相关配置文件中，之后就不必获取了。在网上搜索得到Eclipse软件的配置文件为安装目录下bin文件夹中的<code>eclipse.ini</code>文件，我们打开搜索，可以看到<code>vm</code>（virtual machine 虚拟机）选项下有个旧版本<code>JDK</code>安装路径的bin文件夹：</p><p><img src="/images/eclipse.ini%E4%B8%AD%E4%BF%AE%E6%94%B9vm%E4%B8%8Bjavaw.exe%E7%9A%84%E8%B7%AF%E5%BE%84.PNG" alt="eclipse.ini中修改vm下javaw.exe的路径.PNG"></p><p>我们将其修改为重新安装的<code>JDK</code>路径下bin文件夹：<code>C:\Program Files\Java\jdk-11.0.2\bin</code>，重新打开Eclipse软件，可以成功运行！</p><p>这里顺便提一下，很多软件安装完之后都有一个bin文件夹，<em>bin</em>是binary的缩写，代表的意思是二进制，该文件夹下一般都存放二进制可执行文件。</p><p><em>ini 文件</em>，全称 “Initialization File”，即初始化文件，是windows的系统配置文件所采用的存储格式，统管windows的各项配置。<a href="https://blog.csdn.net/a123441/article/details/90668032">配置文件的好处</a>在于，能够通过直接编辑<code>ini</code>文件来修改配置：</p><blockquote><p>如果我们的程序没有任何配置文件时，这样的程序对外是全封闭的，一旦程序需要修改一些参数必须要修改程序代码本身并重新编译，这样很不好，所以要用配置文件，让程序出厂后还能根据需要进行必要的配置；配置文件有很多，如INI配置文件，<a href="https://so.csdn.net/so/search?q=XML&spm=1001.2101.3001.7020">XML</a>配置文件，还有就是可以使用系统注册表等。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;博主在将原先的JDK卸载，又重新安装JDK11后，发现了Eclipse软件无法正常打开的情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85Java%E5%90%8EEclipse%E6%97%A</summary>
      
    
    
    
    <category term="Java" scheme="http://justskim.github.io/categories/Java/"/>
    
    <category term="Eclipse" scheme="http://justskim.github.io/categories/Java/Eclipse/"/>
    
    
    <category term="java" scheme="http://justskim.github.io/tags/java/"/>
    
    <category term="eclipse" scheme="http://justskim.github.io/tags/eclipse/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7系统安装python3.7.8</title>
    <link href="http://justskim.github.io/2022/03/06/CentOS7%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85python3.7.8/"/>
    <id>http://justskim.github.io/2022/03/06/CentOS7%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85python3.7.8/</id>
    <published>2022-03-05T17:17:00.722Z</published>
    <updated>2022-03-07T01:33:57.245Z</updated>
    
    <content type="html"><![CDATA[<p>首先在<a href="https://www.python.org/downloads/source/">Python官方网站</a>中找到我们特定版本的安装包，这里我们要选择适合Linux系统的<code>tar.xz</code>格式压缩包。我们要注意，大部分Linux系统发行版，比如博主所用的Centos7都预装了python2，可以使用命令<code>python -V</code>查看其版本为2.7.5，但可能没有装pip工具。但是这样也有个好处，下载包的时候免得我们混淆。我们注意<a href="https://blog.csdn.net/qq_40584960/article/details/86082019">pip2和pip3的关系</a>：</p><blockquote><ol><li>pip是python的包管理工具，pip和pip3版本不同，都位于Scripts\目录下；</li><li>如果系统中只安装了Python2，那么就只能使用pip；</li><li>如果系统中只安装了Python3，那么既可以使用pip也可以使用pip3，二者是等价的；</li><li>如果系统中同时安装了Python2和Python3，则pip默认给Python2用，pip3指定给Python3用；</li><li>使用<code>pip install XXX</code>安装的库会位于路径<code>python2.X/site-packages</code>中，而使用<code>pip3 install XXX</code>安装的库会放在目录<code>python3.X/site-packages</code>下。</li></ol></blockquote><p>博主按照网上常见的教程安装后，一直显示的是<code>python 3.6.8</code>，跑到路径<code>/usr/bin</code>下使用命令<code>rm -rf python3*</code>删除了旧的python文件（前缀为python3的，前缀为python没有3的是python2版本的文件），再重新安装，编译，成功启动程序。</p><p><code>which python3 </code>命令在PATH变量指定的路径中，<strong>搜索系统命令<code>python</code>的位置</strong>，并且返回第一个搜索结果（使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先在&lt;a href=&quot;https://www.python.org/downloads/source/&quot;&gt;Python官方网站&lt;/a&gt;中找到我们特定版本的安装包，这里我们要选择适合Linux系统的&lt;code&gt;tar.xz&lt;/code&gt;格式压缩包。我们要注意，大部分Linu</summary>
      
    
    
    
    <category term="Programming languages and projects" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/"/>
    
    <category term="Python3" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"/>
    
    
    <category term="linux" scheme="http://justskim.github.io/tags/linux/"/>
    
    <category term="python" scheme="http://justskim.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Windows系统下环境变量配置与计算机重启</title>
    <link href="http://justskim.github.io/2022/03/05/Windows%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E5%90%AF/"/>
    <id>http://justskim.github.io/2022/03/05/Windows%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E5%90%AF/</id>
    <published>2022-03-05T08:50:11.668Z</published>
    <updated>2022-03-05T09:59:52.900Z</updated>
    
    <content type="html"><![CDATA[<p>我们来看一下<a href="https://blog.csdn.net/shuixin536/article/details/8084612">对于Windows不重启使环境变量修改生效的解释</a>：</p><blockquote><p>一个程序启动时，环境变量被复制到该程序所在的环境中，在该程序执行过程中不会被除该程序以外的其他程序所改变。也就是说，假设我们启动了一个cmd程序，然后通过控制面板修改了环境变量设置，但是已经启动了的cmd所拥有的环境变量并不会被改变。如果我们在修改环境变量之后启动cmd程序，则该程序将拥有新的环境变量。<br>那么结论就很明显了：修改环境变量之后，如果受影响的是应用程序，那么只要简单地重新启动此应用程序，环境变量的修改就会反映到该程序中，而不必重新启动计算机；但是，如果受影响的是系统服务，就必须重新启动才能将环境变量的修改反映到系统服务中（因为没有办法在不重启计算机的情况下重新启动系统服务管理器）</p></blockquote><p>那么有没有什么办法可以不重启就使一切修改的环境变量配置生效呢？有，当我们很不想重启windows系统时可以尝试这么做：</p><blockquote><p>以修改环境变量“PATH”为例，修改完成后，进入DOS命令提示符，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set PATH=C: 1</span><br></pre></td></tr></table></figure><p>关闭DOS窗口。再次打开DOS窗口，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo %PATH% 1</span><br></pre></td></tr></table></figure><p>可以发现“我的电脑”-&gt;“属性”-&gt;“高级”-&gt;“环境变量”中设置的 PATH 值已经生效。<br>不用担心DOS窗口中的修改会影响环境变量的值，DOS窗口中的环境变量只是Windows环境变量的一个副本而已。但是对副本的修改却会引发Windows环境变量的刷新，这正是我们想要的！</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们来看一下&lt;a href=&quot;https://blog.csdn.net/shuixin536/article/details/8084612&quot;&gt;对于Windows不重启使环境变量修改生效的解释&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个程序启动时，环境变量被复</summary>
      
    
    
    
    <category term="Windows" scheme="http://justskim.github.io/categories/Windows/"/>
    
    
    <category term="windows" scheme="http://justskim.github.io/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>Java基础语法学习要注意的小细节</title>
    <link href="http://justskim.github.io/2022/03/02/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%B0%8F%E7%BB%86%E8%8A%82/"/>
    <id>http://justskim.github.io/2022/03/02/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%B0%8F%E7%BB%86%E8%8A%82/</id>
    <published>2022-03-01T19:38:13.360Z</published>
    <updated>2022-03-12T13:33:17.374Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java基础语法学习要注意的小细节"><a href="#Java基础语法学习要注意的小细节" class="headerlink" title="Java基础语法学习要注意的小细节"></a>Java基础语法学习要注意的小细节</h1><p><strong>最最基本的</strong></p><p><code>Java</code><strong>8</strong>和11是两个最常用的版本，也是推荐新手起步安装的版本，博主一开始使用最新的JDK17，但很多文件位置和环境配置都不同，看使用旧版本的开发教程时很麻烦。Java平台包括Java se(J2SE，标准版)  Java ee(J2EE，企业版，J2SE是其子集) Java me(J2ME，用于嵌入式的，比较少)。普通用户只需安装JER(Java Runtime Environment)来运行Java程序，而开发者必须安装JDK来对程序进行编译调试。版本的关系对应为：Java X &#x3D; Java SE X &#x3D; JDK 1.X 。</p><p>对于Java SE，<a href="https://www.huoxiaoqiang.com/experience/javae/2381.html">各大厂商的JDK</a>有所区别。官网的下载速度很慢还要注册账号，我们可以在<a href="https://blog.csdn.net/wanghao72214/article/details/109720371">推荐的三家国内jdk镜像站</a>中下载相应的JDK。其中，<a href="https://mirrors.tuna.tsinghua.edu.cn/AdoptOpenJDK/11/jdk/x64/windows/">清华大学开源软件镜像站</a>的<code>JDK</code>为Eclipse Temurin Java SE，由Eclipse基金会发布，即OpenJDK的”生产就绪“构建，免费试用，且所有版本都通过了Oracle的Java SE技术兼容性工具包测试以及Eclipse AQAvit互操作性和性能测试。不过博主还是选择了传统的OpenJDK11版本，在之后可能会再使用探究（尽可能省去麻烦）。安装<code>JDK</code>时，路径中不能有中文和空格，并且要单独取消外部公共<code>JRE</code>的安装。</p><p>虚拟机 <code>JVM</code> ⫋ 运行环境 <code>JRE</code> ⫋ 开发工具 <code>JDK </code></p><p><strong>编译的编码与修改环境变量</strong></p><p>使用命令<code>javac </code>编译<code>java</code>文件，可能会出现中文信息乱码的情况，我们首先选择添加参数<code>-encoding UTF8</code>来解决问题。但博主在卸载Java11，转而安装Java9后出现的乱码问题却无法通过此方式解决。但是博主看到在一大堆的乱码报错信息前有这么一条：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF-<span class="number">8</span></span><br></pre></td></tr></table></figure><p>这可能是博主先前想通过startup.bat文件来启动tomcat10，而千方百计设置Java11环境变量遗留下来的，于是博主在环境变量中将此系统变量移除。</p><p><img src="/images/%E5%88%A0%E9%99%A4JAVA_TOOL_OPTIONS%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%90%8E%E9%87%8D%E5%90%AF.PNG" alt="删除JAVA_TOOL_OPTIONS环境变量后重启"></p><p>重新打开一个<code>cmd</code>窗口，执行编译命令依然乱码。只好在重启后重来一次，才成功编译。</p><p><strong>文件名和类名</strong></p><p>一个<code>java</code>文件中可以有很多类，但最多只能有一个类的类名和文件名相同——如果该类被<code>public</code>修饰，那么其类名必须和文件名相同，<strong>一个<code>java</code>文件中也最多只有一个类被public修饰</strong>。</p><p>尽管windows系统下文件名不区分大小写，但为了方便起见，以及在Linux操作系统下文件能被顺利编译执行，我们所有的<code>java</code>文件名及public修饰类，以及在windows控制台下运行时输入的文件名，都要保持一致的大小写！</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>&gt;<span class="title">javac</span>  <span class="title">DEMOCONST.java</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>&gt;<span class="title">java</span>  <span class="title">DEMOCONST</span></span></span><br><span class="line"><span class="function">错误: 找不到或无法加载主类 <span class="title">DEMOCONST</span></span></span><br><span class="line"><span class="function">原因: <span class="title">java.lang.NoClassDefFoundError</span>: <span class="title">DemoConst</span> (<span class="title">wrong</span> <span class="title">name</span>: <span class="title">DEMOCONST</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>&gt;<span class="title">java</span>  <span class="title">DemoConst</span></span></span><br><span class="line"><span class="function"><span class="title">the</span> <span class="title">name</span> <span class="title">of</span> <span class="title">class</span> <span class="title">is</span> <span class="title">democonst</span></span></span><br><span class="line"><span class="function"><span class="title">true</span></span></span><br><span class="line"><span class="function"><span class="title">false</span></span></span><br><span class="line"><span class="function">#可以看到，对于文件<span class="title">Democonst.java</span>，大小写不一致情况下<span class="title">javac</span>命令能编译，但<span class="title">java</span>命令不能执行</span></span><br></pre></td></tr></table></figure><p><strong>引用路径和包</strong><br>在学习类和对象的时候，博主定义了两个程序，并将其放在同一个文件夹(cn)下，首先是定义一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//package cn;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="comment">//成员变量</span></span><br><span class="line">String name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="comment">//成员方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;eat now!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;sleep now!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;study now!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，是在另一个Java程序中使用这个类创建对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//package cn;</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;<span class="comment">//这一行可以让我们引用同一个目标文件夹下的java类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demoStudent</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line"><span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">System.out.println(<span class="string">&quot;student&#x27;s name is &quot;</span>+stu.name);</span><br><span class="line">System.out.println(<span class="string">&quot;student&#x27;s age is &quot;</span>+stu.age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们在控制台可以编译后执行程序，注意，声明后<strong>没有被赋值的成员变量会有一个默认值（但是Java中局部变量未赋值将无法通过编译）</strong></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>\<span class="title">cn</span>&gt;<span class="title">javac</span> -<span class="title">encoding</span> <span class="title">UTF</span>-8 <span class="title">demoStudent.java</span></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>\<span class="title">cn</span>&gt;<span class="title">java</span> <span class="title">demoStudent</span></span></span><br><span class="line"><span class="function"><span class="title">student</span>&#x27;<span class="title">s</span> <span class="title">name</span> <span class="title">is</span> <span class="title">null</span></span></span><br><span class="line"><span class="function"><span class="title">student</span>&#x27;<span class="title">s</span> <span class="title">age</span> <span class="title">is</span> 0</span></span><br></pre></td></tr></table></figure><p>而如果我们取消注释的代码，并将<code>import java.io.*;</code>这一行注释掉，会发现，第二个程序编译时会报错：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>\<span class="title">cn.itcast.demo</span>&gt;<span class="title">javac</span> -<span class="title">encoding</span> <span class="title">UTF</span>-8 <span class="title">demoStudent.java</span></span></span><br><span class="line"><span class="function"><span class="title">demoStudent.java</span>:5: 错误: 无法访问<span class="title">Student</span></span></span><br><span class="line"><span class="function">                <span class="title">Student</span> <span class="title">stu</span> = <span class="title">new</span> <span class="title">Student</span>();</span></span><br><span class="line"><span class="function">                ^</span></span><br><span class="line"><span class="function">  错误的源文件: .\<span class="title">Student.java</span></span></span><br><span class="line"><span class="function">    文件不包含类<span class="title">Student</span></span></span><br><span class="line"><span class="function">    请删除该文件或确保该文件位于正确的源路径子目录中。</span></span><br><span class="line"><span class="function">1 个错误</span></span><br></pre></td></tr></table></figure><p>但是这样的写法在Eclipse软件的Java项目中又是能正常运行的，因此，博主决定探究一下Java的package机制，以及其在Windows系统下的编译机制，来确定我们命令语句该怎么输入（Eclipse和IDEA这类软件肯定是把这个步骤封装好的，不过我还是要了解这个原理）。</p><p>类是Java中一种引用数据类型（Java中除了八种基本数据类型，其它的都是<strong>对象，也就是引用类型，包括数组</strong>和字符串），对其使用以下三步走：</p><ol><li>导包：<ul><li>如果要使用的目标类，和当前类（含有main方法）位于<strong>同一个包</strong>下，可以省略导包不写；</li><li>否则需要使用<code>import</code>导包语句。</li></ul></li><li>创建对象：类名称 对象名 &#x3D; new 类名称();</li><li>使用。</li></ol><p>最后，我们根据该<a href="https://blog.csdn.net/scgaliguodong123_/article/details/41804667">博客</a>提出的方法，能在命令行中正确编译并执行以上的Java文件——配置参数，编译后，<strong>返回到包名父目录</strong>，运行程序。</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>\<span class="title">cn</span>&gt;<span class="title">javac</span> -<span class="title">encoding</span> <span class="title">UTF</span>-8 -<span class="title">sourcepath</span> <span class="title">E</span>:/<span class="title">Java_practice</span> <span class="title">demoStudent.java</span></span></span><br><span class="line"><span class="function">#注意！<span class="title">sourcepath</span>参数这里不能带上任何一级的包名，就能正确编译</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>\<span class="title">cn</span>&gt;<span class="title">java</span> <span class="title">demoStudent</span></span></span><br><span class="line"><span class="function">错误: 找不到或无法加载主类 <span class="title">demoStudent</span></span></span><br><span class="line"><span class="function">原因: <span class="title">java.lang.NoClassDefFoundError</span>: <span class="title">cn</span>/<span class="title">demoStudent</span> (<span class="title">wrong</span> <span class="title">name</span>: <span class="title">demoStudent</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>\<span class="title">cn</span>&gt;<span class="title">java</span> <span class="title">cn.demoStudent</span></span></span><br><span class="line"><span class="function">错误: 找不到或无法加载主类 <span class="title">cn.demoStudent</span></span></span><br><span class="line"><span class="function">原因: <span class="title">java.lang.ClassNotFoundException</span>: <span class="title">cn.demoStudent</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>\<span class="title">cn</span>&gt;<span class="title">cd</span> ..</span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>&gt;<span class="title">java</span> <span class="title">cn.demoStudent</span></span></span><br><span class="line"><span class="function"><span class="title">student</span>&#x27;<span class="title">s</span> <span class="title">name</span> <span class="title">is</span> <span class="title">null</span></span></span><br><span class="line"><span class="function"><span class="title">student</span>&#x27;<span class="title">s</span> <span class="title">age</span> <span class="title">is</span> 0</span></span><br><span class="line"><span class="function">#在控制台编译运行，使用<span class="title">java</span>命令运行时要加上包名：<span class="title">java</span> 包名.类名</span></span><br></pre></td></tr></table></figure><p>我们重新写一下两个文件，这次弄的复杂点，我们两个文件是在多级包(<code>cn.demo</code>)下的：</p><p><img src="/images/%E5%90%8C%E4%B8%80%E4%B8%AA%E5%8C%85%E4%B8%8B%E7%9A%84%E4%B8%A4%E4%B8%AAjava%E6%96%87%E4%BB%B6.png" alt="同一个包下的两个java文件"></p><p>在控制台中使用<code>tree</code>命令查看目录结构树，可以看到，这两个文件都放在demo文件夹下：</p><p><img src="/images/%E5%8C%85cn.demo%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E6%A0%91.png" alt="包cn.demo的目录结构树"></p><p>在控制台中的正确编译运行命令如下：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>\<span class="title">cn</span>\<span class="title">demo</span>&gt;<span class="title">javac</span> -<span class="title">encoding</span> <span class="title">UTF</span>-8 -<span class="title">classpath</span> <span class="title">E</span>:/<span class="title">Java_practice</span> <span class="title">Student.java</span></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>\<span class="title">cn</span>\<span class="title">demo</span>&gt;<span class="title">javac</span> -<span class="title">encoding</span> <span class="title">UTF</span>-8 -<span class="title">classpath</span> <span class="title">E</span>:/<span class="title">Java_practice</span> <span class="title">demoStudent.java</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>\<span class="title">cn</span>\<span class="title">demo</span>&gt;<span class="title">cd</span> ..</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>\<span class="title">cn</span>&gt;<span class="title">java</span> <span class="title">demo.demoStudent</span></span></span><br><span class="line"><span class="function">错误: 找不到或无法加载主类 <span class="title">demo.demoStudent</span></span></span><br><span class="line"><span class="function">原因: <span class="title">java.lang.NoClassDefFoundError</span>: <span class="title">cn</span>/<span class="title">demo</span>/<span class="title">demoStudent</span> (<span class="title">wrong</span> <span class="title">name</span>: <span class="title">demo</span>/<span class="title">demoStudent</span>)</span></span><br><span class="line"><span class="function">#注意，是要在最顶级包的父文件夹下才能运行</span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>\<span class="title">cn</span>&gt;<span class="title">cd</span> ..</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>&gt;<span class="title">java</span> <span class="title">cn.demo.demoStudent</span></span></span><br><span class="line"><span class="function"><span class="title">student</span>&#x27;<span class="title">s</span> <span class="title">name</span> <span class="title">is</span> <span class="title">null</span></span></span><br><span class="line"><span class="function"><span class="title">student</span>&#x27;<span class="title">s</span> <span class="title">age</span> <span class="title">is</span> 0</span></span><br></pre></td></tr></table></figure><p><strong>main方法的参数<code>args[]</code></strong></p><p>所有的 Java 程序，都由 <strong>public static void main(String[] args)</strong> 方法开始执行，在一般情况下我们不会用到main方法的这个形参，但一定要加上！否则可以通过编译，但在运行时会报错：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误: 在类 mainFunction 中找不到 main 方法, 请将 main 方法定义为:</span><br><span class="line">   public static void main(String[] args)</span><br><span class="line">否则 JavaFX 应用程序类必须扩展javafx.application.Application</span><br></pre></td></tr></table></figure><p>我们下面来尝试下这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainFunction</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;打印main方法中的输入参数：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(String element: args)&#123;</span><br><span class="line">System.out.println(element);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>&gt;<span class="title">java</span> <span class="title">mainFunction</span> <span class="title">gogoing</span>,<span class="title">ukr</span>,<span class="title">xibanya</span>...<span class="title">ufo</span> -<span class="title">sss</span> <span class="title">STK1</span></span></span><br><span class="line"><span class="function">打印<span class="title">main</span>方法中的输入参数：</span></span><br><span class="line"><span class="function"><span class="title">gogoing</span>,<span class="title">ukr</span>,<span class="title">xibanya</span>...<span class="title">ufo</span></span></span><br><span class="line"><span class="function">-<span class="title">sss</span></span></span><br><span class="line"><span class="function"><span class="title">STK1</span></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>&gt;<span class="title">java</span> <span class="title">mainFunction</span> <span class="title">gogo</span>--|<span class="title">ukr</span> &quot;<span class="title">xibanya</span>&quot; &#x27;<span class="title">s</span>&#x27; <span class="title">ufo</span> -<span class="title">sss</span> <span class="title">STK1</span></span></span><br><span class="line"><span class="function">&#x27;<span class="title">ukr</span>&#x27; 不是内部或外部命令，也不是可运行的程序</span></span><br><span class="line"><span class="function">或批处理文件。</span></span><br><span class="line"><span class="function">#注意这里，符号“|”会被<span class="title">windows</span>控制台识别为过滤命令！所以报错</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">Java_practice</span>&gt;<span class="title">java</span> <span class="title">mainFunction</span> <span class="title">gogo</span>-- <span class="title">ukr</span> &quot;<span class="title">xibanya</span>&quot; &#x27;<span class="title">s</span>&#x27; <span class="title">ufo</span> -<span class="title">sss</span> <span class="title">STK1</span></span></span><br><span class="line"><span class="function">打印<span class="title">main</span>方法中的输入参数：</span></span><br><span class="line"><span class="function"><span class="title">gogo</span>--</span></span><br><span class="line"><span class="function"><span class="title">ukr</span></span></span><br><span class="line"><span class="function">0<span class="title">xibanya</span></span></span><br><span class="line"><span class="function">&#x27;<span class="title">s</span>&#x27;</span></span><br><span class="line"><span class="function"><span class="title">ufo</span></span></span><br><span class="line"><span class="function">-<span class="title">sss</span></span></span><br><span class="line"><span class="function"><span class="title">STK1</span></span></span><br><span class="line"><span class="function">#我们可以看到，输入字符串参数，是按照空格来隔开的，注意双引号的使用，单引号会正常打印</span></span><br></pre></td></tr></table></figure><p><strong>编译并执行程序</strong></p><p><code>javac</code> 可以将<code>java</code>格式源文件编译为class字节码文件，也就是把我们写的<code>java</code>代码编译成计算机能识别的内部代码；<code>java</code>则可以运行该class字节码文件。</p><p>在命令行中输入<code>javac -help</code>可以看到其<a href="https://www.cnblogs.com/wangpei/p/7084341.html">用法</a>：</p><blockquote><p>用法: javac <options> <source files></p><p><code>options</code>命令行选项。<code>sourcefiles</code>一个或多个要编译的源文件（例如 MyClass.java）</p><ul><li>如果源文件数量少，在命令行上列出文件名即可。</li><li>如果源文件数量多，则将源文件名列在一个文件中，名称间用空格或回车行来进行分隔。然后在 javac 命令行中使用该列表文件名，文件名前冠以 @ 字符</li></ul></blockquote><p>其中，**-encoding**，设置源文件编码名称，不设置则默认为操作系统默认的字符编码（windows下为<code>GBK</code>），因此我们常常发现有关编码的报错信息，我们可以使用命令<code>javac -encoding UTF8 myclass.java</code>来成功编译。</p><p><strong>能为空的，是字符串（String）还是字符（Character）</strong>?</p><blockquote><p>Java语言提供了八种基本类型：六种数字类型（四个整数型，两个浮点型），一种字符类型（<strong>char</strong>），还有一种是布尔型。</p><p>和C语言类似，Java中的char 类型是一个<strong>单一</strong>的 16 位 Unicode 字符，最小值是 **<code>\u0000</code>**（十进制等效值为 0），最大值是 **<code>\uffff</code>**（十进制下等效于 65535）；</p></blockquote><p>Character 类用于对单个字符进行操作，在对象中包装一个基本类型 char 的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="comment">// Unicode 字符表示形式</span></span><br><span class="line"><span class="type">char</span> <span class="variable">uniChar</span> <span class="operator">=</span> <span class="string">&#x27;\u039A&#x27;</span></span><br><span class="line"><span class="comment">//Character类提供了一系列方法来操纵字符，我们可以使用Character的构造方法创建一个Character类对象</span></span><br><span class="line"><span class="type">Character</span> <span class="variable">ch_object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Character</span>(<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。有两种方法：使用关键字或者构造方法来创建 String 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;SKT&quot;</span>;</span><br><span class="line">String str2=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;SSW&quot;</span>);</span><br></pre></td></tr></table></figure><p>这两种方法的区别在于：<u>String 创建的字符串存储在公共池中，而 new 创建的字符串对象在堆上</u>。</p><p>关于这一点我们日后再进行深入探究，并和<strong>JavaScript中String()与new String()的区别</strong>做对比。</p><p>我们要注意，<u>单个字符的char类型不能为空，但String对象可以为一个空字符串</u>。我们在程序中依次对下面几行进行注释，然后将<code>java</code>文件编译执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;&quot;</span>);<span class="comment">//输出一行空行</span></span><br><span class="line">System.out.println(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="comment">/*编译时就无法通过，会报错</span></span><br><span class="line"><span class="comment">DEMOCONST.java:5: 错误: 空字符文字</span></span><br><span class="line"><span class="comment">                System.out.println(&#x27;&#x27;);</span></span><br><span class="line"><span class="comment">                                   ^</span></span><br><span class="line"><span class="comment">1 个错误</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">System.out.println(<span class="literal">true</span>);<span class="comment">//输出字符串true</span></span><br><span class="line">System.out.println(<span class="literal">false</span>);<span class="comment">//输出字符串false</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="literal">null</span>); <span class="comment">//null代表空，什么都没有</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">DemoConst.java:8: 错误: 对println的引用不明确</span></span><br><span class="line"><span class="comment">                System.out.println(null);</span></span><br><span class="line"><span class="comment">                          ^</span></span><br><span class="line"><span class="comment">  PrintStream 中的方法 println(char[]) 和 PrintStream 中的方法 println(String) 都匹配</span></span><br><span class="line"><span class="comment">1 个错误</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>for-each循环</strong></p><p><code>JDK</code>1.5 中引进的一种新的循环类型，能在不使用下标的情况下遍历数组，在Python和JavaScript中也有类似语法。注意，数组索引从0开始，不能像Python那样使用负数索引！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">team</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">double</span>[] teamList = &#123;<span class="number">1.2</span>, <span class="number">3.4</span>, <span class="number">9.3</span>, <span class="number">5.5</span>&#125;;</span><br><span class="line">      <span class="comment">// 打印所有数组元素，这里的i只是一个指代其中任一元素的作用</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">double</span> i: teamList) &#123;</span><br><span class="line">         System.out.println(i);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(teamList.length);<span class="comment">//打印数组长度</span></span><br><span class="line">       System.out.println(teamList[<span class="number">99</span>]);<span class="comment">//数组越界，编译不会报错，但运行时会报错</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法重载</strong></p><p>类似于C语言，Java也有方法重载的效果，允许在一个类中,存在多个方法拥有不同的参数（无论是参数的个数还是类型、顺序），而却有相同的名字。比如我们要想用一个函数来实现数字相加和字符串拼接两个功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mainFunction</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> sum(<span class="number">100</span>,<span class="number">200</span>);<span class="comment">//注意！！变量的名称可以跟方法的一样，但不推荐这么写！</span></span><br><span class="line"><span class="comment">//不必像c语言中声明方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;sum(100+200) = &quot;</span>+sum);</span><br><span class="line">System.out.println(sum(<span class="string">&quot;ssudi&quot;</span>,<span class="string">&quot;+ jhderhyiu&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a,<span class="type">double</span> b)</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> a+b;<span class="comment">//注意！！要运算的数据类型不一样时，结果为数据范围大的那一个类型！！</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">sum</span><span class="params">(String a,String b)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后，运行结果为：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>&gt;<span class="title">java</span> <span class="title">mainFunction</span></span></span><br><span class="line"><span class="function"><span class="title">sum</span>(100+200) = 300</span></span><br><span class="line"><span class="function"><span class="title">ssudi</span>+ <span class="title">jhderhyiu</span></span></span><br></pre></td></tr></table></figure><p>在其他编程语言中，Python由于可以接受任何类型的参数，对于缺少的参数也可以设置为缺省参数，因此不需要也不支持函数重载。而在JavaScript中，同一个作用域内，两个名称相同的函数，后来居上——后面的函数会覆盖前面的，这是因为<strong>声明提升</strong>——函数声明和变量声明总会被解释器提升到作用域的最顶端去执行。不过，<a href="https://segmentfault.com/a/1190000015602959">我们可以在JavaScript中实现模拟重载的效果</a>。</p><p><strong>局部变量和成员变量</strong></p><p>不同之处：</p><ol><li>定义的位置不同：局部变量定义在方法内部；成员变量直接定义在类当中，在方法外面；</li><li>内存中的位置不一样：局部变量在栈内存中，成员变量在堆内存中；</li><li>生命周期不同：局部变量随着方法的进栈而出现，方法出栈时消失；成员变量当对象被创建时出现，在对象被<code>JVM</code>回收，也就是垃圾回收时消失;</li><li>默认值不同：局部变量没有默认值，必须赋值后才可使用，成员变量声明后自动有一个默认值。</li></ol><h2 id="类方法，static修饰符"><a href="#类方法，static修饰符" class="headerlink" title="类方法，static修饰符"></a>类方法，static修饰符</h2><ul><li><p>变量，可以按照两种方式划分：</p><ol><li><p>按位置来分：成员变量——类中方法外的变量（有默认值），局部变量——类中方法内的变量；</p></li><li><p>按是否使用<code>static</code>关键字声明来分：</p><ul><li><p>类变量(静态变量)：在类中<strong>使用static关键字声明</strong>，但位于方法、构造函数、块之外。无论一个类实例化多少对象，它的静态变量只有一份拷贝。为了加以区分，我们用static声明的局部变量称之为静态局部变量；</p></li><li><p>实例变量：由类生成对象时，才分配存储空间。各对象间的实例变量互不干扰，能通过对象的引用来访问实例变量。但在Java多线程中，实例变量是多个线程共享资源，要注意同步访问时可能出现的问题。</p></li></ul></li><li><p>注意：static修饰的成员（字段和方法）应该使用<strong>类名.成员名</strong>访问，也可以使用对象名.成员名，但是不推荐。</p></li></ol></li><li><p>成员方法：类中的方法，包含：</p><ul><li>静态方法：被static修饰的成员方法，不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据；</li><li>实例方法：没有用关键字static修饰的成员方法。</li></ul></li><li><p>构造方法：类中专门用来创建对象的方法，通过<code>new</code>关键字创建对象时就是在调用构造方法，注意一下两点：</p><ol><li>构造方法<strong>不能写返回值类型！包括void也不能写！</strong></li><li>构造方法的名称必须和所在的类名称完全一致（包括大小写一致）</li></ol></li></ul><p><strong>被static修饰的成员变量和成员方法独立于该类的任何对象</strong>。也就是说，它不依赖类特定的实例，<strong>被类的所有实例共享</strong>。只要这个类被加载，Java虚拟机就能根据类名在运行时数据区或者方法区内找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。 而用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它类的对象时，不生成static变量的副本，而是类的所有实例共享同一个static变量。 这也就意味着我们可以通过类&#x2F;对象来修改静态变量的值，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String name=<span class="string">&quot;cattt&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span>  <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">ct1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        ct1.name=<span class="string">&quot;sss&quot;</span>;<span class="comment">//这一句也可以换成 Cat.name=&quot;sss&quot;;</span></span><br><span class="line">        System.out.println(Cat.name);<span class="comment">//结果为sss</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有加<code>public/private</code>修饰符的变量，默认为<code>public</code>公开类型，可以被外部调用，当然这样不安全，一般采用加<code>private</code>修饰符，配合特定<code>setter/getter</code>方法的使用。</p><p>我们接着来看一下，<code>static</code>修饰符在类中的应用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">String name;String address;<span class="type">int</span> age;</span><br><span class="line"><span class="keyword">static</span> <span class="type">String</span> <span class="variable">country</span> <span class="operator">=</span> <span class="string">&quot;大清&quot;</span>;<span class="comment">//被static修饰的静态变量</span></span><br><span class="line"><span class="comment">//构造方法的名称必须跟类名称相同！</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name,String address)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="built_in">this</span>.address = address;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;北平&quot;</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;南昌&quot;</span>);</span><br><span class="line"><span class="comment">//下面我们对数值分别进行更改</span></span><br><span class="line">p1.country = <span class="string">&quot;民国&quot;</span>;<span class="comment">//不推荐这样使用静态变量</span></span><br><span class="line">p1.address = <span class="string">&quot;北京&quot;</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;p1.country = &quot;</span>+p1.country+<span class="string">&quot;\np1.address = &quot;</span>+p1.address+<span class="string">&quot;\np1.age = &quot;</span>+p1.age);</span><br><span class="line">System.out.println(<span class="string">&quot;p2.country = &quot;</span>+p2.country+<span class="string">&quot;\np2.address = &quot;</span>+p2.address+<span class="string">&quot;\np2.age = &quot;</span>+p2.age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>\<span class="title">cn</span>\<span class="title">demo</span>&gt;<span class="title">java</span> <span class="title">Person</span></span></span><br><span class="line"><span class="function"><span class="title">p1.country</span> = 民国</span></span><br><span class="line"><span class="function"><span class="title">p1.address</span> = 北京</span></span><br><span class="line"><span class="function"><span class="title">p1.age</span> = 0#<span class="title">int</span>类型的成员变量默认值为0</span></span><br><span class="line"><span class="function"><span class="title">p2.country</span> = 民国</span></span><br><span class="line"><span class="function"><span class="title">p2.address</span> = 南昌</span></span><br><span class="line"><span class="function"><span class="title">p2.age</span> = 0</span></span><br></pre></td></tr></table></figure><p>可以看到，我们只更改了对象<code>p1</code>中的country属性，但因为这是个被<code>static</code>修饰的静态变量，因此所有由<code>Person</code>类所构造的对象中，这一项属性都改变了。</p><h3 id="静态变量与实例化"><a href="#静态变量与实例化" class="headerlink" title="静态变量与实例化"></a>静态变量与实例化</h3><p>我们首先写一个程序，这里有静态变量和静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">staticFunction</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//实例变量</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">99</span>;<span class="comment">//静态变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printCountpublic</span><span class="params">()</span>&#123;</span><br><span class="line">count++; </span><br><span class="line">System.out.println(<span class="string">&quot;Now,count = &quot;</span>+count+age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printCountstatic</span><span class="params">()</span>&#123;</span><br><span class="line">count+=<span class="number">10</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;Now,count = &quot;</span>+count);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序将无法编译通过，并报错：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>\<span class="title">cn</span>\<span class="title">demo</span>&gt;<span class="title">javac</span> -<span class="title">encoding</span> <span class="title">UTF</span>-8 <span class="title">staticFunction.java</span></span></span><br><span class="line"><span class="function"><span class="title">staticFunction.java</span>:9: 错误: 无法从静态上下文中引用非静态变量 <span class="title">count</span></span></span><br><span class="line"><span class="function">                <span class="title">count</span>+=10;</span></span><br><span class="line"><span class="function">                ^</span></span><br><span class="line"><span class="function"><span class="title">staticFunction.java</span>:10: 错误: 无法从静态上下文中引用非静态变量 <span class="title">count</span></span></span><br><span class="line"><span class="function">                <span class="title">System.out.println</span>(&quot;<span class="title">Now</span>,<span class="title">count</span> = &quot;+<span class="title">count</span>);</span></span><br><span class="line"><span class="function">                                                  ^</span></span><br><span class="line"><span class="function">2 个错误</span></span><br></pre></td></tr></table></figure><p>报错原因是：静态方法只能访问静态变量；如果<strong>要让静态方法访问动态变量</strong>，<strong>必须将动态变量实例化</strong>。</p><p><strong>继承与静态</strong></p><p>我们创建一个父类<code>LiYua</code>和一个继承它的子类<code>LiShiMing</code>，并在父类中定义了静态变量，静态方法与实例变量，实例方法。可以看到，IDEA软件会智能提示能否使用该类&#x2F;对象的属性&#x2F;方法（在我们输入的时候可以看到在其智能提示输入中是否存在该项），时刻牢记，<code>static</code>修饰的静态变量&#x2F;方法，只存在一份拷贝，可以被类&#x2F;对象调用，我们可以通过子类使用它们，但这不是继承！<em>原因</em>：继承是对于实体而言的，而静态的东西不属于实体，也可以说，静态与类是一个级别。</p><p>但是实例变量只能在创建对象（也就是实例化）之后通过该对象进行调用：</p><p><img src="/images/%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%99%E6%80%81.PNG" alt="继承与静态"></p><p><strong>多态，向上&#x2F;下转型</strong></p><p>在学会继承之后，我们可以定义一个父类<code>Animal</code>，在其中定义一个实例方法<code>eat</code>，这样，无论我们定义多少个该父类下的子类（比如猫狗鸡鸭鹅），都有一个继承来的<code>eat</code>方法，就不必在这些子类的Java代码中编写了。那么，问题来了，如果我们要编写一个<code>feed</code>方法来代表喂养动物，由于这些动物的子类是不同的，意味着作为传入到<code>feed</code>函数中的参数也是不同的类，那我们岂不是要在代码中重载（<strong>在一个类中的叫重载，子类对父类方法的叫重写</strong>）很多个<code>feed</code>方法？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Cat cat01)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Dog dg01)</span>&#123;&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>事实上我们不用这么干，只需要利用多态的向上转型：类的对象赋给了父类的引用，这样的缺点是屏蔽掉子类中特有的方法，然后我们只定义参数为父类<code>Animal</code>型对象的一个<code>feed</code>函数即可，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">ani1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"><span class="type">Animal</span> <span class="variable">ani2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Animal ani)</span>&#123;ani.eat();&#125;</span><br></pre></td></tr></table></figure><p>但是，这样子，对象<code>ani2</code>这只狗只是被当作动物看待，无法使用<code>Dog</code>子类中的一个特有方法<code>guard</code>，为了解决这一点，我们可以使用向下转型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span>  <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Animal</span> <span class="variable">ani1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">    <span class="comment">//向上转型——子类的对象赋给了父类的引用，猫狗当做动物来看，会屏蔽掉类中特有的方法</span></span><br><span class="line">    <span class="type">Animal</span> <span class="variable">ani2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">ani0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">pr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="comment">//ani0.feed(ani1);这一个就报错了，原因在于ani0已经向上转型成父类型Animal，没有了feed函数</span></span><br><span class="line">        pr.feed(ani1);</span><br><span class="line">        <span class="comment">//pr.feed(ani2);这一处的错误在于ani2没有被我们定义成静态变量而是实例化变量</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">ani3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">//ani3.guard();    输入ani3后，在IDEA给的输入提示里面选择guard，会自动将ani3.guard修改为((Dog) ani3).guard();</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dg</span> <span class="operator">=</span> (Dog) ani3;<span class="comment">//向下转型</span></span><br><span class="line">        dg.guard();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Animal ani)</span>&#123;</span><br><span class="line">        ani.eat();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Cat ct)</span>&#123;ct.eat();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java中由于继承和向上转型的存在，子类型可以非常自然地转成父类，但向下转型，即父类转子类，必须强制转型。Java中的基本数据转型也是强制转型。</p><p>注意，如果子类重写了父类的方法，子类对象<strong>向上转型</strong>之后，调用的还是<strong>重载之后的子类方法</strong>。</p><p><strong>一个子类，只能继承一个父类，但可以实现多个接口</strong></p><p>接口这一块主要是架构师来负责的内容。我们定义两个接口<code>Valuable</code>和<code>Protectable</code>，由类<code>Panda</code>来继承父类<code>Animal</code>，并实现这两个接口，如上面所说的，执行的是子类<code>Panda</code>对象的<code>eat</code>方法，重写后将父类的覆盖了：</p><p><img src="/images/%E7%BB%A7%E6%89%BF%E4%B8%80%E4%B8%AA%E7%88%B6%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3.PNG" alt="继承一个父类实现多个接口"></p><p><strong>instanceof关键字与父子类</strong></p><p>根据相关定义：</p><blockquote><p>instanceof 是 Java 的一个二元操作符，类似于 &#x3D;&#x3D;，&gt;，&lt; 等操作符。作用是测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型。</p></blockquote><p>我们用下面一个例子来说明，<code>Panda</code>是继承自<code>Animal</code>的子类，可以看到，<strong>子类对象既是子类的实例，又是父类的实例</strong>，但反过来就不是了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Panda</span> <span class="variable">panda</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Panda</span>();</span><br><span class="line">System.out.println(panda <span class="keyword">instanceof</span> Panda);<span class="comment">//true</span></span><br><span class="line">System.out.println(panda <span class="keyword">instanceof</span> Animal);<span class="comment">//true</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> (Animal)panda;</span><br><span class="line">System.out.println(animal <span class="keyword">instanceof</span> Panda);<span class="comment">//true</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">yuan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line"><span class="comment">//Panda panda1 = (Panda)yuan; 这种做法是不被允许的！</span></span><br><span class="line">System.out.println(yuan <span class="keyword">instanceof</span> Panda);<span class="comment">//false</span></span><br><span class="line"><span class="type">Panda</span> <span class="variable">panda2</span> <span class="operator">=</span> (Panda)animal;</span><br><span class="line">System.out.println(panda2 <span class="keyword">instanceof</span> Panda);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>被注释掉的那行代码<code>Panda panda1 = (Panda)yuan</code>会报错，是因为这并不是向下转型——Java中，只有是<u>由子类对象向上转型转成的</u>父类对象，才能向下转型又再次成为子类对象！！</p><h3 id="静态构造器"><a href="#静态构造器" class="headerlink" title="静态构造器"></a>静态构造器</h3><p>又称静态构造函数，是实现对一个类进行初始化的方法成员，一般用于对静态数据的初始化（<strong>静态变量也是最先初始化的</strong>）。静态构造函数不能有参数，不能有修饰符，不能被调用。当类被加载时，类的静态构造函数自动被调用。因此，在一个程序的执行过程中，静态构造器<strong>最多执行一次</strong>。注意执行顺序：</p><ol><li><p>静态构造器在任何类的静态成员被引用之前执行；</p></li><li><p>静态构造器在任何类的实例变量被分配之前执行；</p></li><li><p>静态构造器在类的静态成员初始化之后执行，或者说编译器会将静态成员初始化语句转换成赋值语句放在静态构造器执行的最开始。</p></li></ol><p>我们用下面这个例子来实践一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">staticTest</span>&#123;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;这里是通用构造器&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;静态构造器&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">staticTest</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;构造方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="comment">//在主方法中调用构造方法，创建一个对象，就不用再写一个java程序来验证了</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">staticTest</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，可以看到，静态构造器是最先被执行的。</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>\<span class="title">cn</span>\<span class="title">demo</span>&gt;<span class="title">java</span> <span class="title">staticTest</span></span></span><br><span class="line"><span class="function">静态构造器</span></span><br><span class="line"><span class="function">这里是通用构造器</span></span><br><span class="line"><span class="function">构造方法</span></span><br></pre></td></tr></table></figure><p>在有继承的情况下，执行顺序为：<strong>父类静态代码块 &gt; 子类静态代码块 &gt; 父类构造代码块 &gt; 父类构造器 &gt; 子类构造代码块 &gt; 子类构造器</strong></p><p><strong>Java语言中，标准类（pojo类）</strong></p><p><code>POJO</code>的全称为<code>plain old java object</code>，可以翻译成：普通Java类。主要用于数据的临时传递，但它只能装载数据， 作为数据存储的载体，而不具有业务逻辑处理的能力，也就是说，<u><code>POJO</code>类中不允许有业务方法，也不能携带connection之类的方法</u>。</p><p>**<a name="标准类的四个必要条件">标准类的四个<u>必要</u>组成部分</a>**（四个必要条件）</p><ol><li>所有的成员<strong>变量</strong>都要使用 private 关键字进行修饰；</li><li>为每一个成员变量编写 set、get 方法；</li><li>创建一个无参数的构造方法；</li><li>创建一个有参数的构造方法。</li></ol><p><strong>pojo类和java bean的关系</strong></p><p><a href="https://blog.csdn.net/tiantangdizhibuxiang/article/details/81784873">博客</a></p><blockquote><p>按着Sun公司的定义，Java Bean是一个可重复使用的软件组件。实际上Java Bean是一种<a href="https://so.csdn.net/so/search?q=Java&spm=1001.2101.3001.7020">Java</a>类，通过封装属性和方法成为具有某种功能或者处理某个业务的对象，简称bean。</p><p><code>JavaBean</code> 是一种JAVA语言写成的可重用组件，不是一种技术，而是一种规范，它的方法命名，构造及行为必须符合特定的约定：</p><ol><li>这个类必须有一个公共的缺省构造函数；</li><li>这个类的属性使用getter和setter来访问，其他方法遵从标准命名规范;</li><li>这个类应是可<strong>序列化</strong>的（一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象——详见<a href="https://www.runoob.com/java/java-serialization.html">类的序列化</a>）。</li></ol><p><code>Java Bean</code>的任务可以概括为: “Write once, run anywhere, reuse everywhere”，即“一次性编写，任何地方执行，任何地方重用”。可分为两种：</p><ol><li>是有用户界面（UI，User Interface）的Java Bean；</li><li>没有用户界面，主要负责处理事务（如数据运算，操纵数据库）的Java Bean（部署于网络服务器上的<code>JSP</code>，又称<code>JavaServer Pages</code>，通常访问的是这一种Java Bean）。</li></ol><p>简而言之，当一个<code>PoJo</code>可序列化，有一个无参的构造函数，使用getter和setter方法来访问属性时，他就是一个Java Bean。</p></blockquote><p>然而，通常情况下，由于 Java Bean 是被容器所创建（如 Tomcat) 的，<strong>所以 Java Bean 应具有一个无参的构造器</strong>，另外，通常 <strong>Java Bean 还要实现 <code>Serializable</code> 接口用于实现 Bean 的持久性</strong>。 Java Bean 是不能被跨进程访问的。一般在web应用程序中建立一个数据库的映射对象时，我们只能称它为<code>POJO</code>——一个普通Java对象，而不是一个特殊的对象，其主要用来指代那些没有遵从特定的Java对象模型、约定或框架（如<code>EJB</code>）的Java对象。理想地讲，一个<code>POJO</code>是一个不受任何限制的Java对象（除了Java语言规范）</p><p>Java中还有很多特定类（<code>entity</code>、 <code>VO</code> 、<code>DTO</code>等）的概念和作用，我们详见好心人整理的<a href="https://www.pianshen.com/article/5933825452/">专栏</a>和<a href="https://www.cnblogs.com/feily/articles/14225139.html">博客</a>。</p><p><img src="/images/java%E5%90%84%E7%A7%8D%E7%B1%BB%E5%9C%A8%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8.png" alt="java各种类在实际项目中的运用"></p><p>我们再顺便了解另一个概念：<strong>entity(实体类)</strong></p><p>通常定义在model层里面，一个实体映射一张表，其中的<strong>属性</strong>对应数据表中的<strong>字段</strong>，，一般无业务逻辑代码。</p><p>entity类也要满足<a href="#标准类的四个必要条件">普通JavaBeans类的四个必要条件</a>，这篇<a href="https://blog.csdn.net/u012393192/article/details/80808237">博客</a>还介绍了entity的其他优点：</p><ol><li>对象实体的封装，体现<strong>OO(Object Oriented面向对象)思想</strong>——Java是面向对象的语言，由于面向对象有<strong>封装、继承、多态</strong>性的特性，可以设计出低耦合的系统，并使系统更加灵活和易于维护，缺点是性能比面向过程的低；</li><li>entity类中的属性可以对字段定义和状态进行判断和过滤；</li><li>一个数据库表映射成一个实体类，对数据库操作起来方便（在程序中可以把实体类作为参数传递），使程序员程序员在对数据库操作的时候不用写<code>SQL</code>语句,专注逻辑关系。换句话说，实体类就是把对某一个数据表（table）的操作全写在一个类里面：创建一个Entity Bean对象相当于创建一条记录，删除一个Entity Bean对象会同时从数据库中删除对应记录，修改一个Entity Bean时，容器会自动将Entity Bean的状态和数据库同步。</li></ol><p>另外，在Java开发中对于定义entity类的总结经验如下：</p><ul><li>实体类的名字尽量和数据库的表的名字对应相同；</li><li>实体类应该实现<code>java.io.Serializable</code>接口；</li><li>实体类应该有个无参的构造方法；</li><li>实体类应该至少有一个有参数的构造方法；</li><li>实体类有属性和方法，属性对应数据库中表的字段，主要有getter和setter方法。</li><li>实体类还应该有个属性<code>serialVersionUID</code>。例如：<code>private static final long serialVersionUID = -6125297654796395674L;</code></li><li>在实体类中，<strong>属性</strong>一般是<strong>private</strong>类型，而<strong>方法</strong>为<strong>public</strong>类型，对于数据库自动生成的ID字段对应的属性的<strong>set方法应为private</strong>。</li></ul><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>Java中的数据类型分为：基本数据类型（八种），引用类型——引用强度和生命周期长度依次为：强引用&gt;软引用＞弱引用＞虚引用。（JDK1.2之后的引用概念扩充）</p><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>默认声明的就是强引用，比如<code>Object obj = new Object()</code>，只要obj还指向Object对象（也就是强引用还存在），Object对象就不会被垃圾回收器回收。即使内存不足时，<code>JVM</code>也会直接抛出<code>OutOfMemoryError</code>而不会去回收。若想中断强引用与对象之间的联系，可以将强引用赋值为null。</p><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>描述一些非必需但仍有用的对象。<strong>在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常</strong>。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。在 JDK1.2 之后，用java.lang.ref.SoftReference类来表示软引用。</p><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了<strong>只具有弱引用</strong>的对象，不管当前内存空间足够与否，都会回收它的内存——也就是说，<strong>无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收</strong>。在 JDK1.2 之后，用 java.lang.ref.WeakReference 来表示弱引用。</p><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>又称为“幽灵引用”或“幻影引用”，最弱的一种引用关系，其存在与否，不会对对象的生存产生任何影响，且也无法通过虚引用来获得对象实例。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收。创建虚引用需要使用java.lang.ref.PhantomReference。这个类的源码中只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象。与软引用、弱引用不同的是，虚引用必须要和 ReferenceQueue 引用队列一起使用。</p><h3 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h3><p>引用队列可以与软引用、弱引用以及虚引用一起配合使用（强引用自然不行），当垃圾回收器准备回收一个对象时，如果发现它还有引用，那么就会在回收对象之前，把这个引用加入到与之关联的引用队列中去。程序可以通过判断引用队列中是否已经加入了引用，来判断被引用的对象是否将要被垃圾回收，这样就可以在对象被回收之前采取一些必要的措施。牢记：虚引用必须和引用队列一起使用。</p><h2 id="类与导包import"><a href="#类与导包import" class="headerlink" title="类与导包import"></a>类与导包import</h2><p>所有的类都需要导包才能使用，除了两种情况：</p><ol><li>要使用的目标类，和当前类位于同一个包（package）下；</li><li>要使用的目标类，位于<code>java.lang</code>包下，但是不包含子包内容（比如路径<code>C:\Program Files\Java\jdk-11.0.2\lib\src\java.base\java\lang\reflect</code>下的Field.java这一个类，就需要引用）</li></ol><p>我们使用的字符串对象，是String类，其实就属于第二种情况，在博主使用的JDK11版本中，我们可以在路径<code>C:\Program Files\Java\jdk-11.0.2\lib\src\java.base\java\lang</code>看到文件<code>String.java</code>。</p><p>字符串是对象，却可以原封不动打印出来，是因为<code>println</code>方法的判断逻辑：</p><ol><li>若是字符串类型，直接显示内容；</li><li>若不是字符串类型，就将其内部通过某些方法转换成字符串再显示（参考定义println方法的源码可知，比如int基本数据类型的会被String.valueOf方法转换为字符串类型）；</li><li>最终打印出来的一定是字符串类型。</li></ol><p>比方说，我们引入一个使用自定Employee类的程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo_println</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">Employee</span> <span class="variable">adc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;adcssss&quot;</span>);</span><br><span class="line">System.out.println(adc);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台中的打印结果：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Java_practice</span>&gt;<span class="title">java</span> <span class="title">Demo_println</span></span></span><br><span class="line"><span class="function"><span class="title">Employee</span>@512<span class="title">ddf17</span></span></span><br><span class="line"><span class="function">#一般的对象都是使用“类型信息+@+地址值”来作为字符串内容</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java基础语法学习要注意的小细节&quot;&gt;&lt;a href=&quot;#Java基础语法学习要注意的小细节&quot; class=&quot;headerlink&quot; title=&quot;Java基础语法学习要注意的小细节&quot;&gt;&lt;/a&gt;Java基础语法学习要注意的小细节&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;最最</summary>
      
    
    
    
    <category term="Java" scheme="http://justskim.github.io/categories/Java/"/>
    
    
    <category term="java" scheme="http://justskim.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>tomcat下startup.bat启动报错详解</title>
    <link href="http://justskim.github.io/2022/03/01/tomcat%E4%B8%8Bstartup.bat%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99%E8%AF%A6%E8%A7%A3/"/>
    <id>http://justskim.github.io/2022/03/01/tomcat%E4%B8%8Bstartup.bat%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-03-01T03:10:04.038Z</published>
    <updated>2022-03-01T08:37:17.479Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tomcat下startup-bat启动报错详解"><a href="#tomcat下startup-bat启动报错详解" class="headerlink" title="tomcat下startup.bat启动报错详解"></a>tomcat下startup.bat启动报错详解</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>博主在tomcat服务器的安装启动时，遇到问题：在官网下载的tomcat10压缩包版本，解压后可以在bin文件夹中双击tomcat10.exe并成功运行，但是双击startup.bat会闪退。而在网上找到的博客所遇到的问题都跟博主的相反，都是tomcat.exe不能运行。在控制台运行该程序，会得到信息如下：</p><p><img src="/images/startup.bat%E9%97%AA%E9%80%80.PNG" alt="startup.bat闪退.PNG"></p><p>博主也检测了主机安装<code>java</code>的配置以及环境变量，<strong>使用命令<code>netstat -ano|findstr 8080</code>也没有发现占用端口的程序</strong>，在控制台中使用命令<code>java -version</code>打印结果也正常，因此查询tomcat相关资料，探究该问题。</p><h2 id="startup与catalina"><a href="#startup与catalina" class="headerlink" title="startup与catalina"></a>startup与catalina</h2><p>我们在tomcat安装目录的bin目录下，可以看到有四个文件：startup.bat，startup.sh，catalina.bat，catalina.sh。</p><p>这其中，sh格式的文件是linux系统下的脚本文件，在Windows系统下无需理会。我们只看另外两个bat文件就行——bat是<strong>dos下的批处理文件</strong>。我们要启动tomcat除了双击startup.bat和tomcat.exe，还有一种方式就是在该目录下的命令行中输入<code>catalina.bat run</code>或者<code>catalina run</code>。startup.bat在执行时也会在最后调用catalina.bat，并且传递了start参数，设置了CATALINA_HOME和CURRENT_DIR俩个临时环境变量，当然我们也可以在系统中自行添加这两个变量。这两个文件的另一个区别在于：startup是在新界面运行，而<code>catalina run</code>命令会使相关程序在当前界面运行，会有更多的报错信息：</p><p><img src="/images/catalina.bat%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF.png" alt="catalina.bat报错信息"></p><h2 id="原因查询"><a href="#原因查询" class="headerlink" title="原因查询"></a>原因查询</h2><p>原因可能是JDK版本过高（博主所用的JDK17）所导致的，AVA11以后大大简化了JAVA环境配置方式，也没有jre文件夹，不过我们可以在jdk目录下使用命令<code>bin\jlink.exe --module-path jmods --add-modules java.desktop --output jre</code>来自动生成。<code>JAVA_HOME/lib</code>目录下没有tool.jar, dt.jar这两个文件，因此我们需要在配置环境变量的时候，要写成:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH  ;%JAVA_HOME%\bin\;%JAVA_HOME%\jre\bin\; CLASSPATH=.;%JAVA_HOME%\lib;%JAVA_HOME%\jre\lib;</span><br></pre></td></tr></table></figure><p>即使如此，博主还是依然无法通过startup.bat或者catalina.bat来启动tomcat，依旧只能选择tomcat.exe的启动方式┓( ´∀&#96; )┏</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;tomcat下startup-bat启动报错详解&quot;&gt;&lt;a href=&quot;#tomcat下startup-bat启动报错详解&quot; class=&quot;headerlink&quot; title=&quot;tomcat下startup.bat启动报错详解&quot;&gt;&lt;/a&gt;tomcat下startup</summary>
      
    
    
    
    <category term="服务器" scheme="http://justskim.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="tomcat" scheme="http://justskim.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/tomcat/"/>
    
    
    <category term="服务器" scheme="http://justskim.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="java" scheme="http://justskim.github.io/tags/java/"/>
    
    <category term="tomcat" scheme="http://justskim.github.io/tags/tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Linux服务器上的nginx与apache</title>
    <link href="http://justskim.github.io/2022/02/26/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84nginx%E4%B8%8Eapache/"/>
    <id>http://justskim.github.io/2022/02/26/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84nginx%E4%B8%8Eapache/</id>
    <published>2022-02-26T11:00:54.169Z</published>
    <updated>2022-02-26T17:45:10.530Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux服务器上的nginx与apache"><a href="#Linux服务器上的nginx与apache" class="headerlink" title="Linux服务器上的nginx与apache"></a>Linux服务器上的nginx与apache</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>博主在进行<a href="https://www.byhy.net/tut/webdev/django/07/">django框架的web项目练习</a>时，参考<a href="https://www.byhy.net/tut/webdev/django/16/#%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4-nginx">相关教程</a>进行<code>django</code>项目在Linux云服务器上的部署。<code>nginx</code>无法启动服务，需要修改路径<code>/etc/nginx/nginx.conf</code>（使用命令<code>yum -y install nginx</code>默认安装）下的<code>nginx.conf</code>文件。而在浏览器上的web端阿里云控制台上，使用<code>linux</code>系统自带的<code>vim</code>编辑器，不像在桌面系统上编辑那么容易。因此打算使用第三方工具（如<code>win-scp</code>，<code>Xshell</code>），在本地编辑文件后直接拖拽进去替代。但是在这些终端模拟器上无法与阿里云服务器建立ssh连接，但却可以ping通云服务器的公网<code>ip</code>地址，如下图所示。因此博主决定深入探究，并解决该问题。</p><p><img src="/images/ssh%E8%BF%9E%E6%8E%A5%E6%8A%A5%E9%94%99.PNG" alt="ssh连接报错"></p><h2 id="没有公网ip地址-x3D-端口被屏蔽？"><a href="#没有公网ip地址-x3D-端口被屏蔽？" class="headerlink" title="没有公网ip地址&#x3D;端口被屏蔽？"></a>没有公网<code>ip</code>地址&#x3D;端口被屏蔽？</h2><p>博主遇到的这一个离谱的问题，当阿里云的服务器设置了白名单以及安全组等配置后，无法在家庭网络的三台主机中使用ssh命令或者第三方工具通过22端口进行连接。而在阿里云网页端的官方控制台可以远程连接。异地协助的朋友也可以在他的主机上直接使用<code>ssh</code>命令或者<code>Xshell</code>等第三方工具。</p><h3 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h3><ol><li><p>首先是一如既往地检查阿里云服务器的安全组设置，请求客服协助，均没有问题；</p></li><li><p>在<code>win10</code>系统的主机上打开防火墙高级设置，设置22端口的出站规则；</p></li><li><p>使用命令<code>netstat -ano|findstr 22</code>查看端口，22端口和80、443等端口均没有发生占用情况；</p></li><li><p>使用手机开启移动4G热点，主机连接该热点后竟然能够成功ssh连接阿里云远程服务器！</p></li></ol><h3 id="真正的问题所在"><a href="#真正的问题所在" class="headerlink" title="真正的问题所在"></a>真正的问题所在</h3><p>经过问题排查的过程后，博主将目标锁定在运营商的端口规则上。</p><p><code>ISP</code>的全称是<code>Internet Service Provider</code>，翻译为互联网服务提供商，即向广大用户综合提供互联网接入业务、信息业务、和增值业务的电信<strong>运营商</strong>。</p><p>为了了解我们的运营商屏蔽了哪些端口，我们使用<a href="https://www.sojson.com/zz/portscan.html">站长工具中的端口扫描工具</a>，或者<a href="https://gist.github.com/vfreex/32b7de2e36422dbee94454afc762305e">相关脚本</a>来扫描看看哪些端口可以代为使用。对博主主机扫描的结果是所有端口都被屏蔽，无法使用。。。</p><p>根据网络相关文章，这可能跟博主所用的主机并没有公网ip地址有关，以及运营商的屏蔽规则，导致正常无法使用端口。</p><p>最后，给你们介绍一下，博主家里使用的是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">宽带类型：广电</span><br><span class="line">宽带业务：高清电视(IPTV)业务</span><br><span class="line">接入方式：光纤接入(FTTH)</span><br></pre></td></tr></table></figure><h2 id="80端口与Nginx与Apache"><a href="#80端口与Nginx与Apache" class="headerlink" title="80端口与Nginx与Apache"></a>80端口与Nginx与Apache</h2><p>Apache和Nginx都属于Web服务器（也称为WWW(WORLD WIDE WEB)服务器，主要功能是提供网上信息浏览服务），都实现了HTTP 1.1协议。我们在具体工程项目中选择哪个，都是根据应用场景来决定的，关于这两个服务器的更多异同我们将在之后进行学习探讨。</p><p>80端口是为HTTP超文本传输协议开放的端口卡相关的限制。<code>Apache</code>与<code>nginx</code>都会使用到该端口。比如博主在启动<code>nginx</code>时遇到的一个报错：“<strong>Address already in use</strong>…”，就说明该端口已经被其他程序所占用（大多数情况下是Apache，可能是很多软件不注意间被我们设置开机自动启动了）因此，要么将其中一个的端口进行修改，要么至启动一个（正常生产环境下的操作，无需两个都使用，功能有重复的地方）</p><p>我们使用<code>systemctl  stop httpd</code>来结束apache服务，使用<code>systemctl start nginx</code>来启动<code>nginx</code>服务，反之亦然。</p><p>解决了<code>nginx</code>启动报错的问题后，我们得以部署成功，在浏览器上输入相关<code>ip</code>地址路由，可以成功访问到页面！</p><p><img src="/images/%E6%88%90%E5%8A%9F%E7%99%BB%E5%BD%95%E4%B8%8A%E8%87%AA%E5%B7%B1%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%A1%B9%E7%9B%AE.PNG" alt="成功登录上自己服务器的项目"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux服务器上的nginx与apache&quot;&gt;&lt;a href=&quot;#Linux服务器上的nginx与apache&quot; class=&quot;headerlink&quot; title=&quot;Linux服务器上的nginx与apache&quot;&gt;&lt;/a&gt;Linux服务器上的nginx与apac</summary>
      
    
    
    
    <category term="网络" scheme="http://justskim.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="http://justskim.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="nginx" scheme="http://justskim.github.io/tags/nginx/"/>
    
    <category term="apache" scheme="http://justskim.github.io/tags/apache/"/>
    
  </entry>
  
  <entry>
    <title>localhost与127.0.0.1与0.0.0.0以及端口</title>
    <link href="http://justskim.github.io/2022/02/22/localhost%E4%B8%8E127.0.0.1%E4%B8%8E0.0.0.0%E4%BB%A5%E5%8F%8A%E7%AB%AF%E5%8F%A3/"/>
    <id>http://justskim.github.io/2022/02/22/localhost%E4%B8%8E127.0.0.1%E4%B8%8E0.0.0.0%E4%BB%A5%E5%8F%8A%E7%AB%AF%E5%8F%A3/</id>
    <published>2022-02-21T17:43:42.599Z</published>
    <updated>2022-02-22T02:48:52.071Z</updated>
    
    <content type="html"><![CDATA[<h1 id="localhost与127-0-0-1与0-0-0-0以及端口"><a href="#localhost与127-0-0-1与0-0-0-0以及端口" class="headerlink" title="localhost与127.0.0.1与0.0.0.0以及端口"></a>localhost与127.0.0.1与0.0.0.0以及端口</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>博主在进行<a href="https://www.byhy.net/tut/webdev/django/07/">django框架的web项目练习</a>时，遇到的一个问题。当博主按照所需的操作编写代码后，在网页链接栏输入<code>http://localhost/mgr/index.html</code>或者<code>http://localhost/mgr/index.html#/</code>时，都会显示404的错误提示界面，如下所示：</p><p><img src="E:\JS练习\blog\Myblog\source\images\localhost下的404界面.PNG" alt="localhost下的404界面"></p><p>而只有在输入链接为<code>127.0.0.1:4000/mgr/index.html#/</code>时，才会出现正常界面：</p><p><img src="E:\JS练习\blog\Myblog\source\images\127.0.0.1下的正常显示界面.PNG" alt="127.0.0.1下的正常显示界面.PNG"></p><p>与教程中唯一不同的步骤在于，博主的django应用，是使用命令<code>python manage.py runserver 4000</code>运行在4000端口上而不是80端口上。原因在于80端口被其他应用所占用。</p><h2 id="如何查看端口是否被占用"><a href="#如何查看端口是否被占用" class="headerlink" title="如何查看端口是否被占用"></a>如何查看端口是否被占用</h2><p>在win 10 系统上，打开控制台，输入命令<code>netstat -ano</code>可以查看所有端口的占用情况。若要查看某一个端口的占用情况，则使用诸如<code>netstat -ano|findstr &quot;80&quot;</code>的命令形式，注意要加双引号。查到占用该端口的进程的PID后，可以使用<code>tasklist|find &quot;123&quot;</code>命令查看进程，这里的123是进程PID。或者打开任务管理器，在“详细信息”一栏查看</p><h2 id="80端口"><a href="#80端口" class="headerlink" title="80端口"></a>80端口</h2><p>80端口是为HTTP超文本传输协议开放的端口，主要用于WWW万维网进行传输信息。其中的具体情况如下：</p><p>80端口作为http协议的默认端口，在输入网站的时候其实浏览器（非IE）已经帮忙输入协议了。所以这样一来，如果输入<a href="http://baidu.com,其实就等于访问http//baidu.com:80%E3%80%82%E5%9B%A0%E6%AD%A4%E6%88%91%E4%BB%AC%E8%AE%BF%E9%97%AElocalhost%EF%BC%8C%E9%BB%98%E8%AE%A4%E6%98%AF%E8%AE%BF%E9%97%AElocalhost:80">http://baidu.com，其实就等于访问http://baidu.com:80。因此我们访问localhost，默认是访问localhost:80</a></p><h2 id="localhost与127-0-0-1的区别"><a href="#localhost与127-0-0-1的区别" class="headerlink" title="localhost与127.0.0.1的区别"></a>localhost与127.0.0.1的区别</h2><p>localhost也叫local ，正确的解释是：本地服务器</p><p>127.0.0.1在windows等系统的正确解释是：本机地址（本机服务器）</p><p>他们的解析通过本机的host文件，windows自动将localhost解析为127.0.0.1</p><p>localhost也叫local ，正确的解释是：本地服务器</p><p>127.0.0.1在windows等系统的正确解释是：本机地址（本机服务器）</p><p>他们的解析通过本机的host文件，windows自动将localhost解析为127.0.0.1</p><p>localhot（local）是不经网卡传输！这点很重要，它不受网络防火墙和网卡相关的的限制。</p><p>127.0.0.1是通过网卡传输，依赖网卡，并受到网络防火墙和网卡相关的限制。</p><p>一般设置程序时本地服务用localhost是最好的，localhost不会解析成ip，也不会占用网卡、网络资源。</p><p>有时候用localhost可以，但用127.0.0.1就不可以的情况就是在于此。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="解决方法1："><a href="#解决方法1：" class="headerlink" title="解决方法1："></a>解决方法1：</h3><p>修改host文件用记事本打开C:&#x2F;WINDOWS&#x2F;system32&#x2F;drivers&#x2F;etc&#x2F;hosts文件，看是否有127.0.0.1 localhost 。如果没有则将其添加进去，再查看能否访问localhost。博主使用此方法，即可访问<a href="http://localhost:4000/mgr/index.html#/">http://localhost:4000/mgr/index.html#/</a></p><h3 id="解决方法2："><a href="#解决方法2：" class="headerlink" title="解决方法2："></a>解决方法2：</h3><p>1、打开Internert信息管理查看IIS是否启动，且默认网站时候已经开启；<br>2、打开<a href="http://127.0.0.1/">http://127.0.0.1/</a> 看是否能访问IIS的默认网页，能访问则说明IIS已经成功安装到电脑上，可能是无法解析localhost；<br>3、开始–命令（cmd）–ping localhost，看是否能ping通，从127.0.0.1上返回信息，如果成功则说明可以解析localhost；<br>4、如果上一步不成功，则用记事本打开C:&#x2F;WINDOWS&#x2F;system32&#x2F;drivers&#x2F;etc&#x2F;hosts文件，看里面是否有包含：127.0.0.1 localhost ，如果没有则将其添加进去，再查看能否访问localhost。<br>5、尝试将网站的主目录指向另一个目录或新建一个虚拟目录，并在该新目录创建一个新的网页文件，如index.html，然后将其加到默认网站的”文档”项中作为默认访问的网页，重新输入网址：<a href="http://localhost/%EF%BC%8C%E7%9C%8B%E5%90%A6%E8%83%BD%E8%AE%BF%E9%97%AE%E3%80%82">http://localhost/，看否能访问。</a><br>6、还是不行的话将IIS卸载掉，重新再安装一次。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;localhost与127-0-0-1与0-0-0-0以及端口&quot;&gt;&lt;a href=&quot;#localhost与127-0-0-1与0-0-0-0以及端口&quot; class=&quot;headerlink&quot; title=&quot;localhost与127.0.0.1与0.0.0.0以及端</summary>
      
    
    
    
    <category term="网络" scheme="http://justskim.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="http://justskim.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Mysql安装的版本选择</title>
    <link href="http://justskim.github.io/2022/02/12/Mysql%E5%AE%89%E8%A3%85%E7%9A%84%E7%89%88%E6%9C%AC%E9%80%89%E6%8B%A9/"/>
    <id>http://justskim.github.io/2022/02/12/Mysql%E5%AE%89%E8%A3%85%E7%9A%84%E7%89%88%E6%9C%AC%E9%80%89%E6%8B%A9/</id>
    <published>2022-02-12T10:30:47.490Z</published>
    <updated>2022-02-17T15:09:38.844Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql安装的版本选择"><a href="#Mysql安装的版本选择" class="headerlink" title="Mysql安装的版本选择"></a>Mysql安装的版本选择</h1><h2 id="官网中的版本类别"><a href="#官网中的版本类别" class="headerlink" title="官网中的版本类别"></a>官网中的版本类别</h2><p>在<a href="https://www.mysql.com/downloads/">mysql官方下载页面</a>，可以看到有以下几个版本：</p><ol><li><p>MySQL Community Server 社区版本，由于开源免费因此是最常用的，但不提供官方技术支持。</p></li><li><p>MySQL Enterprise Edition 企业版本，需付费，可以试用30天。</p></li><li><p>MySQL Cluster 集群版，开源免费。可将几个MySQL Server封装成一个Server</p></li><li><p>MySQL Cluster CGE 高级集群版，需付费。</p></li><li><p>MySQL Workbench（GUI TOOL）一款专为MySQL设计的ER&#x2F;数据库建模工具。它是著名的数据库设计工具DBDesigner4的继任者。MySQL Workbench又分为两个版本，分别是社区版（MySQL Workbench OSS）、商用版（MySQL Workbench SE）。</p></li></ol><h2 id="Linux中安装MySQL"><a href="#Linux中安装MySQL" class="headerlink" title="Linux中安装MySQL"></a>Linux中安装MySQL</h2><p>这里为了方便，我们使用MySQL Community Server版本来进行安装示例。</p><h3 id="选择与Linux系统相配的安装版本"><a href="#选择与Linux系统相配的安装版本" class="headerlink" title="选择与Linux系统相配的安装版本"></a>选择与Linux系统相配的安装版本</h3><p>注意，<code>linux</code>内核版本和<code>linux</code>系统版本是不同的概念！内核是系统的心脏，也是运行程序和管理设备的核心程序，而我们平时所说的<code>Redhat</code>，<code>Ubuntu</code>及<code>Centos</code>是不同的<code>linux</code>发行版</p><p><strong>查看Linux内核版本命令</strong></p><ol><li><code>cat /proc/version</code>    这个文件只有一行内容, 说明正在运行的内核版本</li><li><code>uname -a</code>    Linux <code>uname</code>（英文全拼：unix name）命令用于显示系统信息。<code>uname</code> 可显示电脑以及操作系统的相关信息，语法：<code>uname [-amnrsv][--help][--version]</code>；其中-a或–all 　显示全部的信息。</li></ol><p><strong>查看Linux系统版本命令</strong></p><ol><li>使用命令<code>lsb_release -a</code>列出所有版本信息，如果提示未找到相关命令，则需要我们使用命令<code>yum install -y redhat-lsb</code>进行安装；</li><li><code>cat /etc/redhat-release</code>，这种方法只适合<code>RedHat</code>系的Linux；</li><li><code>cat /etc/issue</code>，<code>/etc/issue</code>、<code>/etc/issue</code>与 <code>/etc/motd</code> 作用一致，都是<strong>用于显示欢迎信息</strong>，可能包含Linux系统版本的信息。</li></ol><p>查找到的结果为：<code>CentOS Linux release 7.8.2003</code></p><p>我们在这里选择Linux genertic下x86_64的版本，复制相关链接，在远程服务器的Linux系统中使用wget进行下载安装。</p><p><img src="/images/linux%E4%B8%8Bmysql%E5%AE%89%E8%A3%85%E7%89%88%E6%9C%AC%E9%80%89%E6%8B%A9.png" alt="linux下mysql安装版本选择"></p><p>下载得到的是一个tar压缩包，我们可以在<a href="https://dev.mysql.com/doc/refman/8.0/en/binary-installation.html">MySQL官方提供的说明文档</a>（这里以8.0版本为例）中</p><p>对该安装包使用命令<code>tar -xvf</code>解压：</p><p><img src="/images/mysql%E7%9A%84xz%E5%AE%89%E8%A3%85%E5%8C%85%E8%A7%A3%E5%8E%8B.png" alt="mysql的xz安装包解压"></p><p>我们使用的系统是<code>Centos</code>，因此有yum工具而没有apt，如果是<code>ubuntu</code>要使用apt进行安装，操作如<a href="https://blog.jkdev.cn/index.php/archieves/125">相关教程博客</a>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt install numactl</span><br><span class="line"><span class="comment">#仅安装libaio库还不行，还要安装numactl库</span></span><br><span class="line"></span><br><span class="line">apt install libaio-dev</span><br></pre></td></tr></table></figure><p>在安装完相关库之后，我们使用以下的命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$<span class="operator">&gt;</span> groupadd mysql</span><br><span class="line">$<span class="operator">&gt;</span> useradd <span class="operator">-</span>r <span class="operator">-</span>g mysql <span class="operator">-</span>s <span class="operator">/</span>bin<span class="operator">/</span><span class="literal">false</span> mysql</span><br><span class="line">$<span class="operator">&gt;</span> cd mysql</span><br><span class="line">$<span class="operator">&gt;</span> mkdir mysql<span class="operator">-</span>files</span><br><span class="line">$<span class="operator">&gt;</span> chown mysql:mysql mysql<span class="operator">-</span>files</span><br><span class="line">$<span class="operator">&gt;</span> chmod <span class="number">750</span> mysql<span class="operator">-</span>files</span><br><span class="line">$<span class="operator">&gt;</span> bin<span class="operator">/</span>mysqld <span class="comment">--initialize --user=mysql</span></span><br><span class="line">$<span class="operator">&gt;</span> bin<span class="operator">/</span>mysql_ssl_rsa_setup</span><br><span class="line">$<span class="operator">&gt;</span> bin<span class="operator">/</span>mysqld_safe <span class="comment">--user=mysql &amp;</span></span><br><span class="line"># Next command <span class="keyword">is</span> optional</span><br><span class="line">$<span class="operator">&gt;</span> cp support<span class="operator">-</span>files<span class="operator">/</span>mysql.server <span class="operator">/</span>etc<span class="operator">/</span>init.d<span class="operator">/</span>mysql.server</span><br></pre></td></tr></table></figure><p>其中，如果赋相关目录<code>MySQL</code>用户权限的<code>chown</code>命令发生以下报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span>: invalid user: mysql:mysql</span><br></pre></td></tr></table></figure><p>我们需要再次通过添加执行用户名和组的方式解决：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd mysql</span><br><span class="line">useradd -g mysql mysql</span><br></pre></td></tr></table></figure><p>注意，初始化数据库时，如果提示<code>mysqld not found</code>错误，是由于 &#x2F;etc&#x2F;init.d&#x2F; 不存在 mysqld 这个命令</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Mysql安装的版本选择&quot;&gt;&lt;a href=&quot;#Mysql安装的版本选择&quot; class=&quot;headerlink&quot; title=&quot;Mysql安装的版本选择&quot;&gt;&lt;/a&gt;Mysql安装的版本选择&lt;/h1&gt;&lt;h2 id=&quot;官网中的版本类别&quot;&gt;&lt;a href=&quot;#官网中的版</summary>
      
    
    
    
    <category term="Mysql" scheme="http://justskim.github.io/categories/Mysql/"/>
    
    <category term="安装" scheme="http://justskim.github.io/categories/Mysql/%E5%AE%89%E8%A3%85/"/>
    
    
    <category term="mysql" scheme="http://justskim.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>win10上的代理服务器设置与127.0.0.1</title>
    <link href="http://justskim.github.io/2022/02/08/win10%E4%B8%8A%E7%9A%84%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE%E4%B8%8E127.0.0.1/"/>
    <id>http://justskim.github.io/2022/02/08/win10%E4%B8%8A%E7%9A%84%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE%E4%B8%8E127.0.0.1/</id>
    <published>2022-02-08T06:02:05.413Z</published>
    <updated>2022-02-08T07:13:50.206Z</updated>
    
    <content type="html"><![CDATA[<h1 id="win10上的代理服务器设置与127-0-0-1"><a href="#win10上的代理服务器设置与127-0-0-1" class="headerlink" title="win10上的代理服务器设置与127.0.0.1"></a>win10上的代理服务器设置与127.0.0.1</h1><h2 id="代理服务器的定义"><a href="#代理服务器的定义" class="headerlink" title="代理服务器的定义"></a>代理服务器的定义</h2><p>代理服务器（Proxy Server）是介于浏览器和Web服务器之间的一台服务器，可被用于代理网络用户去取得网络信息。可以说，代理服务器是网络信息的中转站，是个人网络和Internet服务商之间的中间代理机构，负责转发合法的网络信息，对转发进行控制和登记，工作在OSI模型的对话层。当你通过代理服务器上网浏览时，浏览器不是直接到Web服务器去取回网页，而是向代理服务器发出请求，由代理服务器来取回浏览器所需要的信息，并传送给你的浏览器。 </p><p>Win10系统提供<strong>系统级代理服务器设置，通过在Win10系统中设置代理服务器</strong>，系统中所有的软件都会通过我们设置的代理服务器访问网络，这样就不用一个一个软件设置代理服务器了，包括浏览器等应用，都会使用设定的系统代理服务器上网。</p><h2 id="环回地址127-0-0-1"><a href="#环回地址127-0-0-1" class="headerlink" title="环回地址127.0.0.1"></a>环回地址127.0.0.1</h2><p>127.0.0.1是回送地址主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，协议软件立即返回之，不进行任何网络传输。有时候当我们使用浏览器点击网页时，有时候会发现提示网页无法找到，建议我们检查代理服务器设置。而在win10系统的设置一栏，有一项“代理服务器”的设置，有时我们点开这里，会发现代理服务器被设置为127.0.0.1，原因不明，但将代理服务器关闭即可正常访问网络，检查host文件也没有发现异常。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;win10上的代理服务器设置与127-0-0-1&quot;&gt;&lt;a href=&quot;#win10上的代理服务器设置与127-0-0-1&quot; class=&quot;headerlink&quot; title=&quot;win10上的代理服务器设置与127.0.0.1&quot;&gt;&lt;/a&gt;win10上的代理服务器设置</summary>
      
    
    
    
    <category term="网络" scheme="http://justskim.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="服务器" scheme="http://justskim.github.io/categories/%E7%BD%91%E7%BB%9C/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
    <category term="网络" scheme="http://justskim.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="服务器" scheme="http://justskim.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>在vmware虚拟机中进行网络连接</title>
    <link href="http://justskim.github.io/2021/11/16/%E5%9C%A8vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5/"/>
    <id>http://justskim.github.io/2021/11/16/%E5%9C%A8vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5/</id>
    <published>2021-11-16T07:16:40.924Z</published>
    <updated>2022-02-12T10:13:06.192Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在vmware虚拟机中进行网络连接"><a href="#在vmware虚拟机中进行网络连接" class="headerlink" title="在vmware虚拟机中进行网络连接"></a>在<code>vmware</code>虚拟机中进行网络连接</h1><h2 id="四种网络模式"><a href="#四种网络模式" class="headerlink" title="四种网络模式"></a>四种网络模式</h2><p>点击<code>VMware Workstation</code>的导航栏，在“虚拟机-&gt;设置-&gt;硬件-&gt;网络设配器”中，可看到网络连接模式的选择（不能在虚拟机挂起的时候进行更改），<a href="https://docs.vmware.com/cn/VMware-Workstation-Pro/14.0/com.vmware.ws.using.doc/GUID-3B504F2F-7A0B-415F-AE01-62363A95D052.html">VMware的官方网站</a>中说明了四种网络模式的区别：</p><table><thead><tr><th align="left">设置</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><strong>使用桥接模式网络连接</strong></td><td align="left">为虚拟机配置桥接模式网络连接。使用桥接模式网络连接时，虚拟机将具有直接访问外部以太网网络的权限。虚拟机必须在外部网络中具有自己的 IP 地址。如果您的主机系统位于网络中，而且您拥有可用于虚拟机的单独 IP 地址（或者可以从 DHCP 服务器获得 IP 地址），请选择此设置。网络中的其他计算机将能够与该虚拟机直接通信。</td></tr><tr><td align="left"><strong>使用网络地址转换 (NAT)</strong></td><td align="left">为虚拟机配置 NAT 连接。利用 NAT，虚拟机和主机系统将共享一个网络标识，此标识在网络以外不可见。如果您没有可用于虚拟机的单独 IP 地址，但又希望能够连接到 Internet，请选择 NAT。</td></tr><tr><td align="left"><strong>使用仅主机模式网络连接</strong></td><td align="left">为虚拟机配置仅主机模式网络连接。仅主机模式网络连接使用对主机操作系统可见的虚拟网络适配器，在虚拟机和主机系统之间提供网络连接。使用仅主机模式网络连接时，虚拟机只能与主机系统以及仅主机模式网络中的其他虚拟机进行通信。要设置独立的虚拟网络，请选择仅主机模式网络连接。</td></tr><tr><td align="left"><strong>不使用网络连接</strong></td><td align="left">不为虚拟机配置网络连接。</td></tr><tr><td align="left"><strong>自定义</strong>（Windows 主机）或<strong>已命名的网络</strong>（Linux 主机）</td><td align="left">（仅限远程虚拟机）选择特定虚拟网络。从下拉菜单中选择一个自定义网络。尽管列表中有 <code>VMnet0</code>、<code>VMnet1 </code>和 <code>VMnet8</code>，但这些网络通常被用于桥接模式、仅主机模式和 NAT 模式网络。</td></tr></tbody></table><p>对于使用校园网或者公司网络的用户，NAT是最简单的方式。</p><h2 id="网络配置相关文件"><a href="#网络配置相关文件" class="headerlink" title="网络配置相关文件"></a>网络配置相关文件</h2><p><strong>eth0</strong></p><p>该文件一般位于路径“&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts”中</p><h2 id="网络配置相关命令"><a href="#网络配置相关命令" class="headerlink" title="网络配置相关命令"></a>网络配置相关命令</h2><p><strong><code>ifconfig</code></strong></p><p><strong>用于配置网卡的基本命令</strong>，注意不是<code>ipconfig</code>！<code>ifconfig</code>命令的英文全称是“network interfaces configuring”，即用于配置和显示Linux内核中网络接口的网络参数。用<code>ifconfig</code>命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。要想将上述的配置信息永远的存的电脑里，那就要修改网卡的配置文件了。</p><p><strong>常用参数：</strong></p><table><thead><tr><th>add &lt;地址&gt;</th><th>设置网络设备IPv6的IP地址</th></tr></thead><tbody><tr><td><code>del</code> &lt;地址&gt;</td><td>删除网络设备IPv6的IP地址</td></tr><tr><td>down</td><td>关闭指定的网络设备</td></tr><tr><td>up</td><td>启动指定的网络设备</td></tr><tr><td>IP地址</td><td>指定网络设备的IP地址</td></tr></tbody></table><p>一个与之相似的命令是windows系统下的<code>ipconfig</code>命令</p><p><strong>ethtool</strong></p><p>用于查询ethX网口基本设置、及设置网卡的参数</p><h2 id="以上步骤尝试过后，依然无法解决联网问题"><a href="#以上步骤尝试过后，依然无法解决联网问题" class="headerlink" title="以上步骤尝试过后，依然无法解决联网问题"></a>以上步骤尝试过后，依然无法解决联网问题</h2><p>如果在以上步骤尝试过后，依然无法解决联网问题，特别是最简单的NAT模式下，可以查看相关端口是否被杀毒软件禁止，以及服务是否成功启动。笔者在实际操作中遇到过这种情况，最后，根据<a href="https://www.cnblogs.com/hi3254014978/p/12668471.html">这篇博客</a>，将win10中的服务打开，手动启动或者重新启动<code>VMware DHCP Service</code>和<code>VMware NAT Service</code>两个服务即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;在vmware虚拟机中进行网络连接&quot;&gt;&lt;a href=&quot;#在vmware虚拟机中进行网络连接&quot; class=&quot;headerlink&quot; title=&quot;在vmware虚拟机中进行网络连接&quot;&gt;&lt;/a&gt;在&lt;code&gt;vmware&lt;/code&gt;虚拟机中进行网络连接&lt;/h1&gt;</summary>
      
    
    
    
    <category term="Linux" scheme="http://justskim.github.io/categories/Linux/"/>
    
    
    <category term="linux" scheme="http://justskim.github.io/tags/linux/"/>
    
    <category term="虚拟机" scheme="http://justskim.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    <category term="ubuntu" scheme="http://justskim.github.io/tags/ubuntu/"/>
    
    <category term="vmware" scheme="http://justskim.github.io/tags/vmware/"/>
    
  </entry>
  
  <entry>
    <title>python3中的运行命令与环境</title>
    <link href="http://justskim.github.io/2021/11/09/python3%E4%B8%AD%E7%9A%84%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4%E4%B8%8E%E7%8E%AF%E5%A2%83/"/>
    <id>http://justskim.github.io/2021/11/09/python3%E4%B8%AD%E7%9A%84%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4%E4%B8%8E%E7%8E%AF%E5%A2%83/</id>
    <published>2021-11-08T18:35:42.058Z</published>
    <updated>2021-11-08T18:36:09.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python3中的运行命令与环境"><a href="#python3中的运行命令与环境" class="headerlink" title="python3中的运行命令与环境"></a>python3中的运行命令与环境</h1><p>本机电脑仅安装python3，以下使用的均为python3环境配置</p><h2 id="镜像是什么？"><a href="#镜像是什么？" class="headerlink" title="镜像是什么？"></a>镜像是什么？</h2><p>镜像（Mirroring）是一种文件存储形式，是冗余的一种类型，一个磁盘上的数据在另一个磁盘上存在一个完全相同的副本即为镜像。</p><p>镜像源 就是把官<strong>方的源做一个镜像，你</strong>可以在这下载软件。 比如ubuntu官方源在国外，下载软件可能会很慢，这时候就需要换成国内的镜像源。 源 端口就是指本地端口 目的端口就是远程端口 一个数据包（pocket）被解封装成数据段（segment）后就会涉及到 连接上层协议的端口问题。</p><p>镜像网站（Mirror sites）又称之为镜像站点</p><h2 id="anaconda环境"><a href="#anaconda环境" class="headerlink" title="anaconda环境"></a>anaconda环境</h2><h2 id="命令行运行python程序，与idle中”Run-module“的区别"><a href="#命令行运行python程序，与idle中”Run-module“的区别" class="headerlink" title="命令行运行python程序，与idle中”Run module“的区别"></a>命令行运行python程序，与idle中”Run module“的区别</h2><p>笔者在学习<a href="https://gitee.com/daochenzha/rlcard?_from=gitee_search#/daochenzha/rlcard/blob/master/docs/toy-examples.md#playing-with-random-agents">RLCard——一款卡牌游戏强化学习工具包</a>的时候，发现了<a href="https://gitee.com/daochenzha/rlcard/blob/master/docs/toy-examples.md#playing-with-random-agents">范例</a>中的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> rlcard</span><br><span class="line"><span class="keyword">from</span> rlcard.agents <span class="keyword">import</span> RandomAgent</span><br><span class="line"><span class="keyword">from</span> rlcard.utils <span class="keyword">import</span> set_seed</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">args</span>):</span><br><span class="line">    <span class="comment"># Make environment</span></span><br><span class="line">    env = rlcard.make(args.env, config=&#123;<span class="string">&#x27;seed&#x27;</span>: <span class="number">42</span>&#125;)</span><br><span class="line">    num_episodes = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Seed numpy, torch, random</span></span><br><span class="line">    set_seed(<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set agents</span></span><br><span class="line">    agent = RandomAgent(num_actions=env.num_actions)</span><br><span class="line">    env.set_agents([agent <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(env.num_players)])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> episode <span class="keyword">in</span> <span class="built_in">range</span>(num_episodes):</span><br><span class="line">        <span class="comment"># Generate data from the environment</span></span><br><span class="line">        trajectories, player_wins = env.run(is_training=<span class="literal">False</span>)</span><br><span class="line">        <span class="comment"># Print out the trajectories</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\nEpisode &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(episode))</span><br><span class="line">        <span class="built_in">print</span>(trajectories)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    parser = argparse.ArgumentParser(<span class="string">&quot;Random example in RLCard&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--env&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;leduc-holdem&#x27;</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    run(args)</span><br></pre></td></tr></table></figure><p>这段代码在idle中无法被“Run module”运行，却可以在命令行中运行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在idle中无法被“Run module”运行</span></span><br><span class="line">============== RESTART: E:/python练习/RLCard/examples/run_random.py ==============</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;E:/python练习/RLCard/examples/run_random.py&quot;</span>, line <span class="number">4</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">from</span> rlcard.agents <span class="keyword">import</span> RandomAgent</span><br><span class="line">  File <span class="string">&quot;E:\python\lib\site-packages\rlcard\agents\__init__.py&quot;</span>, line <span class="number">5</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    reqs = subprocess.check_output([sys.executable, <span class="string">&#x27;-m&#x27;</span>, <span class="string">&#x27;pip&#x27;</span>, <span class="string">&#x27;freeze&#x27;</span>])</span><br><span class="line">  File <span class="string">&quot;E:\python\lib\subprocess.py&quot;</span>, line <span class="number">424</span>, <span class="keyword">in</span> check_output</span><br><span class="line">    <span class="keyword">return</span> run(*popenargs, stdout=PIPE, timeout=timeout, check=<span class="literal">True</span>,</span><br><span class="line">  File <span class="string">&quot;E:\python\lib\subprocess.py&quot;</span>, line <span class="number">528</span>, <span class="keyword">in</span> run</span><br><span class="line">    <span class="keyword">raise</span> CalledProcessError(retcode, process.args,</span><br><span class="line">subprocess.CalledProcessError: Command <span class="string">&#x27;[&#x27;</span>E:\\python\\pythonw.exe<span class="string">&#x27;, &#x27;</span>-m<span class="string">&#x27;, &#x27;</span>pip<span class="string">&#x27;, &#x27;</span>freeze<span class="string">&#x27;]&#x27;</span> returned non-zero exit status <span class="number">120.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#可以在命令行中运行</span></span><br><span class="line">$ python examples/run_random.py</span><br><span class="line">WARNING: Ignoring invalid distribution -ip (e:\python\lib\site-packages)</span><br><span class="line">WARNING: Ignoring invalid distribution -ip (e:\python\lib\site-packages)</span><br><span class="line"></span><br><span class="line">Episode <span class="number">0</span></span><br><span class="line">[[&#123;<span class="string">&#x27;legal_actions&#x27;</span>: OrderedDict([(<span class="number">1</span>, <span class="literal">None</span>), (<span class="number">2</span>, <span class="literal">None</span>), (<span class="number">3</span>, <span class="literal">None</span>)]), <span class="string">&#x27;obs&#x27;</span>: array([<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>,</span><br><span class="line">       <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>,</span><br><span class="line">       <span class="number">0.</span>, <span class="number">0.</span>]), <span class="string">&#x27;raw_obs&#x27;</span>: &#123;<span class="string">&#x27;hand&#x27;</span>: <span class="string">&#x27;HQ&#x27;</span>, <span class="string">&#x27;public_card&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;all_chips&#x27;</span>: [<span class="number">2</span>, <span class="number">1</span>], <span class="string">&#x27;my_chips&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;legal_actions&#x27;</span>: [<span class="string">&#x27;raise&#x27;</span>, <span class="string">&#x27;fold&#x27;</span>, <span class="string">&#x27;check&#x27;</span>], <span class="string">&#x27;current_player&#x27;</span>: <span class="number">0</span>&#125;, <span class="string">&#x27;raw_legal_actions&#x27;</span>: [<span class="string">&#x27;raise&#x27;</span>, <span class="string">&#x27;fold&#x27;</span>, <span class="string">&#x27;check&#x27;</span>], <span class="string">&#x27;action_record&#x27;</span>: [(<span class="number">1</span>, <span class="string">&#x27;fold&#x27;</span>)]&#125;], [&#123;<span class="string">&#x27;legal_actions&#x27;</span>: OrderedDict([(<span class="number">0</span>, <span class="literal">None</span>), (<span class="number">1</span>, <span class="literal">None</span>), (<span class="number">2</span>, <span class="literal">None</span>)]), <span class="string">&#x27;obs&#x27;</span>: array([<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>,</span><br><span class="line">       <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>,</span><br><span class="line">       <span class="number">0.</span>, <span class="number">0.</span>]), <span class="string">&#x27;raw_obs&#x27;</span>: &#123;<span class="string">&#x27;hand&#x27;</span>: <span class="string">&#x27;HJ&#x27;</span>, <span class="string">&#x27;public_card&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;all_chips&#x27;</span>: [<span class="number">2</span>, <span class="number">1</span>], <span class="string">&#x27;my_chips&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;legal_actions&#x27;</span>: [<span class="string">&#x27;call&#x27;</span>, <span class="string">&#x27;raise&#x27;</span>, <span class="string">&#x27;fold&#x27;</span>], <span class="string">&#x27;current_player&#x27;</span>: <span class="number">1</span>&#125;, <span class="string">&#x27;raw_legal_actions&#x27;</span>: [<span class="string">&#x27;call&#x27;</span>, <span class="string">&#x27;raise&#x27;</span>, <span class="string">&#x27;fold&#x27;</span>], <span class="string">&#x27;action_record&#x27;</span>: [(<span class="number">1</span>, <span class="string">&#x27;fold&#x27;</span>)]&#125;, <span class="number">2</span>, &#123;<span class="string">&#x27;legal_actions&#x27;</span>: OrderedDict([(<span class="number">1</span>, <span class="literal">None</span>), (<span class="number">2</span>, <span class="literal">None</span>), (<span class="number">3</span>, <span class="literal">None</span>)]), <span class="string">&#x27;obs&#x27;</span>: array([<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>,</span><br><span class="line">       <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>,</span><br><span class="line">       <span class="number">0.</span>, <span class="number">0.</span>]), <span class="string">&#x27;raw_obs&#x27;</span>: &#123;<span class="string">&#x27;hand&#x27;</span>: <span class="string">&#x27;HJ&#x27;</span>, <span class="string">&#x27;public_card&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;all_chips&#x27;</span>: [<span class="number">2</span>, <span class="number">1</span>], <span class="string">&#x27;my_chips&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;legal_actions&#x27;</span>: [<span class="string">&#x27;raise&#x27;</span>, <span class="string">&#x27;fold&#x27;</span>, <span class="string">&#x27;check&#x27;</span>], <span class="string">&#x27;current_player&#x27;</span>: <span class="number">0</span>&#125;, <span class="string">&#x27;raw_legal_actions&#x27;</span>: [<span class="string">&#x27;raise&#x27;</span>, <span class="string">&#x27;fold&#x27;</span>, <span class="string">&#x27;check&#x27;</span>], <span class="string">&#x27;action_record&#x27;</span>: [(<span class="number">1</span>, <span class="string">&#x27;fold&#x27;</span>)]&#125;]]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们试着来比较这两个命令的差别：</p><p><a href="https://zhuanlan.zhihu.com/p/150835014">这篇博客中介绍了sys模块的使用详情</a>，我们只讲两个下面会使用到的函数，</p><p><em>sys模块</em>提供了一系列有关<em>Python</em>运行环境的变量和函数，</p><p>sys.path<br>返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值</p><h3 id="sys-executable"><a href="#sys-executable" class="headerlink" title="sys.executable"></a><strong>sys.executable</strong></h3><p>该属性是一个字符串，在正常情况下，其值是当前运行的 Python 解释器对应的可执行程序所在的绝对路径。</p><p>比如在 Windows 上使用 Anaconda 安装的 Python，该属性的值就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.executable</span><br><span class="line"><span class="string">&#x27;E:\\Anaconda\\Anaconda\\python.exe&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="E:\JS练习\blog\Myblog\source\images\两个命令差别.png"></p><p>打印结果，我们可以发现二者的绝对路径不一样，在Idle中，python解释器对应的可执行程序为pythonw.exe，而在命令行中则是python.exe</p><p><strong>python.exe与pythonw.exe</strong></p><p>Windows系统搭建好Python的环境后，进入Python的安装目录，大家会发现目录中有python.exe和pythonw.exe两个程序。</p><p><a href="https://zhuanlan.zhihu.com/p/302384158">这两个程序的区别在于</a>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a）、python.exe在运行程序的时候，会弹出一个黑色的控制台窗口（也叫命令行窗口、DOS/CMD窗口）；</span><br><span class="line">   b）、pythonw.exe是无窗口的Python可执行程序，意思是在运行程序的时候，没有窗口，代码在后台执行</span><br><span class="line">   .py和.pyw文件的区别也来源于python.exe和pythonw.exe的区别：</span><br><span class="line">   安装视窗版 Python 时，扩展名为 .py 的文件被默认为用 python.exe 运行的文件，而 .pyw文件则被默认为用 pythonw.exe 运行。</span><br><span class="line">这里还要解释一个问题，如果.py文件直接用python.exe打开，文件被执行完成之后，视窗会立即关闭，如果想让视窗停留；给大家提供两个方法：</span><br><span class="line">① 可以在程序中import time模块，加入超长睡眠语句，如time.sleep(1800)，如果你不手动关闭视窗，视窗将会停留30min；</span><br><span class="line">② 可以调用sys和os模块，使用命令行语句pause</span><br><span class="line"></span><br><span class="line">  3、.pyw格式是被设计用来运行开发的纯图形界面程序的，纯图形界面程序的用户不需要看到控制台窗口。</span><br><span class="line">    在开发纯图形界面程序的时候，可以暂时把 .pyw 改成 .py ，运行时能调出控制台窗口，方便看到所有错误信息。</span><br><span class="line">    至于.pyc文件，是Python解释器运行程序的过程中产生的字节码文件（也就是中间文件）。</span><br></pre></td></tr></table></figure><p>总之，我们尽可能地使用命令行来执行.py格式程序。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;python3中的运行命令与环境&quot;&gt;&lt;a href=&quot;#python3中的运行命令与环境&quot; class=&quot;headerlink&quot; title=&quot;python3中的运行命令与环境&quot;&gt;&lt;/a&gt;python3中的运行命令与环境&lt;/h1&gt;&lt;p&gt;本机电脑仅安装python3</summary>
      
    
    
    
    <category term="Programming languages and projects" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/"/>
    
    <category term="Python3" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"/>
    
    
    <category term="python3" scheme="http://justskim.github.io/tags/python3/"/>
    
    <category term="anaconda" scheme="http://justskim.github.io/tags/anaconda/"/>
    
  </entry>
  
  <entry>
    <title>python3中的生成器与迭代器</title>
    <link href="http://justskim.github.io/2021/11/03/python3%E4%B8%AD%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>http://justskim.github.io/2021/11/03/python3%E4%B8%AD%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/</id>
    <published>2021-11-03T01:55:18.115Z</published>
    <updated>2021-11-03T08:39:09.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python3中的生成器与迭代器"><a href="#python3中的生成器与迭代器" class="headerlink" title="python3中的生成器与迭代器"></a>python3中的生成器与迭代器</h1><h2 id="生成器与迭代器"><a href="#生成器与迭代器" class="headerlink" title="生成器与迭代器"></a>生成器与迭代器</h2><p>在Python社区，生成器和迭代器被看作一种工具，生成器的本质就是迭代器。唯一的区别就是生成器是开发人员自己用Python代码构建的数据结构，而迭代器是Python内置提供或转化而来的。</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器是一种对象，该对象包含值的可计数数字。</p><p>迭代器是可迭代的对象，这意味着您可以遍历所有值。</p><p>从技术上讲，在 Python 中，迭代器是实现迭代器协议的对象，它包含方法<code>__iter__()</code>和 <code>__next__()</code>。<br>要把对象&#x2F;类创建为迭代器，必须为对象实现<code> __iter__()</code> 和 <code>__next__()</code> 方法。</p><p>正如您在 Python 类&#x2F;对象 一章中学到的，所有类都有名为 <code>__init__()</code> 的函数，它允许您在创建对象时进行一些初始化。</p><p><code>__iter__()</code>方法的作用相似，您可以执行操作（初始化等），但必须始终返回迭代器对象本身。</p><p><code>__next__()</code>方法也允许您执行操作，并且必须返回序列中的下一个项目。</p><h3 id="可迭代对象（Iterable）"><a href="#可迭代对象（Iterable）" class="headerlink" title="可迭代对象（Iterable）"></a>可迭代对象（Iterable）</h3><p>列表、元组、字典和集合、字符串都是可迭代的对象。它们是可迭代的容器，您可以从中获取迭代器（Iterator）。</p><p>所有这些对象都有用于获取迭代器的 iter() 方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mytuple = (<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>)</span><br><span class="line">myit = <span class="built_in">iter</span>(mytuple)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myit))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myit))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myit))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mytuple = (<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myit=<span class="built_in">iter</span>(mytuple)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(myit))</span><br><span class="line">apple</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(myit))</span><br><span class="line">banana</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(myit))</span><br><span class="line">cherry</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mytuple1=<span class="string">&quot;banana&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myit1=<span class="built_in">iter</span>(mytuple1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(myit))</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#54&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(myit))</span><br><span class="line">StopIteration<span class="comment">#序列的所有项目都被迭代过，因此迭代（iteration）停止，报错</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(myit1))</span><br><span class="line">b</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(myit1))</span><br><span class="line">a</span><br></pre></td></tr></table></figure><p>也可以使用 for 循环遍历可迭代对象</p><h3 id="StopIteration-异常的使用"><a href="#StopIteration-异常的使用" class="headerlink" title="StopIteration 异常的使用"></a><code>StopIteration</code> 异常的使用</h3><p><code>StopIteration</code>异常用于完成标识迭代，防止无限循环。</p><p><code>__next__()</code>函数完成指定循环次数后，会触发该异常结束迭代。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">it = <span class="built_in">iter</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        x = <span class="built_in">next</span>(it)</span><br><span class="line">        <span class="built_in">print</span>(x)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment">#如果不使用StopIteration，则会报错异常</span></span><br></pre></td></tr></table></figure><h3 id="将一个类当做迭代器使用"><a href="#将一个类当做迭代器使用" class="headerlink" title="将一个类当做迭代器使用"></a>将一个类当做迭代器使用</h3><p>把一个类作为一个迭代器使用需要在类中方法 <code>__iter__()0</code>与 <code>__next__()</code> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyNumbers</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">    self.a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">    x = self.a</span><br><span class="line">    self.a += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"> </span><br><span class="line">myclass = MyNumbers()</span><br><span class="line">myiter = <span class="built_in">iter</span>(myclass)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))<span class="comment">#1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))<span class="comment">#2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))<span class="comment">#3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))<span class="comment">#4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))<span class="comment">#5</span></span><br></pre></td></tr></table></figure><h2 id="python3生成器"><a href="#python3生成器" class="headerlink" title="python3生成器"></a><code>python3</code>生成器</h2><p>在 Python 中，使用了 yield 的函数被称为<strong>生成器（generator）</strong>。</p><p>跟普通函数不同的是，<strong>生成器</strong>是一个<strong>返回迭代器的函数</strong>，<strong>只能用于迭代操作</strong>，更简单点理解生成器就是一个迭代器。</p><p>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。</p><p>调用一个生成器函数，返回的是一个迭代器对象。</p><h3 id="yield关键字"><a href="#yield关键字" class="headerlink" title="yield关键字"></a>yield关键字</h3><p>我们先将yield看做return，执行下面的程序，看看结果如何？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;starting...&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">res=<span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;res:&quot;</span>,res)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g=foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br><span class="line">starting...</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line">********************</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br><span class="line">res: <span class="literal">None</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/mieleizhi0522/article/details/82142856">原文章</a>的博主对于执行顺序给出了以下解释：</p><blockquote><p>1.程序开始执行以后，因为<code>foo</code>函数中有yield关键字，所以<code>foo</code>函数并不会真的执行，而是先得到一个生成器g(相当于一个对象)</p><p>2.直到调用next方法，<code>foo</code>函数正式开始执行，先执行<code>foo</code>函数中的print方法，然后进入while循环</p><p>3.程序遇到yield关键字，然后把yield想象成return，return了一个4之后，程序停止，并没有执行赋值给res操作，此时next(g)语句执行完成，所以输出的前两行（第一行“starting…”是while上面的print的结果，第二行“4”是return出的结果）是执行print(next(g))的结果，<strong>注意并没有执行yield一句下一行的print(“res:”,res)语句</strong></p><p>4.程序执行print(“<code>*</code>“*20)，输出20个<code>*</code></p><p>5.又开始执行下面的<code>print(next(g))</code>，不同的是，这一次<strong>从刚才那个next程序停止的地方开始执行的</strong>，也就是要<strong>从yield语句的下一行语句开始</strong>，执行res的赋值操作，这时候要注意，这个时候赋值操作的右边是没有值的（因为刚才那个是return出去了，并没有给赋值操作的左边传参数），所以这个时候res赋值是None,所以接着下面的输出就是<code>res:None</code></p><p>6.程序会继续在while里执行，又一次碰到yield,这个时候同样return 出4，然后程序停止，print函数输出的4就是这次return出的4.</p></blockquote><p>带yield的函数是一个生成器，可以不再看做一个函数了。这个生成器有一个next函数，相当于“下一步”生成哪个数，<strong>这一次的next开始的地方是接着上一次的next停止的地方执行的</strong>，所以调用next的时候，生成器并不会从<code>foo</code>函数的开始执行，只是接着上一步停止的地方开始，然后遇到yield后，return出要生成的数，此步就结束。</p><p>我们接着上面的代码，继续输出next(g)，每一次的next开始的地方都是上一次的next停止的地方：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br><span class="line">res: <span class="literal">None</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br><span class="line">res: <span class="literal">None</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>也就是说，除了第一次next函数可能会特殊（循环体外的代码部分执行原因），<strong>每次我们使用next函数，都是从上一个yield停止的地方，开始跑代码，跑到下一个yield语句，return了值， 停止</strong>。下面的例子更加直观一些：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">fo</span>(<span class="params">n</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;fo start!&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:<span class="comment">#注意，因为下一次next函数执行在循环体中开始，因此要再接一轮while判断，而不会执行循环体外面的上一行print(&quot;fo start&quot;)语句</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;before yield, n = &quot;</span>,n)</span><br><span class="line">n = n + <span class="number">1</span></span><br><span class="line">res = <span class="keyword">yield</span> n<span class="comment">#跑到这里结束</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;after yield, n = &quot;</span>,n)<span class="comment">#从这里开始</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = fo(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(x))</span><br><span class="line">fo start!</span><br><span class="line">before <span class="keyword">yield</span>, n =  <span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(x))</span><br><span class="line">after <span class="keyword">yield</span>, n =  <span class="number">2</span></span><br><span class="line">before <span class="keyword">yield</span>, n =  <span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(x))</span><br><span class="line">after <span class="keyword">yield</span>, n =  <span class="number">3</span></span><br><span class="line">before <span class="keyword">yield</span>, n =  <span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(x))</span><br><span class="line">after <span class="keyword">yield</span>, n =  <span class="number">4</span></span><br><span class="line">before <span class="keyword">yield</span>, n =  <span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(x))</span><br><span class="line">after <span class="keyword">yield</span>, n =  <span class="number">5</span></span><br><span class="line">before <span class="keyword">yield</span>, n =  <span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;python3中的生成器与迭代器&quot;&gt;&lt;a href=&quot;#python3中的生成器与迭代器&quot; class=&quot;headerlink&quot; title=&quot;python3中的生成器与迭代器&quot;&gt;&lt;/a&gt;python3中的生成器与迭代器&lt;/h1&gt;&lt;h2 id=&quot;生成器与迭代器&quot;&gt;</summary>
      
    
    
    
    <category term="Programming languages and projects" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/"/>
    
    <category term="Python3" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"/>
    
    
    <category term="python3" scheme="http://justskim.github.io/tags/python3/"/>
    
  </entry>
  
  <entry>
    <title>python3中的一些常见语法糖整理</title>
    <link href="http://justskim.github.io/2021/10/31/python3%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    <id>http://justskim.github.io/2021/10/31/python3%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E8%AF%AD%E6%B3%95%E7%B3%96/</id>
    <published>2021-10-31T12:02:01.432Z</published>
    <updated>2021-11-08T18:11:54.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python3中的一些常见语法糖整理"><a href="#python3中的一些常见语法糖整理" class="headerlink" title="python3中的一些常见语法糖整理"></a>python3中的一些常见语法糖整理</h1><h2 id="输入输出的类型提示"><a href="#输入输出的类型提示" class="headerlink" title="输入输出的类型提示"></a>输入输出的类型提示</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addBinary</span>(<span class="params">self, a: <span class="built_in">str</span>, b: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span></span><br></pre></td></tr></table></figure><p>学过C语言的同学，都懂得，参数中a，b要求为str类型的输入参数</p><p>在定义函数时，在def那一行后面会加一个-&gt;。这个玩意儿有个专门的名词叫 <strong>type hint， 即类型提示</strong>。这里就是说返回的数据类型为<code>str</code>。</p><p>在Python中，<code>str</code> 表示字符串类 ，也可以是将变量强制转换为字符串的函数，写作<code>str ()</code> </p><p><strong>类型标注</strong></p><ul><li><code>int</code>,<code>long</code>,<code>float</code>: 整型,长整形,浮点型</li><li><code>bool</code>,<code>str</code>: 布尔型，字符串类型</li><li><code>List</code>, <code>Tuple</code>, <code>Dict</code>, <code>Set</code>:列表，元组，字典, 集合</li><li><code>Iterable</code>,<code>Iterator</code>:可迭代类型，迭代器类型</li><li><code>Generator</code>：生成器类型</li></ul><h2 id="限定函数参数类型及输出"><a href="#限定函数参数类型及输出" class="headerlink" title="限定函数参数类型及输出"></a>限定函数参数类型及输出</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">text:<span class="string">&#x27;str&#x27;</span>,<span class="built_in">max</span>:<span class="string">&#x27;int &gt; 0&#x27;</span> = <span class="number">100</span>,<span class="built_in">min</span>:<span class="string">&#x27;int &gt; 0&#x27;</span></span>)-&gt;<span class="built_in">str</span>:</span><br></pre></td></tr></table></figure><p>在限定函数参数类型的同时还可以限定参数的范围以及默认值。</p><p>注意！在函数定义时，第一个带有默认值的参数之后的所有参数都必须有默认值，否则，运行时报错</p><h2 id="函数定义时的和"><a href="#函数定义时的和" class="headerlink" title="函数定义时的和*"></a>函数定义时的<em>和</em>*</h2><p>在参数前面加上<code>*</code>号 ，意味着参数个数不止一个，而带一个星号<code>*</code>参数的函数传入的参数存储为一个元组（tuple），带两个<code>*</code>号则是表示字典（dict）。</p><p>*将参数按顺序一一赋值，而dict类型则是将字典的keys作为函数参数进行赋值。</p><p>**参数方式则要求输入必须是一个dict，而且变量名称要与函数定义的变量名称一致</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">a, *b</span>):</span><br><span class="line">  <span class="built_in">print</span>(a)</span><br><span class="line">  <span class="built_in">print</span>(b)</span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">type</span>(b))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">a, **b</span>):</span><br><span class="line">  <span class="built_in">print</span>(a)</span><br><span class="line">  <span class="built_in">print</span>(b)</span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">type</span>(b))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func3</span>(<span class="params">a, *b, **c</span>):</span><br><span class="line">  <span class="built_in">print</span>(a)</span><br><span class="line">  <span class="built_in">print</span>(b)</span><br><span class="line">  <span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func1(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func1(<span class="number">1111</span>,(<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="number">1111</span></span><br><span class="line">((<span class="number">2</span>, <span class="number">3</span>),)<span class="comment">#如果传入一个元组，该元组会被当成元组的第一个参数</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func2(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#17&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    func2(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">TypeError: func2() takes <span class="number">1</span> positional argument but <span class="number">3</span> were given</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func2(<span class="number">1</span>,x=<span class="number">1</span>,y=<span class="number">2</span>)    <span class="comment">#传入的字典参数必须有key和value</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">&#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func2(<span class="number">111</span>,&#123;x=<span class="number">22</span>,y=<span class="number">44</span>&#125;)<span class="comment">#注意是传入的参数作为字典，不能传入dict类型的参数！</span></span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func3(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,x=<span class="number">5</span>,y=<span class="number">6</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure><p>在调用时，*主要是用来解压参数列表，对于set、tuple、list、dict(会取其values的值)类型的数据都适用</p><p>另外一个值得注意的就是参数的顺序，我们知道，最正规的写法就是将这三个参数按<code>*</code>号从少到多排列，那换一种写法呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func4</span>(<span class="params">a,**b,*c</span>):</span><br><span class="line">SyntaxError: invalid syntax<span class="comment">#**参数方式在*参数方式之前，无效</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func5</span>(<span class="params">*b,a</span>):<span class="comment">#*参数方式在不带*的参数之前，可以定义，但注意输入！！</span></span><br><span class="line"><span class="built_in">print</span>(b,<span class="string">&#x27;\n&#x27;</span>,a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func5</span>(<span class="params">**b,a</span>):<span class="comment">#**参数方式在不带*参数方式之前，无效</span></span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func5</span>(<span class="params">**b,*c</span>):<span class="comment">#**参数方式在*参数方式之前，无效</span></span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func5</span>(<span class="params">*b,**c</span>):<span class="comment">#没有不带*的参数，*参数方式在**参数方式之前，有效</span></span><br><span class="line"><span class="built_in">print</span>(b,c)</span><br></pre></td></tr></table></figure><p>但是要注意的是，如果带<code>*</code>的参数在不带<code>*</code>的参数之前，输入的时候要进行明确参数赋值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func6</span>(<span class="params">*b,a</span>):</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a=&quot;</span>,a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func6(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="string">&#x27;222&#x27;</span>,<span class="number">333</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#38&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    func6(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="string">&#x27;222&#x27;</span>,<span class="number">333</span>)</span><br><span class="line">TypeError: func6() missing <span class="number">1</span> required keyword-only argument: <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func6(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="string">&#x27;222&#x27;</span>,a=<span class="number">333</span>)<span class="comment">#输入的时候要进行明确参数赋值</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="string">&#x27;222&#x27;</span>)</span><br><span class="line">a= <span class="number">333</span></span><br></pre></td></tr></table></figure><h2 id="函数参数中的self"><a href="#函数参数中的self" class="headerlink" title="函数参数中的self"></a>函数参数中的self</h2><p>Python类中规定，函数的第一个参数是实例对象本身，并且约定俗成，把其名字写为self。其作用相当于java中的this，表示当前类的对象，可以调用当前类中的属性和方法。</p><p>在<a href="https://www.runoob.com/python3/python3-class.html">菜鸟教程</a>中，对于python类有如下介绍：</p><blockquote><ul><li><strong>类(Class):</strong> 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</li><li><strong>方法：</strong>类中定义的函数。</li><li><strong>类变量：</strong>类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</li><li><strong>数据成员：</strong>类变量或者实例变量用于处理类及其实例对象的相关的数据。</li><li><strong>方法重写：</strong>如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</li><li><strong>局部变量：</strong>定义在方法中的变量，只作用于当前实例的类。</li><li><strong>实例变量：</strong>在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。</li><li><strong>继承：</strong>即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。</li><li><strong>实例化：</strong>创建一个类的实例，类的具体对象。</li><li><strong>对象：</strong>通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</li></ul></blockquote><p>class是面向对象的设计思想，instance（也即是 object，对象）是根据 class 创建的。<br>在类的内部，使用 <strong>def</strong> 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self, 且为第一个参数，self 代表的是类的实例而不是类！<br>self 代表的是类的实例，代表当前对象的地址，而 <code>self.class </code>则指向类。<br>self 不是 python 关键字，我们把他替换成合格的字符串形式参数也是可以正常执行的。</p><h2 id="类中的-init-方法"><a href="#类中的-init-方法" class="headerlink" title="类中的__init__方法"></a>类中的<code>__init__</code>方法</h2><p>类有一个名为·<code>__init__()</code> 的特殊方法（<strong>构造方法</strong>），该方法在类实例化时会自动调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, realpart, imagpart</span>):</span><br><span class="line">        self.r = realpart</span><br><span class="line">        self.i = imagpart</span><br><span class="line">x = Complex(<span class="number">3.0</span>, -<span class="number">4.5</span>)</span><br><span class="line"><span class="built_in">print</span>(x.r, x.i)   <span class="comment"># 输出结果：3.0 -4.5</span></span><br></pre></td></tr></table></figure><h2 id="python-类的继承"><a href="#python-类的继承" class="headerlink" title="python 类的继承"></a>python 类的继承</h2><p>Python 同样支持类的继承，<strong>如果一种语言不支持继承，类就没有什么意义</strong>。</p><p>子类（派生类 DerivedClassName）会继承父类（基类 BaseClassName）的属性和方法。</p><p><code>BaseClassName</code>（实例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment">#类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">people</span>:</span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义私有属性,私有属性在类外部无法直接进行访问</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义构造方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,n,a,w</span>):</span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s 说: 我 %d 岁。&quot;</span> %(self.name,self.age))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#单继承示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>(<span class="title class_ inherited__">people</span>):</span><br><span class="line">    grade = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,n,a,w,g</span>):</span><br><span class="line">        <span class="comment">#调用父类的构函</span></span><br><span class="line">        people.__init__(self,n,a,w)</span><br><span class="line">        self.grade = g</span><br><span class="line">    <span class="comment">#覆写父类的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;</span>%(self.name,self.age,self.grade))</span><br><span class="line">s = student(<span class="string">&#x27;ken&#x27;</span>,<span class="number">10</span>,<span class="number">60</span>,<span class="number">3</span>)</span><br><span class="line">s.speak()</span><br><span class="line"><span class="comment">#执行结果：ken 说: 我 10 岁了，我在读 3 年级</span></span><br></pre></td></tr></table></figure><p>python也支持多重继承</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">people</span>:</span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义私有属性,私有属性在类外部无法直接进行访问</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义构造方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,n,a,w</span>):</span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s 说: 我 %d 岁。&quot;</span> %(self.name,self.age))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#单继承示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>(<span class="title class_ inherited__">people</span>):</span><br><span class="line">    grade = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,n,a,w,g</span>):</span><br><span class="line">        <span class="comment">#调用父类的构函</span></span><br><span class="line">        people.__init__(self,n,a,w)</span><br><span class="line">        self.grade = g</span><br><span class="line">    <span class="comment">#覆写父类的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;</span>%(self.name,self.age,self.grade))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#另一个类，多重继承之前的准备</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">speaker</span>():</span><br><span class="line">    topic = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,n,t</span>):</span><br><span class="line">        self.name = n</span><br><span class="line">        self.topic = t</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;</span>%(self.name,self.topic))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#多重继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sample</span>(speaker,student):</span><br><span class="line">    a =<span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,n,a,w,g,t</span>):</span><br><span class="line">        student.__init__(self,n,a,w,g)</span><br><span class="line">        speaker.__init__(self,n,t)</span><br><span class="line"> </span><br><span class="line">test = sample(<span class="string">&quot;Tim&quot;</span>,<span class="number">25</span>,<span class="number">80</span>,<span class="number">4</span>,<span class="string">&quot;Python&quot;</span>)</span><br><span class="line">test.speak()   <span class="comment">#方法名同，默认调用的是在括号中排前地父类的方法</span></span><br><span class="line"><span class="comment">#执行结果：我叫 Tim，我是一个演说家，我演讲的主题是 Python</span></span><br></pre></td></tr></table></figure><h3 id="类的私有属性"><a href="#类的私有属性" class="headerlink" title="类的私有属性"></a>类的私有属性</h3><p><strong>__private_attrs</strong>：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 <strong>self.__private_attrs</strong>。</p><h3 id="类的方法"><a href="#类的方法" class="headerlink" title="类的方法"></a>类的方法</h3><p>在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 <strong>self</strong>，且<strong>必须</strong>为<strong>第一个</strong>参数，<strong>self</strong> 代表的是类的实例。</p><p><strong>self</strong> 的名字并不是规定死的，也可以使用 <strong>this</strong>，但是最好还是按照约定使用 <strong>self</strong>。</p><h3 id="类的私有方法"><a href="#类的私有方法" class="headerlink" title="类的私有方法"></a>类的私有方法</h3><p><strong>__private_method</strong>：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。<strong>self.__private_methods</strong>。</p><h2 id="lambda表达式（匿名函数）"><a href="#lambda表达式（匿名函数）" class="headerlink" title="lambda表达式（匿名函数）"></a>lambda表达式（匿名函数）</h2><p>如果一个函数的函数体<strong>仅有 1 行</strong>，那么该函数就可以用 lambda 表达式来代替，下面两个函数在表达效果上是相等的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">arg1,...argn</span>):</span><br><span class="line">    <span class="keyword">return</span> 表达式</span><br><span class="line">name = <span class="keyword">lambda</span>  [arg1 [,arg2,.....argn]]: 表达式</span><br></pre></td></tr></table></figure><p>定义 lambda 表达式，必须使用 lambda 关键字，注意冒号前是<strong>参数</strong>，可以有<strong>多个</strong>，用<strong>逗号隔开</strong>，冒号右边的为表达式（只能为一个）。其实lambda返回值是一个函数的地址，也就是函数对象。</p><p>注意传入的参数必须用逗号隔开，下面这么定义是错误的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>add = <span class="keyword">lambda</span> [x,y]:x+y</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add = <span class="keyword">lambda</span> x,y:x+y</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="python中的5种下划线形式"><a href="#python中的5种下划线形式" class="headerlink" title="python中的5种下划线形式"></a>python中的5种下划线形式</h2><ul><li>单前导下划线：**_var**</li><li>单末尾下划线：<strong>var_</strong></li><li>双前导下划线：**__var**</li><li>双前导和末尾下划线：<code>__var__</code></li><li>单下划线：**_**</li></ul><h3 id="单前导下划线：-var"><a href="#单前导下划线：-var" class="headerlink" title="单前导下划线：**_var**"></a>单前导下划线：**_var**</h3><p>，前置单下划线只有约定含义。它对于程序员而言是一种提示——Python社区约定好单下划线表达的是某种意思，其本身并不会影响程序的行为。</p><p>前置下划线的意思是<strong>提示</strong>其他程序员，以单下划线开头的变量或方法只在内部使用。PEP 8中定义了这个约定（PEP 8是最常用的Python代码风格指南。</p><p>详见PEP 8：“Style Guide for Python Code”。</p><p>不过，这个约定对Python解释器并没有特殊含义。与Java不同，Python在“私有”和“公共”变量之间并没有很强的区别。在变量名之前添加一个下划线更像是有人挂出了一个小小的下划线警告标志：“<strong>注意，这并不是这个类的公共接口。最好不要使用它</strong>。”</p><p>我们实例化一个类，并为其添加一个使用单前导下划线的属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.foo = <span class="number">11</span></span><br><span class="line">        self._bar = <span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = Test()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.foo</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t._bar</span><br><span class="line"><span class="number">23</span></span><br></pre></td></tr></table></figure><p><code>_bar</code>前面的单下划线并没有阻止我们“进入”这个类访问变量的值。</p><p>这是因为Python中的前置单下划线只是一个公认的约定，至少在涉及变量名和方法名时是这样的。</p><p><strong>使用单前导下划线需要注意的是</strong>，前置下划线会影响从模块中导入名称的方式，如果使用<strong>通配符<code>*</code>导入</strong>从这个模块中导入所有名称，Python<strong>不会</strong>导入带有前置单下划线的名称（除非模块中定义了<code>__all__</code>列表覆盖了这个行为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在my_module.py中这么定义：</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">external_func</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">23</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_internal_func</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在idle或另一个py文件中导入</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> my_module <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>external_func()</span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_internal_func()</span><br><span class="line">NameError: <span class="string">&quot;name &#x27;_internal_func&#x27; is not defined&quot;</span></span><br></pre></td></tr></table></figure><p>值得注意的是：要<strong>尽可能避免使用通配符<code>*</code>导入</strong>，因为这样就不清楚当前名称空间中存在哪些名称了。为了清楚起见，最好坚持使用常规导入方法。与通配符导入不同，常规导入不受前置单下划线命名约定的影响.</p><p>遵循PEP 8的建议不使用通配符导入，那么真正需要记住的只有下面这一条。<br>以单下划线开头的名称只是Python命名中的约定，表示供内部使用。它通常对Python解释器没有特殊含义，仅仅作为对程序员的提示。</p><h3 id="单末尾下划线：var"><a href="#单末尾下划线：var" class="headerlink" title="单末尾下划线：var_"></a>单末尾下划线：<strong>var_</strong></h3><p>有时某个变量最合适的名称已被Python语言中的关键字占用。因此，诸如<code>class</code>或<code>def</code>的名称不能用作Python中的变量名。在这种情况下，可以追加一个下划线来绕过命名冲突。PEP 8中定义并解释了这个用一个单末尾下划线来避免与python关键字冲突的约定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">name,<span class="keyword">class</span></span>):</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">name,class_</span>):</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>上面介绍的单下划线（无论放在前边还是末尾），都只是约定的作用。</p><h3 id="双前导下划线：-var"><a href="#双前导下划线：-var" class="headerlink" title="双前导下划线：**__var**"></a>双前导下划线：**__var**</h3><p>上面介绍的单下划线（无论放在前边还是末尾），都只是约定的作用。</p><p>但使用以双下划线开头的Python类属性（变量和方法）就不一样了。</p><p>双下划线前缀会让Python解释器重写属性名称，以避免子类中的命名冲突。</p><p>这也称为<strong>名称改写</strong>（name mangling），即解释器会更改变量的名称，以便在稍后扩展这个类时避免命名冲突。</p><h3 id="双前导和末尾下划线：-var"><a href="#双前导和末尾下划线：-var" class="headerlink" title="双前导和末尾下划线：__var__"></a>双前导和末尾下划线：<code>__var__</code></h3><p><strong>一些特殊的双前导和末尾下划线</strong></p><ol><li><p><code>__all__</code></p><p>不像 Ruby 或者 Java，Python 没有语言原生的可见性控制，而是靠一套需要大家自觉遵守的”约定“下工作。比如下划线开头的应该对外部不可见。同样，<code>__all__</code> 也是对于模块公开接口的一种约定，比起下划线，<code>__all__</code> 提供了暴露接口用的”白名单“。一些不以下划线开头的变量（比如从其他地方 <code>import</code> 到当前模块的成员）可以同样被排除出去。</p><p>当我们向文件导入某个模块时，导入的是该模块中那些<strong>名称不以下划线（单下划线“_”或者双下划线“__”）开头</strong>的变量、函数和类。因此，如果我们不想模块文件中的某个成员被引入到其它文件中使用，有两种方法：</p><ol><li>在其名称前添加单下划线。</li><li>借助模块提供的__all__ 变量，该变量的值是一个列表，存储的是当前模块中一些成员（变量、函数或者类）的名称。</li></ol><p>通过在模块文件中设置__all__变量，当其它文件以“from 模块名 import *”的形式导入该模块时，该文件中只能使用__all__ 列表中指定的成员。__all__也是对于模块公开接口的一种约定，比起下划线，__all__提供了暴露接口用的“白名单”。<br>       ————————————————<br>      版权声明：本文为CSDN博主「-徐徐图之-」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>      原文链接：<a href="https://blog.csdn.net/zylooooooooong/article/details/115564782">https://blog.csdn.net/zylooooooooong/article/details/115564782</a></p></li><li><p><code>__init__</code></p><p>在创建类时，我们可以手动添加一个<code>__init__()</code>方法，该方法是一个特殊的类实例方法，称为构造方法（或构造函数）。</p><p>构造方法用于创建对象时使用，每当创建一个类的实例对象时，<a href="http://c.biancheng.net/python/">Python</a> 解释器都会自动调用它。</p><p><code>__init__() </code>方法可以包含多个参数，但必须包含一个名为 self 的参数，且必须作为第一个参数。</p><p>即便不手动为类添加任何构造方法，Python 也会自动为类添加一个仅包含 self 参数的构造方法。</p><p>如果子类中不重写<code>__init__</code>，实例化子类时，就会调用父类中定义的<code>__init__</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        <span class="built_in">print</span> ( <span class="string">&quot;name: %s&quot;</span> %( self.name) )</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getName</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Father &#x27;</span> + self.name</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>(<span class="title class_ inherited__">Father</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getName</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Son &#x27;</span>+self.name</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    son=Son(<span class="string">&#x27;runoob&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span> ( son.getName() )</span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line">name: runoob</span><br><span class="line">Son runoob</span><br></pre></td></tr></table></figure><p>如果重写了**<strong>init</strong>** 时，实例化子类，就不会调用父类已经定义的 **<strong>init</strong>**，语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        <span class="built_in">print</span> ( <span class="string">&quot;name: %s&quot;</span> %( self.name) )</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getName</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Father &#x27;</span> + self.name</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>(<span class="title class_ inherited__">Father</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">print</span> ( <span class="string">&quot;hi&quot;</span> )</span><br><span class="line">        self.name =  name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getName</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Son &#x27;</span>+self.name</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    son=Son(<span class="string">&#x27;runoob&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span> ( son.getName() )</span><br><span class="line"><span class="comment">#输出结果：</span></span><br><span class="line">hi</span><br><span class="line">Son runoob</span><br></pre></td></tr></table></figure><p>若重写了<code>__init__</code>，还要继承父类的构造方法，可以使用<code>super</code>关键字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        <span class="built_in">print</span> ( <span class="string">&quot;name: %s&quot;</span> %( self.name))</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getName</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Father &#x27;</span> + self.name</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>(<span class="title class_ inherited__">Father</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">super</span>(Son, self).__init__(name)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;hi&quot;</span>)</span><br><span class="line">        self.name =  name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getName</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Son &#x27;</span>+self.name</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    son=Son(<span class="string">&#x27;runoob&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span> ( son.getName() )</span><br><span class="line">    </span><br><span class="line"><span class="comment">#输出结果如下：</span></span><br><span class="line">name: runoob</span><br><span class="line">hi</span><br><span class="line">Son runoob</span><br></pre></td></tr></table></figure><p>也可以直接调用父类的<code>__init__</code>类方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dad = Father(<span class="string">&#x27;luo&#x27;</span>)</span><br><span class="line">name: luo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dad.__init__()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#10&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    dad.__init__()</span><br><span class="line">TypeError: __init__() missing <span class="number">1</span> required positional argument: <span class="string">&#x27;name&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dad.__init__(<span class="string">&quot;WHALE&quot;</span>)</span><br><span class="line">name: WHALE</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dad.name</span><br><span class="line"><span class="string">&#x27;WHALE&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><code>__name__</code></p><p>一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用<code>__name__</code>属性来使该程序块仅在该模块自身运行时执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># Filename: using_name.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;程序自身在运行&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;我来自另一模块&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#以下是程序运行结果</span></span><br><span class="line">$ python using_name.py<span class="comment">#在模块自身运行时</span></span><br><span class="line">程序自身在运行</span><br><span class="line">$ python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> using_name<span class="comment">#在模块被引用时</span></span><br><span class="line">我来自另一模块</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>注意：每个模块都有一个<code>__name__</code>属性，当其值是<code>__main__</code>时，表明该模块自身在运行，否则是被引入。</p></li><li></li></ol><h3 id="单下划线："><a href="#单下划线：" class="headerlink" title="单下划线：**_**"></a>单下划线：**_**</h3><p>有时候单个独立下划线是用作一个名字，来表示某个变量是临时的或无关紧要的。</p><p>例如，在下面的循环中，我们不需要访问正在运行的索引，我们可以使用”_”来表示它只是一个临时值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line"><span class="meta">... </span>   <span class="built_in">print</span>(<span class="string">&#x27;Hello, World.&#x27;</span>)</span><br></pre></td></tr></table></figure><p>你也可以在拆分(unpacking)表达式中将单个下划线用作”不关心的”变量，以忽略特定的值。 同样，这个含义只是”依照约定”，并不会在Python解释器中触发特殊的行为。 单个下划线仅仅是一个有效的变量名称，会有这个用途而已。</p><p>在下面的代码示例中，我将汽车元组拆分为单独的变量，但我只对颜色和里程值感兴趣。 但是，为了使拆分表达式成功运行，我需要将包含在元组中的所有值分配给变量。 在这种情况下，”_”作为占位符变量可以派上用场：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>car = (<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;auto&#x27;</span>, <span class="number">12</span>, <span class="number">3812.4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>color, _, _, mileage = car</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>color</span><br><span class="line"><span class="string">&#x27;red&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mileage</span><br><span class="line"><span class="number">3812.4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><p>除了用作临时变量之外，”_”是大多数Python REPL中的一个特殊变量，它表示由解释器评估的最近一个表达式的结果。</p><p>这样就很方便了，比如你可以在一个解释器会话中访问先前计算的结果，或者，你是在动态构建多个对象并与它们交互，无需事先给这些对象分配名字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">20</span> + <span class="number">3</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_</span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(_)</span><br><span class="line"><span class="number">23</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>()</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_.append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_.append(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_.append(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>对于上面五种类型的下划线，<a href="https://www.runoob.com/w3cnote/python-5-underline.html">菜鸟教程的小结</a>可以很好的帮助我们：</p><p><img src="E:\JS练习\blog\Myblog\source\images\python下划线类型小结.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;python3中的一些常见语法糖整理&quot;&gt;&lt;a href=&quot;#python3中的一些常见语法糖整理&quot; class=&quot;headerlink&quot; title=&quot;python3中的一些常见语法糖整理&quot;&gt;&lt;/a&gt;python3中的一些常见语法糖整理&lt;/h1&gt;&lt;h2 id=&quot;输</summary>
      
    
    
    
    <category term="Programming languages and projects" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/"/>
    
    <category term="Python3" scheme="http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"/>
    
    
    <category term="python3" scheme="http://justskim.github.io/tags/python3/"/>
    
  </entry>
  
  <entry>
    <title>linux的进程优先级与进程调度策略</title>
    <link href="http://justskim.github.io/2021/10/23/linux%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%8E%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/"/>
    <id>http://justskim.github.io/2021/10/23/linux%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%8E%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/</id>
    <published>2021-10-23T12:38:09.488Z</published>
    <updated>2021-10-25T07:05:02.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux的进程优先级与进程调度策略"><a href="#linux的进程优先级与进程调度策略" class="headerlink" title="linux的进程优先级与进程调度策略"></a>linux的进程优先级与进程调度策略</h1><h2 id="linux中的进程调度策略"><a href="#linux中的进程调度策略" class="headerlink" title="linux中的进程调度策略"></a>linux中的进程调度策略</h2><p>FIFO，RR，OTHER</p><p>实时进程会抢占普通进程，FIFO会导致同优先级实时进程始终占用CPU，RR会保证同优先级实时进程按时间片轮流执行。</p><p>上面说的很通俗易懂，那么，两个同等优先级的FIFO实时进程，是不是谁先占据了cpu，另一个就只能等待它完成了让出CPU呢？</p><p>其实不尽然，即使是在单核cpu的linux系统中，FIFO实时进程也会被调度。</p><p>具体可见博客：</p><p>cnblogs.com&#x2F;tongye&#x2F;p&#x2F;9575602.html</p><p>blog.csdn.net&#x2F;qq_37451250&#x2F;article&#x2F;details&#x2F;104807725</p><h2 id="C语言中的进程优先级设置"><a href="#C语言中的进程优先级设置" class="headerlink" title="C语言中的进程优先级设置"></a>C语言中的进程优先级设置</h2><p>创建实时进程与普通进程略有区别——在创建普通进程的基础上，将调度类从CFS（completely fair完全公平调度类）转向RT类（实时调度类型，包括RR和FIFO）</p><p>常见的几个进程优先级设置与取得函数（位于头文件sched.h中）：</p><p>sched_get_priority_max()  取得静态优先级的上限</p><p>sched_get_priority_min()  取得静态优先级的下限</p><p>sched_getparam()取得进程的调度参数</p><p>sched_setparam()设置进程的调度参数</p><p>sched_getscheduler()取得指定进程的调度类</p><p>sched_setscheduler()设置指定进程的调度类</p><blockquote><p>int sched_getscheduler(pid_t pid, int policy, const struct sched_param *param)</p><p>第一个参数是进程号（0表示本进程），第二个参数为调度类（SCHED_RR为2、SCHED_FIFO为1、SCHED_OTHER为0，三个之一） ，第三个参数是一个struct sched_param 类型的调度参数——其sched_priority成员可以指定优先级。</p></blockquote><p>sched_rr_get_interval()取得按RR算法调度的实时进程的时间片长度</p><p>sched_yield()进程主动让出处理器并将自己挂入等候调度队列的队尾</p><p>sched文件</p><p><strong>C语言system函数</strong></p><p>执行 dos(windows系统) 或 shell(Linux&#x2F;Unix系统) 命令，参数字符串command为命令名。另，在windows系统下参数字符串不区分大小写。</p><p>说明：在windows系统中，system函数直接在控制台调用一个command命令。<br>在Linux&#x2F;Unix系统中，system函数会调用fork函数产生子进程，由子进程来执行command命令，命令执行完后随即返回原调用的进程。</p><p>函数返回值<br>命令执行成功返回0，执行失败返回-1。</p><p><strong>C语言sprintf函数</strong></p><p>int sprintf( char *buffer, const char *format, [ argument] … )；</p><p>这个函数包含三个部分的参数：</p><p>buffer：char型指针，指向将要写入的字符串的缓冲区。format：格式化字符串。即可选参数的想要输入的数据类型。[argument]…：可选参数，可以是任何类型的数据。</p><p>这个函数就是把第三部分的数据，按照第二部分格式化字符的格式，把第三部分的数据进行”格式化“，然后在<strong>把格式化后的数据类型，存储到字符串</strong>的缓存区间里去。</p><p>通过查看&#x2F; proc &#x2F;&lt; PID&gt; &#x2F; sched中的调度统计信息(scheduling stats in <code>/proc/&lt;PID&gt;/sched</code>),您可以获得如下输出（仅限进程运行着的时候）</p><p>为了在进程退出后依然能看到这些调度统计信息，我们可以使用以上代码将其存储至本目录的sched-pid文件中</p><p>&gt; nr_switches：上下文切换次数.<br>&gt; nr_voluntary_switches：自愿切换的数量,即线程被阻塞,因此拾取另一个线程.<br>&gt; nr_involuntary_switches：调度程序将线程踢出,因为有另一个饥饿的线程已准备好运行.</p><h2 id="C语言中的进程调度函数"><a href="#C语言中的进程调度函数" class="headerlink" title="C语言中的进程调度函数"></a>C语言中的进程调度函数</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;linux的进程优先级与进程调度策略&quot;&gt;&lt;a href=&quot;#linux的进程优先级与进程调度策略&quot; class=&quot;headerlink&quot; title=&quot;linux的进程优先级与进程调度策略&quot;&gt;&lt;/a&gt;linux的进程优先级与进程调度策略&lt;/h1&gt;&lt;h2 id=&quot;l</summary>
      
    
    
    
    <category term="Linux" scheme="http://justskim.github.io/categories/Linux/"/>
    
    
    <category term="linux" scheme="http://justskim.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>在vmware中“/mnt/hgfs”路径下共享文件夹的挂载</title>
    <link href="http://justskim.github.io/2021/10/23/%E5%9C%A8vmware%E4%B8%AD%E2%80%9Cmnthgfs%E2%80%9D%E8%B7%AF%E5%BE%84%E4%B8%8B%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E6%8C%82%E8%BD%BD/"/>
    <id>http://justskim.github.io/2021/10/23/%E5%9C%A8vmware%E4%B8%AD%E2%80%9Cmnthgfs%E2%80%9D%E8%B7%AF%E5%BE%84%E4%B8%8B%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E6%8C%82%E8%BD%BD/</id>
    <published>2021-10-23T12:13:05.314Z</published>
    <updated>2021-10-23T12:28:45.188Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在vmware中“-x2F-mnt-x2F-hgfs”路径下共享文件夹的挂载"><a href="#在vmware中“-x2F-mnt-x2F-hgfs”路径下共享文件夹的挂载" class="headerlink" title="在vmware中“&#x2F;mnt&#x2F;hgfs”路径下共享文件夹的挂载"></a>在vmware中“&#x2F;mnt&#x2F;hgfs”路径下共享文件夹的挂载</h1><p>在之前的博客中，我们已经讲过如何在vmware虚拟机中设置共享文件夹，mnt目录是挂接光驱、USB设备的目录，在其中进行文件操作需要有root权限。linux系统中一定会有&#x2F;mnt目录，但其下不一定有hgfs目录，在我们成功安装完VMWare tools后会出现hgfs文件夹，但一些情况下hgfs文件夹中可能不存在我们之前在虚拟机中设置的共享文件夹名称，下面是解决办法</p><h2 id="x2F-mnt路径下有hgfs但却没有共享文件夹"><a href="#x2F-mnt路径下有hgfs但却没有共享文件夹" class="headerlink" title="&#x2F;mnt路径下有hgfs但却没有共享文件夹"></a>&#x2F;mnt路径下有hgfs但却没有共享文件夹</h2><p>先进入到root权限下，使用命令<code>vmware-hgfsclient</code>来查看当前有哪些共享的目录，如果未能成功安装VMWare tools则该命令会导致报错。</p><p>然后使用命令<code>mount -t vmhgfs .host:/你所设置的共享文件夹名称 /mnt/hgfs</code>来挂载共享文件夹即可。</p><p>以上设置后每次重新开机都要重复设置一次共享文件夹，我们使用在文件<code>/etc/fstab</code>中进行修改来设置开机后自动挂载：</p><p>在文件<code>/etc/fstab</code>中添加以下一行：<code>.host:/mnt/hgfs vmhgfs defaults 0 0</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;在vmware中“-x2F-mnt-x2F-hgfs”路径下共享文件夹的挂载&quot;&gt;&lt;a href=&quot;#在vmware中“-x2F-mnt-x2F-hgfs”路径下共享文件夹的挂载&quot; class=&quot;headerlink&quot; title=&quot;在vmware中“&amp;#x2F;m</summary>
      
    
    
    
    <category term="Linux" scheme="http://justskim.github.io/categories/Linux/"/>
    
    
    <category term="linux" scheme="http://justskim.github.io/tags/linux/"/>
    
    <category term="虚拟机" scheme="http://justskim.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    <category term="ubuntu" scheme="http://justskim.github.io/tags/ubuntu/"/>
    
    <category term="vmware" scheme="http://justskim.github.io/tags/vmware/"/>
    
  </entry>
  
  <entry>
    <title>linux的权限与隐藏权限</title>
    <link href="http://justskim.github.io/2021/09/27/linux%E7%9A%84%E6%9D%83%E9%99%90%E4%B8%8E%E9%9A%90%E8%97%8F%E6%9D%83%E9%99%90/"/>
    <id>http://justskim.github.io/2021/09/27/linux%E7%9A%84%E6%9D%83%E9%99%90%E4%B8%8E%E9%9A%90%E8%97%8F%E6%9D%83%E9%99%90/</id>
    <published>2021-09-27T12:26:36.587Z</published>
    <updated>2021-09-29T02:11:21.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux的权限与隐藏权限"><a href="#linux的权限与隐藏权限" class="headerlink" title="linux的权限与隐藏权限"></a>linux的权限与隐藏权限</h1><h2 id="linux的权限"><a href="#linux的权限" class="headerlink" title="linux的权限"></a>linux的权限</h2><h3 id="linux中的文件类型"><a href="#linux中的文件类型" class="headerlink" title="linux中的文件类型"></a>linux中的文件类型</h3><p>　　linux一共有7种文件类型,分别如下:</p><p>​    　　 -：普通文件</p><p>​     　d：目录文件</p><p>​     　l： 软链接（类似Windows的快捷方式）</p><p>​    　　(<strong>下面四种是特殊文件)</strong></p><p>​     　b：块设备文件（例如硬盘、光驱等）</p><p>​    　　 p：管道文件</p><p>​     　c：字符设备文件（例如猫等串口设备）</p><p>​     　s：套接口文件&#x2F;数据接口文件（例如启动一个MySql服务器时会产生一个mysql.sock文件）</p><h2 id="linux的隐藏权限"><a href="#linux的隐藏权限" class="headerlink" title="linux的隐藏权限"></a>linux的隐藏权限</h2><p>除了文件的读写,执行权限外,linux还有一种隐藏权限,设置隐藏权限可以防止一些其他用户的误操作或者恶意操作,当我们配置了<code>nginx</code>的放跨站攻击或其他安全措施后,相应的会在项目的根目录下生成一个隐藏文件<code>.user.ini</code>,当删除整个项目时会阻止操作完成.我们使用<code>ls</code>命令并使用<code>chmod chown</code>等命令设置了文件权限后会发现还是无法删除.这就是因为这个文件有隐藏的权限。</p><p>linux系统的隐藏权限总共有以下十三种类型：</p><ul><li><p>A：即Atime，告诉系统不要修改对这个文件的最后访问时间；</p></li><li><p>S：即Sync，一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘；</p></li><li><p>a：即Append Only，系统只允许在这个文件之后追加数据，不允许任何进程覆盖或截断这个文件。如果目录具有这个属性，系统将只允许在这个目录下建立和修改文件，而不允许删除任何文件；</p></li><li><p>b：不更新文件或目录的最后存取时间；</p></li><li><p>c：将文件或目录压缩后存放；</p></li><li><p>d：当dump程序执行时，该文件或目录不会被dump备份；</p></li><li><p>D:检查压缩文件中的错误；</p></li><li><p>i：即Immutable，系统不允许对这个文件进行任何的修改。如果目录具有这个属性，那么任何的进程只能修改目录之下的文件，不允许建立和删除文件；</p></li><li><p>s：彻底删除文件，不可恢复，因为是从磁盘上删除，然后用0填充文件所在区域；</p></li><li><p>u：当一个应用程序请求删除这个文件，系统会保留其数据块以便以后能够恢复删除这个文件，用来防止意外删除文件或目录；</p></li><li><p>t:文件系统支持尾部合并（tail-merging）；</p></li><li><p>X：可以直接访问压缩文件的内容 </p></li><li><p>e: 表示文件以ext4 extents存储的，ext4上新建文件的默认属性，<strong>不可用chattr修改</strong>。</p></li></ul><p>使用命令<code>chattr +权限类型</code>和<code>chattr -权限类型</code>可以为文件添加或删除隐藏权限</p><h2 id="chattr命令"><a href="#chattr命令" class="headerlink" title="chattr命令"></a>chattr命令</h2><p>提到文件权限的修改，必然绕不过这一命令，根据<a href="http://c.biancheng.net/view/874.html">C语言中文网</a>（这个网站怎么啥都有）：</p><blockquote><p>chattr 命令，专门用来修改文件或目录的隐藏属性，只有 root 用户可以使用。该命令的基本格式为：</p><p>[root@localhost ~]# chattr [+-&#x3D;] [属性] 文件或目录名</p></blockquote><p>下面是常用chattr命令来授予&#x2F;删除的一些属性：</p><table><thead><tr><th>属性选项</th><th>功能</th></tr></thead><tbody><tr><td>i</td><td>如果对文件设置 i 属性，那么不允许对文件进行删除、改名，也不能添加和修改数据； 如果对目录设置 i 属性，那么只能修改目录下文件中的数据，但不允许建立和删除文件；</td></tr><tr><td>a</td><td>如果对文件设置 a 属性，那么只能在文件中増加数据，但是不能删除和修改数据； 如果对目录设置 a 属性，那么只允许在目录中建立和修改文件，但是不允许删除文件；</td></tr><tr><td>u</td><td>设置此属性的文件或目录，在删除时，其内容会被保存，以保证后期能够恢复，常用来防止意外删除文件或目录。</td></tr><tr><td>s</td><td>和 u 相反，删除文件或目录时，会被彻底删除（直接从硬盘上删除，然后用 0 填充所占用的区域），不可恢复。</td></tr><tr><td>b</td><td>不更新文件或目录的最后存取时间。</td></tr><tr><td>c</td><td>将文件或目录压缩后存放。</td></tr><tr><td>d</td><td>将文件或目录排除在倾倒操作之外</td></tr><tr><td>S</td><td>即时更新文件或目录</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;linux的权限与隐藏权限&quot;&gt;&lt;a href=&quot;#linux的权限与隐藏权限&quot; class=&quot;headerlink&quot; title=&quot;linux的权限与隐藏权限&quot;&gt;&lt;/a&gt;linux的权限与隐藏权限&lt;/h1&gt;&lt;h2 id=&quot;linux的权限&quot;&gt;&lt;a href=&quot;#l</summary>
      
    
    
    
    <category term="Linux" scheme="http://justskim.github.io/categories/Linux/"/>
    
    
    <category term="linux" scheme="http://justskim.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>在vmware中实现共享文件夹以及安装vmware-tools</title>
    <link href="http://justskim.github.io/2021/09/27/%E5%9C%A8vmware%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85vmware-tools/"/>
    <id>http://justskim.github.io/2021/09/27/%E5%9C%A8vmware%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85vmware-tools/</id>
    <published>2021-09-27T11:27:13.351Z</published>
    <updated>2021-10-01T01:46:47.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在vmware中实现共享文件夹以及安装vmware-tools"><a href="#在vmware中实现共享文件夹以及安装vmware-tools" class="headerlink" title="在vmware中实现共享文件夹以及安装vmware-tools"></a>在vmware中实现共享文件夹以及安装vmware-tools</h1><p>原因：想要设置共享文件夹，而ubuntu16.04版本系统中，只有文件夹mnt，其中没有文件夹hgfs，而按照网上教程操作，需要重新安装vmware-tools才能使得该选项可以点击，然而虚拟机菜单栏中，“重新安装vmware-tool”的选项为灰色不可点击</p><p>首先使用命令<code>su root</code>跳转至超级用户权限，</p><p>然后，使用命令<code>apt-get install open-vmware-tools</code>安装，</p><p>注意，完成之后，在文件夹<code>media</code>下面会有以下的文件</p><p><img src="E:\JS练习\blog\Myblog\source\images\media文件夹下的vmwareTools.png" alt="media文件夹下的vmwareTools"></p><p>我们如果在media文件夹中使用tar命令对 文件 进行解压缩，会发现出错，大量的报错语句：</p><p><code>tar: vmware-tools-distrib: Cannot mkdir: Read only file system</code></p><p>然后我们使用命令<code>su root</code>输入密码进入超级用户权限，再次尝试解压缩，依然出错！</p><p>原因在于<a href="https://zhidao.baidu.com/question/367521394739288804.html">linux系统对我们的贴心</a>：</p><blockquote><p>我们知道<strong>root用户</strong>是linux执行<strong>权限最高</strong>的管理者用户，他可以进行任何的权限操作；<strong>然而</strong>我们的<strong>操作系统</strong>同样也考虑过这样的弊端，就是当我们使用者并不了解文件属性和重要性时会给予我们使用者提示；</p><p>  举个例子，当我们在linux下打开磁盘文件时，想要直接修改磁盘中的文件属性，一般会提示为只读文件，这时我们可以将其从磁盘中移动到本地目录下，这样就可以进行权限操作了；</p><p>  实例如图显示，我的操作是试图对DVD中的文件进行权限修改，这是不被允许的；</p></blockquote><p>如果我们在media文件夹目录下使用<code>lsattr</code>命令：可以发现：</p><p><img src="/"></p><p>注意，<code>e</code>是linux文件的隐藏权限类型！！</p><p>在linux操作系统中，有这么几个特殊的文件夹：</p><blockquote><p>&#x2F;mnt：一般是挂在镜像和硬盘一类的目录；&#x2F;media:是挂在多媒体设备的目录，如默认情况下的光盘、优盘、硬盘等设备都挂在在此目录；&#x2F;misc即各种其它杂七杂八东西</p><p>otp 是第三方软件的存放目录<br>selinux 是linux 下强制存取控制的实现 一般用来保护apache<br>srv 是存放系统提供服务站点的数据<br>media 是存放即插即用 设备的 挂载点。 比如USB 设备 自动在这个目录下创建一个目录</p><p>因为你没有对 文件所对应的内容进行操作 所以他是空的 </p></blockquote><p>在<a href="https://www.howtogeek.com/117435/htg-explains-the-linux-directory-structure-explained/">How-To-Geek上对Linux系统的目录结构说明文档</a>中，关于media文件夹有这样的解释：</p><blockquote><h2 id="x2F-media-—-Removable-Media"><a href="#x2F-media-—-Removable-Media" class="headerlink" title="&#x2F;media — Removable Media"></a>&#x2F;media — Removable Media</h2><p>The &#x2F;media directory contains subdirectories where removable media devices inserted into the computer are mounted. For example, when you insert a CD into your Linux system, a directory will automatically be created inside the &#x2F;media directory. You can access the contents of the CD inside this directory.</p></blockquote><p>在我们使用apt-get下载了相关tar.gz格式的压缩文件后，这一篇<a href="https://blog.csdn.net/a1219532602/article/details/110071982">博客</a>介绍了之后的步骤：</p><p>当然，作者也遇到了media文件夹中不能解压缩的问题，给出了下面的解答步骤：</p><p>于是，我们使用命令<code>cp VMwaretools.tar.gz /home/user/Desktop</code>将其拷贝一份至桌面进行解压缩</p><p><code>tar -zxvf VMwareTools.tar.gz</code></p><p>然后跳转到解压后的文件夹 <code>cd vmware-tools-distrib/</code></p><p>执行命令<code>sudo ./vmware-install.pl</code>。</p><p>完成，成功解压缩。</p><p>然后我们重新启动虚拟机，可以看到，&#x2F;mnt文件夹下已经有了hgfs文件夹</p><p>在<a href="https://www.linuxcool.com/">中文的一个方便网站上</a>，我们可以搜索到<strong>上面几个重要命令的讲解：</strong></p><ul><li><p><code>cp</code> </p><p>CoPy，功能为复制文件或目录，可以将多个文件复制到一个具体的文件名或一个已经存在的目录下，也可以同时复制多个文件到一个指定的目录中。</p><p><code>cp [参数] [文件] [路径]</code></p></li><li><p><code>tar</code></p><p>TARball，根据<a href="https://www.runoob.com/linux/linux-comm-tar.html">菜鸟教程中的描述</a>：</p><blockquote><p>tar 是用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件。</p></blockquote></li></ul><p>必要参数如下：<br>  <strong>A</strong>   新增压缩文件到已存在的压缩<br>  <strong>c</strong>    建立新的压缩文件<br>  <strong>d</strong>   记录文件的差别<br>  <strong>r</strong>    添加文件到已经压缩的文件<br>  <strong>u</strong>   添加改变了和现有的文件到已经存在的压缩文件<br>  <strong>x</strong>   从压缩的文件中提取文件<br>  <strong>t</strong>   显示压缩文件的内容<br>  <strong>z</strong>   支持<code>gzip</code>解压文件<br>  <strong>j</strong>    支持<code>bzip2</code>解压文件<br>  <strong>Z</strong>   支持compress解压文件<br>  <strong>v</strong>   显示操作过程<br>  <strong>l</strong>    文件系统边界设置<br>  <strong>k</strong>   保留原有文件不覆盖<br>  <strong>m</strong>  保留文件不被覆盖<br>  <strong>W</strong>  确认压缩文件的正确性</p><ul><li><p><code>cd</code></p><p>Change Directory，切换目录</p><p><code>cd [参数] [目录名]</code></p><p>一些特殊的目录表示：</p><p>“ <strong>~</strong> ”表示为<strong>用户目录</strong>的意思；</p><p>“ <strong>. <strong>”则是表示</strong>目前所在的目录</strong>；</p><p>“ <strong>..</strong> ”则表示<strong>当前目录位置的上一级目录</strong>。</p><p>常用参数</p><table><thead><tr><th>-P</th><th>如果切换的目标目录是一个符号链接，则直接切换到符号链接指向的目标目录</th></tr></thead><tbody><tr><td>-L</td><td>如果切换的目标目录是一个符号链接，则直接切换到符号链接名所在的目录</td></tr><tr><td>–</td><td>仅使用”-“选项时，当前目录将被切换到环境变量”OLDPWD”对应值的目录</td></tr><tr><td>~</td><td>切换至当前用户目录</td></tr><tr><td>..</td><td>切换至当前目录位置的上一级目录</td></tr></tbody></table></li><li><p><code>sudo</code></p><p>SuperUser DO</p><p>sudo 是一种权限管理机制，管理员可以授权于一些普通用户去执行一些 root 执行的操作，而不需要知道 root 的密码。</p><p>sudo 允许一个已授权用户以超级用户或者其它用户的角色运行一个命令。当然，能做什么不能做什么都是通过安全策略来指定的。sudo 支持插件架构的安全策略，并能把输入输出写入日志。第三方可以开发并发布自己的安全策略和输入输出日志插件，并让它们无缝的和 sudo 一起工作。默认的安全策略记录在 &#x2F;etc&#x2F;sudoers 文件中。而安全策略可能需要用户通过密码来验证他们自己。也就是在用户执行 sudo 命令时要求用户输入自己账号的密码。如果验证失败，sudo 命令将会退出。</p><p><strong>语法格式：</strong>sudo [参数]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-v</th><th>因为 sudo 在第一次执行时或是在 N分钟内没有执行（N 预设为五）会问密码，这个参数是重新做一次确认，如果超过N分钟，也会问密码</th></tr></thead><tbody><tr><td>-k</td><td>强迫使用者在下一次执行 sudo 时问密码（不论有没有超过 N 分钟）</td></tr><tr><td>-b</td><td>将要执行的指令放在背景执行</td></tr><tr><td>-p</td><td>prompt 可以更改问密码的提示语，其中 %u 会代换为使用者的帐号名称，%h 会显示主机名称</td></tr><tr><td>-s</td><td>执行环境变数中的SHELL 所指定的shell ，或是 &#x2F;etc&#x2F;passwd 里所指定的 shell</td></tr><tr><td>command</td><td>要以系统管理者身份（或以 -u 更改为其他人）执行的指令</td></tr></tbody></table></li></ul><p>例如我们要切换到root用户，需要使用命令<code>sudo su</code></p><h2 id="一个小插曲——如何在ubuntu中启用中英文输入法"><a href="#一个小插曲——如何在ubuntu中启用中英文输入法" class="headerlink" title="一个小插曲——如何在ubuntu中启用中英文输入法"></a>一个小插曲——如何在ubuntu中启用中英文输入法</h2><p>按照<a href="https://blog.csdn.net/qq_45797116/article/details/114260047">这一篇教程</a>安装搜狗输入法的linux版本，并进行相关配置。</p><p>当我们在linux桌面系统的终端或编辑器中启用输入的时候，只要记得右上角linux图标点击切换输入法即可。</p><p>当我们在Linux系统启用搜狗输入法时，记得用”shift”键切换中英文即可，对于大写的启用键与windows系统中一致。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;在vmware中实现共享文件夹以及安装vmware-tools&quot;&gt;&lt;a href=&quot;#在vmware中实现共享文件夹以及安装vmware-tools&quot; class=&quot;headerlink&quot; title=&quot;在vmware中实现共享文件夹以及安装vmware-tool</summary>
      
    
    
    
    <category term="Linux" scheme="http://justskim.github.io/categories/Linux/"/>
    
    
    <category term="linux" scheme="http://justskim.github.io/tags/linux/"/>
    
    <category term="虚拟机" scheme="http://justskim.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    <category term="ubuntu" scheme="http://justskim.github.io/tags/ubuntu/"/>
    
    <category term="vmware" scheme="http://justskim.github.io/tags/vmware/"/>
    
  </entry>
  
  <entry>
    <title>在linux系统创建父子进程及相关操作</title>
    <link href="http://justskim.github.io/2021/09/26/%E5%9C%A8linux%E7%B3%BB%E7%BB%9F%E5%88%9B%E5%BB%BA%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
    <id>http://justskim.github.io/2021/09/26/%E5%9C%A8linux%E7%B3%BB%E7%BB%9F%E5%88%9B%E5%BB%BA%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</id>
    <published>2021-09-26T02:16:56.153Z</published>
    <updated>2021-10-01T01:46:43.533Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在linux系统创建父子进程及相关操作"><a href="#在linux系统创建父子进程及相关操作" class="headerlink" title="在linux系统创建父子进程及相关操作"></a>在linux系统创建父子进程及相关操作</h1><h2 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h2><p><code>fork</code>这一词，在英文中有两个意思：</p><ul><li>n. 叉(挖掘用的园艺工具); 餐叉; (道路、河流等的)分岔处; 岔路;</li><li>v. 分岔出分支，走岔路中的一条。</li></ul><p><em>fork</em>函数是基本上只在Linux环境中会使用到的C语言函数，在使用时需要调用<code>unistd.h</code>这个头文件，我们在Linux环境下举例讲解<a href="https://www.jianshu.com/p/586300fdb1ce">C语言的fork()函数</a>用法：</p><blockquote><p>一个进程，包括代码、数据和分配给进程的资源。fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。</p><p><strong>一个进程调用fork（）函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。</strong></p><p>由<strong>fork函数创建的新进程</strong>被称为<strong>子进程</strong>。fork函数<strong>被调用一次</strong>，但是<strong>返回两次</strong>。父进程返回的值是<strong>新进程的进程ID</strong>，而子进程返回的值是0。</p><h4 id="fork函数返回值的三种情况"><a href="#fork函数返回值的三种情况" class="headerlink" title="fork函数返回值的三种情况"></a>fork函数返回值的三种情况</h4><ul><li>返回<strong>子进程标识符，即PID</strong>给父进程（在父进程中，fork返回新创建子进程的进程ID）<ul><li>因为一个进程的子进程可能有多个，并且<strong>没有一个函数可以获得一个进程的所有子进程ID</strong>。</li></ul></li><li>返回0给子进程（在子进程中，fork返回值为0）<ul><li>一个进程只会有一个父进程，所以子进程总是可以调用<strong>getpid</strong>以获得<strong>当前进程Id</strong>以及调用<strong>getppid</strong>获得<strong>父进程Id</strong>.</li></ul></li><li>出现错误，返回负值<ul><li>当前进程数已经达到系统规定的上限，这时errno的值被设置为EAGAIN</li><li>系统内存不足，这时errno的值被设置为ENOMEM</li></ul></li></ul><p>创建新进程成功后，系统中出现两个基本完全相同的进程，这两个进程执行没有固定的先后顺序，哪个进程先执行要看系统的进程调度策略</p></blockquote><p><a href="https://blog.csdn.net/wangww631/article/details/78413815">更加形象的解释</a>：</p><blockquote><p>“ 其实就相当于<strong>链表</strong>，进程形成了链表，<strong>父进程的fork函数返回的值指向子进程的进程id</strong>, 因为<strong>子进程没有子进程</strong>，所以其<strong>fork函数返回的值为0</strong> .</p><pre><code>调用fork之后，数据、堆、栈有两份，代码仍然为一份但是这个代码段成为两个进程的共享代码段都从fork函数中返回。当父子进程有一个想要修改数据或者堆栈时，两个进程真正分裂。</code></pre></blockquote><p>注意！子进程代码是<strong>从fork处开始执行</strong>的， 为什么不是从<code>#include</code>处开始复制代码的？这是因为fork是把 <strong>进程当前的情况拷贝一份</strong> ，执行fork时，进程已经执行完了int count&#x3D;0;fork只拷贝下一个要执行的代码到新的进程。</p><h2 id="fork函数被调用一次，返回两次，详解"><a href="#fork函数被调用一次，返回两次，详解" class="headerlink" title="fork函数被调用一次，返回两次，详解"></a>fork函数被调用一次，返回两次，详解</h2><p>来自<a href="https://blog.csdn.net/jason314/article/details/5640969">这篇博客的例子</a>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span><span class="comment">//引入pid_t类型的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="type">pid_t</span> fpid; <span class="comment">//fpid表示fork函数返回的值</span></span><br><span class="line"><span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">fpid=fork(); </span><br><span class="line"><span class="keyword">if</span> (fpid &lt; <span class="number">0</span>) </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;error in fork!&quot;</span>); <span class="comment">//fork函数返回的第一种情况，为负数，错误处理</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (fpid == <span class="number">0</span>) &#123;<span class="comment">//fork函数返回的第二种情况，在子进程中返回0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i am the child process, my process id is %d/n&quot;</span>,getpid()); </span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//fork函数返回的第三种情况，在父进程中，fork返回新创建子进程的进程ID</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i am the parent process, my process id is %d/n&quot;</span>,getpid());</span><br><span class="line">        <span class="comment">//这里因为已经在父进程中了，getpid()函数返回的是当前进程（elseif语句中进程的父进程）的进程ID</span></span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;统计结果是: %d/n&quot;</span>,count);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后运行的结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i am the child process, my process <span class="built_in">id</span> is 5574</span><br><span class="line">统计结果是: 1</span><br><span class="line">i am the parent process, my process <span class="built_in">id</span> is 5573</span><br><span class="line">统计结果是: 1</span><br></pre></td></tr></table></figure><p>借用一张图解释一下<strong>为什么同一个if else语句会执行两次，并且count的值为1而不是2</strong>：</p><p><img src="E:\JS练习\blog\Myblog\source\images\fork中的父子进程.jpg"></p><p>上面的代码都是位于语句<code>fpid=fork()</code>之后，进程1的变量为<code>count=0，fpid！=0（父进程）</code>。进程2的变量为<code>count=0，fpid=0（子进程）</code>，这两个进程的变量都是独立的，存在不同的地址中，不是共用的，这点要注意。可以说，我们就是通过<code>fpid</code>来识别和操作父子进程的。<br> 如果疑惑为什么不是从<code>#include</code>处开始复制代码的，这是因为fork是把进程当前的情况拷贝一份，执行fork时，进程已经执行完了<code>int count=0;</code>，正如我们上面所说的，<strong>子进程代码</strong>是<strong>从fork处开始执行</strong>的，fork只拷贝下一个要执行的代码到新的进程。</p><p>所以，其实执行的是两个if…else语句，输出的两个count也不是同一个。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;i son/pa ppid pid  fpid/n&quot;</span>);<span class="comment">//打印表头</span></span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">       <span class="type">pid_t</span> fpid=fork();</span><br><span class="line">       <span class="keyword">if</span>(fpid==<span class="number">0</span>)</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%d child  %4d %4d %4d/n&quot;</span>,i,getppid(),getpid(),fpid);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%d parent %4d %4d %4d/n&quot;</span>,i,getppid(),getpid(),fpid);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">    i son/pa ppid pid  fpid</span></span><br><span class="line"><span class="comment">    0 parent 2043 3224 3225     这里是最开始的那个父进程id3224，它的ppid2043我们不用管</span></span><br><span class="line"><span class="comment">    0 child  3224 3225    0子进程3225的ppid是父进程的pid</span></span><br><span class="line"><span class="comment">    1 parent 2043 3224 3226仍然是父进程id3224，又用fork创建了一个子进程3226</span></span><br><span class="line"><span class="comment">    1 parent 3224 3225 3227在这里fork返回了子进程3225创建的孙子进程3227</span></span><br><span class="line"><span class="comment">    1 child     1 3227    0</span></span><br><span class="line"><span class="comment">    1 child     1 3226    0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>从上面，我们可以看到，每次都是先执行父进程中的语句，再执行子进程中拷贝的代码语句，正如博主所说：</p><blockquote><ol><li>第一步：在父进程中，指令执行到for循环中，i&#x3D;0，接着执行fork，fork执行完后，系统中出现两个进程，分别是p3224和p3225（后面我都用pxxxx表示进程id为xxxx的进程）。可以看到父进程p3224的父进程是p2043，子进程p3225的父进程正好是p3224。我们用一个链表来表示这个关系：<br> <code>p2043-&gt;p3224-&gt;p3225</code><br> 第一次fork后，p3224（父进程）的变量为i&#x3D;0，fpid&#x3D;3225（fork函数在父进程中返向子进程id）<br> p3225（子进程）的变量为i&#x3D;0，fpid&#x3D;0（fork函数在子进程中返回0），打印出结果：<br> 0 parent 2043 3224 3225<br> 0 child  3224 3225    0</li><li>第二步：假设父进程p3224先执行，当进入下一个循环时，i&#x3D;1，接着执行fork，系统中又新增一个进程p3226，对于此时的父进程，p2043-&gt;p3224（当前进程）-&gt;p3226（被创建的子进程）。<br> 对于子进程p3225，执行完第一次循环后，i&#x3D;1，接着执行fork，系统中新增一个进程p3227，对于此进程，p3224-&gt;p3225（当前进程）-&gt;p3227（被创建的子进程）。从输出可以看到p3225原来是p3224的子进程，现在变成p3227的父进程。父子是相对的，这个大家应该容易理解。只要当前进程执行了fork，该进程就变成了父进程了，就打印出了parent。<br> 所以打印出结果是：<br> 1 parent 2043 3224 3226<br> 1 parent 3224 3225 3227 </li><li>第三步：第二步创建了两个进程p3226，p3227，这两个进程执行完printf函数后就结束了，因为这两个进程无法进入第三次循环，无法fork，该执行return 0;了，其他进程也是如此。<br> 以下是p3226，p3227打印出的结果：<br> 1 child     1 3227    0<br> 1 child     1 3226    0</li><li>细心的读者可能注意到p3226，p3227的父进程难道不该是p3224和p3225吗，怎么会是1呢？这里得讲到进程的创建和死亡的过程，在p3224和p3225执行完第二个循环后，main函数就该退出了，也即进程该死亡了，因为它已经做完所有事情了。p3224和p3225死亡后，p3226，p3227就没有父进程了，这在操作系统是不被允许的，所以p3226，p3227的父进程就被置为p1了，p1是永远不会死亡的，至于为什么，这里先不介绍。</li></ol></blockquote><p><img src="E:\JS练习\blog\Myblog\source\images\fork中的父子进程2.jpg" alt="fork中的父子进程进阶"></p><p>最后，用博主的这段打印祖孙三代关系的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">       <span class="type">pid_t</span> fpid=fork();</span><br><span class="line">       <span class="keyword">if</span>(fpid==<span class="number">0</span>)</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;son/n&quot;</span>);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;father/n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    for        i=0         1           2</span></span><br><span class="line"><span class="comment">              father     father     father</span></span><br><span class="line"><span class="comment">                                        son</span></span><br><span class="line"><span class="comment">                            son       father</span></span><br><span class="line"><span class="comment">                                        son</span></span><br><span class="line"><span class="comment">               son       father     father</span></span><br><span class="line"><span class="comment">                                        son</span></span><br><span class="line"><span class="comment">                            son       father</span></span><br><span class="line"><span class="comment">                                        son</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="pid-t类型"><a href="#pid-t类型" class="headerlink" title="pid_t类型"></a>pid_t类型</h2><p>pid_t类型是Linux下的<strong>进程号类型</strong>，在Linux环境编程中用于定义进程ID，需要引入头文件<code>&lt;sys/types.h&gt;</code>，否则会报错：<code>error:&#39;pid_t&#39; was not declared in this  scope</code>。</p><p><a href="https://blog.csdn.net/shanshu12/article/details/7896331">使用fork函数时，为什么使用pid_t而不用int</a>:</p><blockquote><p>pid_t是一个typedef定义类型，<br>sys&#x2F;types.h中的定义:<br>typedef short       pid_t;     &#x2F;* used for process ids *&#x2F;</p><p>pid_t就是一个short类型变量，实际表示的是内核中的进程表的索引</p><p>可以看到，头文件里也不过是个typedef而已.<br>使用pid_t而不使用int只是为了可移植性好一些.<br>因为在不同的平台上有可能这么定义：<br><code>typedef int pid_t</code><br>也有可能：<br><code>typedef long pid_t</code></p></blockquote><p>但是，在和fork函数配合使用时，由于进程很多时，fork函数返回的pid_t类型的子进程id，可能长度超过了int类型，需要用long int类型来存储，这时候就使用pid_t来存储子进程PID比较便于使用和移植。</p><h2 id="PID-PPID-PGID与SID"><a href="#PID-PPID-PGID与SID" class="headerlink" title="PID PPID PGID与SID"></a>PID PPID PGID与SID</h2><p>详见<a href="https://blog.csdn.net/Justdoit123_/article/details/101347971">博客</a>，在Linux中，进程都拥有以下的ID</p><ul><li><strong>Process ID</strong>(<strong>PID</strong>，也称之为<strong>进程标识</strong>)<br>Linux中标识进程的一个数字，它的值是不确定的，是由系统分配的（但是有一个例外，启动阶段,kernel运行的第一个进程是init，它的PID是1，是所有进程的最原始的父进程），每个进程都有唯一PID，当进程退出运行之后，PID就会回收，可能之后创建的进程会分配这个PID</li><li><strong>Parent</strong> Process ID(<strong>P</strong>PID)<br>字面意思，父进程的PID</li><li>Process <strong>Group</strong> ID(P<strong>G</strong>ID)<br>PGID就是进程所属的Group的Leader的PID，如果PGID&#x3D;PID，那么该进程是Group Leader</li><li><strong>Session</strong> ID(<strong>S</strong>ID)<br>和PGID非常相似，SID就是进程所属的Session Leader的PID，如果SID&#x3D;&#x3D;PID，那么该进程是session leader</li></ul><blockquote><p>Session和Group都是管理多个进程的方式，同一个Group的进程属于同一个Session，一个Session里可以包含多个Group</p></blockquote><p>注意，父进程也有<code>ppid</code>（爸爸的爸爸叫爷爷(～￣▽￣)～ ），<code>ppid</code>为<code>1</code>的进程被称之为<strong>僵尸进程</strong>，这是因为<code>linux</code>下有3个特殊的进程，<code>idle</code>进程(<code>PID = 0</code>), <code>init</code>进程(<code>PID = 1</code>)和<code>kthreadd(PID = 2</code>)。</p><p>在<code>terminal</code>中使用默认的ps命令输出的信息值包括和当前终端会话相关的进程信息，自然看不到<code>id</code>很短的进程：</p><p><img src="E:\JS练习\blog\Myblog\source\images\默认ps命令.png" alt="使用ps命令"></p><p>我们可以使用命令<code>ps --help</code>获取帮助，然后使用命令<code>ps -A</code>或<code>ps -e</code>来获取全部进程（all process）<br>![查看全部进程](E:\JS练习\blog\Myblog\source\images\ps -A命令.png)</p><h2 id="getpid和getppid函数，与fork函数产生的pid"><a href="#getpid和getppid函数，与fork函数产生的pid" class="headerlink" title="getpid和getppid函数，与fork函数产生的pid"></a>getpid和getppid函数，与fork函数产生的pid</h2><p><code>getpid</code>返回当前进程标识（也就是<code>PID</code>），<code>getppid</code>返回当前进程的父进程标识，使用这两个函数需要引入头文件<code>&lt;unistd.h&gt;</code>。</p><blockquote><p>每个进程都有一个独特（互不相同）的进程标识符（<code>process ID</code>），可以通过<code>getpid()</code>函数获得，还有一个记录父进程<code>pid</code>的变量，可以通过<code>getppid()</code>函数获得变量的值。</p></blockquote><p>这两个函数<strong>在调用中都不能返回错误</strong>，注意，返回值的<code>pid_t</code>类型 能够放进 int类型中去，返回值被转为<code>long</code> 整型输出。</p><p>！！注意，我们常用到命令<code>pid_t pid = fork()</code>产生的<code>pid</code>根据所处分支是在子进程还是在父进程而具有不同的值，同时要注意，这个<code>pid</code>的值，是<code>getpid()</code>返回的进程id刚创建的子进程<code>id</code>（没有则为0），从祖宗关系上，是<code>getppid()</code>返回的id所属的进程的孙子进程的<code>id</code>，例如下面这一段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">fencha</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> num)</span>;</span><br><span class="line">    fencha(<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fencha</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="type">int</span> pid = fork;</span><br><span class="line">    <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">&quot;ERROR\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;num)</span><br><span class="line">            fencha(i+<span class="number">1</span>,num);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;现在在父进程中&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;由fork函数产生的pid是 %d,&quot;</span>,pid)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;用getpid函数获取的值为%d，用getppid函数获取的值为%d\n&quot;</span>,getpid(),getppid());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到代码结果如下，这是一个十层的子进程递归创建，祖宗总共十代：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>注意，在上面的代码中，我们使用了sleep()函数，这是为了确保在子进程代码运行的过程中，父进程不会执行完所有代码而被内核释放掉所有资源，如果我们不使用sleep函数，如下面的代码，会导致<strong>孤儿进程（没有父进程的进程，那么照顾他的重任就落到了init进程身上）</strong>的产生。</p><p>想想看，为什么我们的代码已经执行完毕，但是id为6666的进程依然可以在ps命令中被查询到，tty为一个问号?说明该进程不是通过tty&#x2F;console启动，自然与终端terminal无关。</p><h3 id="孤儿进程与僵尸进程"><a href="#孤儿进程与僵尸进程" class="headerlink" title="孤儿进程与僵尸进程"></a>孤儿进程与僵尸进程</h3><p>这篇博客中提到了一个区别：</p><p><strong>孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</strong></p><p><strong>僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</strong></p><p>值得注意的是，照顾孤儿进程的进程id在不同版本的Linux系统中是不一样的，笔者所用的ubuntu16.04版本中由id为6666的进程负责收养孤儿进程。</p><p>虽然孤儿进程并没有危害，<strong>任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。</strong>这是每个 子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。  如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;在linux系统创建父子进程及相关操作&quot;&gt;&lt;a href=&quot;#在linux系统创建父子进程及相关操作&quot; class=&quot;headerlink&quot; title=&quot;在linux系统创建父子进程及相关操作&quot;&gt;&lt;/a&gt;在linux系统创建父子进程及相关操作&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="Linux" scheme="http://justskim.github.io/categories/Linux/"/>
    
    
    <category term="linux" scheme="http://justskim.github.io/tags/linux/"/>
    
    <category term="虚拟机" scheme="http://justskim.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    <category term="ubuntu" scheme="http://justskim.github.io/tags/ubuntu/"/>
    
    <category term="c语言" scheme="http://justskim.github.io/tags/c%E8%AF%AD%E8%A8%80/"/>
    
    <category term="进程" scheme="http://justskim.github.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
</feed>
