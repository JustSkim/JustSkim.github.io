{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://JustSkim.github.io","root":"/"},"pages":[{"title":"About me and this blog","date":"2021-08-28T00:28:35.000Z","updated":"2021-08-31T05:21:26.498Z","comments":true,"path":"about/index.html","permalink":"http://justskim.github.io/about/index.html","excerpt":"","text":"Hi~，你可以在这里看到我在此分享的一些的笔记总结，有什么有趣的事情也记得与我分享哦φ(．．) 写作业ing… 关于hexo命令的操作可以见 https://hexo.io/zh-cn/docs/commands简单地说，命令hexo g &amp;&amp; hexo s 可以方便我们在本地4000端口上查看博客效果使用命令hexo d可以将我们生成的.deploy_git文件夹推送到仓库上注意，hexo博客部署到github上名为username.github.io的仓库上，实际上是只推送.deploy_git中的文件而不是对整个项目使用push！建议每次编辑完成之后，使用hexo g &amp;&amp; hexo s先在本地查看效果，并生成相关文件再使用命令hexo d部署到Github上"},{"title":"tags","date":"2022-02-16T05:20:25.000Z","updated":"2022-02-16T05:25:53.976Z","comments":true,"path":"tags/index.html","permalink":"http://justskim.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-08-28T00:29:33.000Z","updated":"2021-08-29T14:29:42.427Z","comments":true,"path":"categories/index.html","permalink":"http://justskim.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"linux服务器上的nginx与apache","slug":"linux服务器上的nginx与apache","date":"2022-02-26T11:00:54.169Z","updated":"2022-02-26T17:34:53.926Z","comments":true,"path":"2022/02/26/linux服务器上的nginx与apache/","link":"","permalink":"http://justskim.github.io/2022/02/26/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84nginx%E4%B8%8Eapache/","excerpt":"","text":"linux服务器上的nginx与apache起因博主在进行django框架的web项目练习时，参考相关教程进行django项目在Linux云服务器上的部署。nginx无法启动服务，需要修改路径/etc/nginx/nginx.conf（使用命令yum -y install nginx默认安装）下的nginx.conf文件。而在浏览器上的web端阿里云控制台上，使用linux系统自带的vim编辑器，不像在桌面系统上编辑那么容易。因此打算使用第三方工具（如win-scp，Xshell），在本地编辑文件后直接拖拽进去替代。但是在这些终端模拟器上无法与阿里云服务器建立ssh连接，但却可以ping通云服务器的公网ip地址，如下图所示。因此博主决定深入探究，并解决该问题。 没有公网ip地址&#x3D;端口被屏蔽？博主遇到的这一个离谱的问题，当阿里云的服务器设置了白名单以及安全组等配置后，无法在家庭网络的三台主机中使用ssh命令或者第三方工具通过22端口进行连接。而在阿里云网页端的官方控制台可以远程连接。异地协助的朋友也可以在他的主机上直接使用ssh命令或者Xshell等第三方工具。 问题排查 首先是一如既往地检查阿里云服务器的安全组设置，请求客服协助，均没有问题； 在win10系统的主机上打开防火墙高级设置，设置22端口的出站规则； 使用命令netstat -ano|findstr 22查看端口，22端口和80、443等端口均没有发生占用情况； 使用手机开启移动4G热点，主机连接该热点后竟然能够成功ssh连接阿里云远程服务器！ 真正的问题所在经过问题排查的过程后，博主将目标锁定在运营商的端口规则上。 ISP的全称是Internet Service Provider，翻译为互联网服务提供商，即向广大用户综合提供互联网接入业务、信息业务、和增值业务的电信运营商。 为了了解我们的运营商屏蔽了哪些端口，我们使用站长工具中的端口扫描工具，或者相关脚本来扫描看看哪些端口可以代为使用。对博主主机扫描的结果是所有端口都被屏蔽，无法使用。。。 根据网络相关文章，这可能跟博主所用的主机并没有公网ip地址有关，以及运营商的屏蔽规则，导致正常无法使用端口。 最后，给你们介绍一下，博主家里使用的是： 123宽带类型：广电宽带业务：高清电视(IPTV)业务接入方式：光纤接入(FTTH) 80端口与Nginx与ApacheApache和Nginx都属于Web服务器（也称为WWW(WORLD WIDE WEB)服务器，主要功能是提供网上信息浏览服务），都实现了HTTP 1.1协议。我们在具体工程项目中选择哪个，都是根据应用场景来决定的，关于这两个服务器的更多异同我们将在之后进行学习探讨。 80端口是为HTTP超文本传输协议开放的端口卡相关的限制。Apache与nginx都会使用到该端口。比如博主在启动nginx时遇到的一个报错：“Address already in use…”，就说明该端口已经被其他程序所占用（大多数情况下是Apache，可能是很多软件不注意间被我们设置开机自动启动了）因此，要么将其中一个的端口进行修改，要么至启动一个（正常生产环境下的操作，无需两个都使用，功能有重复的地方） 我们使用systemctl stop httpd来结束apache服务，使用systemctl start nginx来启动nginx服务，反之亦然。 解决了nginx启动报错的问题后，我们得以部署成功，在浏览器上输入相关ip地址路由，可以成功访问到页面！","categories":[{"name":"网络","slug":"网络","permalink":"http://justskim.github.io/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://justskim.github.io/tags/%E7%BD%91%E7%BB%9C/"},{"name":"nginx","slug":"nginx","permalink":"http://justskim.github.io/tags/nginx/"},{"name":"apache","slug":"apache","permalink":"http://justskim.github.io/tags/apache/"}]},{"title":"localhost与127.0.0.1与0.0.0.0以及端口","slug":"localhost与127.0.0.1与0.0.0.0以及端口","date":"2022-02-21T17:43:42.599Z","updated":"2022-02-22T02:48:52.071Z","comments":true,"path":"2022/02/22/localhost与127.0.0.1与0.0.0.0以及端口/","link":"","permalink":"http://justskim.github.io/2022/02/22/localhost%E4%B8%8E127.0.0.1%E4%B8%8E0.0.0.0%E4%BB%A5%E5%8F%8A%E7%AB%AF%E5%8F%A3/","excerpt":"","text":"localhost与127.0.0.1与0.0.0.0以及端口起因博主在进行django框架的web项目练习时，遇到的一个问题。当博主按照所需的操作编写代码后，在网页链接栏输入http://localhost/mgr/index.html或者http://localhost/mgr/index.html#/时，都会显示404的错误提示界面，如下所示： 而只有在输入链接为127.0.0.1:4000/mgr/index.html#/时，才会出现正常界面： 与教程中唯一不同的步骤在于，博主的django应用，是使用命令python manage.py runserver 4000运行在4000端口上而不是80端口上。原因在于80端口被其他应用所占用。 如何查看端口是否被占用在win 10 系统上，打开控制台，输入命令netstat -ano可以查看所有端口的占用情况。若要查看某一个端口的占用情况，则使用诸如netstat -ano|findstr &quot;80&quot;的命令形式，注意要加双引号。查到占用该端口的进程的PID后，可以使用tasklist|find &quot;123&quot;命令查看进程，这里的123是进程PID。或者打开任务管理器，在“详细信息”一栏查看 80端口80端口是为HTTP超文本传输协议开放的端口，主要用于WWW万维网进行传输信息。其中的具体情况如下： 80端口作为http协议的默认端口，在输入网站的时候其实浏览器（非IE）已经帮忙输入协议了。所以这样一来，如果输入http://baidu.com，其实就等于访问http://baidu.com:80。因此我们访问localhost，默认是访问localhost:80 localhost与127.0.0.1的区别localhost也叫local ，正确的解释是：本地服务器 127.0.0.1在windows等系统的正确解释是：本机地址（本机服务器） 他们的解析通过本机的host文件，windows自动将localhost解析为127.0.0.1 localhost也叫local ，正确的解释是：本地服务器 127.0.0.1在windows等系统的正确解释是：本机地址（本机服务器） 他们的解析通过本机的host文件，windows自动将localhost解析为127.0.0.1 localhot（local）是不经网卡传输！这点很重要，它不受网络防火墙和网卡相关的的限制。 127.0.0.1是通过网卡传输，依赖网卡，并受到网络防火墙和网卡相关的限制。 一般设置程序时本地服务用localhost是最好的，localhost不会解析成ip，也不会占用网卡、网络资源。 有时候用localhost可以，但用127.0.0.1就不可以的情况就是在于此。 解决办法解决方法1：修改host文件用记事本打开C:&#x2F;WINDOWS&#x2F;system32&#x2F;drivers&#x2F;etc&#x2F;hosts文件，看是否有127.0.0.1 localhost 。如果没有则将其添加进去，再查看能否访问localhost。博主使用此方法，即可访问http://localhost:4000/mgr/index.html#/ 解决方法2：1、打开Internert信息管理查看IIS是否启动，且默认网站时候已经开启；2、打开http://127.0.0.1/ 看是否能访问IIS的默认网页，能访问则说明IIS已经成功安装到电脑上，可能是无法解析localhost；3、开始–命令（cmd）–ping localhost，看是否能ping通，从127.0.0.1上返回信息，如果成功则说明可以解析localhost；4、如果上一步不成功，则用记事本打开C:&#x2F;WINDOWS&#x2F;system32&#x2F;drivers&#x2F;etc&#x2F;hosts文件，看里面是否有包含：127.0.0.1 localhost ，如果没有则将其添加进去，再查看能否访问localhost。5、尝试将网站的主目录指向另一个目录或新建一个虚拟目录，并在该新目录创建一个新的网页文件，如index.html，然后将其加到默认网站的”文档”项中作为默认访问的网页，重新输入网址：http://localhost/，看否能访问。6、还是不行的话将IIS卸载掉，重新再安装一次。","categories":[{"name":"网络","slug":"网络","permalink":"http://justskim.github.io/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://justskim.github.io/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"Mysql安装的版本选择","slug":"Mysql安装的版本选择","date":"2022-02-12T10:30:47.490Z","updated":"2022-02-17T15:09:38.844Z","comments":true,"path":"2022/02/12/Mysql安装的版本选择/","link":"","permalink":"http://justskim.github.io/2022/02/12/Mysql%E5%AE%89%E8%A3%85%E7%9A%84%E7%89%88%E6%9C%AC%E9%80%89%E6%8B%A9/","excerpt":"","text":"Mysql安装的版本选择官网中的版本类别在mysql官方下载页面，可以看到有以下几个版本： MySQL Community Server 社区版本，由于开源免费因此是最常用的，但不提供官方技术支持。 MySQL Enterprise Edition 企业版本，需付费，可以试用30天。 MySQL Cluster 集群版，开源免费。可将几个MySQL Server封装成一个Server MySQL Cluster CGE 高级集群版，需付费。 MySQL Workbench（GUI TOOL）一款专为MySQL设计的ER&#x2F;数据库建模工具。它是著名的数据库设计工具DBDesigner4的继任者。MySQL Workbench又分为两个版本，分别是社区版（MySQL Workbench OSS）、商用版（MySQL Workbench SE）。 Linux中安装MySQL这里为了方便，我们使用MySQL Community Server版本来进行安装示例。 选择与Linux系统相配的安装版本注意，linux内核版本和linux系统版本是不同的概念！内核是系统的心脏，也是运行程序和管理设备的核心程序，而我们平时所说的Redhat，Ubuntu及Centos是不同的linux发行版 查看Linux内核版本命令 cat /proc/version 这个文件只有一行内容, 说明正在运行的内核版本 uname -a Linux uname（英文全拼：unix name）命令用于显示系统信息。uname 可显示电脑以及操作系统的相关信息，语法：uname [-amnrsv][--help][--version]；其中-a或–all 显示全部的信息。 查看Linux系统版本命令 使用命令lsb_release -a列出所有版本信息，如果提示未找到相关命令，则需要我们使用命令yum install -y redhat-lsb进行安装； cat /etc/redhat-release，这种方法只适合RedHat系的Linux； cat /etc/issue，/etc/issue、/etc/issue与 /etc/motd 作用一致，都是用于显示欢迎信息，可能包含Linux系统版本的信息。 查找到的结果为：CentOS Linux release 7.8.2003 我们在这里选择Linux genertic下x86_64的版本，复制相关链接，在远程服务器的Linux系统中使用wget进行下载安装。 下载得到的是一个tar压缩包，我们可以在MySQL官方提供的说明文档（这里以8.0版本为例）中 对该安装包使用命令tar -xvf解压： 我们使用的系统是Centos，因此有yum工具而没有apt，如果是ubuntu要使用apt进行安装，操作如相关教程博客： 1234apt install numactl#仅安装libaio库还不行，还要安装numactl库apt install libaio-dev 在安装完相关库之后，我们使用以下的命令： 1234567891011$&gt; groupadd mysql$&gt; useradd -r -g mysql -s /bin/false mysql$&gt; cd mysql$&gt; mkdir mysql-files$&gt; chown mysql:mysql mysql-files$&gt; chmod 750 mysql-files$&gt; bin/mysqld --initialize --user=mysql$&gt; bin/mysql_ssl_rsa_setup$&gt; bin/mysqld_safe --user=mysql &amp;# Next command is optional$&gt; cp support-files/mysql.server /etc/init.d/mysql.server 其中，如果赋相关目录MySQL用户权限的chown命令发生以下报错： 1chown: invalid user: mysql:mysql 我们需要再次通过添加执行用户名和组的方式解决： 12groupadd mysqluseradd -g mysql mysql 注意，初始化数据库时，如果提示mysqld not found错误，是由于 &#x2F;etc&#x2F;init.d&#x2F; 不存在 mysqld 这个命令","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://justskim.github.io/categories/Mysql/"},{"name":"安装","slug":"Mysql/安装","permalink":"http://justskim.github.io/categories/Mysql/%E5%AE%89%E8%A3%85/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://justskim.github.io/tags/mysql/"}]},{"title":"win10上的代理服务器设置与127.0.0.1","slug":"win10上的代理服务器设置与127.0.0.1","date":"2022-02-08T06:02:05.413Z","updated":"2022-02-08T07:13:50.206Z","comments":true,"path":"2022/02/08/win10上的代理服务器设置与127.0.0.1/","link":"","permalink":"http://justskim.github.io/2022/02/08/win10%E4%B8%8A%E7%9A%84%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE%E4%B8%8E127.0.0.1/","excerpt":"","text":"win10上的代理服务器设置与127.0.0.1代理服务器的定义代理服务器（Proxy Server）是介于浏览器和Web服务器之间的一台服务器，可被用于代理网络用户去取得网络信息。可以说，代理服务器是网络信息的中转站，是个人网络和Internet服务商之间的中间代理机构，负责转发合法的网络信息，对转发进行控制和登记，工作在OSI模型的对话层。当你通过代理服务器上网浏览时，浏览器不是直接到Web服务器去取回网页，而是向代理服务器发出请求，由代理服务器来取回浏览器所需要的信息，并传送给你的浏览器。 Win10系统提供系统级代理服务器设置，通过在Win10系统中设置代理服务器，系统中所有的软件都会通过我们设置的代理服务器访问网络，这样就不用一个一个软件设置代理服务器了，包括浏览器等应用，都会使用设定的系统代理服务器上网。 环回地址127.0.0.1127.0.0.1是回送地址主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，协议软件立即返回之，不进行任何网络传输。有时候当我们使用浏览器点击网页时，有时候会发现提示网页无法找到，建议我们检查代理服务器设置。而在win10系统的设置一栏，有一项“代理服务器”的设置，有时我们点开这里，会发现代理服务器被设置为127.0.0.1，原因不明，但将代理服务器关闭即可正常访问网络，检查host文件也没有发现异常。","categories":[{"name":"网络","slug":"网络","permalink":"http://justskim.github.io/categories/%E7%BD%91%E7%BB%9C/"},{"name":"服务器","slug":"网络/服务器","permalink":"http://justskim.github.io/categories/%E7%BD%91%E7%BB%9C/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://justskim.github.io/tags/%E7%BD%91%E7%BB%9C/"},{"name":"服务器","slug":"服务器","permalink":"http://justskim.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"在vmware虚拟机中进行网络连接","slug":"在vmware虚拟机中进行网络连接","date":"2021-11-16T07:16:40.924Z","updated":"2022-02-12T10:13:06.192Z","comments":true,"path":"2021/11/16/在vmware虚拟机中进行网络连接/","link":"","permalink":"http://justskim.github.io/2021/11/16/%E5%9C%A8vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5/","excerpt":"","text":"在vmware虚拟机中进行网络连接四种网络模式点击VMware Workstation的导航栏，在“虚拟机-&gt;设置-&gt;硬件-&gt;网络设配器”中，可看到网络连接模式的选择（不能在虚拟机挂起的时候进行更改），VMware的官方网站中说明了四种网络模式的区别： 设置 说明 使用桥接模式网络连接 为虚拟机配置桥接模式网络连接。使用桥接模式网络连接时，虚拟机将具有直接访问外部以太网网络的权限。虚拟机必须在外部网络中具有自己的 IP 地址。如果您的主机系统位于网络中，而且您拥有可用于虚拟机的单独 IP 地址（或者可以从 DHCP 服务器获得 IP 地址），请选择此设置。网络中的其他计算机将能够与该虚拟机直接通信。 使用网络地址转换 (NAT) 为虚拟机配置 NAT 连接。利用 NAT，虚拟机和主机系统将共享一个网络标识，此标识在网络以外不可见。如果您没有可用于虚拟机的单独 IP 地址，但又希望能够连接到 Internet，请选择 NAT。 使用仅主机模式网络连接 为虚拟机配置仅主机模式网络连接。仅主机模式网络连接使用对主机操作系统可见的虚拟网络适配器，在虚拟机和主机系统之间提供网络连接。使用仅主机模式网络连接时，虚拟机只能与主机系统以及仅主机模式网络中的其他虚拟机进行通信。要设置独立的虚拟网络，请选择仅主机模式网络连接。 不使用网络连接 不为虚拟机配置网络连接。 自定义（Windows 主机）或已命名的网络（Linux 主机） （仅限远程虚拟机）选择特定虚拟网络。从下拉菜单中选择一个自定义网络。尽管列表中有 VMnet0、VMnet1 和 VMnet8，但这些网络通常被用于桥接模式、仅主机模式和 NAT 模式网络。 对于使用校园网或者公司网络的用户，NAT是最简单的方式。 网络配置相关文件eth0 该文件一般位于路径“&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts”中 网络配置相关命令ifconfig 用于配置网卡的基本命令，注意不是ipconfig！ifconfig命令的英文全称是“network interfaces configuring”，即用于配置和显示Linux内核中网络接口的网络参数。用ifconfig命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。要想将上述的配置信息永远的存的电脑里，那就要修改网卡的配置文件了。 常用参数： add &lt;地址&gt; 设置网络设备IPv6的IP地址 del &lt;地址&gt; 删除网络设备IPv6的IP地址 down 关闭指定的网络设备 up 启动指定的网络设备 IP地址 指定网络设备的IP地址 一个与之相似的命令是windows系统下的ipconfig命令 ethtool 用于查询ethX网口基本设置、及设置网卡的参数 以上步骤尝试过后，依然无法解决联网问题如果在以上步骤尝试过后，依然无法解决联网问题，特别是最简单的NAT模式下，可以查看相关端口是否被杀毒软件禁止，以及服务是否成功启动。笔者在实际操作中遇到过这种情况，最后，根据这篇博客，将win10中的服务打开，手动启动或者重新启动VMware DHCP Service和VMware NAT Service两个服务即可。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://justskim.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://justskim.github.io/tags/linux/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://justskim.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://justskim.github.io/tags/ubuntu/"},{"name":"vmware","slug":"vmware","permalink":"http://justskim.github.io/tags/vmware/"}]},{"title":"python3中的运行命令与环境","slug":"python3中的运行命令与环境","date":"2021-11-08T18:35:42.058Z","updated":"2021-11-08T18:36:09.710Z","comments":true,"path":"2021/11/09/python3中的运行命令与环境/","link":"","permalink":"http://justskim.github.io/2021/11/09/python3%E4%B8%AD%E7%9A%84%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4%E4%B8%8E%E7%8E%AF%E5%A2%83/","excerpt":"","text":"python3中的运行命令与环境本机电脑仅安装python3，以下使用的均为python3环境配置 镜像是什么？镜像（Mirroring）是一种文件存储形式，是冗余的一种类型，一个磁盘上的数据在另一个磁盘上存在一个完全相同的副本即为镜像。 镜像源 就是把官方的源做一个镜像，你可以在这下载软件。 比如ubuntu官方源在国外，下载软件可能会很慢，这时候就需要换成国内的镜像源。 源 端口就是指本地端口 目的端口就是远程端口 一个数据包（pocket）被解封装成数据段（segment）后就会涉及到 连接上层协议的端口问题。 镜像网站（Mirror sites）又称之为镜像站点 anaconda环境命令行运行python程序，与idle中”Run module“的区别笔者在学习RLCard——一款卡牌游戏强化学习工具包的时候，发现了范例中的代码如下： 1234567891011121314151617181920212223242526272829import argparseimport rlcardfrom rlcard.agents import RandomAgentfrom rlcard.utils import set_seeddef run(args): # Make environment env = rlcard.make(args.env, config=&#123;&#x27;seed&#x27;: 42&#125;) num_episodes = 1 # Seed numpy, torch, random set_seed(42) # Set agents agent = RandomAgent(num_actions=env.num_actions) env.set_agents([agent for _ in range(env.num_players)]) for episode in range(num_episodes): # Generate data from the environment trajectories, player_wins = env.run(is_training=False) # Print out the trajectories print(&#x27;\\nEpisode &#123;&#125;&#x27;.format(episode)) print(trajectories)if __name__ == &#x27;__main__&#x27;: parser = argparse.ArgumentParser(&quot;Random example in RLCard&quot;) parser.add_argument(&#x27;--env&#x27;, type=str, default=&#x27;leduc-holdem&#x27;) args = parser.parse_args() run(args) 这段代码在idle中无法被“Run module”运行，却可以在命令行中运行 123456789101112131415161718192021222324252627#在idle中无法被“Run module”运行============== RESTART: E:/python练习/RLCard/examples/run_random.py ==============Traceback (most recent call last): File &quot;E:/python练习/RLCard/examples/run_random.py&quot;, line 4, in &lt;module&gt; from rlcard.agents import RandomAgent File &quot;E:\\python\\lib\\site-packages\\rlcard\\agents\\__init__.py&quot;, line 5, in &lt;module&gt; reqs = subprocess.check_output([sys.executable, &#x27;-m&#x27;, &#x27;pip&#x27;, &#x27;freeze&#x27;]) File &quot;E:\\python\\lib\\subprocess.py&quot;, line 424, in check_output return run(*popenargs, stdout=PIPE, timeout=timeout, check=True, File &quot;E:\\python\\lib\\subprocess.py&quot;, line 528, in run raise CalledProcessError(retcode, process.args,subprocess.CalledProcessError: Command &#x27;[&#x27;E:\\\\python\\\\pythonw.exe&#x27;, &#x27;-m&#x27;, &#x27;pip&#x27;, &#x27;freeze&#x27;]&#x27; returned non-zero exit status 120.#可以在命令行中运行$ python examples/run_random.pyWARNING: Ignoring invalid distribution -ip (e:\\python\\lib\\site-packages)WARNING: Ignoring invalid distribution -ip (e:\\python\\lib\\site-packages)Episode 0[[&#123;&#x27;legal_actions&#x27;: OrderedDict([(1, None), (2, None), (3, None)]), &#x27;obs&#x27;: array([0., 1., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]), &#x27;raw_obs&#x27;: &#123;&#x27;hand&#x27;: &#x27;HQ&#x27;, &#x27;public_card&#x27;: None, &#x27;all_chips&#x27;: [2, 1], &#x27;my_chips&#x27;: 2, &#x27;legal_actions&#x27;: [&#x27;raise&#x27;, &#x27;fold&#x27;, &#x27;check&#x27;], &#x27;current_player&#x27;: 0&#125;, &#x27;raw_legal_actions&#x27;: [&#x27;raise&#x27;, &#x27;fold&#x27;, &#x27;check&#x27;], &#x27;action_record&#x27;: [(1, &#x27;fold&#x27;)]&#125;], [&#123;&#x27;legal_actions&#x27;: OrderedDict([(0, None), (1, None), (2, None)]), &#x27;obs&#x27;: array([1., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]), &#x27;raw_obs&#x27;: &#123;&#x27;hand&#x27;: &#x27;HJ&#x27;, &#x27;public_card&#x27;: None, &#x27;all_chips&#x27;: [2, 1], &#x27;my_chips&#x27;: 1, &#x27;legal_actions&#x27;: [&#x27;call&#x27;, &#x27;raise&#x27;, &#x27;fold&#x27;], &#x27;current_player&#x27;: 1&#125;, &#x27;raw_legal_actions&#x27;: [&#x27;call&#x27;, &#x27;raise&#x27;, &#x27;fold&#x27;], &#x27;action_record&#x27;: [(1, &#x27;fold&#x27;)]&#125;, 2, &#123;&#x27;legal_actions&#x27;: OrderedDict([(1, None), (2, None), (3, None)]), &#x27;obs&#x27;: array([1., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]), &#x27;raw_obs&#x27;: &#123;&#x27;hand&#x27;: &#x27;HJ&#x27;, &#x27;public_card&#x27;: None, &#x27;all_chips&#x27;: [2, 1], &#x27;my_chips&#x27;: 1, &#x27;legal_actions&#x27;: [&#x27;raise&#x27;, &#x27;fold&#x27;, &#x27;check&#x27;], &#x27;current_player&#x27;: 0&#125;, &#x27;raw_legal_actions&#x27;: [&#x27;raise&#x27;, &#x27;fold&#x27;, &#x27;check&#x27;], &#x27;action_record&#x27;: [(1, &#x27;fold&#x27;)]&#125;]] 我们试着来比较这两个命令的差别： 这篇博客中介绍了sys模块的使用详情，我们只讲两个下面会使用到的函数， sys模块提供了一系列有关Python运行环境的变量和函数， sys.path返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值 sys.executable该属性是一个字符串，在正常情况下，其值是当前运行的 Python 解释器对应的可执行程序所在的绝对路径。 比如在 Windows 上使用 Anaconda 安装的 Python，该属性的值就是： 12&gt;&gt;&gt; sys.executable&#x27;E:\\\\Anaconda\\\\Anaconda\\\\python.exe&#x27; 打印结果，我们可以发现二者的绝对路径不一样，在Idle中，python解释器对应的可执行程序为pythonw.exe，而在命令行中则是python.exe python.exe与pythonw.exe Windows系统搭建好Python的环境后，进入Python的安装目录，大家会发现目录中有python.exe和pythonw.exe两个程序。 这两个程序的区别在于： 1234567891011a）、python.exe在运行程序的时候，会弹出一个黑色的控制台窗口（也叫命令行窗口、DOS/CMD窗口）； b）、pythonw.exe是无窗口的Python可执行程序，意思是在运行程序的时候，没有窗口，代码在后台执行 .py和.pyw文件的区别也来源于python.exe和pythonw.exe的区别： 安装视窗版 Python 时，扩展名为 .py 的文件被默认为用 python.exe 运行的文件，而 .pyw文件则被默认为用 pythonw.exe 运行。这里还要解释一个问题，如果.py文件直接用python.exe打开，文件被执行完成之后，视窗会立即关闭，如果想让视窗停留；给大家提供两个方法： ① 可以在程序中import time模块，加入超长睡眠语句，如time.sleep(1800)，如果你不手动关闭视窗，视窗将会停留30min； ② 可以调用sys和os模块，使用命令行语句pause 3、.pyw格式是被设计用来运行开发的纯图形界面程序的，纯图形界面程序的用户不需要看到控制台窗口。 在开发纯图形界面程序的时候，可以暂时把 .pyw 改成 .py ，运行时能调出控制台窗口，方便看到所有错误信息。 至于.pyc文件，是Python解释器运行程序的过程中产生的字节码文件（也就是中间文件）。 总之，我们尽可能地使用命令行来执行.py格式程序。","categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"},{"name":"Python3","slug":"Programming-languages-and-projects/Python3","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"}],"tags":[{"name":"python3","slug":"python3","permalink":"http://justskim.github.io/tags/python3/"},{"name":"anaconda","slug":"anaconda","permalink":"http://justskim.github.io/tags/anaconda/"}]},{"title":"python3中的生成器与迭代器","slug":"python3中的生成器与迭代器","date":"2021-11-03T01:55:18.115Z","updated":"2021-11-03T08:39:09.363Z","comments":true,"path":"2021/11/03/python3中的生成器与迭代器/","link":"","permalink":"http://justskim.github.io/2021/11/03/python3%E4%B8%AD%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/","excerpt":"","text":"python3中的生成器与迭代器生成器与迭代器在Python社区，生成器和迭代器被看作一种工具，生成器的本质就是迭代器。唯一的区别就是生成器是开发人员自己用Python代码构建的数据结构，而迭代器是Python内置提供或转化而来的。 迭代器迭代器是一种对象，该对象包含值的可计数数字。 迭代器是可迭代的对象，这意味着您可以遍历所有值。 从技术上讲，在 Python 中，迭代器是实现迭代器协议的对象，它包含方法__iter__()和 __next__()。要把对象&#x2F;类创建为迭代器，必须为对象实现 __iter__() 和 __next__() 方法。 正如您在 Python 类&#x2F;对象 一章中学到的，所有类都有名为 __init__() 的函数，它允许您在创建对象时进行一些初始化。 __iter__()方法的作用相似，您可以执行操作（初始化等），但必须始终返回迭代器对象本身。 __next__()方法也允许您执行操作，并且必须返回序列中的下一个项目。 可迭代对象（Iterable）列表、元组、字典和集合、字符串都是可迭代的对象。它们是可迭代的容器，您可以从中获取迭代器（Iterator）。 所有这些对象都有用于获取迭代器的 iter() 方法： 1234567891011121314151617181920212223242526&gt;&gt;&gt; mytuple = (&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;)myit = iter(mytuple)print(next(myit))print(next(myit))print(next(myit))&gt;&gt;&gt; mytuple = (&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;)&gt;&gt;&gt; myit=iter(mytuple)&gt;&gt;&gt; print(next(myit))apple&gt;&gt;&gt; print(next(myit))banana&gt;&gt;&gt; print(next(myit))cherry&gt;&gt;&gt; mytuple1=&quot;banana&quot;&gt;&gt;&gt; myit1=iter(mytuple1)&gt;&gt;&gt; print(next(myit))Traceback (most recent call last): File &quot;&lt;pyshell#54&gt;&quot;, line 1, in &lt;module&gt; print(next(myit))StopIteration #序列的所有项目都被迭代过，因此迭代（iteration）停止，报错&gt;&gt;&gt; print(next(myit1))b&gt;&gt;&gt; print(next(myit1))a 也可以使用 for 循环遍历可迭代对象 StopIteration 异常的使用StopIteration异常用于完成标识迭代，防止无限循环。 __next__()函数完成指定循环次数后，会触发该异常结束迭代。 12345678it = iter([1,2,3,4,5])while True: try: x = next(it) print(x) except StopIteration: break#如果不使用StopIteration，则会报错异常 将一个类当做迭代器使用把一个类作为一个迭代器使用需要在类中方法 __iter__()0与 __next__() 。 1234567891011121314151617class MyNumbers: def __iter__(self): self.a = 1 return self def __next__(self): x = self.a self.a += 1 return x myclass = MyNumbers()myiter = iter(myclass)print(next(myiter))#1print(next(myiter))#2print(next(myiter))#3print(next(myiter))#4print(next(myiter))#5 python3生成器在 Python 中，使用了 yield 的函数被称为生成器（generator）。 跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。 在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。 调用一个生成器函数，返回的是一个迭代器对象。 yield关键字我们先将yield看做return，执行下面的程序，看看结果如何？ 1234567891011121314&gt;&gt;&gt; def foo(): print(&quot;starting...&quot;) while True: res=yield 4 print(&quot;res:&quot;,res) &gt;&gt;&gt; g=foo()&gt;&gt;&gt; print(next(g))starting...4&gt;&gt;&gt; print(&quot;*&quot;*20)********************&gt;&gt;&gt; print(next(g))res: None4 原文章的博主对于执行顺序给出了以下解释： 1.程序开始执行以后，因为foo函数中有yield关键字，所以foo函数并不会真的执行，而是先得到一个生成器g(相当于一个对象) 2.直到调用next方法，foo函数正式开始执行，先执行foo函数中的print方法，然后进入while循环 3.程序遇到yield关键字，然后把yield想象成return，return了一个4之后，程序停止，并没有执行赋值给res操作，此时next(g)语句执行完成，所以输出的前两行（第一行“starting…”是while上面的print的结果，第二行“4”是return出的结果）是执行print(next(g))的结果，注意并没有执行yield一句下一行的print(“res:”,res)语句 4.程序执行print(“*“*20)，输出20个* 5.又开始执行下面的print(next(g))，不同的是，这一次从刚才那个next程序停止的地方开始执行的，也就是要从yield语句的下一行语句开始，执行res的赋值操作，这时候要注意，这个时候赋值操作的右边是没有值的（因为刚才那个是return出去了，并没有给赋值操作的左边传参数），所以这个时候res赋值是None,所以接着下面的输出就是res:None 6.程序会继续在while里执行，又一次碰到yield,这个时候同样return 出4，然后程序停止，print函数输出的4就是这次return出的4. 带yield的函数是一个生成器，可以不再看做一个函数了。这个生成器有一个next函数，相当于“下一步”生成哪个数，这一次的next开始的地方是接着上一次的next停止的地方执行的，所以调用next的时候，生成器并不会从foo函数的开始执行，只是接着上一步停止的地方开始，然后遇到yield后，return出要生成的数，此步就结束。 我们接着上面的代码，继续输出next(g)，每一次的next开始的地方都是上一次的next停止的地方： 123456&gt;&gt;&gt; print(next(g))res: None4&gt;&gt;&gt; print(next(g))res: None4 也就是说，除了第一次next函数可能会特殊（循环体外的代码部分执行原因），每次我们使用next函数，都是从上一个yield停止的地方，开始跑代码，跑到下一个yield语句，return了值， 停止。下面的例子更加直观一些： 12345678910111213141516171819202122232425262728&gt;&gt;&gt; def fo(n): print(&quot;fo start!&quot;) while True: #注意，因为下一次next函数执行在循环体中开始，因此要再接一轮while判断，而不会执行循环体外面的上一行print(&quot;fo start&quot;)语句 print(&quot;before yield, n = &quot;,n) n = n + 1 res = yield n #跑到这里结束 print(&quot;after yield, n = &quot;,n) #从这里开始&gt;&gt;&gt; x = fo(1)&gt;&gt;&gt; print(next(x))fo start!before yield, n = 12&gt;&gt;&gt; print(next(x))after yield, n = 2before yield, n = 23&gt;&gt;&gt; print(next(x))after yield, n = 3before yield, n = 34&gt;&gt;&gt; print(next(x))after yield, n = 4before yield, n = 45&gt;&gt;&gt; print(next(x))after yield, n = 5before yield, n = 56","categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"},{"name":"Python3","slug":"Programming-languages-and-projects/Python3","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"}],"tags":[{"name":"python3","slug":"python3","permalink":"http://justskim.github.io/tags/python3/"}]},{"title":"python3中的一些常见语法糖整理","slug":"python3中的一些常见语法糖","date":"2021-10-31T12:02:01.432Z","updated":"2021-11-08T18:11:54.922Z","comments":true,"path":"2021/10/31/python3中的一些常见语法糖/","link":"","permalink":"http://justskim.github.io/2021/10/31/python3%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E8%AF%AD%E6%B3%95%E7%B3%96/","excerpt":"","text":"python3中的一些常见语法糖整理输入输出的类型提示123class Solution: def addBinary(self, a: str, b: str) -&gt; str: return str 学过C语言的同学，都懂得，参数中a，b要求为str类型的输入参数 在定义函数时，在def那一行后面会加一个-&gt;。这个玩意儿有个专门的名词叫 type hint， 即类型提示。这里就是说返回的数据类型为str。 在Python中，str 表示字符串类 ，也可以是将变量强制转换为字符串的函数，写作str () 类型标注 int,long,float: 整型,长整形,浮点型 bool,str: 布尔型，字符串类型 List, Tuple, Dict, Set:列表，元组，字典, 集合 Iterable,Iterator:可迭代类型，迭代器类型 Generator：生成器类型 限定函数参数类型及输出1def foo(text:&#x27;str&#x27;,max:&#x27;int &gt; 0&#x27; = 100,min:&#x27;int &gt; 0&#x27;)-&gt;str: 在限定函数参数类型的同时还可以限定参数的范围以及默认值。 注意！在函数定义时，第一个带有默认值的参数之后的所有参数都必须有默认值，否则，运行时报错 函数定义时的和*在参数前面加上*号 ，意味着参数个数不止一个，而带一个星号*参数的函数传入的参数存储为一个元组（tuple），带两个*号则是表示字典（dict）。 *将参数按顺序一一赋值，而dict类型则是将字典的keys作为函数参数进行赋值。 **参数方式则要求输入必须是一个dict，而且变量名称要与函数定义的变量名称一致 1234567891011121314151617181920212223242526272829303132333435363738&gt;&gt;&gt; def func1(a, *b): print(a) print(b) print(type(b))&gt;&gt;&gt; def func2(a, **b): print(a) print(b) print(type(b))&gt;&gt;&gt; def func3(a, *b, **c): print(a) print(b) print(c)&gt;&gt;&gt; func1(1,2,3,4)1(2, 3, 4)&lt;class &#x27;tuple&#x27;&gt;&gt;&gt;&gt; func1(1111,(2,3))1111((2, 3),) #如果传入一个元组，该元组会被当成元组的第一个参数&lt;class &#x27;tuple&#x27;&gt;&gt;&gt;&gt; func2(1,2,3)Traceback (most recent call last): File &quot;&lt;pyshell#17&gt;&quot;, line 1, in &lt;module&gt; func2(1,2,3)TypeError: func2() takes 1 positional argument but 3 were given&gt;&gt;&gt; func2(1,x=1,y=2) #传入的字典参数必须有key和value1&#123;&#x27;x&#x27;: 1, &#x27;y&#x27;: 2&#125;&lt;class &#x27;dict&#x27;&gt;&gt;&gt;&gt; func2(111,&#123;x=22,y=44&#125;) #注意是传入的参数作为字典，不能传入dict类型的参数！SyntaxError: invalid syntax&gt;&gt;&gt; func3(1,2,3,4,x=5,y=6)1(2, 3, 4)&#123;&#x27;x&#x27;: 5, &#x27;y&#x27;: 6&#125; 在调用时，*主要是用来解压参数列表，对于set、tuple、list、dict(会取其values的值)类型的数据都适用 另外一个值得注意的就是参数的顺序，我们知道，最正规的写法就是将这三个参数按*号从少到多排列，那换一种写法呢？ 12345678910&gt;&gt;&gt; def func4(a,**b,*c):SyntaxError: invalid syntax #**参数方式在*参数方式之前，无效&gt;&gt;&gt; def func5(*b,a): #*参数方式在不带*的参数之前，可以定义，但注意输入！！ print(b,&#x27;\\n&#x27;,a)&gt;&gt;&gt; def func5(**b,a): #**参数方式在不带*参数方式之前，无效SyntaxError: invalid syntax&gt;&gt;&gt; def func5(**b,*c): #**参数方式在*参数方式之前，无效SyntaxError: invalid syntax&gt;&gt;&gt; def func5(*b,**c): #没有不带*的参数，*参数方式在**参数方式之前，有效 print(b,c) 但是要注意的是，如果带*的参数在不带*的参数之前，输入的时候要进行明确参数赋值： 1234567891011&gt;&gt;&gt; def func6(*b,a): print(b) print(&quot;a=&quot;,a)&gt;&gt;&gt; func6(1,2,3,4,5,&#x27;222&#x27;,333)Traceback (most recent call last): File &quot;&lt;pyshell#38&gt;&quot;, line 1, in &lt;module&gt; func6(1,2,3,4,5,&#x27;222&#x27;,333)TypeError: func6() missing 1 required keyword-only argument: &#x27;a&#x27;&gt;&gt;&gt; func6(1,2,3,4,5,&#x27;222&#x27;,a=333) #输入的时候要进行明确参数赋值(1, 2, 3, 4, 5, &#x27;222&#x27;)a= 333 函数参数中的selfPython类中规定，函数的第一个参数是实例对象本身，并且约定俗成，把其名字写为self。其作用相当于java中的this，表示当前类的对象，可以调用当前类中的属性和方法。 在菜鸟教程中，对于python类有如下介绍： 类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。 方法：类中定义的函数。 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。 数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。 局部变量：定义在方法中的变量，只作用于当前实例的类。 实例变量：在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。 实例化：创建一个类的实例，类的具体对象。 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。 class是面向对象的设计思想，instance（也即是 object，对象）是根据 class 创建的。在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self, 且为第一个参数，self 代表的是类的实例而不是类！self 代表的是类的实例，代表当前对象的地址，而 self.class 则指向类。self 不是 python 关键字，我们把他替换成合格的字符串形式参数也是可以正常执行的。 类中的__init__方法类有一个名为·__init__() 的特殊方法（构造方法），该方法在类实例化时会自动调用 123456class Complex: def __init__(self, realpart, imagpart): self.r = realpart self.i = imagpartx = Complex(3.0, -4.5)print(x.r, x.i) # 输出结果：3.0 -4.5 python 类的继承Python 同样支持类的继承，如果一种语言不支持继承，类就没有什么意义。 子类（派生类 DerivedClassName）会继承父类（基类 BaseClassName）的属性和方法。 BaseClassName（实例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用: 1234567891011121314151617181920212223242526272829#!/usr/bin/python3#类定义class people: #定义基本属性 name = &#x27;&#x27; age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age)) #单继承示例class student(people): grade = &#x27;&#x27; def __init__(self,n,a,w,g): #调用父类的构函 people.__init__(self,n,a,w) self.grade = g #覆写父类的方法 def speak(self): print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade))s = student(&#x27;ken&#x27;,10,60,3)s.speak()#执行结果：ken 说: 我 10 岁了，我在读 3 年级 python也支持多重继承 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#!/usr/bin/python3 #类定义class people: #定义基本属性 name = &#x27;&#x27; age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age)) #单继承示例class student(people): grade = &#x27;&#x27; def __init__(self,n,a,w,g): #调用父类的构函 people.__init__(self,n,a,w) self.grade = g #覆写父类的方法 def speak(self): print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade)) #另一个类，多重继承之前的准备class speaker(): topic = &#x27;&#x27; name = &#x27;&#x27; def __init__(self,n,t): self.name = n self.topic = t def speak(self): print(&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;%(self.name,self.topic)) #多重继承class sample(speaker,student): a =&#x27;&#x27; def __init__(self,n,a,w,g,t): student.__init__(self,n,a,w,g) speaker.__init__(self,n,t) test = sample(&quot;Tim&quot;,25,80,4,&quot;Python&quot;)test.speak() #方法名同，默认调用的是在括号中排前地父类的方法#执行结果：我叫 Tim，我是一个演说家，我演讲的主题是 Python 类的私有属性__private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs。 类的方法在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self，且必须为第一个参数，self 代表的是类的实例。 self 的名字并不是规定死的，也可以使用 this，但是最好还是按照约定使用 self。 类的私有方法__private_method：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。self.__private_methods。 lambda表达式（匿名函数）如果一个函数的函数体仅有 1 行，那么该函数就可以用 lambda 表达式来代替，下面两个函数在表达效果上是相等的： 123def name(arg1,...argn): return 表达式name = lambda [arg1 [,arg2,.....argn]]: 表达式 定义 lambda 表达式，必须使用 lambda 关键字，注意冒号前是参数，可以有多个，用逗号隔开，冒号右边的为表达式（只能为一个）。其实lambda返回值是一个函数的地址，也就是函数对象。 注意传入的参数必须用逗号隔开，下面这么定义是错误的： 12345&gt;&gt;&gt; add = lambda [x,y]:x+ySyntaxError: invalid syntax&gt;&gt;&gt; add = lambda x,y:x+y&gt;&gt;&gt; add(2,3)5 python中的5种下划线形式 单前导下划线：**_var** 单末尾下划线：var_ 双前导下划线：**__var** 双前导和末尾下划线：__var__ 单下划线：**_** 单前导下划线：**_var**，前置单下划线只有约定含义。它对于程序员而言是一种提示——Python社区约定好单下划线表达的是某种意思，其本身并不会影响程序的行为。 前置下划线的意思是提示其他程序员，以单下划线开头的变量或方法只在内部使用。PEP 8中定义了这个约定（PEP 8是最常用的Python代码风格指南。 详见PEP 8：“Style Guide for Python Code”。 不过，这个约定对Python解释器并没有特殊含义。与Java不同，Python在“私有”和“公共”变量之间并没有很强的区别。在变量名之前添加一个下划线更像是有人挂出了一个小小的下划线警告标志：“注意，这并不是这个类的公共接口。最好不要使用它。” 我们实例化一个类，并为其添加一个使用单前导下划线的属性： 123456789class Test: def __init__(self): self.foo = 11 self._bar = 23&gt;&gt;&gt; t = Test()&gt;&gt;&gt; t.foo11&gt;&gt;&gt; t._bar23 _bar前面的单下划线并没有阻止我们“进入”这个类访问变量的值。 这是因为Python中的前置单下划线只是一个公认的约定，至少在涉及变量名和方法名时是这样的。 使用单前导下划线需要注意的是，前置下划线会影响从模块中导入名称的方式，如果使用通配符*导入从这个模块中导入所有名称，Python不会导入带有前置单下划线的名称（除非模块中定义了__all__列表覆盖了这个行为： 123456789101112# 在my_module.py中这么定义：def external_func(): return 23def _internal_func(): return 42#在idle或另一个py文件中导入&gt;&gt;&gt; from my_module import *&gt;&gt;&gt; external_func()23&gt;&gt;&gt; _internal_func()NameError: &quot;name &#x27;_internal_func&#x27; is not defined&quot; 值得注意的是：要尽可能避免使用通配符*导入，因为这样就不清楚当前名称空间中存在哪些名称了。为了清楚起见，最好坚持使用常规导入方法。与通配符导入不同，常规导入不受前置单下划线命名约定的影响. 遵循PEP 8的建议不使用通配符导入，那么真正需要记住的只有下面这一条。以单下划线开头的名称只是Python命名中的约定，表示供内部使用。它通常对Python解释器没有特殊含义，仅仅作为对程序员的提示。 单末尾下划线：var_有时某个变量最合适的名称已被Python语言中的关键字占用。因此，诸如class或def的名称不能用作Python中的变量名。在这种情况下，可以追加一个下划线来绕过命名冲突。PEP 8中定义并解释了这个用一个单末尾下划线来避免与python关键字冲突的约定。 1234&gt;&gt;&gt; def func(name,class):SyntaxError: invalid syntax&gt;&gt;&gt; def func(name,class_): pass 上面介绍的单下划线（无论放在前边还是末尾），都只是约定的作用。 双前导下划线：**__var**上面介绍的单下划线（无论放在前边还是末尾），都只是约定的作用。 但使用以双下划线开头的Python类属性（变量和方法）就不一样了。 双下划线前缀会让Python解释器重写属性名称，以避免子类中的命名冲突。 这也称为名称改写（name mangling），即解释器会更改变量的名称，以便在稍后扩展这个类时避免命名冲突。 双前导和末尾下划线：__var__一些特殊的双前导和末尾下划线 __all__ 不像 Ruby 或者 Java，Python 没有语言原生的可见性控制，而是靠一套需要大家自觉遵守的”约定“下工作。比如下划线开头的应该对外部不可见。同样，__all__ 也是对于模块公开接口的一种约定，比起下划线，__all__ 提供了暴露接口用的”白名单“。一些不以下划线开头的变量（比如从其他地方 import 到当前模块的成员）可以同样被排除出去。 当我们向文件导入某个模块时，导入的是该模块中那些名称不以下划线（单下划线“_”或者双下划线“__”）开头的变量、函数和类。因此，如果我们不想模块文件中的某个成员被引入到其它文件中使用，有两种方法： 在其名称前添加单下划线。 借助模块提供的__all__ 变量，该变量的值是一个列表，存储的是当前模块中一些成员（变量、函数或者类）的名称。 通过在模块文件中设置__all__变量，当其它文件以“from 模块名 import *”的形式导入该模块时，该文件中只能使用__all__ 列表中指定的成员。__all__也是对于模块公开接口的一种约定，比起下划线，__all__提供了暴露接口用的“白名单”。 ———————————————— 版权声明：本文为CSDN博主「-徐徐图之-」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/zylooooooooong/article/details/115564782 __init__ 在创建类时，我们可以手动添加一个__init__()方法，该方法是一个特殊的类实例方法，称为构造方法（或构造函数）。 构造方法用于创建对象时使用，每当创建一个类的实例对象时，Python 解释器都会自动调用它。 __init__() 方法可以包含多个参数，但必须包含一个名为 self 的参数，且必须作为第一个参数。 即便不手动为类添加任何构造方法，Python 也会自动为类添加一个仅包含 self 参数的构造方法。 如果子类中不重写__init__，实例化子类时，就会调用父类中定义的__init__: 1234567891011121314151617class Father(object): def __init__(self, name): self.name=name print ( &quot;name: %s&quot; %( self.name) ) def getName(self): return &#x27;Father &#x27; + self.name class Son(Father): def getName(self): return &#x27;Son &#x27;+self.name if __name__==&#x27;__main__&#x27;: son=Son(&#x27;runoob&#x27;) print ( son.getName() )#输出结果name: runoobSon runoob 如果重写了**init** 时，实例化子类，就不会调用父类已经定义的 **init**，语法格式如下： 1234567891011121314151617181920class Father(object): def __init__(self, name): self.name=name print ( &quot;name: %s&quot; %( self.name) ) def getName(self): return &#x27;Father &#x27; + self.name class Son(Father): def __init__(self, name): print ( &quot;hi&quot; ) self.name = name def getName(self): return &#x27;Son &#x27;+self.name if __name__==&#x27;__main__&#x27;: son=Son(&#x27;runoob&#x27;) print ( son.getName() )#输出结果：hiSon runoob 若重写了__init__，还要继承父类的构造方法，可以使用super关键字。 1234567891011121314151617181920212223class Father(object): def __init__(self, name): self.name=name print ( &quot;name: %s&quot; %( self.name)) def getName(self): return &#x27;Father &#x27; + self.name class Son(Father): def __init__(self, name): super(Son, self).__init__(name) print (&quot;hi&quot;) self.name = name def getName(self): return &#x27;Son &#x27;+self.name if __name__==&#x27;__main__&#x27;: son=Son(&#x27;runoob&#x27;) print ( son.getName() ) #输出结果如下：name: runoobhiSon runoob 也可以直接调用父类的__init__类方法： 1234567891011&gt;&gt;&gt; dad = Father(&#x27;luo&#x27;)name: luo&gt;&gt;&gt; dad.__init__()Traceback (most recent call last): File &quot;&lt;pyshell#10&gt;&quot;, line 1, in &lt;module&gt; dad.__init__()TypeError: __init__() missing 1 required positional argument: &#x27;name&#x27;&gt;&gt;&gt; dad.__init__(&quot;WHALE&quot;)name: WHALE&gt;&gt;&gt; dad.name&#x27;WHALE&#x27; __name__ 一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用__name__属性来使该程序块仅在该模块自身运行时执行。 123456789101112131415#!/usr/bin/python3# Filename: using_name.pyif __name__ == &#x27;__main__&#x27;: print(&#x27;程序自身在运行&#x27;)else: print(&#x27;我来自另一模块&#x27;)#以下是程序运行结果$ python using_name.py #在模块自身运行时程序自身在运行$ python&gt;&gt;&gt; import using_name #在模块被引用时我来自另一模块&gt;&gt;&gt; 注意：每个模块都有一个__name__属性，当其值是__main__时，表明该模块自身在运行，否则是被引入。 单下划线：**_**有时候单个独立下划线是用作一个名字，来表示某个变量是临时的或无关紧要的。 例如，在下面的循环中，我们不需要访问正在运行的索引，我们可以使用”_”来表示它只是一个临时值： 12&gt;&gt;&gt; for _ in range(32):... print(&#x27;Hello, World.&#x27;) 你也可以在拆分(unpacking)表达式中将单个下划线用作”不关心的”变量，以忽略特定的值。 同样，这个含义只是”依照约定”，并不会在Python解释器中触发特殊的行为。 单个下划线仅仅是一个有效的变量名称，会有这个用途而已。 在下面的代码示例中，我将汽车元组拆分为单独的变量，但我只对颜色和里程值感兴趣。 但是，为了使拆分表达式成功运行，我需要将包含在元组中的所有值分配给变量。 在这种情况下，”_”作为占位符变量可以派上用场： 123456789&gt;&gt;&gt; car = (&#x27;red&#x27;, &#x27;auto&#x27;, 12, 3812.4)&gt;&gt;&gt; color, _, _, mileage = car&gt;&gt;&gt; color&#x27;red&#x27;&gt;&gt;&gt; mileage3812.4&gt;&gt;&gt; _12 除了用作临时变量之外，”_”是大多数Python REPL中的一个特殊变量，它表示由解释器评估的最近一个表达式的结果。 这样就很方便了，比如你可以在一个解释器会话中访问先前计算的结果，或者，你是在动态构建多个对象并与它们交互，无需事先给这些对象分配名字： 1234567891011121314&gt;&gt;&gt; 20 + 323&gt;&gt;&gt; _23&gt;&gt;&gt; print(_)23&gt;&gt;&gt; list()[]&gt;&gt;&gt; _.append(1)&gt;&gt;&gt; _.append(2)&gt;&gt;&gt; _.append(3)&gt;&gt;&gt; _[1, 2, 3] 对于上面五种类型的下划线，菜鸟教程的小结可以很好的帮助我们：","categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"},{"name":"Python3","slug":"Programming-languages-and-projects/Python3","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"}],"tags":[{"name":"python3","slug":"python3","permalink":"http://justskim.github.io/tags/python3/"}]},{"title":"linux的进程优先级与进程调度策略","slug":"linux的进程优先级与进程调度策略","date":"2021-10-23T12:38:09.488Z","updated":"2021-10-25T07:05:02.833Z","comments":true,"path":"2021/10/23/linux的进程优先级与进程调度策略/","link":"","permalink":"http://justskim.github.io/2021/10/23/linux%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%8E%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/","excerpt":"","text":"linux的进程优先级与进程调度策略linux中的进程调度策略FIFO，RR，OTHER 实时进程会抢占普通进程，FIFO会导致同优先级实时进程始终占用CPU，RR会保证同优先级实时进程按时间片轮流执行。 上面说的很通俗易懂，那么，两个同等优先级的FIFO实时进程，是不是谁先占据了cpu，另一个就只能等待它完成了让出CPU呢？ 其实不尽然，即使是在单核cpu的linux系统中，FIFO实时进程也会被调度。 具体可见博客： cnblogs.com&#x2F;tongye&#x2F;p&#x2F;9575602.html blog.csdn.net&#x2F;qq_37451250&#x2F;article&#x2F;details&#x2F;104807725 C语言中的进程优先级设置创建实时进程与普通进程略有区别——在创建普通进程的基础上，将调度类从CFS（completely fair完全公平调度类）转向RT类（实时调度类型，包括RR和FIFO） 常见的几个进程优先级设置与取得函数（位于头文件sched.h中）： sched_get_priority_max() 取得静态优先级的上限 sched_get_priority_min() 取得静态优先级的下限 sched_getparam()取得进程的调度参数 sched_setparam()设置进程的调度参数 sched_getscheduler()取得指定进程的调度类 sched_setscheduler()设置指定进程的调度类 int sched_getscheduler(pid_t pid, int policy, const struct sched_param *param) 第一个参数是进程号（0表示本进程），第二个参数为调度类（SCHED_RR为2、SCHED_FIFO为1、SCHED_OTHER为0，三个之一） ，第三个参数是一个struct sched_param 类型的调度参数——其sched_priority成员可以指定优先级。 sched_rr_get_interval()取得按RR算法调度的实时进程的时间片长度 sched_yield()进程主动让出处理器并将自己挂入等候调度队列的队尾 sched文件 C语言system函数 执行 dos(windows系统) 或 shell(Linux&#x2F;Unix系统) 命令，参数字符串command为命令名。另，在windows系统下参数字符串不区分大小写。 说明：在windows系统中，system函数直接在控制台调用一个command命令。在Linux&#x2F;Unix系统中，system函数会调用fork函数产生子进程，由子进程来执行command命令，命令执行完后随即返回原调用的进程。 函数返回值命令执行成功返回0，执行失败返回-1。 C语言sprintf函数 int sprintf( char *buffer, const char *format, [ argument] … )； 这个函数包含三个部分的参数： buffer：char型指针，指向将要写入的字符串的缓冲区。format：格式化字符串。即可选参数的想要输入的数据类型。[argument]…：可选参数，可以是任何类型的数据。 这个函数就是把第三部分的数据，按照第二部分格式化字符的格式，把第三部分的数据进行”格式化“，然后在把格式化后的数据类型，存储到字符串的缓存区间里去。 通过查看&#x2F; proc &#x2F;&lt; PID&gt; &#x2F; sched中的调度统计信息(scheduling stats in /proc/&lt;PID&gt;/sched),您可以获得如下输出（仅限进程运行着的时候） 为了在进程退出后依然能看到这些调度统计信息，我们可以使用以上代码将其存储至本目录的sched-pid文件中 &gt; nr_switches：上下文切换次数.&gt; nr_voluntary_switches：自愿切换的数量,即线程被阻塞,因此拾取另一个线程.&gt; nr_involuntary_switches：调度程序将线程踢出,因为有另一个饥饿的线程已准备好运行. C语言中的进程调度函数","categories":[{"name":"Linux","slug":"Linux","permalink":"http://justskim.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://justskim.github.io/tags/linux/"}]},{"title":"在vmware中“/mnt/hgfs”路径下共享文件夹的挂载","slug":"在vmware中“mnthgfs”路径下共享文件夹的挂载","date":"2021-10-23T12:13:05.314Z","updated":"2021-10-23T12:28:45.188Z","comments":true,"path":"2021/10/23/在vmware中“mnthgfs”路径下共享文件夹的挂载/","link":"","permalink":"http://justskim.github.io/2021/10/23/%E5%9C%A8vmware%E4%B8%AD%E2%80%9Cmnthgfs%E2%80%9D%E8%B7%AF%E5%BE%84%E4%B8%8B%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E6%8C%82%E8%BD%BD/","excerpt":"","text":"在vmware中“&#x2F;mnt&#x2F;hgfs”路径下共享文件夹的挂载在之前的博客中，我们已经讲过如何在vmware虚拟机中设置共享文件夹，mnt目录是挂接光驱、USB设备的目录，在其中进行文件操作需要有root权限。linux系统中一定会有&#x2F;mnt目录，但其下不一定有hgfs目录，在我们成功安装完VMWare tools后会出现hgfs文件夹，但一些情况下hgfs文件夹中可能不存在我们之前在虚拟机中设置的共享文件夹名称，下面是解决办法 &#x2F;mnt路径下有hgfs但却没有共享文件夹先进入到root权限下，使用命令vmware-hgfsclient来查看当前有哪些共享的目录，如果未能成功安装VMWare tools则该命令会导致报错。 然后使用命令mount -t vmhgfs .host:/你所设置的共享文件夹名称 /mnt/hgfs来挂载共享文件夹即可。 以上设置后每次重新开机都要重复设置一次共享文件夹，我们使用在文件/etc/fstab中进行修改来设置开机后自动挂载： 在文件/etc/fstab中添加以下一行：.host:/mnt/hgfs vmhgfs defaults 0 0","categories":[{"name":"Linux","slug":"Linux","permalink":"http://justskim.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://justskim.github.io/tags/linux/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://justskim.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://justskim.github.io/tags/ubuntu/"},{"name":"vmware","slug":"vmware","permalink":"http://justskim.github.io/tags/vmware/"}]},{"title":"linux的权限与隐藏权限","slug":"linux的权限与隐藏权限","date":"2021-09-27T12:26:36.587Z","updated":"2021-09-29T02:11:21.640Z","comments":true,"path":"2021/09/27/linux的权限与隐藏权限/","link":"","permalink":"http://justskim.github.io/2021/09/27/linux%E7%9A%84%E6%9D%83%E9%99%90%E4%B8%8E%E9%9A%90%E8%97%8F%E6%9D%83%E9%99%90/","excerpt":"","text":"linux的权限与隐藏权限linux的权限linux中的文件类型 linux一共有7种文件类型,分别如下: ​ -：普通文件 ​ d：目录文件 ​ l： 软链接（类似Windows的快捷方式） ​ (下面四种是特殊文件) ​ b：块设备文件（例如硬盘、光驱等） ​ p：管道文件 ​ c：字符设备文件（例如猫等串口设备） ​ s：套接口文件&#x2F;数据接口文件（例如启动一个MySql服务器时会产生一个mysql.sock文件） linux的隐藏权限除了文件的读写,执行权限外,linux还有一种隐藏权限,设置隐藏权限可以防止一些其他用户的误操作或者恶意操作,当我们配置了nginx的放跨站攻击或其他安全措施后,相应的会在项目的根目录下生成一个隐藏文件.user.ini,当删除整个项目时会阻止操作完成.我们使用ls命令并使用chmod chown等命令设置了文件权限后会发现还是无法删除.这就是因为这个文件有隐藏的权限。 linux系统的隐藏权限总共有以下十三种类型： A：即Atime，告诉系统不要修改对这个文件的最后访问时间； S：即Sync，一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘； a：即Append Only，系统只允许在这个文件之后追加数据，不允许任何进程覆盖或截断这个文件。如果目录具有这个属性，系统将只允许在这个目录下建立和修改文件，而不允许删除任何文件； b：不更新文件或目录的最后存取时间； c：将文件或目录压缩后存放； d：当dump程序执行时，该文件或目录不会被dump备份； D:检查压缩文件中的错误； i：即Immutable，系统不允许对这个文件进行任何的修改。如果目录具有这个属性，那么任何的进程只能修改目录之下的文件，不允许建立和删除文件； s：彻底删除文件，不可恢复，因为是从磁盘上删除，然后用0填充文件所在区域； u：当一个应用程序请求删除这个文件，系统会保留其数据块以便以后能够恢复删除这个文件，用来防止意外删除文件或目录； t:文件系统支持尾部合并（tail-merging）； X：可以直接访问压缩文件的内容 e: 表示文件以ext4 extents存储的，ext4上新建文件的默认属性，不可用chattr修改。 使用命令chattr +权限类型和chattr -权限类型可以为文件添加或删除隐藏权限 chattr命令提到文件权限的修改，必然绕不过这一命令，根据C语言中文网（这个网站怎么啥都有）： chattr 命令，专门用来修改文件或目录的隐藏属性，只有 root 用户可以使用。该命令的基本格式为： [root@localhost ~]# chattr [+-&#x3D;] [属性] 文件或目录名 下面是常用chattr命令来授予&#x2F;删除的一些属性： 属性选项 功能 i 如果对文件设置 i 属性，那么不允许对文件进行删除、改名，也不能添加和修改数据； 如果对目录设置 i 属性，那么只能修改目录下文件中的数据，但不允许建立和删除文件； a 如果对文件设置 a 属性，那么只能在文件中増加数据，但是不能删除和修改数据； 如果对目录设置 a 属性，那么只允许在目录中建立和修改文件，但是不允许删除文件； u 设置此属性的文件或目录，在删除时，其内容会被保存，以保证后期能够恢复，常用来防止意外删除文件或目录。 s 和 u 相反，删除文件或目录时，会被彻底删除（直接从硬盘上删除，然后用 0 填充所占用的区域），不可恢复。 b 不更新文件或目录的最后存取时间。 c 将文件或目录压缩后存放。 d 将文件或目录排除在倾倒操作之外 S 即时更新文件或目录","categories":[{"name":"Linux","slug":"Linux","permalink":"http://justskim.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://justskim.github.io/tags/linux/"}]},{"title":"在vmware中实现共享文件夹以及安装vmware-tools","slug":"在vmware中实现共享文件夹以及安装vmware-tools","date":"2021-09-27T11:27:13.351Z","updated":"2021-10-01T01:46:47.786Z","comments":true,"path":"2021/09/27/在vmware中实现共享文件夹以及安装vmware-tools/","link":"","permalink":"http://justskim.github.io/2021/09/27/%E5%9C%A8vmware%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85vmware-tools/","excerpt":"","text":"在vmware中实现共享文件夹以及安装vmware-tools原因：想要设置共享文件夹，而ubuntu16.04版本系统中，只有文件夹mnt，其中没有文件夹hgfs，而按照网上教程操作，需要重新安装vmware-tools才能使得该选项可以点击，然而虚拟机菜单栏中，“重新安装vmware-tool”的选项为灰色不可点击 首先使用命令su root跳转至超级用户权限， 然后，使用命令apt-get install open-vmware-tools安装， 注意，完成之后，在文件夹media下面会有以下的文件 我们如果在media文件夹中使用tar命令对 文件 进行解压缩，会发现出错，大量的报错语句： tar: vmware-tools-distrib: Cannot mkdir: Read only file system 然后我们使用命令su root输入密码进入超级用户权限，再次尝试解压缩，依然出错！ 原因在于linux系统对我们的贴心： 我们知道root用户是linux执行权限最高的管理者用户，他可以进行任何的权限操作；然而我们的操作系统同样也考虑过这样的弊端，就是当我们使用者并不了解文件属性和重要性时会给予我们使用者提示； 举个例子，当我们在linux下打开磁盘文件时，想要直接修改磁盘中的文件属性，一般会提示为只读文件，这时我们可以将其从磁盘中移动到本地目录下，这样就可以进行权限操作了； 实例如图显示，我的操作是试图对DVD中的文件进行权限修改，这是不被允许的； 如果我们在media文件夹目录下使用lsattr命令：可以发现： 注意，e是linux文件的隐藏权限类型！！ 在linux操作系统中，有这么几个特殊的文件夹： &#x2F;mnt：一般是挂在镜像和硬盘一类的目录；&#x2F;media:是挂在多媒体设备的目录，如默认情况下的光盘、优盘、硬盘等设备都挂在在此目录；&#x2F;misc即各种其它杂七杂八东西 otp 是第三方软件的存放目录selinux 是linux 下强制存取控制的实现 一般用来保护apachesrv 是存放系统提供服务站点的数据media 是存放即插即用 设备的 挂载点。 比如USB 设备 自动在这个目录下创建一个目录 因为你没有对 文件所对应的内容进行操作 所以他是空的 在How-To-Geek上对Linux系统的目录结构说明文档中，关于media文件夹有这样的解释： &#x2F;media — Removable MediaThe &#x2F;media directory contains subdirectories where removable media devices inserted into the computer are mounted. For example, when you insert a CD into your Linux system, a directory will automatically be created inside the &#x2F;media directory. You can access the contents of the CD inside this directory. 在我们使用apt-get下载了相关tar.gz格式的压缩文件后，这一篇博客介绍了之后的步骤： 当然，作者也遇到了media文件夹中不能解压缩的问题，给出了下面的解答步骤： 于是，我们使用命令cp VMwaretools.tar.gz /home/user/Desktop将其拷贝一份至桌面进行解压缩 tar -zxvf VMwareTools.tar.gz 然后跳转到解压后的文件夹 cd vmware-tools-distrib/ 执行命令sudo ./vmware-install.pl。 完成，成功解压缩。 然后我们重新启动虚拟机，可以看到，&#x2F;mnt文件夹下已经有了hgfs文件夹 在中文的一个方便网站上，我们可以搜索到上面几个重要命令的讲解： cp CoPy，功能为复制文件或目录，可以将多个文件复制到一个具体的文件名或一个已经存在的目录下，也可以同时复制多个文件到一个指定的目录中。 cp [参数] [文件] [路径] tar TARball，根据菜鸟教程中的描述： tar 是用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件。 必要参数如下： A 新增压缩文件到已存在的压缩 c 建立新的压缩文件 d 记录文件的差别 r 添加文件到已经压缩的文件 u 添加改变了和现有的文件到已经存在的压缩文件 x 从压缩的文件中提取文件 t 显示压缩文件的内容 z 支持gzip解压文件 j 支持bzip2解压文件 Z 支持compress解压文件 v 显示操作过程 l 文件系统边界设置 k 保留原有文件不覆盖 m 保留文件不被覆盖 W 确认压缩文件的正确性 cd Change Directory，切换目录 cd [参数] [目录名] 一些特殊的目录表示： “ ~ ”表示为用户目录的意思； “ . ”则是表示目前所在的目录； “ .. ”则表示当前目录位置的上一级目录。 常用参数 -P 如果切换的目标目录是一个符号链接，则直接切换到符号链接指向的目标目录 -L 如果切换的目标目录是一个符号链接，则直接切换到符号链接名所在的目录 – 仅使用”-“选项时，当前目录将被切换到环境变量”OLDPWD”对应值的目录 ~ 切换至当前用户目录 .. 切换至当前目录位置的上一级目录 sudo SuperUser DO sudo 是一种权限管理机制，管理员可以授权于一些普通用户去执行一些 root 执行的操作，而不需要知道 root 的密码。 sudo 允许一个已授权用户以超级用户或者其它用户的角色运行一个命令。当然，能做什么不能做什么都是通过安全策略来指定的。sudo 支持插件架构的安全策略，并能把输入输出写入日志。第三方可以开发并发布自己的安全策略和输入输出日志插件，并让它们无缝的和 sudo 一起工作。默认的安全策略记录在 &#x2F;etc&#x2F;sudoers 文件中。而安全策略可能需要用户通过密码来验证他们自己。也就是在用户执行 sudo 命令时要求用户输入自己账号的密码。如果验证失败，sudo 命令将会退出。 语法格式：sudo [参数] 常用参数： -v 因为 sudo 在第一次执行时或是在 N分钟内没有执行（N 预设为五）会问密码，这个参数是重新做一次确认，如果超过N分钟，也会问密码 -k 强迫使用者在下一次执行 sudo 时问密码（不论有没有超过 N 分钟） -b 将要执行的指令放在背景执行 -p prompt 可以更改问密码的提示语，其中 %u 会代换为使用者的帐号名称，%h 会显示主机名称 -s 执行环境变数中的SHELL 所指定的shell ，或是 &#x2F;etc&#x2F;passwd 里所指定的 shell command 要以系统管理者身份（或以 -u 更改为其他人）执行的指令 例如我们要切换到root用户，需要使用命令sudo su 一个小插曲——如何在ubuntu中启用中英文输入法按照这一篇教程安装搜狗输入法的linux版本，并进行相关配置。 当我们在linux桌面系统的终端或编辑器中启用输入的时候，只要记得右上角linux图标点击切换输入法即可。 当我们在Linux系统启用搜狗输入法时，记得用”shift”键切换中英文即可，对于大写的启用键与windows系统中一致。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://justskim.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://justskim.github.io/tags/linux/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://justskim.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://justskim.github.io/tags/ubuntu/"},{"name":"vmware","slug":"vmware","permalink":"http://justskim.github.io/tags/vmware/"}]},{"title":"在linux系统创建父子进程及相关操作","slug":"在linux系统创建父子进程及相关操作","date":"2021-09-26T02:16:56.153Z","updated":"2021-10-01T01:46:43.533Z","comments":true,"path":"2021/09/26/在linux系统创建父子进程及相关操作/","link":"","permalink":"http://justskim.github.io/2021/09/26/%E5%9C%A8linux%E7%B3%BB%E7%BB%9F%E5%88%9B%E5%BB%BA%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/","excerpt":"","text":"在linux系统创建父子进程及相关操作fork函数fork这一词，在英文中有两个意思： n. 叉(挖掘用的园艺工具); 餐叉; (道路、河流等的)分岔处; 岔路; v. 分岔出分支，走岔路中的一条。 fork函数是基本上只在Linux环境中会使用到的C语言函数，在使用时需要调用unistd.h这个头文件，我们在Linux环境下举例讲解C语言的fork()函数用法： 一个进程，包括代码、数据和分配给进程的资源。fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。 一个进程调用fork（）函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。 由fork函数创建的新进程被称为子进程。fork函数被调用一次，但是返回两次。父进程返回的值是新进程的进程ID，而子进程返回的值是0。 fork函数返回值的三种情况 返回子进程标识符，即PID给父进程（在父进程中，fork返回新创建子进程的进程ID） 因为一个进程的子进程可能有多个，并且没有一个函数可以获得一个进程的所有子进程ID。 返回0给子进程（在子进程中，fork返回值为0） 一个进程只会有一个父进程，所以子进程总是可以调用getpid以获得当前进程Id以及调用getppid获得父进程Id. 出现错误，返回负值 当前进程数已经达到系统规定的上限，这时errno的值被设置为EAGAIN 系统内存不足，这时errno的值被设置为ENOMEM 创建新进程成功后，系统中出现两个基本完全相同的进程，这两个进程执行没有固定的先后顺序，哪个进程先执行要看系统的进程调度策略 更加形象的解释： “ 其实就相当于链表，进程形成了链表，父进程的fork函数返回的值指向子进程的进程id, 因为子进程没有子进程，所以其fork函数返回的值为0 . 调用fork之后，数据、堆、栈有两份，代码仍然为一份但是这个代码段成为两个进程的共享代码段都从fork函数中返回。当父子进程有一个想要修改数据或者堆栈时，两个进程真正分裂。 注意！子进程代码是从fork处开始执行的， 为什么不是从#include处开始复制代码的？这是因为fork是把 进程当前的情况拷贝一份 ，执行fork时，进程已经执行完了int count&#x3D;0;fork只拷贝下一个要执行的代码到新的进程。 fork函数被调用一次，返回两次，详解来自这篇博客的例子： 123456789101112131415161718192021#include &lt;unistd.h&gt; //引入pid_t类型的头文件#include &lt;stdio.h&gt; int main () &#123; pid_t fpid; //fpid表示fork函数返回的值 int count=0; fpid=fork(); if (fpid &lt; 0) printf(&quot;error in fork!&quot;); //fork函数返回的第一种情况，为负数，错误处理 else if (fpid == 0) &#123; //fork函数返回的第二种情况，在子进程中返回0 printf(&quot;i am the child process, my process id is %d/n&quot;,getpid()); count++; &#125; else &#123; //fork函数返回的第三种情况，在父进程中，fork返回新创建子进程的进程ID printf(&quot;i am the parent process, my process id is %d/n&quot;,getpid()); //这里因为已经在父进程中了，getpid()函数返回的是当前进程（elseif语句中进程的父进程）的进程ID count++; &#125; printf(&quot;统计结果是: %d/n&quot;,count); return 0;&#125; 编译后运行的结果： 1234i am the child process, my process id is 5574统计结果是: 1i am the parent process, my process id is 5573统计结果是: 1 借用一张图解释一下为什么同一个if else语句会执行两次，并且count的值为1而不是2： 上面的代码都是位于语句fpid=fork()之后，进程1的变量为count=0，fpid！=0（父进程）。进程2的变量为count=0，fpid=0（子进程），这两个进程的变量都是独立的，存在不同的地址中，不是共用的，这点要注意。可以说，我们就是通过fpid来识别和操作父子进程的。 如果疑惑为什么不是从#include处开始复制代码的，这是因为fork是把进程当前的情况拷贝一份，执行fork时，进程已经执行完了int count=0;，正如我们上面所说的，子进程代码是从fork处开始执行的，fork只拷贝下一个要执行的代码到新的进程。 所以，其实执行的是两个if…else语句，输出的两个count也不是同一个。 12345678910111213141516171819202122232425#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main(void)&#123; int i=0; printf(&quot;i son/pa ppid pid fpid/n&quot;);//打印表头 for(i=0;i&lt;2;i++)&#123; pid_t fpid=fork(); if(fpid==0) printf(&quot;%d child %4d %4d %4d/n&quot;,i,getppid(),getpid(),fpid); else printf(&quot;%d parent %4d %4d %4d/n&quot;,i,getppid(),getpid(),fpid); &#125; return 0;&#125;/*运行结果： i son/pa ppid pid fpid 0 parent 2043 3224 3225 这里是最开始的那个父进程id3224，它的ppid2043我们不用管 0 child 3224 3225 0 子进程3225的ppid是父进程的pid 1 parent 2043 3224 3226 仍然是父进程id3224，又用fork创建了一个子进程3226 1 parent 3224 3225 3227 在这里fork返回了子进程3225创建的孙子进程3227 1 child 1 3227 0 1 child 1 3226 0*/ 从上面，我们可以看到，每次都是先执行父进程中的语句，再执行子进程中拷贝的代码语句，正如博主所说： 第一步：在父进程中，指令执行到for循环中，i&#x3D;0，接着执行fork，fork执行完后，系统中出现两个进程，分别是p3224和p3225（后面我都用pxxxx表示进程id为xxxx的进程）。可以看到父进程p3224的父进程是p2043，子进程p3225的父进程正好是p3224。我们用一个链表来表示这个关系： p2043-&gt;p3224-&gt;p3225 第一次fork后，p3224（父进程）的变量为i&#x3D;0，fpid&#x3D;3225（fork函数在父进程中返向子进程id） p3225（子进程）的变量为i&#x3D;0，fpid&#x3D;0（fork函数在子进程中返回0），打印出结果： 0 parent 2043 3224 3225 0 child 3224 3225 0 第二步：假设父进程p3224先执行，当进入下一个循环时，i&#x3D;1，接着执行fork，系统中又新增一个进程p3226，对于此时的父进程，p2043-&gt;p3224（当前进程）-&gt;p3226（被创建的子进程）。 对于子进程p3225，执行完第一次循环后，i&#x3D;1，接着执行fork，系统中新增一个进程p3227，对于此进程，p3224-&gt;p3225（当前进程）-&gt;p3227（被创建的子进程）。从输出可以看到p3225原来是p3224的子进程，现在变成p3227的父进程。父子是相对的，这个大家应该容易理解。只要当前进程执行了fork，该进程就变成了父进程了，就打印出了parent。 所以打印出结果是： 1 parent 2043 3224 3226 1 parent 3224 3225 3227 第三步：第二步创建了两个进程p3226，p3227，这两个进程执行完printf函数后就结束了，因为这两个进程无法进入第三次循环，无法fork，该执行return 0;了，其他进程也是如此。 以下是p3226，p3227打印出的结果： 1 child 1 3227 0 1 child 1 3226 0 细心的读者可能注意到p3226，p3227的父进程难道不该是p3224和p3225吗，怎么会是1呢？这里得讲到进程的创建和死亡的过程，在p3224和p3225执行完第二个循环后，main函数就该退出了，也即进程该死亡了，因为它已经做完所有事情了。p3224和p3225死亡后，p3226，p3227就没有父进程了，这在操作系统是不被允许的，所以p3226，p3227的父进程就被置为p1了，p1是永远不会死亡的，至于为什么，这里先不介绍。 最后，用博主的这段打印祖孙三代关系的代码： 1234567891011121314151617181920212223242526#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main(void)&#123; int i=0; for(i=0;i&lt;3;i++)&#123; pid_t fpid=fork(); if(fpid==0) printf(&quot;son/n&quot;); else printf(&quot;father/n&quot;); &#125; return 0;&#125;/* for i=0 1 2 father father father son son father son son father father son son father son*/ pid_t类型pid_t类型是Linux下的进程号类型，在Linux环境编程中用于定义进程ID，需要引入头文件&lt;sys/types.h&gt;，否则会报错：error:&#39;pid_t&#39; was not declared in this scope。 使用fork函数时，为什么使用pid_t而不用int: pid_t是一个typedef定义类型，sys&#x2F;types.h中的定义:typedef short pid_t; &#x2F;* used for process ids *&#x2F; pid_t就是一个short类型变量，实际表示的是内核中的进程表的索引 可以看到，头文件里也不过是个typedef而已.使用pid_t而不使用int只是为了可移植性好一些.因为在不同的平台上有可能这么定义：typedef int pid_t也有可能：typedef long pid_t 但是，在和fork函数配合使用时，由于进程很多时，fork函数返回的pid_t类型的子进程id，可能长度超过了int类型，需要用long int类型来存储，这时候就使用pid_t来存储子进程PID比较便于使用和移植。 PID PPID PGID与SID详见博客，在Linux中，进程都拥有以下的ID Process ID(PID，也称之为进程标识)Linux中标识进程的一个数字，它的值是不确定的，是由系统分配的（但是有一个例外，启动阶段,kernel运行的第一个进程是init，它的PID是1，是所有进程的最原始的父进程），每个进程都有唯一PID，当进程退出运行之后，PID就会回收，可能之后创建的进程会分配这个PID Parent Process ID(PPID)字面意思，父进程的PID Process Group ID(PGID)PGID就是进程所属的Group的Leader的PID，如果PGID&#x3D;PID，那么该进程是Group Leader Session ID(SID)和PGID非常相似，SID就是进程所属的Session Leader的PID，如果SID&#x3D;&#x3D;PID，那么该进程是session leader Session和Group都是管理多个进程的方式，同一个Group的进程属于同一个Session，一个Session里可以包含多个Group 注意，父进程也有ppid（爸爸的爸爸叫爷爷(～￣▽￣)～ ），ppid为1的进程被称之为僵尸进程，这是因为linux下有3个特殊的进程，idle进程(PID = 0), init进程(PID = 1)和kthreadd(PID = 2)。 在terminal中使用默认的ps命令输出的信息值包括和当前终端会话相关的进程信息，自然看不到id很短的进程： 我们可以使用命令ps --help获取帮助，然后使用命令ps -A或ps -e来获取全部进程（all process）![查看全部进程](E:\\JS练习\\blog\\Myblog\\source\\images\\ps -A命令.png) getpid和getppid函数，与fork函数产生的pidgetpid返回当前进程标识（也就是PID），getppid返回当前进程的父进程标识，使用这两个函数需要引入头文件&lt;unistd.h&gt;。 每个进程都有一个独特（互不相同）的进程标识符（process ID），可以通过getpid()函数获得，还有一个记录父进程pid的变量，可以通过getppid()函数获得变量的值。 这两个函数在调用中都不能返回错误，注意，返回值的pid_t类型 能够放进 int类型中去，返回值被转为long 整型输出。 ！！注意，我们常用到命令pid_t pid = fork()产生的pid根据所处分支是在子进程还是在父进程而具有不同的值，同时要注意，这个pid的值，是getpid()返回的进程id刚创建的子进程id（没有则为0），从祖宗关系上，是getppid()返回的id所属的进程的孙子进程的id，例如下面这一段代码： 123456789101112131415161718int main()&#123; int fencha(int i,int num); fencha(0,10);&#125;int fencha(int i,int num)&#123; int pid = fork; if(pid&lt;0)printf(&quot;ERROR\\n&quot;); else if(pid==0)&#123; sleep(1); if(i&lt;num) fencha(i+1,num); &#125; else&#123; printf(&quot;现在在父进程中&quot;); printf(&quot;由fork函数产生的pid是 %d,&quot;,pid) printf(&quot;用getpid函数获取的值为%d，用getppid函数获取的值为%d\\n&quot;,getpid(),getppid()); &#125;&#125; 我们看到代码结果如下，这是一个十层的子进程递归创建，祖宗总共十代： 1 注意，在上面的代码中，我们使用了sleep()函数，这是为了确保在子进程代码运行的过程中，父进程不会执行完所有代码而被内核释放掉所有资源，如果我们不使用sleep函数，如下面的代码，会导致孤儿进程（没有父进程的进程，那么照顾他的重任就落到了init进程身上）的产生。 想想看，为什么我们的代码已经执行完毕，但是id为6666的进程依然可以在ps命令中被查询到，tty为一个问号?说明该进程不是通过tty&#x2F;console启动，自然与终端terminal无关。 孤儿进程与僵尸进程这篇博客中提到了一个区别： 孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。 僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。 值得注意的是，照顾孤儿进程的进程id在不同版本的Linux系统中是不一样的，笔者所用的ubuntu16.04版本中由id为6666的进程负责收养孤儿进程。 虽然孤儿进程并没有危害，任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。这是每个 子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。 如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://justskim.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://justskim.github.io/tags/linux/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://justskim.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://justskim.github.io/tags/ubuntu/"},{"name":"c语言","slug":"c语言","permalink":"http://justskim.github.io/tags/c%E8%AF%AD%E8%A8%80/"},{"name":"进程","slug":"进程","permalink":"http://justskim.github.io/tags/%E8%BF%9B%E7%A8%8B/"}]},{"title":"在linux系统中编写并执行C语言程序","slug":"在linux系统中编写并执行C语言程序","date":"2021-09-24T12:07:36.765Z","updated":"2021-09-27T02:26:49.095Z","comments":true,"path":"2021/09/24/在linux系统中编写并执行C语言程序/","link":"","permalink":"http://justskim.github.io/2021/09/24/%E5%9C%A8linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%BC%96%E5%86%99%E5%B9%B6%E6%89%A7%E8%A1%8CC%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"在linux系统中编写并执行C语言程序1. 按照教程使用Vmware创建虚拟机值得注意的两点是，vmware15的激活码无法适用于vmware16的虚拟机，ubuntu的iso映像文件可以在官方网站中下载，使用最新（20版本）的即可。版本名称中带有desktop字段的意味着自带图形界面系统。 2. linux系统下的C语言编译执行我们按照教程的步骤配置编译程序环境： 找到命令行窗口输入：（1）、sudo apt-get install gcc（2）、sudo apt-get install build-essential &#x2F;&#x2F;编写c所用到的库（3）、gedit [文件名].c &#x2F;&#x2F;创建一个c文件，并且会自动打开，即可开始编写（4）、gcc [文件名].c -o [自定义程序名] &#x2F;&#x2F;创建可执行文件（5）、.&#x2F; [自定义程序名] &#x2F;&#x2F;即可运行 然后写了第一个简单的程序： 12345#include &lt;stdio.h&gt;int main()&#123; printf(&quot;hello world\\n&quot;); return 0;&#125; 执行，报错： 12345user@ubuntu:~$ cd Desktop#因为是在桌面上直接创建的cpp程序，因此要从home/user文件夹中跳到子文件夹Desktop中user@ubuntu:~/Desktop$ ./hello.cppbash: ./hello.cpp: Permission denied 根据博客的讲解： 出现这个问题的原因是由于权限不够。解决办法就是改变可执行文件的权限。 对于单个的可执行文件使用命令：chmod 777 file-name若需要将一个目录下的所有可执行文件的权限都升级，可使用命令：chmod -R 777 directory-name 其中：-R 是指级联应用到目录里的所有子目录和文件777 是所有用户都拥有最高权限 如果我们不对cpp文件创建可执行文件，而是直接运行cpp文件，会导致报错如下： 123user@ubuntu:~/Desktop$ ./hello.cpp./hello.cpp: line 2: syntax error near unexpected token `(&#x27;./hello.cpp: line 2: `int main()&#123;&#x27; 只有执行gcc编译命令后，再执行相关可执行文件，才可正确输出： 123user@ubuntu:~/Desktop$ gcc hello.cpp -o hellouser@ubuntu:~/Desktop$ ./hellohello world 除此之外，我们还可以在ubuntu的页面上看到一个hello可执行文件： 可以看到，文件的类型其实就是executable，简称exe可执行文件。 3. GCC编译在配置好的windows系统中，C程序执行步骤如下所示： 打开一个文本编辑器，添加上述代码。 保存文件为 hello.c。 打开命令提示符，进入到保存文件所在的目录。 键入 gcc hello.c，输入回车，编译代码。 如果代码中没有错误，命令提示符会跳到下一行，并生成 a.out 可执行文件。 现在，键入 a.out 来执行程序。 您可以看到屏幕上显示 *”Hello World”*。 123$ gcc hello.c$ ./a.outHello, World! 在C语言中，一个源程序如果不编译是绝对无法运行的。一个源程序必须经过编译生成后缀为.obj目标程序，然后连接生成后缀为.exe的可执行文件，方能运行。如果编译没有问题，只能说明没有语法错误，但可能会存在一些逻辑错误导致程序不能运行。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://justskim.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://justskim.github.io/tags/linux/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://justskim.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://justskim.github.io/tags/ubuntu/"},{"name":"c语言","slug":"c语言","permalink":"http://justskim.github.io/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"几个常用的vue名词详解","slug":"几个常用的vue名词详解","date":"2021-09-19T02:25:01.014Z","updated":"2021-09-19T12:19:51.412Z","comments":true,"path":"2021/09/19/几个常用的vue名词详解/","link":"","permalink":"http://justskim.github.io/2021/09/19/%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84vue%E5%90%8D%E8%AF%8D%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"几个常用的vue名词详解vue是什么？没有比官网更好的解释了： Vue (读音 &#x2F;vjuː&#x2F;，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 官方文档中还提供提供了vue2与其他几个常见框架的对比。 相比传统的html、css、javascript使用vue的优势在于我们不必手动操作DOM，而是可以直接将js变量放到html页面当中，数据会自动绑定。开发者只需将重点放到对数据的处理上即可，代码也更加精简。当页面元素很多的时候，使用vue组件（如v-for列表渲染），可以让我们不必再一味复制粘贴html标签。 但是，以上操作只是将html和js组合在一起，并解决了html的复用问题，但css样式依然需要复制粘贴。为了解决这个问题，我们要使用单文件的vue组件，将html，css，javascript代码放到同一个.vue文件中。然后，使用webpack这一构建工具将代码进行分离，并分别与其他同类型的代码打包到一起。在基础阶段不必熟知webpack的具体原理，只需会用即可。 使用webpack打包有以下几个好处： 将许多碎小文件打包成一个整体，减少单页面内的衍生请求次数，提高网站效率。 将ES6的高级语法进行转换编译，以兼容老版本的浏览器。 将代码打包的同时进行混淆，提高代码的安全性。 webpack模板webpack官方文档对此有解释： 本质上，webpack 是一个现代 JavaScript 应用程序的*静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)*，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 这篇简书文章中也有提到： Webpack是一个模块化打包工具，专注于构建模块化项目，在Webpack眼里一切文件都是模块，通过Loader转换翻译文件，通过Plugin注入钩子，最后输出由多个模块组合成的文件。 之所以一切文件皆模块，如：JavaScript、CSS、SCSS以及图片等资源，在Webpack眼中都是模块，因为这样可以更好的理清描述各个模块之间的依赖关系，方便Webpack对模块进行打包组合，输出浏览器使用的静态资源。 目前，大部分的教程和大型项目都推荐使用webpack对vue进行打包。 为什么要使用vue-cli?Vue 提供了一个官方的 CLI，为单页面应用 (SPA) 快速搭建繁杂的脚手架。它为现代前端工作流提供了开箱即用的构建设置。只需要几分钟的时间就可以运行起来并带有热重载、保存时 lint 校验，以及生产环境可用的构建版本。更多详情可查阅 vue cli官方文档对vue-cli的定义： Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统，提供： 通过 @vue/cli 实现的交互式的项目脚手架。 通过 @vue/cli + @vue/cli-service-global 实现的零配置原型开发。 一个运行时依赖 ( 1@vue/cli-service )，该依赖： 可升级； 基于 webpack 构建，并带有合理的默认配置； 可以通过项目内的配置文件进行配置； 可以通过插件进行扩展。 一个丰富的官方插件集合，集成了前端生态中最好的工具。 一套完全图形化的创建和管理 Vue.js 项目的用户界面。 Vue CLI 致力于将 Vue 生态中的工具基础标准化。它确保了各种构建工具能够基于智能的默认配置即可平稳衔接，这样你可以专注在撰写应用上，而不必花好几天去纠结配置的问题。与此同时，它也为每个工具提供了调整配置的灵活性，无需 eject。 这篇掘金文章中，讲到了使用命令vue init webpack myproject来创建项目时候的信息填写与选择： Project name (baoge)： —–项目名称，直接回车，按照括号中默认名字（注意这里的名字不能有大写字母，否则会报错：Sorry, name can no longer contain capital letters） Project description (A Vue.js project)： —-项目描述，也可直接点击回车，使用默认名字 Author ()： —-作者 接下来是用户可以进行选择的项： Runtime + Compiler: recommended for most users 运行加编译，既然已经说了推荐，就选它了Runtime-only: about 6KB lighter min+gzip, but templates (or any Vue-specificHTML) are ONLY allowed in .vue files - render functions are required elsewhere 仅运行时，已经有推荐了就选择第一个了 Install vue-router? (Y&#x2F;n) 是否安装vue-router，这是官方的路由，大多数情况下都使用，这里就输入“y”后回车即可。 Use ESLint to lint your code? (Y&#x2F;n) 是否使用ESLint管理代码，ESLint是个代码风格管理工具，是用来统一代码风格的，一般项目中都会使用。接下来也是选择题Pick an ESLint preset (Use arrow keys) 选择一个ESLint预设，编写vue项目时的代码风格，直接y回车 Setup unit tests with Karma + Mocha? (Y&#x2F;n) 是否安装单元测试，选择安装y回车 Setup e2e tests with Nightwatch(Y&#x2F;n)? 是否安装e2e测试 ，选择安装y回车 不使用vue-cli的情况下搭建vue项目首先，我们在DOS窗口中使用npm init来初始化一个项目。 在node开发中使用npm init会生成一个pakeage.json文件，这个文件主要是用来记录这个项目的详细信息的，它会将我们在项目开发中所要用到的包，以及项目的详细信息等记录在这个项目中。方便在以后的版本迭代和项目移植的时候会更加的方便。也是防止在后期的项目维护中误删除了一个包导致的项目不能够正常运行。使用npm init初始化项目还有一个好处就是在进行项目传递的时候不需要将项目依赖包一起发送给对方，对方在接受到你的项目之后再执行npm install就可以将项目依赖全部下载到项目里。话不多说我们就直接开始进行操作。 执行该命令后，DOS窗口中询问选项的含义如下所示： 123456789package name: 你的项目名字叫啥version: 版本号description: 对项目的描述entry point: 项目的入口文件（一般你要用那个js文件作为node服务，就填写那个文件，旧的版本默认为app.js，在14.15.5版本的node中默认为index.js）test command: 项目启动的时候要用什么命令来执行脚本文件git repository: 如果你要将项目上传到git中的话，那么就需要填写git的仓库地址keywords： 项目关键字author: 作者的名字license: 发行项目需要的证书，默认为ISC npmjs的官方网站上有对这几个名词的解释，中文方面的翻译欠缺。 对于任何项目，Entry point是执行开始的文件。它取决于正在使用的技术的项目配置和运行时环境。 示例：对于node.js项目，使用app.js初始化应用程序并将所有内容粘合在一起。 在我们生成的package.json中，也有一个名为main的属性，官方解释： The main field is a module ID that is the primary entry point to your program. 对于属性keywords的解释： Put keywords in it. It’s an array of strings. This helps people discover your package as it’s listed in npm search. 想省事的话，可以使用命令npm init -y来代替，该命令会采用所有默认的配置。 项目会生成一个package.json文件，代码如下： 12345678910111213&#123; &quot;name&quot;: &quot;vue_test&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;&#125;","categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"},{"name":"JavaScript","slug":"Programming-languages-and-projects/JavaScript","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/JavaScript/"},{"name":"Vue","slug":"Programming-languages-and-projects/JavaScript/Vue","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/JavaScript/Vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://justskim.github.io/tags/vue/"},{"name":"vue-cli","slug":"vue-cli","permalink":"http://justskim.github.io/tags/vue-cli/"},{"name":"webpack","slug":"webpack","permalink":"http://justskim.github.io/tags/webpack/"},{"name":"store","slug":"store","permalink":"http://justskim.github.io/tags/store/"},{"name":"router","slug":"router","permalink":"http://justskim.github.io/tags/router/"}]},{"title":"创建vue项目的两个命令：vue create myproject与vue init webpack 详解","slug":"创建vue项目的两个命令：vue-create-myproject与vue-init-webpack-详解","date":"2021-09-19T02:11:56.099Z","updated":"2021-09-22T03:01:21.593Z","comments":true,"path":"2021/09/19/创建vue项目的两个命令：vue-create-myproject与vue-init-webpack-详解/","link":"","permalink":"http://justskim.github.io/2021/09/19/%E5%88%9B%E5%BB%BAvue%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%91%BD%E4%BB%A4%EF%BC%9Avue-create-myproject%E4%B8%8Evue-init-webpack-%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"创建vue项目的两个命令：vue create myproject与vue init webpack 详解两个不同方法的来源vue create 是vue-cli3.x（包括现在最新的vue-cli4.x）的初始化方式，目前模板是固定的，模板选项可自由配置，创建出来的是vue-cli3的项目，与cue-cli2项目结构不同，配置方法不同，具体配置方法参考官方文档网页链接。 vue init 则是vue-cli2.x的初始化方式，可以使用github上面的一些模板来初始化项目，webpack是官方推荐的标准模板名。vue-cli2.x项目向3.x迁移只需要把static目录复制到public目录下，老项目的src目录覆盖3.x的src目录(如果修改了配置，可以查看文档，用cli3的方法进行配置) vue init webpack 详解简书文章中对DOS窗口中各个选择题的解释： Project name (my-project): #项目名称，如果不需要就直接回车。注：此处项目名不能使用大写。 Project description (A Vue.js project): #项目描述，如果不需要就直接回车。 Author (xxx)：#项目作者，默认计算机用户名 vue build (Use arrow keys) &gt; Runtime + Compiler:recommended for most users #译：运行+编译：被推荐为大多数用户的默认选择 &gt; Runtime-only:about 6KB lighter min+gzip,but templates (or any Vue-specific HTML) are ONLY allowed in .vue files-render functions are required elsewhere #译：只运行大约6KB比较轻量的压缩文件，但只允许模板（或任何VUE特定HTML，VUE文件需要在其他地方呈现函数。翻译不精准，意思大概是选择该构建方式对文件大小有要求 install vue-router? #安装vue的路由插件，需要就选y，否则就n [建议Y] Use ESLint to lint your code? #是否使用ESLint检测你的代码？[ESLint 是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。建议选择 ‘N’ 因为选择 ‘Y’ 在做调试项目时,控制台会有很多 黄色警告 提示格式不规范,但其实并不影响项目] Setup unit tests? #是否安装单元测试(国内其实为了追求开发速度这一块很少安装，但后续添加麻烦) Setup e2e tests with Nightwatch(Y&#x2F;n)? #是否安装E2E测试框架NightWatch（E2E，也就是End To End，就是所谓的“用户真实场景” [建议N] Should we run ‘npm install’ for you after the project has been created? #项目创建后是否要为你运行“npm install”?这里选择包管理工具 [建议yes,use npm] yes,use npm #使用npm yes,use yarn #使用yarn no,I will handle that myself #自己操作 Run time complier和Run time only的区别 二者区别主要在main.js文件上：Run time complier中注册了App在使用，而在Run time only中，直接是一个render函数 12345678import Vue from &#x27;vue&#x27;import App from &#x27;./App&#x27;Vue.config.productionTip = falsenew Vue(&#123; el:&#x27;#app&#x27;, components:&#123; App &#125;, template:&#x27;&lt;App/&gt;&#x27;&#125;) Run time only 1234567import Vue from &#x27;vue&#x27;import App from &#x27;./App&#x27;Vue.config.productionTip = falsenew Vue(&#123; el:&#x27;#app&#x27;, render: h =&gt; h(App)&#125;) 二者区别的原因在于运行原理 在run time comliper中，将template传进给Vue时，会将template保存在Vue实例中的potions中，然后解析成ast 结构（ast是abstrct syntax trees英文的简称，译为抽象语法树）进而，将ast 编译成render函数；render函数又会将对应的tempalet转换成虚拟的dom节点元素，这些虚拟的节点元素就会构成一课虚拟dom树，最后再转化成真实的dom元素，也是就UI。 这就是run time comliper 的原理，总结起来就是：template –&gt; ast –&gt; render –&gt;virtual dom –&gt; UI。 run time only 中没有template 而只有函数，所以它的原理就是比 run time compiler 少了template –&gt; ast 的步骤。直接从render函数开始，转换成虚拟的dom最后变成真实的UI。 全部选择y的情况文件目录结构： 123456789101112131415161718192021222324252627282930313233343536project| README.md| .editorconfig| .eslintignore| .eslintrc.js| .gitignore| .postcssrc.js| .babelrc| package.json| package-lock.json| index.html└---node_modules└---config| |---dev.env.js| |---index.js| |---prod.env.js└---build| |---build.js| |---check-versions.js| |---logo.png| |---utils.js| |---vue-loader.conf.js| |---webpack.base.conf.js| |---webpack.dev.conf.js| |---webpack.prod.conf.js└---static| |---.gitkeep└---src |---App.vue |---main.js └---router | |---index.js └---components | |---HelloWorld.vue └---assets |---logo.png 简易说明一下其中几个文件和文件夹的说明： 123456789node_modules：安装的依赖代码库.babelrc：babel相关配置（babel的作用在于将es6语法转换成浏览器支持的es5语法）.editorconfig：编辑器的配置，可以在此修改代码、缩进等.eslintrc.js：eslint的配置文件.gitignore：git忽略里面设定的这些文件的提交src：项目源码static：存放静态资源index.html：入口html文件package.json：项目的配置文件，用于描述该项目，包括初始化时的设置、环境、依赖包、版本等信息 .eslintignore文件： 当 ESLint 运行时，在确定哪些文件要检测之前，它会在当前工作目录中查找一个 .eslintignore 文件。如果发现了这个文件，当遍历目录时，将会应用这些偏好设置。一次只有一个 .eslintignore 文件会被使用，所以，不是当前工作目录下的 .eslintignore 文件将不会被用到。 static文件夹中的.gitkeep文件： git无法追踪一个空文件夹,当用户需要追踪(track)一个空文件夹的时候,按照惯例,大家会把一个称为.gitkeep的文件放在这些文件夹里 build文件夹build文件夹中的文件对 webpack 开发和打包进行相关设置，包括入口文件、输出文件、使用的模块等。build.js构建环境下的配置:loading动画、删除创建目标文件夹、webpack编译、输出信息： 123456789101112131415161718192021222324252627282930313233343536373839404142&#x27;use strict&#x27;require(&#x27;./check-versions&#x27;)() //请求同级目录下的check-versions.js文件，进行node和npm的版本检查process.env.NODE_ENV = &#x27;production&#x27; //设置环境变量为生产环境const ora = require(&#x27;ora&#x27;) //主要用来实现node.js命令行环境的loading效果,和显示各种状态的图标等const rm = require(&#x27;rimraf&#x27;)const path = require(&#x27;path&#x27;)const chalk = require(&#x27;chalk&#x27;)const webpack = require(&#x27;webpack&#x27;)const config = require(&#x27;../config&#x27;)const webpackConfig = require(&#x27;./webpack.prod.conf&#x27;)const spinner = ora(&#x27;building for production...&#x27;)spinner.start() //启动Loading动画//删除dist/static文件夹rm(path.join(config.build.assetsRoot, config.build.assetsSubDirectory), err =&gt; &#123; if (err) throw err webpack(webpackConfig, (err, stats) =&gt; &#123; spinner.stop() //结束Loading动画 if (err) throw err process.stdout.write(stats.toString(&#123; //标准输出流，类似于console.log colors: true, //增加控制台颜色开关 modules: false, //是否增加内置模块信息 children: false, // If you are using ts-loader, setting this to true will make TypeScript errors show up during build. chunks: false, //是否允许较少的输出 chunkModules: false//是否在编译过程中持续打印 &#125;) + &#x27;\\n\\n&#x27;) //编译出错的信息 if (stats.hasErrors()) &#123; console.log(chalk.red(&#x27; Build failed with errors.\\n&#x27;)) process.exit(1) &#125; //编译成功的信息 console.log(chalk.cyan(&#x27; Build complete.\\n&#x27;)) console.log(chalk.yellow( &#x27; Tip: built files are meant to be served over an HTTP server.\\n&#x27; + &#x27; Opening index.html over file:// won\\&#x27;t work.\\n&#x27; )) &#125;)&#125;) check-versions.js文件负责node和npm的版本检查 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&#x27;use strict&#x27;const chalk = require(&#x27;chalk&#x27;)const semver = require(&#x27;semver&#x27;)const packageConfig = require(&#x27;../package.json&#x27;)const shell = require(&#x27;shelljs&#x27;)/*脚本跨域通过child_process模块新建子进程，从而执行unix系统命令将cmd参数传递的值转换成前后没有空格的字符串，即版本号*/function exec (cmd) &#123; return require(&#x27;child_process&#x27;).execSync(cmd).toString().trim()&#125;//声明常量数组，数组内容为有关node相关信息的对象const versionRequirements = [ &#123; name: &#x27;node&#x27;,//对象名称 currentVersion: semver.clean(process.version), //使用semver插件，将版本信息转换成规定格式 versionRequirement: packageConfig.engines.node //规定package.json中engines选项的node版本信息 &#125;]if (shell.which(&#x27;npm&#x27;)) &#123; //linux指令 versionRequirements.push(&#123; name: &#x27;npm&#x27;, currentVersion: exec(&#x27;npm --version&#x27;), versionRequirement: packageConfig.engines.npm &#125;)&#125;module.exports = function () &#123; const warnings = [] for (let i = 0; i &lt; versionRequirements.length; i++) &#123; const mod = versionRequirements[i] if (!semver.satisfies(mod.currentVersion, mod.versionRequirement)) &#123; warnings.push(mod.name + &#x27;: &#x27; + chalk.red(mod.currentVersion) + &#x27; should be &#x27; + chalk.green(mod.versionRequirement) //若版本号用红色标识，则要求改用绿色标识 ) &#125; &#125;//为真则打印提示用户升级新版本 if (warnings.length) &#123; console.log(&#x27;&#x27;) console.log(chalk.yellow(&#x27;To use this template, you must update following to modules:&#x27;)) console.log() for (let i = 0; i &lt; warnings.length; i++) &#123; const warning = warnings[i] console.log(&#x27; &#x27; + warning) &#125; console.log() process.exit(1) &#125;&#125; util.js文件配置静态资源路径，生成cssLoaders用于加载.vue文件中的样式，生成styleLoaders用于加载不在.vue文件中的单独存在的样式文件（被引入的css文件） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&#x27;use strict&#x27;const path = require(&#x27;path&#x27;)const config = require(&#x27;../config&#x27;) //！引入的是config文件夹下的index.js文件const ExtractTextPlugin = require(&#x27;extract-text-webpack-plugin&#x27;)//该插件抽离css样式const packageConfig = require(&#x27;../package.json&#x27;)exports.assetsPath = function (_path) &#123; const assetsSubDirectory = process.env.NODE_ENV === &#x27;production&#x27; ? config.build.assetsSubDirectory : config.dev.assetsSubDirectory return path.posix.join(assetsSubDirectory, _path)&#125;exports.cssLoaders = function (options) &#123; options = options || &#123;&#125; const cssLoader = &#123; loader: &#x27;css-loader&#x27;, options: &#123; sourceMap: options.sourceMap &#125; &#125; const postcssLoader = &#123; loader: &#x27;postcss-loader&#x27;, options: &#123; sourceMap: options.sourceMap &#125; &#125; // generate loader string to be used with extract text plugin function generateLoaders (loader, loaderOptions) &#123; const loaders = options.usePostCSS ? [cssLoader, postcssLoader] : [cssLoader] if (loader) &#123; loaders.push(&#123; loader: loader + &#x27;-loader&#x27;, options: Object.assign(&#123;&#125;, loaderOptions, &#123; sourceMap: options.sourceMap &#125;) &#125;) &#125; // Extract CSS when that option is specified // (which is the case during production build) if (options.extract) &#123; return ExtractTextPlugin.extract(&#123; use: loaders, fallback: &#x27;vue-style-loader&#x27; &#125;) &#125; else &#123; return [&#x27;vue-style-loader&#x27;].concat(loaders) &#125; &#125; // https://vue-loader.vuejs.org/en/configurations/extract-css.html return &#123; css: generateLoaders(), postcss: generateLoaders(), less: generateLoaders(&#x27;less&#x27;), sass: generateLoaders(&#x27;sass&#x27;, &#123; indentedSyntax: true &#125;), scss: generateLoaders(&#x27;sass&#x27;), stylus: generateLoaders(&#x27;stylus&#x27;), styl: generateLoaders(&#x27;stylus&#x27;) &#125;&#125;// Generate loaders for standalone style files (outside of .vue)exports.styleLoaders = function (options) &#123; const output = [] const loaders = exports.cssLoaders(options) for (const extension in loaders) &#123; const loader = loaders[extension] output.push(&#123; test: new RegExp(&#x27;\\\\.&#x27; + extension + &#x27;$&#x27;), use: loader &#125;) &#125; return output&#125;exports.createNotifierCallback = () =&gt; &#123; const notifier = require(&#x27;node-notifier&#x27;) return (severity, errors) =&gt; &#123; if (severity !== &#x27;error&#x27;) return const error = errors[0] const filename = error.file &amp;&amp; error.file.split(&#x27;!&#x27;).pop() notifier.notify(&#123; title: packageConfig.name, message: severity + &#x27;: &#x27; + error.name, subtitle: filename || &#x27;&#x27;, icon: path.join(__dirname, &#x27;logo.png&#x27;) &#125;) &#125;&#125; vue-loader.config.js 123456789101112131415161718192021222324&#x27;use strict&#x27;const utils = require(&#x27;./utils&#x27;)const config = require(&#x27;../config&#x27;)const isProduction = process.env.NODE_ENV === &#x27;production&#x27;//判断是否为生产环境//根据环境来获取相应的productionSourceMap或者cssSourceMapconst sourceMapEnabled = isProduction ? config.build.productionSourceMap : config.dev.cssSourceMapmodule.exports = &#123; loaders: utils.cssLoaders(&#123; sourceMap: sourceMapEnabled,//是否开始sourceMap用来调试 extract: isProduction //是否单独提取抽离CSS &#125;), cssSourceMap: sourceMapEnabled,//纪录压缩的代码，用来找到源码位置 cacheBusting: config.dev.cacheBusting,//是否缓存破坏 //在模块编译的过程中，将某些属性转换并调用 transformToRequire: &#123; video: [&#x27;src&#x27;, &#x27;poster&#x27;], source: &#x27;src&#x27;, img: &#x27;src&#x27;, image: &#x27;xlink:href&#x27; &#125;&#125; webpack.base.conf.js文件基本的webpack配置 配置webpack编译入口 配置webpack输出路径和命名规则 配置模块resolve规则 配置不同类型模块的处理规则 webpack.dev.conf.js文件开发环境配置 在base.conf基础进一步完善 将hot-reload相关的代码添加到entry chunks 使用styleLoaders 配置Source Maps 配置webpack插件 webpack.prod.conf.js文件生产环境配置 在base.conf基础进一步完善 合并基础webpack配置 使用styleLoaders 配置webpack输出 配置webpack插件 gzip模式下的webpack插件配置 webpack-bundle分析 config文件夹 config文件夹下有三个文件&#96;&#96;dev.env.js、index.js、prod.env.js&#96;。 prod.env.js： 123456&#x27;use strict&#x27;module.exports = &#123; NODE_ENV: &#x27;&quot;production&quot;&#x27;&#125;//内容非常简单，仅仅是导出了一个对象，里面写明了执行环境是“production（生产环境）”；//注意，严格模式是es5的保留字，但不推荐在es6语法下使用！ dev.env.js： 12345678&#x27;use strict&#x27;const merge = require(&#x27;webpack-merge&#x27;)const prodEnv = require(&#x27;./prod.env&#x27;)module.exports = merge(prodEnv, &#123; NODE_ENV: &#x27;&quot;development&quot;&#x27;&#125;)//在“dev.env.js”中，先引入了webpack-merge这个模块。这个模块的作用是来合并两个配置文件对象并生成一个新的配置文件，有点儿类似于es6的object.assign(); index.js： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&#x27;use strict&#x27;// Template version: 1.3.1// see http://vuejs-templates.github.io/webpack for documentation.const path = require(&#x27;path&#x27;)module.exports = &#123; dev: &#123; // Paths assetsSubDirectory: &#x27;static&#x27;, //静态资源文件夹，默认“static” assetsPublicPath: &#x27;/&#x27;, //发布路径 proxyTable: &#123;&#125;, //设置代理API，常用于解决跨域问题 // Various Dev Server settings host: &#x27;localhost&#x27;, // can be overwritten by process.env.HOST port: 8080, // can be overwritten by process.env.PORT, if port is in use, a free one will be determined autoOpenBrowser: false, //是否自动打开浏览器 errorOverlay: true, //查询错误 notifyOnErrors: true, //通知错误 poll: false, // https://webpack.js.org/configuration/dev-server/#devserver-watchoptions- //poll是跟devserver相关的一个配置，webpack为我们提供的devserver是可以监控文件改动的，但在有些情况下却不能工作，我们可以设置一个轮询（poll）来解决 // Use Eslint Loader? // If true, your code will be linted during bundling and // linting errors and warnings will be shown in the console. useEslint: true, // If true, eslint errors and warnings will also be shown in the error overlay // in the browser. showEslintErrorsInOverlay: false, //上面这两个是跟eslint相关的属性 /** * Source Maps */ devtool: &#x27;cheap-module-eval-source-map&#x27;, /* webpack提供的用来方便调试的配置，它有四种模式， 详见https://webpack.js.org/configuration/devtool/#development */ // If you have problems debugging vue-files in devtools, // set this to false - it *may* help // https://vue-loader.vuejs.org/en/options.html#cachebusting cacheBusting: true, //一个配合devtool的配置，当给文件名插入新的hash导致清楚缓存时是否生成souce maps，默认在开发环境下为true cssSourceMap: true //是否开启cssSourceMap &#125;, build: &#123; // Template for index.html index: path.resolve(__dirname, &#x27;../dist/index.html&#x27;), //编译后index.html的路径 //Node.js 中,__dirname总是指向被执行 js 文件的绝对路径,比如你在/d1/d2/myscript.js文件中写了__dirname, 它的值就是/d1/d2 // Paths assetsRoot: path.resolve(__dirname, &#x27;../dist&#x27;),//打包后的文件根路径 assetsSubDirectory: &#x27;static&#x27;, assetsPublicPath: &#x27;/&#x27;, /** * Source Maps */ productionSourceMap: true, // https://webpack.js.org/configuration/devtool/#production devtool: &#x27;#source-map&#x27;, // Gzip off by default as many popular static hosts such as // Surge or Netlify already gzip all static assets for you. // Before setting to `true`, make sure to: // npm install --save-dev compression-webpack-plugin productionGzip: false, productionGzipExtensions: [&#x27;js&#x27;, &#x27;css&#x27;], // Run the build command with an extra argument to // View the bundle analyzer report after build finishes: // `npm run build --report` // Set to `true` or `false` to always turn it on or off bundleAnalyzerReport: process.env.npm_config_report &#125;&#125; package.json中的情况： 参照这一篇CSDN博客为各个属性名添加了注释 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&#123; &quot;name&quot;: &quot;helloworld&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;A Vue.js project&quot;, &quot;author&quot;: &quot;your name&lt;your email&gt;&quot;, &quot;private&quot;: true, &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;, &quot;start&quot;: &quot;npm run dev&quot;, &quot;lint&quot;: &quot;eslint --ext .js,.vue src&quot;, &quot;build&quot;: &quot;node build/build.js&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;vue&quot;: &quot;^2.5.2&quot;, //该属性介绍了vue的版本 &quot;vue-router&quot;: &quot;^3.0.1&quot; //该属性介绍了vue-router的版本 &#125;, &quot;devDependencies&quot;: &#123; &quot;autoprefixer&quot;: &quot;^7.1.2&quot;, &quot;babel-core&quot;: &quot;^6.22.1&quot;, &quot;babel-eslint&quot;: &quot;^8.2.1&quot;, &quot;babel-helper-vue-jsx-merge-props&quot;: &quot;^2.0.3&quot;, &quot;babel-loader&quot;: &quot;^7.1.1&quot;, &quot;babel-plugin-syntax-jsx&quot;: &quot;^6.18.0&quot;, &quot;babel-plugin-transform-runtime&quot;: &quot;^6.22.0&quot;, &quot;babel-plugin-transform-vue-jsx&quot;: &quot;^3.5.0&quot;, &quot;babel-preset-env&quot;: &quot;^1.3.2&quot;, &quot;babel-preset-stage-2&quot;: &quot;^6.22.0&quot;, &quot;chalk&quot;: &quot;^2.0.1&quot;, &quot;copy-webpack-plugin&quot;: &quot;^4.0.1&quot;, &quot;css-loader&quot;: &quot;^0.28.0&quot;, &quot;eslint&quot;: &quot;^4.15.0&quot;, &quot;eslint-config-airbnb-base&quot;: &quot;^11.3.0&quot;, &quot;eslint-friendly-formatter&quot;: &quot;^3.0.0&quot;, &quot;eslint-import-resolver-webpack&quot;: &quot;^0.8.3&quot;, &quot;eslint-loader&quot;: &quot;^1.7.1&quot;, &quot;eslint-plugin-import&quot;: &quot;^2.7.0&quot;, &quot;eslint-plugin-vue&quot;: &quot;^4.0.0&quot;, &quot;extract-text-webpack-plugin&quot;: &quot;^3.0.0&quot;, &quot;file-loader&quot;: &quot;^1.1.4&quot;, &quot;friendly-errors-webpack-plugin&quot;: &quot;^1.6.1&quot;, &quot;html-webpack-plugin&quot;: &quot;^2.30.1&quot;, &quot;node-notifier&quot;: &quot;^5.1.2&quot;, &quot;optimize-css-assets-webpack-plugin&quot;: &quot;^3.2.0&quot;, &quot;ora&quot;: &quot;^1.2.0&quot;, &quot;portfinder&quot;: &quot;^1.0.13&quot;, &quot;postcss-import&quot;: &quot;^11.0.0&quot;, &quot;postcss-loader&quot;: &quot;^2.0.8&quot;, &quot;postcss-url&quot;: &quot;^7.2.1&quot;, &quot;rimraf&quot;: &quot;^2.6.0&quot;, &quot;semver&quot;: &quot;^5.3.0&quot;, &quot;shelljs&quot;: &quot;^0.7.6&quot;, &quot;uglifyjs-webpack-plugin&quot;: &quot;^1.1.1&quot;, &quot;url-loader&quot;: &quot;^0.5.8&quot;, &quot;vue-loader&quot;: &quot;^13.3.0&quot;, &quot;vue-style-loader&quot;: &quot;^3.0.1&quot;, &quot;vue-template-compiler&quot;: &quot;^2.5.2&quot;, &quot;webpack&quot;: &quot;^3.6.0&quot;, &quot;webpack-bundle-analyzer&quot;: &quot;^2.9.0&quot;, &quot;webpack-dev-server&quot;: &quot;^2.9.1&quot;, &quot;webpack-merge&quot;: &quot;^4.1.0&quot; &#125;, &quot;engines&quot;: &#123; //引擎相关的内容 &quot;node&quot;: &quot;&gt;= 6.0.0&quot;, //node版本要求 &quot;npm&quot;: &quot;&gt;= 3.0.0&quot; //npm版本要求 &#125;, &quot;browserslist&quot;: [ //配置浏览器的信息查询范围，这些信息将给Autoprefixer babel-env-preset eslint-plugin-compat这些组件来使用 &quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, //每种浏览器的最近两个版本 &quot;not ie &lt;= 8&quot; //IE8及之前的旧版本不查询 ]&#125; 这里面的很多字段我们之前已经提到过，下面介绍几个重要的名词。 dependencies和devDependencies使用npm install安装模块，有以下四个常用命令： 1234npm install moduleName # 安装模块到项目目录下npm install -g moduleName # -g 的意思是将模块安装到全局，具体安装到磁盘哪个位置，要看 npm config prefix 的位置。npm install -save moduleName # -save 的意思是将模块安装到项目目录下，并在package文件的dependencies节点写入依赖。npm install -save-dev moduleName # -save-dev 的意思是将模块安装到项目目录下，并在package文件的devDependencies节点写入依赖。 简单的来说，安装在dependencies中的库是在生产环境中使用的，而安装在devDependencies中的库是在开发环境中使用的（记住develop有发展的意思）。 例如：webpack，gulp等打包工具，这些都是我们开发阶段使用的，代码提交线上时，不需要这些工具，所以我们将它放入devDependencies即可，但是像jquery这类插件库，是我们生产环境所使用的，所以如要放入dependencies，如果未将jquery安装到dependencies，那么项目就可能报错，无法运行，所以类似这种项目必须依赖的插件库，我们则必须打入dependencies中，这下子都明白了吧。链接：https://www.jianshu.com/p/afb171cac890 我们可以在上面的package.json文件中看到，devDependencies中有一个模块autoprefixer，简书文章中对此解释： Autoprefixer是一个后处理程序，不象Sass以及Stylus之类的预处理器。它适用于普通的CSS，可以实现css3代码自动补全。也可以轻松跟Sass，LESS及Stylus集成，在CSS编译前或编译后运行。 Autoprefixer 同样会清理过期的前缀 12345#清理前的CSS样式a &#123; -webkit-border-radius : 5px; border-radius : 5px&#125; 12345&gt;#清理后的CSS样式a &#123; border-radius : 5px&#125; private属性 If you set &quot;private&quot;: true in your package.json, then npm will refuse to publish it. This is a way to prevent accidental publication of private repositories. If you would like to ensure that a given package is only ever published to a specific registry (for example, an internal registry), then use the publishConfig dictionary described below to override the registry config param at publish-time. 在项目的package.json文件中，直接将该属性设置为true即可。 package-lock.json文件 安装之后锁定包的版本，手动更改package.json文件安装将不会更新包，想要更新只能使用 npm install &#x78;&#x78;&#120;&#64;&#49;&#x2e;&#48;&#x2e;&#x30; –save 这种方式来进行版本更新package-lock.json 文件才可以 加快了npm install 的速度，因为 package-lock.json 文件中已经记录了整个 node_modules 文件夹的树状结构，甚至连模块的下载地址都记录了，如果删除了nodel_modules模块，再重新安装的时候只需要直接下载文件即可 如果我们全部选择’n’，就形成了更简单的文件目录结构12345678910111213141516171819202122232425262728293031323334project| README.md| .editorconfig| .gitignore| .postcssrc.js| .babelrc| package.json| package-lock.json| index.html└---node_modules└---config| |---dev.env.js| |---index.js| |---prod.env.js└---build| |---build.js| |---check-versions.js| |---logo.png| |---utils.js| |---vue-loader.conf.js| |---webpack.base.conf.js| |---webpack.dev.conf.js| |---webpack.prod.conf.js└---static| |---.gitkeep└---src |---App.vue |---main.js └---router | |---index.js └---components | |---HelloWorld.vue └---assets |---logo.png vue create 详解我们使用版本为4.5.13的vue-cli脚手架，选定vue3版本模板创建一个项目，项目文件目录结构如下 1234567891011121314151617project| README.md| .gitignore| babel.config.js| package.json| package-lock.json└---node_modules└---public| |---favicon.ico| |---index.html└---src |---App.vue |---main.js └---components | |---HelloWorld.vue └---assets |---logo.png 可以看到，使用vue-cli3之后版本脚手架的命令来创建的项目文件目录结构变得简单了许多。 babel.config.js 我们前面已经说过，babel是一个编译器，主要作用是将es5之后的语法转换成浏览器支持的es5语法。该文件存在于vue3.0根目录中，详见https://babeljs.io/docs/en/config-files#project-wide-configuration 12345module.exports = &#123; presets: [ &#x27;@vue/cli-plugin-babel/preset&#x27; ]&#125; 我们看一下新版脚手架创建的package.json文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; &quot;name&quot;: &quot;vue_create&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;private&quot;: true, &quot;scripts&quot;: &#123; &quot;serve&quot;: &quot;vue-cli-service serve&quot;, &quot;build&quot;: &quot;vue-cli-service build&quot;, &quot;lint&quot;: &quot;vue-cli-service lint&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;core-js&quot;: &quot;^3.6.5&quot;, &quot;vue&quot;: &quot;^3.0.0&quot; //vue版本 &#125;, &quot;devDependencies&quot;: &#123; //脚手架部分插件的版本 &quot;@vue/cli-plugin-babel&quot;: &quot;~4.5.0&quot;, &quot;@vue/cli-plugin-eslint&quot;: &quot;~4.5.0&quot;, &quot;@vue/cli-service&quot;: &quot;~4.5.0&quot;, &quot;@vue/compiler-sfc&quot;: &quot;^3.0.0&quot;, &quot;babel-eslint&quot;: &quot;^10.1.0&quot;, &quot;eslint&quot;: &quot;^6.7.2&quot;, &quot;eslint-plugin-vue&quot;: &quot;^7.0.0&quot; &#125;, &quot;eslintConfig&quot;: &#123; &quot;root&quot;: true, &quot;env&quot;: &#123; &quot;node&quot;: true &#125;, &quot;extends&quot;: [ &quot;plugin:vue/vue3-essential&quot;, &quot;eslint:recommended&quot; ], &quot;parserOptions&quot;: &#123; &quot;parser&quot;: &quot;babel-eslint&quot; &#125;, &quot;rules&quot;: &#123;&#125; &#125;, &quot;browserslist&quot;: [ &quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;not dead&quot; ]&#125;","categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"},{"name":"JavaScript","slug":"Programming-languages-and-projects/JavaScript","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/JavaScript/"},{"name":"Vue","slug":"Programming-languages-and-projects/JavaScript/Vue","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/JavaScript/Vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://justskim.github.io/tags/vue/"},{"name":"vue-cli","slug":"vue-cli","permalink":"http://justskim.github.io/tags/vue-cli/"}]},{"title":"对于github.io的访问","slug":"对于github.io的访问","date":"2021-09-16T09:51:57.773Z","updated":"2021-09-16T09:58:47.971Z","comments":true,"path":"2021/09/16/对于github.io的访问/","link":"","permalink":"http://justskim.github.io/2021/09/16/%E5%AF%B9%E4%BA%8Egithub.io%E7%9A%84%E8%AE%BF%E9%97%AE/","excerpt":"","text":"对于github.io的访问 当我们写完一篇博客，想要到自己的github.io界面看一看效果时，在谷歌浏览器中可能会遇到下面的情况： 产生的原因可能是这一篇博客讲到的证书问题，我们后续再进行探究。 对于这个问题，网上有很多千篇一律的解决方案，这里就不一一赘述了，我们这里介绍一下这篇博客分享的一个小技巧： 在当前页面用键盘输入 thisisunsafe，注意这一个字符串没有空格，而且并不是在地址栏输入，直接敲键盘即可（页面中不会显示输入内容），页面即会自动刷新进入网页。 但实际上，使用这一个方法是有缺陷的，其原理和不足可以见码农家园对该绕过chrome证书&#x2F;HSTS错误的讲解，我们后续会再探究。 如果输入之后，github.io博客页面的报错信息发生变化，变成： …无法访问此网站…github.io 请求遭到拒绝 … 未获授权 … 产生的原因和解决方案见这一篇博客中的说法： 因为github.com是外网，我们连接的时候IP地址需要转接地址，一层一层转接下来，就出现了上面的情况。","categories":[{"name":"Git","slug":"Git","permalink":"http://justskim.github.io/categories/Git/"},{"name":"Github","slug":"Git/Github","permalink":"http://justskim.github.io/categories/Git/Github/"}],"tags":[{"name":"安全证书","slug":"安全证书","permalink":"http://justskim.github.io/tags/%E5%AE%89%E5%85%A8%E8%AF%81%E4%B9%A6/"}]},{"title":"scipy版本的一些废弃方法及解决方案","slug":"scipy版本的一些废弃方法及解决方案","date":"2021-09-16T02:40:00.811Z","updated":"2021-09-16T09:30:55.280Z","comments":true,"path":"2021/09/16/scipy版本的一些废弃方法及解决方案/","link":"","permalink":"http://justskim.github.io/2021/09/16/scipy%E7%89%88%E6%9C%AC%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BA%9F%E5%BC%83%E6%96%B9%E6%B3%95%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"","text":"scipy版本的一些废弃方法及解决方案在之前我们为了解决scipy版本的问题，在python的cp37环境中下载了scipy的1.2.0版本。 今天，跟着numpy官方文档中的scipy章节敲代码时，发现了scipy版本废弃方法的相关bug。 文档中的示例代码如下： 12345678910111213141516171819from scipy.misc import imread, imsave, imresize# Read an JPEG image into a numpy arrayimg = imread(&#x27;assets/cat.jpg&#x27;)print(img.dtype, img.shape) # Prints &quot;uint8 (400, 248, 3)&quot;# We can tint the image by scaling each of the color channels# by a different scalar constant. The image has shape (400, 248, 3);# we multiply it by the array [1, 0.95, 0.9] of shape (3,);# numpy broadcasting means that this leaves the red channel unchanged,# and multiplies the green and blue channels by 0.95 and 0.9# respectively.img_tinted = img * [1, 0.95, 0.9]# Resize the tinted image to be 300 by 300 pixels.img_tinted = imresize(img_tinted, (300, 300))# Write the tinted image back to diskimsave(&#x27;assets/cat_tinted.jpg&#x27;, img_tinted) 运行后，会产生以下几个报错： 123456789101112PS E:\\python练习\\Numpy练习&gt; &amp; C:/Users/Ryan/Anaconda3/python.exe e:/python练习/Numpy练习/python中的Scipy.py e:/python练习/Numpy练习/python中的Scipy.py:13: DeprecationWarning: `imread` is deprecated! `imread` is deprecated in SciPy 1.0.0, and will be removed in 1.2.0. Use ``imageio.imread`` instead. img = imread(&#x27;assets/cat.jpg&#x27;)uint8 (400, 248, 3) `imresize` is deprecated in SciPy 1.0.0, and will be removed in 1.3.0. Use Pillow instead: ``numpy.array(Image.fromarray(arr).resize())``. img_tinted = imresize(img_tinted, (300, 300))e:/python练习/Numpy练习/python中的Scipy.py:28: DeprecationWarning: `imsave` is deprecated! `imsave` is deprecated in SciPy 1.0.0, and will be removed in 1.2.0. Use ``imageio.imwrite`` instead. 大概意思就是，scipy.misc模块中的imsave，imresize，imread这几个方法在scipy包的1.0版本中就已被弃用（deprecated）。为了实现该方法的功能，我们可以用报错信息中提示的几个方法来代替。 1. 从PIL包中引入Image模块，来取代imresize方法：stackoverflow上的这一个问题给出了 scipy.misc.imresize 的官方文档方面对此方法弃用的解释： imresize is deprecated! imresize is deprecated in SciPy 1.0.0, and will be removed in 1.3.0. Use Pillow instead: numpy.array(Image.fromarray(arr).resize()). Resize an image. This function is only available if Python Imaging Library (PIL) is installed. Warning This function uses bytescale under the hood to rescale images to use the full (0, 255) range if mode is one of None, &#39;L&#39;, &#39;P&#39;, &#39;l&#39;. It will also cast data for 2-D images to uint32 for mode=None (which is the default). Parameters: arr : ndarrayThe array of image to be resized.size : int, float or tupleint - Percentage of current size.float - Fraction of current size.tuple - Size of the output image (height, width).interp : str, optionalInterpolation to use for re-sizing (‘nearest’, ‘lanczos’, ‘bilinear’, ‘bicubic’ or ‘cubic’).mode : str, optionalThe PIL image mode (‘P’, ‘L’, etc.) to convert arr before resizing. If mode=None (the default), 2-D images will be treated like mode=&#39;L&#39;, i.e. casting to long integer. For 3-D and 4-D arrays, mode will be set to &#39;RGB&#39; and &#39;RGBA&#39; respectively. Returns: imresize : ndarrayThe resized array of image. 2. 从imageio包中使用相关方法替代imsave和imreadimageio的官方文档中，就有代替scipy.misc的相关说明： Transitioning from Scipy’s imreadScipy is deprecating their image I&#x2F;O functionality. This document is intended to help people coming from Scipy to adapt to Imageio’s imread function. We recommend reading the user api and checkout some examples to get a feel of imageio. Imageio makes use of variety of plugins to support reading images (and volumes&#x2F;movies) from many different formats. Fortunately, Pillow is the main plugin for common images, which is the same library as used by Scipy’s imread. Note that Imageio automatically selects a plugin based on the image to read (unless a format is explicitly specified), but uses Pillow where possible. In short terms: For images previously read by Scipy’s imread, imageio should generally use Pillow as well, and imageio provides the same functionality as Scipy in these cases. But keep in mind: Instead of mode, use the pilmode keyword argument. Instead of flatten, use the as_gray keyword argument. The documentation for the above arguments is not on imread, but on the docs of the individual formats, e.g. PNG. Imageio’s functions all return numpy arrays, albeit as a subclass (so that meta data can be attached). 我们使用imageio.imread和imageio.write分别代替scipy.misc中的imread和imsave两个方法，成功解决问题。 3. PIL包的作用廖雪峰的官方网站中关于pillow这一个常用第三方模块的介绍是： PIL：Python Imaging Library，已经是Python平台事实上的图像处理标准库了。PIL功能非常强大，但API却非常简单易用。 由于PIL仅支持到Python 2.7，加上年久失修，于是一群志愿者在PIL的基础上创建了兼容的版本，名字叫Pillow，支持最新Python 3.x，又加入了许多新特性，因此，我们可以直接安装使用Pillow。 若已经安装anaconda，则无需使用pip安装Pillow包了。 对于这一个库的学习，在以后我们会继续探讨 改正后，我们的代码如下： 123456789101112131415161718192021222324252627282930313233# -*- coding: UTF-8 –*-# 上面这一行是python头文件的声明# 缺省情况下程序需要用ascii码书写，但如果其中写中文的话，python解释器会报错import imageiofrom PIL import Imageimport numpy &#x27;&#x27;&#x27;直接使用pip安装misc会报错 ImportError:cannot import name &#x27;imread&#x27; from &#x27;scipy.misc&#x27;原因在于包的版本问题，新版本的scipy.misc没有这一个方法为了对照文档，我们卸载并重新安装：pip3 install scipy==1.2.0但是依然无法解决问题，发现是我们下错版本了，要用1.0的才行，不过我们不会管这个问题了，因为我们使用imageio和PIL来作为解决方案，详见我的个人博客&#x27;&#x27;&#x27;# Read an JPEG image into a numpy arrayimg = imageio.imread(&#x27;assets/cat.jpg&#x27;)print(img.dtype, img.shape) # Prints &quot;uint8 (400, 248, 3)&quot;# We can tint the image by scaling each of the color channels# by a different scalar constant. The image has shape (400, 248, 3);# we multiply it by the array [1, 0.95, 0.9] of shape (3,);# numpy broadcasting means that this leaves the red channel unchanged,# and multiplies the green and blue channels by 0.95 and 0.9# respectively.img_tinted = img * [1, 0.95, 0.9]# Resize the tinted image to be 300 by 300 pixels.img_tinted = numpy.array(Image.fromarray(img).resize((300,300)))#成功将图片保存# Write the tinted image back to diskimageio.imwrite(&#x27;assets/cat_tinted.jpg&#x27;, img_tinted) 成功运行！","categories":[{"name":"Data analysis","slug":"Data-analysis","permalink":"http://justskim.github.io/categories/Data-analysis/"}],"tags":[{"name":"数据分析","slug":"数据分析","permalink":"http://justskim.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"python","slug":"python","permalink":"http://justskim.github.io/tags/python/"},{"name":"debug","slug":"debug","permalink":"http://justskim.github.io/tags/debug/"},{"name":"package","slug":"package","permalink":"http://justskim.github.io/tags/package/"},{"name":"scipy","slug":"scipy","permalink":"http://justskim.github.io/tags/scipy/"}]},{"title":"python旧版本的安装与debug ———— 以scipy1.2.0为例","slug":"python旧版本的安装与debug-————-以scipy1.2.0为例","date":"2021-09-15T13:25:23.482Z","updated":"2021-09-16T02:49:20.725Z","comments":true,"path":"2021/09/15/python旧版本的安装与debug-————-以scipy1.2.0为例/","link":"","permalink":"http://justskim.github.io/2021/09/15/python%E6%97%A7%E7%89%88%E6%9C%AC%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8Edebug-%E2%80%94%E2%80%94%E2%80%94%E2%80%94-%E4%BB%A5scipy1.2.0%E4%B8%BA%E4%BE%8B/","excerpt":"","text":"python旧版本的安装与debug ———— 以scipy1.2.0为例在对照numpy中文文档进行学习时，使用pip安装对应的包，启动以下示例代码中的py文件： 12345678910111213141516171819import numpy as npfrom scipy.misc import imread, imresizeimport matplotlib.pyplot as pltimg = imread(&#x27;assets/cat.jpg&#x27;) #这里的是一张自定义的资源图片文件img_tinted = img * [1, 0.95, 0.9]# Show the original imageplt.subplot(1, 2, 1)plt.imshow(img)# Show the tinted imageplt.subplot(1, 2, 2)# A slight gotcha with imshow is that it might give strange results# if presented with data that is not uint8. To work around this, we# explicitly cast the image to uint8 before displaying it.plt.imshow(np.uint8(img_tinted))plt.show() 产生报错如下：AttributeError: &#39;module&#39; object has no attribute &#39;imread&#39; 经过查询相关博客，发现导致该报错的原因在于，从1.3版本开始，imread等几个经典方法已经从scipy包的misc模块中移除。那么，既然找到问题，我们就要寻求解决的方法，目前发现了以下三个： 安装imageio库https://blog.csdn.net/sky_9900/article/details/98171702 安装pillow库https://www.dovov.com/scipy-miscimread.html 使用1.2版本的scipy包，当我们遇到其他类似情况时，也可以寻求使用旧版本的包 容易掉坑的点第一个，就是python的编辑器版本，我下的时候没有注意，直接下的最新的版本3.9 结果，当我直接在cmd中使用命令pip install scipy==1.2.0时，直接弹出一大堆报错： 12ERROR: Command errored out with exit status 1:... #（下面还有很多行，但与解决问题无关紧要） 接着，我尝试着从pypi.org中下载旧版本的whl文件去进行安装，这一次给出的报错信息明显让我意识到了编辑器版本的不匹配： 123456E:\\&gt;pip install scipy-1.2.0-cp37-cp37m-win_amd64.whlWARNING: Ignoring invalid distribution -ip (e:\\python\\lib\\site-packages)WARNING: Ignoring invalid distribution -ip (e:\\python\\lib\\site-packages)ERROR: scipy-1.2.0-cp37-cp37m-win_amd64.whl is not a supported wheel on this platform.WARNING: Ignoring invalid distribution -ip (e:\\python\\lib\\site-packages)WARNING: Ignoring invalid distribution -ip (e:\\python\\lib\\site-packages) （事实证明，pypi.org比很多包的官网有用，含有的包版本也更多，比如scipy官网） 从pypi.org上查找到的scipy1.2版本适用的编辑器最高版本为cp37，所幸我电脑上之前用conda安装了对应版本的python，不必经过配置，在vs code中点击左下角，切换python编辑器环境为3.7。![Switch](&#x2F;images&#x2F;在vs code左下角切换环境.png)然后我们启动代码，成功跑通！ 附：几种python包指定版本的安装方式 pip 安装 whl文件下载安装 tar.gz文件下载安装 conda下载安装conda 下载安装whl文件conda 下载安装tar.gz文件附：几个常用的python包下载网站 https://pypi.org/ https://www.lfd.uci.edu/~gohlke/pythonlibs/","categories":[{"name":"Data analysis","slug":"Data-analysis","permalink":"http://justskim.github.io/categories/Data-analysis/"}],"tags":[{"name":"数据分析","slug":"数据分析","permalink":"http://justskim.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"python","slug":"python","permalink":"http://justskim.github.io/tags/python/"},{"name":"debug","slug":"debug","permalink":"http://justskim.github.io/tags/debug/"},{"name":"package","slug":"package","permalink":"http://justskim.github.io/tags/package/"},{"name":"scipy","slug":"scipy","permalink":"http://justskim.github.io/tags/scipy/"}]},{"title":"网站搜索纪录的删除","slug":"网站搜索纪录的删除","date":"2021-09-06T14:56:21.062Z","updated":"2021-09-06T14:56:21.063Z","comments":true,"path":"2021/09/06/网站搜索纪录的删除/","link":"","permalink":"http://justskim.github.io/2021/09/06/%E7%BD%91%E7%AB%99%E6%90%9C%E7%B4%A2%E7%BA%AA%E5%BD%95%E7%9A%84%E5%88%A0%E9%99%A4/","excerpt":"","text":"网站搜索纪录的删除在一些网站的搜索框中，可能会出现你之前并没有搜索的词条，如： 即使在浏览器中清空浏览历史和cookies都无效。 解决方法：鼠标移至该词条上方选中，同时按住“delete”+“shift”键即可删除。 出现这种情况的原因暂且不明，推测与浏览器的自动保存信息有关，留待以后探究。","categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"},{"name":"JavaScript","slug":"Programming-languages-and-projects/JavaScript","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/JavaScript/"},{"name":"web","slug":"Programming-languages-and-projects/JavaScript/web","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/JavaScript/web/"}],"tags":[{"name":"browser","slug":"browser","permalink":"http://justskim.github.io/tags/browser/"},{"name":"web","slug":"web","permalink":"http://justskim.github.io/tags/web/"}]},{"title":"typora与hexo博客中的图片插入","slug":"typora与hexo博客中的图片插入","date":"2021-09-06T10:25:20.704Z","updated":"2021-09-15T14:03:12.861Z","comments":true,"path":"2021/09/06/typora与hexo博客中的图片插入/","link":"","permalink":"http://justskim.github.io/2021/09/06/typora%E4%B8%8Ehexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%8F%92%E5%85%A5/","excerpt":"","text":"typora与hexo博客中的图片插入Markdown文档^1中给出的图片插入方式 要添加图像，请添加感叹号（!），然后在括号中添加替代文本，并在括号中添加图像资源的路径或URL。您可以选择在括号中的URL之后添加标题。 链接图像——点击该图像后可以跳转到相关链接要向图像添加链接，请将图像的Markdown括在方括号中，然后在括号中添加链接。 Typora编辑器中的图片插入方式如果使用传统的在markdown文档中图片插入的方式，实际上文档中保存的只是一个指向该图片的本地地址。当我们要在typora文档中永久保存一张图片，并且实现实时预览的功能，可以采用这一篇博客^2所讲到的方法： 将图片转化为base64格式并在typora里插入的方法：1、例如，在src里输入这段编码；2、通过常见的![][src]，src里是编码，可以看到这里是中括号[]，而不是括号。 另外，因为编码比较长，且图片可能较多，所以有的时候我们可以通过把src换成图片编号，然后在文档最后将图片编号指向编码。示例： 工具网站很多，比如一个在线的：http://tool.chinaz.com/tools/imgtobase。github上一键转换：https://github.com/hujingnb/markdownImage/tree/master Hexo博客文章中的图片插入方式hexo的官方文档^3中给出了两种博客文章的插入方法： 资源文件夹资源（Asset）代表 source 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。比方说，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 source/images 文件夹中。然后通过类似于 ![](/images/image.jpg) 的方法访问它们。对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，Hexo也提供了更组织化的方式来管理资源。这个稍微有些复杂但是管理资源非常方便的功能可以通过将 config.yml 文件中的 post_asset_folder 选项设为 true 来打开。1_config.ymlpost_asset_folder: true 当资源文件管理功能打开后，Hexo将会在你每一次通过 hexo new [layout] &lt;title&gt; 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。 相对路径引用的标签插件通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。123&gt;&#123;% asset_path slug %&#125;&gt;&#123;% asset_img slug [title] %&#125;&gt;&#123;% asset_link slug [title] %&#125; 比如说：当你打开文章资源文件夹功能后，你把一个 example.jpg 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 ![](example.jpg) ，它将 不会 出现在首页上。（但是它会在文章中按你期待的方式工作）正确的引用图片方式是使用下列的标签插件而不是 markdown ： 1&gt;&#123;% asset_img example.jpg This is an example image %&#125; 通过这种方式，图片将会同时出现在文章和主页以及归档页中。 第二种方法用起来稍微麻烦，这里根据博客——hexo+typora 插入图片的简便解决方案[^4]介绍第三种方法： 使用最简单的方式在 source 目录下创建images目录，然后图片都保存在这里。 关键是要在typora上做以下设置： 在md文件头部的配置项中，添加 typora-root-url: ../ ，格式如下 1234title: hexo+typora 插入图片 date: 2019-06-08 10:37:22 tags: typora-root-url: ../ 这样引用的图片都以上一级目录即 source作为根目录了，此时插入的图片时，只要点击“复制图片到…”并选择一次文件夹，以后每次都会自动保存在 source&#x2F;image目录下，并且本地的显示和服务器上的根目录完全一致，使用体验还是很方便的。 在具体使用中，可以使用以下两种方法添加图片链接： ![描述](图片文件路径，如/images/cat.jpg，注意无引号) &lt;img src=&quot;图片文件路径，如/images/cat.jpg&quot;&gt; 经过验证，这个方法是十分方便可靠的，感谢博主，推荐使用。 很多个markdown中文官方网站 https://markdown.com.cn/basic-syntax/images.html https://markdown-zh.readthedocs.io/en/latest/blockelements/ http://markdown.p2hp.com/basic-syntax/ http://www.markdown.cn/#images References[^4]: 博客——hexo+typora 插入图片的简便解决方案","categories":[{"name":"MarkDown","slug":"MarkDown","permalink":"http://justskim.github.io/categories/MarkDown/"},{"name":"typora的特殊使用","slug":"MarkDown/typora的特殊使用","permalink":"http://justskim.github.io/categories/MarkDown/typora%E7%9A%84%E7%89%B9%E6%AE%8A%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://justskim.github.io/tags/markdown/"},{"name":"typora","slug":"typora","permalink":"http://justskim.github.io/tags/typora/"},{"name":"hexo","slug":"hexo","permalink":"http://justskim.github.io/tags/hexo/"}]},{"title":"MYSQL字段属性","slug":"MYSQL字段属性","date":"2021-09-05T07:24:32.452Z","updated":"2021-09-08T09:59:49.338Z","comments":true,"path":"2021/09/05/MYSQL字段属性/","link":"","permalink":"http://justskim.github.io/2021/09/05/MYSQL%E5%AD%97%E6%AE%B5%E5%B1%9E%E6%80%A7/","excerpt":"","text":"MYSQL字段属性参考博客“MySql中的列属性”^1： MySql中，真正约束字段的是数据类型，但是数据类型的约束太单一，因此我们需要有一些额外的约束，来更加保证数据的合法性。 MySql中的常用列属性有：null、not null、default、primary key、auto_increment、comment。下面以博主所用当前最新的Mysql版本2021-9-1 mysql Ver 8.0.26 for Win64 on x86_64 (MySQL Community Server - GPL)为例介绍几个列属性值： 1. 主键 primary key主键（primary key）有以下几个作用： 能唯一标识记录的字段，可以作为主键。 一个表最多只能有一个主键。 主键具有唯一性，因此又称唯一键需要特别注意的是： 主键字段的值不能为null; 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。使用主键：声明字段时，用 primary key 标识。 添加主键有以下四种方式： 创建表的时候，在字段后加上 primary key。 123456#语法： 字段名 数据类型 primary key #例子：添加一个名叫【my_primark_key1】的表，为其添加id字段和name字段，且将id字段设置成主键。create table if not exists my_primary_key1( id int primary key, name varchar(10) not null)charset utf8; 注意，使用这种主键定义方式的话，只能给一个字段添加primary key，如果为多个字段添加这一标识，如1234create table ttt_test( id int primary key, name varchar(30) primary key)charset utf8; 就会导致以下的报错：1ERROR 1068 (42000): Multiple primary key defined 插入数据：insert into my_primary_key values(1001,&#39;张三&#39;);如果我们再次插入一条主键相同的数据，如: insert into my_primary_key values(1001,&#39;张大&#39;);就会产生报错： Duplicate entry &#39;1001&#39; for key &#39;PRIMARY&#39;报错的原因是主键值不能相同。 复合主键。在创建表的时候，在所有的字段之后，使用primay key(主键字段列表)来创建主键(可以有多个字段作为主键)来创建复合主键。 1234567#语法：primary key(字段1，字段2......)**#例子：创建一张【my_primark_key2】的表，为其添加number字段(int类型)和classname 字段(varchar类型)，将这个字段添加成复合主键。** create table if not exists my_primary_key2( number int not null, classname varchar(20) not null, primary key(number,classname))charset utf8; 插入数据：插入数据只有两个字段(number,name)共同重复时才会插入失败，如果只有1个字段重复，而另一个字段不重复，那么就被允许插入。 123insert into my_primary_key2(number,classname) values(1001,&#x27;高一(2)班&#x27;); #插入成功 insert into my_primary_key2(number,classname) values(1001,&#x27;高一(3)班&#x27;); #也成功插入，因为插入的值中有1个字段的值与表中的值不一样。 向表中的字段追加主键（该方法也适合于修改字段的其他属性值&#x2F;增加其他标识）。 12345678#语法：alter table 表名字 字段名 数据类型 primary key(新建一个字段，添加主键，如果字段已经存在要用修改的方式）;#例子：新建一个名叫【my_primary_key3】的表，为其加入id字段和name字段。create table if not exists my_primary_key3( id int, name varchar(10) not null)charset utf8;#修改 my_primary_key3表中的id字段为主键。alter table my_primary_key2 modify id int primary key comment &#x27;编号&#x27;; 通过add primary key(字段名) 进行添加。语法：alter table 表名字 add primary key(要添加主键的字段名);例子：添加id为主键。alter table userinfo add primary key(id);主键约束。 主键对应的字段中的数据不允许重复，一旦重复，操作失败。主键没有办法更新，只能先删除主键，然后再添加主键。 12345#语法：alter table 表名字 drop primary key#例子：修改【my_primary_key3】表中已存在的主键，为name字段设置主键。alter table my_primary_key3 drop primary key3; -- 先删除。#为name 字段添加主键(以修改的形式)。alter table my_primary_key3 modify name varchar(10) primary key; 2. unique 唯一索引（唯一约束） 使得某字段的值也不能重复。一张表往往有很多字段需要具有唯一性，数据不能重复，这个时候用唯一键(unique)就体现出其优势了，可以解决表中多个字段需要唯一性约束的问题，唯一键的本质与主键的性质差不多，唯一键默认的允许字段为空， 而且可以多个字段为空(空字段不参与唯一性比较)。 添加唯一键。语法：字段名 数据类型 unique&#x2F;unique key有3种方式添加唯一键。 在字段后面添加唯一键。例子：新建一张【my_unique】的表，为其添加一个name字段，并设置成唯一键。 1234567create table if not exists my_unique( name varchar(10) not null unique)charset utf8;#插入数据：insert into my_unique(&#x27;李四&#x27;); #再次插入一个名叫李四的就会报错。 在所有的字段之后添加 unique key(字段列表)，复合唯一键。例子：添加一张【my_unique】的表，为其添加number字段(int类型)和name字段(varchar类型)，然后将两个设置成复合唯一键。 123456789create table if not exists my_unique2(number int not null,name varchar(20) not null,unique key(number,name))charset utf8;#插入数据。 insert into my_unique2 values(10001,&#x27;张三&#x27;); # 有效数据insert into my_unique2 values(10001,&#x27;李四&#x27;); # 有效数据(符合唯一键是两个字段值要相同)insert into my_unique2 values(10001,&#x27;张三&#x27;); # 无效数据(复合主键重复了) 追加唯一键。 1234567#语法：alter table 表名字 add unque key(字段名);#例子：新建一张【my_unique3】的表，添加一个字段name(carchar类型)。create table if not exists my_unique3( name varchar(30) not null)charset utf8;#向my_unique3表中追加唯一键。alter table my_unique3 add unique key(name); 更新唯一键的方法：先删除，后新增。 删除唯一键：语法：alter table 表名字 drop index 索引名字(唯一键默认的使用字段名作为索引名字) 3. 空属性 null 约束空属性有2个值，分别是 null(空，默认的) 和 not null(不为空)，mysql数据库默认字段都是为null的，但是在实际开发过程中，尽可能保证所有的数据都不应该为null，空数据没有意义，空数据没有办法参加运算注意！null不是数据类型，是列的一个属性。 123456 # 语法：字段名 数据类型 not null create table if not exists my_notnull( name varchar(10) not null )charset utf8;#此时表示将第一个字段的值设为null, 取决于该字段是否允许为nullinsert into tab values (null, &#x27;val&#x27;); 4. default 默认值属性 当前字段的默认值，用default表示，某一种数据会经常的出现某个具体值，可以在一开始指定好，在需要真实数据的时候，用户可以选择性地使用默认值。 123456789#语法：字段名 数据类型 default 默认值#例子：添加一个【my_default】表，为其添加name字段，age字段，并未age字段指定默认值为18。 create table if not exists my_default( name varchar(10) not null comment &#x27;姓名&#x27;, age tinyint unsigned not null default 18 comment &#x27;年龄&#x27;)charset utf8;#插入数据：如果要使用默认值，在给表插入数据的时候，不给字段赋值即可。insert into my_default(name) values(&#x27;张三&#x27;); 5. auto_increment 自动增长约束注意拼写方式为auto_increment，有下划线连接当对应的字段不给值，或者给null的时候会自动地被系统触发，系统会从当前字段中已有的最大值再进行+1，得到一个新的不同的字段，通常和主键搭配。 自动增长必须为索引（主键或unique） 只能存在一个字段为自增长auto_increment。默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或alter table tbl auto_increment = x;自增长的特点 ： 任何一个字段做自增长前提 自身是一个索引(key一栏有值)。 自增长字段通常是整形。 一个表中只能有1个自增长。12345#例子：添加一张【my_auto_increment】的表，为其添加id字段和name字段，其中id字段设置成主键和自增长。create table if not exists my_auto_increment( id int primary key auto_increment, name varchar(10) not null)charset utf8; 插入值： 12insert into my_auto_Increment values(null,&#x27;张三&#x27;); #有效insert into my_auto_Increment(name) values(&#x27;李四&#x27;); #有效 自增长如果对应的字段输入了值，那么自增长失效，但是**下一次还是能够正确的自增长(从最大值+1)**。1234567891011121314151617181920212223242526mysql&gt; select * from my_auto_increment;+----+--------+| id | name |+----+--------+| 1 | Mary || 3 | Tom || 5 | Cook || 6 | Lowson |+----+--------+4 rows in set (0.00 sec)mysql&gt; insert my_auto_increment values(null,&quot;Taylo&quot;);Query OK, 1 row affected (0.01 sec)mysql&gt; select * from my_auto_increment;+----+--------+| id | name |+----+--------+| 1 | Mary || 3 | Tom || 5 | Cook || 6 | Lowson || 7 | Taylo |+----+--------+5 rows in set (0.00 sec)#可以看到，新插入的id为7而不是4,5,6 修改自增长：自增长如果是涉及到字段改变，必须先删除自增长，后增加，一张表中只能有1个自增长。修改当前已存在自增长的值，！特别注意：修改只能比当前已有的自增长的最大值大，不能小(小则不生效)！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#插入数据mysql&gt; insert my_auto_increment values(null,&quot;Chechil&quot;);Query OK, 1 row affected (0.01 sec)mysql&gt; select * from my_auto_increment;+----+---------+| id | name |+----+---------+| 1 | Mary || 3 | Tom || 6 | Lowson || 7 | Taylo || 13 | Cook || 14 | Brazil || 15 | Chechil |+----+---------+7 rows in set (0.00 sec)#修改某个数据的自增长属性值，由14改为20mysql&gt; update my_auto_increment set id = 15 where name=&#x27;Chechil&#x27;;Query OK, 0 rows affected (0.00 sec)Rows matched: 1 Changed: 0 Warnings: 0mysql&gt; select * from my_auto_increment;+----+---------+| id | name |+----+---------+| 1 | Mary || 3 | Tom || 6 | Lowson || 7 | Taylo || 13 | Cook || 14 | Brazil || 20 | Chechil |+----+---------+7 rows in set (0.00 sec)#再次插入数据mysql&gt; insert my_auto_increment values(null,&quot;Agent&quot;);Query OK, 1 row affected (0.01 sec)mysql&gt; select * from my_auto_increment;+----+---------+| id | name |+----+---------+| 1 | Mary || 3 | Tom || 6 | Lowson || 7 | Taylo || 13 | Cook || 14 | Brazil || 20 | Chechil || 21 | Agent |+----+---------+8 rows in set (0.00 sec)#注意！！！插入的数据从最大值+1开始，前面的全部跳过不管！！ 删除自增增长。自增长是字段的一个属性，可以通过modify属性来修改(字段没有自增长)。语法：alter table 表名字 modify 字段名 数据类型例子：将【my_auto_Increment】表中 id字段的自增长去掉。alter table my_auto_increment modify id int; 自增长为什么从1开始（注意不像其他编程语言从0开始）？又为什么每次都是自增1呢？所有系统的表现(如字符集、校对集)都是由系统的内部变量进行控制的。查看自增长对应的变量的语法：show variables like ‘auto_increment%’; 可以修改变量实现不同的效果。如果对整个数据修改(而不是但张表)，这种方式是修改时会话级(当前客户端，当此连接有效，关闭失效)。修改成一次自增为5:set auto_increment_increment = 5; 1234567891011121314151617181920212223242526272829303132333435363738mysql&gt; set my_auto_increment = 5;ERROR 1193 (HY000): Unknown system variable &#x27;my_auto_increment&#x27;mysql&gt; set auto_increment = 5;ERROR 1193 (HY000): Unknown system variable &#x27;auto_increment&#x27;mysql&gt; show variables like &#x27;auto_increment%&#x27;;+--------------------------+-------+| Variable_name | Value |+--------------------------+-------+| auto_increment_increment | 1 || auto_increment_offset | 1 |+--------------------------+-------+2 rows in set, 1 warning (0.01 sec)#自增长的两个相关配置：auto_increment_offset和auto_increment_increment#auto_increment_offset表示自增长字段从那个数开始，他的取值范围是1 .. 65535#auto_increment_increment表示自增长字段每次递增的量，其默认值是1，取值范围是1 .. 65535mysql&gt; set auto_increment_increment = 5;Query OK, 0 rows affected (0.01 sec)mysql&gt; insert my_auto_increment value(null,&quot;Panda&quot;);Query OK, 1 row affected (0.01 sec)mysql&gt; select * from my_auto_increment;+----+---------+| id | name |+----+---------+| 1 | Mary || 3 | Tom || 6 | Lowson || 7 | Taylo || 13 | Cook || 14 | Brazil || 20 | Chechil || 21 | Agent || 26 | Panda |+----+---------+9 rows in set (0.00 sec)#可以看到，从21到26一次增加了5 6. comment 注释（列描述）列描述(注释)：comment，实际没有什么含义，是专门用来描述字段的，会根据创建语句保存，用来给程序员(或者数据库管理员)来进行了解的。主要用于查看创建表的语法上进行查看。 12345#语法：字段名 数据类型 comment ‘说明文字’#例子：创建一张【my_comment 】的表，为其添加一个name字段，并为其添加说明。 create table if not exists my_comment( name varchar(10) comment &#x27;姓名字段&#x27;)charset utf8; 7. foreign key 外键约束CSDN博主「Mr.路痴」的这一篇原创文章[^2]中提到了外键约束的一些特点： 父表和子表必须使用相同的存储引擎，而且禁止使用临时表。数据表的存储引擎只能为InnoDB。外键列和参照列必须具有相似的数据类型，也就是可以相互转换类型的列，比如 int 和 tinyint 可以，而 int 和 char 则不可以数字类型的长度以及是否有符号（是否unsigned）必须相同字符类型的长度则可以不同。外键列和参照列必须创建索引。如果外键列不存在索引，MySQl将自动创建。外键的名字不能重复 C语言中文网对于mysql外键约束的这一篇博客[^3]讲的很好： MySQL 外键约束（FOREIGN KEY）是表的一个特殊字段，经常与主键约束一起使用。对于两个具有关联关系的表而言，相关联字段中主键所在的表就是主表（父表），外键所在的表就是从表（子表）。 外键用来建立主表与从表的关联关系，为两个表的数据建立连接，约束两个表中数据的一致性和完整性。比如，一个水果摊，只有苹果、桃子、李子、西瓜等 4 种水果，那么，你来到水果摊要买水果就只能选择苹果、桃子、李子和西瓜，其它的水果都是不能购买的。 主表删除某条记录时，从表中与之对应的记录也必须有相应的改变。一个表可以有一个或多个外键，外键可以为空值，若不为空值，则每一个外键的值必须等于主表中主键的某个值。 定义外键时，需要遵守下列规则： 主表必须已经存在于数据库中，或者是当前正在创建的表。如果是后一种情况，则主表与从表是同一个表，这样的表称为自参照表，这种结构称为自参照完整性。 必须为主表定义主键。 主键不能包含空值，但允许在外键中出现空值。也就是说，只要外键的每个非空值出现在指定的主键中，这个外键的内容就是正确的。 在主表的表名后面指定列名或列名的组合。这个列或列的组合必须是主表的主键或候选键。 外键中列的数目必须和主表的主键中列的数目相同。 外键中列的数据类型必须和主表主键中对应列的数据类型相同。 在创建表时设置外键约束在 CREATE TABLE 语句中，通过 FOREIGN KEY 关键字来指定外键，具体的语法格式如下： [CONSTRAINT &lt;外键名&gt;] FOREIGN KEY 字段名 [，字段名2，…]REFERENCES &lt;主表名&gt; 主键列1 [，主键列2，…] 例 1为了展现表与表之间的外键关系，本例在 test_db 数据库中创建一个部门表 tb_dept1，表结构如下表所示。 字段名称 数据类型 备注 id INT(11) 部门编号 name VARCHAR(22) 部门名称 location VARCHAR(22) 部门位置 创建 tb_dept1 的 SQL 语句和运行结果如下所示。 1234567mysql&gt; CREATE TABLE tb_dept1 -&gt; ( -&gt; id INT(11) PRIMARY KEY, -&gt; name VARCHAR(22) NOT NULL, -&gt; location VARCHAR(50) -&gt; );Query OK, 0 rows affected (0.37 sec) 创建数据表 tb_emp6，并在表 tb_emp6 上创建外键约束，让它的键 deptId 作为外键关联到表 tb_dept1 的主键 id，SQL 语句和运行结果如下所示。 123456789101112131415161718192021mysql&gt; CREATE TABLE tb_emp6 -&gt; ( -&gt; id INT(11) PRIMARY KEY, -&gt; name VARCHAR(25), -&gt; deptId INT(11), -&gt; salary FLOAT, -&gt; CONSTRAINT fk_emp_dept1 -&gt; FOREIGN KEY(deptId) REFERENCES tb_dept1(id) -&gt; );Query OK, 0 rows affected (0.37 sec)mysql&gt; DESC tb_emp6;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(25) | YES | | NULL | || deptId | int(11) | YES | MUL | NULL | || salary | float | YES | | NULL | |+--------+-------------+------+-----+---------+-------+4 rows in set (1.33 sec) 以上语句执行成功之后，在表 tb_emp6 上添加了名称为 fk_emp_dept1 的外键约束，外键名称为 deptId，其依赖于表 tb_dept1 的主键 id。 注意：从表的外键关联的必须是主表的主键，且主键和外键的数据类型必须一致。例如，两者都是 INT 类型，或者都是 CHAR 类型。如果不满足这样的要求，在创建从表时，就会出现“ERROR 1005(HY000): Can’t create table”错误。 在修改表时添加外键约束外键约束也可以在修改表时添加，但是添加外键约束的前提是：从表中外键列中的数据必须与主表中主键列中的数据一致或者是没有数据。 在修改数据表时添加外键约束的语法格式如下： ALTER TABLE &lt;数据表名&gt; ADD CONSTRAINT &lt;外键名&gt;FOREIGN KEY(&lt;列名&gt;) REFERENCES &lt;主表名&gt; (&lt;列名&gt;); 例 2修改数据表 tb_emp2，将字段 deptId 设置为外键，与数据表 tb_dept1 的主键 id 进行关联，SQL 语句和运行结果如下所示。 1234567891011121314151617181920mysql&gt; ALTER TABLE tb_emp2 -&gt; ADD CONSTRAINT fk_tb_dept1 -&gt; FOREIGN KEY(deptId) -&gt; REFERENCES tb_dept1(id);Query OK, 0 rows affected (1.38 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; SHOW CREATE TABLE tb_emp2\\G*************************** 1. row *************************** Table: tb_emp2Create Table: CREATE TABLE `tb_emp2` ( `id` int(11) NOT NULL, `name` varchar(30) DEFAULT NULL, `deptId` int(11) DEFAULT NULL, `salary` float DEFAULT NULL, PRIMARY KEY (`id`), KEY `fk_tb_dept1` (`deptId`), CONSTRAINT `fk_tb_dept1` FOREIGN KEY (`deptId`) REFERENCES `tb_dept1` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=gb23121 row in set (0.12 sec) 注意：在为已经创建好的数据表添加外键约束时，要确保添加外键约束的列的值全部来源于主键列，并且外键列不能为空。 删除外键约束当一个表中不需要外键约束时，就需要从表中将其删除。外键一旦删除，就会解除主表和从表间的关联关系。 删除外键约束的语法格式如下所示： ALTER TABLE &lt;表名&gt; DROP FOREIGN KEY &lt;外键约束名&gt;; 例 3删除数据表 tb_emp2 中的外键约束 fk_tb_dept1，SQL 语句和运行结果如下所示。 1234567891011121314151617mysql&gt; ALTER TABLE tb_emp2 -&gt; DROP FOREIGN KEY fk_tb_dept1;Query OK, 0 rows affected (0.19 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; SHOW CREATE TABLE tb_emp2\\G*************************** 1. row *************************** Table: tb_emp2Create Table: CREATE TABLE `tb_emp2` ( `id` int(11) NOT NULL, `name` varchar(30) DEFAULT NULL, `deptId` int(11) DEFAULT NULL, `salary` float DEFAULT NULL, PRIMARY KEY (`id`), KEY `fk_tb_dept1` (`deptId`)) ENGINE=InnoDB DEFAULT CHARSET=gb23121 row in set (0.00 sec) 可以看到，tb_emp2 中已经不存在 FOREIGN KEY，原有的名称为 fk_emp_dept 的外键约束删除成功。 Mysql workbench中的其他列属性 根据这一篇博客《MySQL Workbench 中各个列属性的含义》： PK: 主键 (Primary Key) NN: 非空 (Not Null) UQ: 唯一索引 (Unique Index) BIN: 二进制 (Binary) 将数据储存为二进制字符串 UN: 无符号的 (Unsigned) ZF: 零填充的 (Zero Fill) 如：INT (5) 的列中，12 会被填充为 00012 AI: 自增长的 (Auto Increment) G: 生成出来的 (Generated) 如：根据公式从其它列中生成的数据 之前我们已经讲过了里面的很多属性，下面重点介绍四个：unsigned、binary、generated和unique inex。 unsiged属性UNSIGNED属性将数字类型无符号化，与C、C++这些程序语言中的unsigned含义相同。例如，INT的类型范围是-2 147 483 648 ～ 2 147 483 647， INT UNSIGNED的范围类型就是0 ～ 4 294 967 295。 在MYSQL中整型范围： 类型 大小 范围（有符号） 范围（无符号） 用途 TINYINT 1 字节 (-128，127) (0，255) 小整数值 SMALLINT 2 字节 (-32 768，32 767) (0，65 535) 大整数值 MEDIUMINT 3 字节 (-8 388 608，8 388 607) (0，16 777 215) 大整数值 INT或INTEGER 4 字节 (-2 147 483 648，2 147 483 647) (0，4 294 967 295) 大整数值 binary属性binary属性只用于char和varchar值。当为列指定了该属性时，将以区分大小写的方式排序。与之相反，忽略binary属性时，将使用不区分大小写的方式排序 generated column属性Generated Column是MySQL5.7引入的新特性，博客MySQL 5.7新特性之Generated Column中对此有详细解释： 所谓Cenerated Column，就是数据库中这一列由其他列计算而得，我们以官方参考手册中的例子予以说明。 例如，知道直角三角形的两条直角边，要求斜边的长度。很明显，斜边的长度可以通过两条直角边计算而得，那么，这时候就可以在数据库中只存放直角边，斜边使用Generated Column，如下所示： 1234567CREATE TABLE triangle ( sidea DOUBLE,#直角边a sideb DOUBLE,#直角边b sidec DOUBLE AS (SQRT(sidea * sidea + sideb * sideb)) #根据公式求出斜边c);INSERT INTO triangle (sidea, sideb) VALUES(1,1),(3,4),(6,8); 查询结果： 123456789101112131415mysql&gt; SELECT * FROM triangle;+-------+-------+--------------------+| sidea | sideb | sidec |+-------+-------+--------------------+| 1 | 1 | 1.4142135623730951 || 3 | 4 | 5 || 6 | 8 | 10 |+-------+-------+--------------------+ 这个例子就足以说明Generated Columns是什么，以及怎么使用用了。 Mysql中key、primary key、unique key、index之间的区别以下引用自简书发布者陈琰AC的博客 一、Key1.1 key 是数据库的物理结构，它包含两层意义和作用 一是约束：偏重于约束和规范数据库的结构完整性 二是索引：辅助查询用的 key包括primary key, unique key, foreign key 等。 1.2 primary key 有两个作用，一是约束作用（constraint），用来规范一个存储主键和唯一性，但同时也在此key上建立了一个主键索引 primary key 约束：唯一标识数据库表中的每条记录 主键必须包含唯一的值； 主键列不能包含 NULL 值； 每个表都应该有一个主键，并且每个表只能有一个主键。（primary key 拥有自动定义的 unique 约束） 1.3 unique key 也有两个作用，一是约束作用（constraint），规范数据的唯一性，但同时也在这个key上建立了一个唯一索引 unique 约束：唯一标识数据库表中的每条记录。 unique 和 primary key 约束均为列或列集合提供了唯一性的保证。-每个表可以有多个 unique 约束，但是每个表只能有一个primary key 约束. 1.4 foreign key也有两个作用，一是约束作用（constraint），规范数据的引用完整性，但同时也在这个key上建立了一个index 可见，MySQL的key是同时具有constraint和index的意义，这点和其他数据库表现的可能有区别（至少在oracle上建立外键，不会自动建立index）。 1.5 因此创建key也有如下几种方式：（1）在字段级以key方式建立， 如 create table t (id int not null primary key);（2）在表级以constraint方式建立，如create table t(id int, CONSTRAINT pk_t_id PRIMARY key (id));（3）在表级以key方式建立，如create table t(id int, primary key (id)); 其它key创建类似，但不管那种方式，既建立了constraint，又建立了index，只不过index使用的就是这个constraint或key。 二、Indexindex是数据库的物理结构，它只是辅助查询的，它创建时会在另外的表空间（mysql中的innodb表空间）以一个类似目录的结构存储。索引要分类的话，分为前缀索引、全文本索引等。因此，索引只是索引，它不会去约束索引的字段的行为（那是key要做的事情）。我们说索引分类，分为： 主键索引（必须指定为“PRIMARY KEY”，没有PRIMARY Index） 唯一索引（unique index，一般写成unique key） 普通索引(index，只有这一种才是纯粹的index) 三、Index 与Key 的区别Key即键值，是关系模型理论中的一部份，比如有主键（Primary Key)，外键（Foreign Key）等，用于数据完整性检否与唯一性约束等。而Index则处于实现层面，比如可以对表的任意列建立索引，那么当建立索引的列处于SQL语句中的Where条件中时，就可以得到快速的数据定位，从而快速检索。至于Unique Index，则只是属于Index中的一种而已，建立了Unique Index表示此列数据不可重复。在设计表的时候，Key只是处于模型层面的，而当需要进行查询优化，则对相关列建立索引即可。另外，在MySQL中，对于一个Primary Key的列，MySQL已经自动对其建立了Unique Index，无需重复再在上面建立索引了。 四、UNIQUE KEY和PRIMARY KEY有什么区别 Primary key的1个或多个列必须为NOT NULL，如果列为NULL，在增加PRIMARY KEY时，列自动更改为NOT NULL。而UNIQUE KEY 对列没有此要求。 一个表只能有一个PRIMARY KEY，但可以有多个UNIQUE KEY 主键和唯一键约束是通过参考索引实施的，如果插入的值均为NULL，则根据索引的原理，全NULL值不被记录在索引上，所以插入全NULL值时，可以有重复的，而其他的则不能插入重复值。 References[^2]: MySQl 外键约束（FOREIGN KEY）[^3]: C语言中文网对于mysql外键约束的这一篇博客讲的很好","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://justskim.github.io/categories/Mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://justskim.github.io/tags/mysql/"},{"name":"数据存储","slug":"数据存储","permalink":"http://justskim.github.io/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"}]},{"title":"MYSQL数据类型","slug":"MYSQL数据类型","date":"2021-09-05T06:24:59.886Z","updated":"2021-09-06T02:01:31.733Z","comments":true,"path":"2021/09/05/MYSQL数据类型/","link":"","permalink":"http://justskim.github.io/2021/09/05/MYSQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"MYSQL数据类型菜鸟教程[^1]中给出了几款主流数据库软件的数据类型 这一篇中我们着重讲MySQL 数据类型在 MySQL 中，有三种主要的类型：Text（文本）、Number（数字）和 Date&#x2F;Time（日期&#x2F;时间）类型。 Text 类型： 数据类型 描述 CHAR(size) 保存固定长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的长度。最多 255 个字符。 VARCHAR(size) 保存可变长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的最大长度。最多 255 个字符。注释：如果值的长度大于 255，则被转换为 TEXT 类型。 TINYTEXT 存放最大长度为 255 个字符的字符串。 TEXT 存放最大长度为 65,535 个字符的字符串。 BLOB 用于 BLOBs（Binary Large OBjects）。存放最多 65,535 字节的数据。 MEDIUMTEXT 存放最大长度为 16,777,215 个字符的字符串。 MEDIUMBLOB 用于 BLOBs（Binary Large OBjects）。存放最多 16,777,215 字节的数据。 LONGTEXT 存放最大长度为 4,294,967,295 个字符的字符串。 LONGBLOB 用于 BLOBs (Binary Large OBjects)。存放最多 4,294,967,295 字节的数据。 ENUM(x,y,z,etc.) 允许您输入可能值的列表。可以在 ENUM 列表中列出最大 65535 个值。如果列表中不存在插入的值，则插入空值。注释：这些值是按照您输入的顺序排序的。可以按照此格式输入可能的值： ENUM(‘X’,’Y’,’Z’) SET 与 ENUM 类似，不同的是，SET 最多只能包含 64 个列表项且 SET 可存储一个以上的选择。 Number 类型： 数据类型 描述 TINYINT(size) 带符号-128到127 ，无符号0到255。 SMALLINT(size) 带符号范围-32768到32767，无符号0到65535, size 默认为 6。 MEDIUMINT(size) 带符号范围-8388608到8388607，无符号的范围是0到16777215。 size 默认为9 INT(size) 带符号范围-2147483648到2147483647，无符号的范围是0到4294967295。 size 默认为 11 BIGINT(size) 带符号的范围是-9223372036854775808到9223372036854775807，无符号的范围是0到18446744073709551615。size 默认为 20 FLOAT(size,d) 带有浮动小数点的小数字。在 size 参数中规定显示最大位数。在 d 参数中规定小数点右侧的最大位数。 DOUBLE(size,d) 带有浮动小数点的大数字。在 size 参数中规显示定最大位数。在 d 参数中规定小数点右侧的最大位数。 DECIMAL(size,d) 作为字符串存储的 DOUBLE 类型，允许固定的小数点。在 size 参数中规定显示最大位数。在 d 参数中规定小数点右侧的最大位数。 注意：以上的 size 代表的并不是存储在数据库中的具体的长度，如 int(4) 并不是只能存储4个长度的数字。 实际上int(size)所占多少存储空间并无任何关系。int(3)、int(4)、int(8) 在磁盘上都是占用 4 btyes 的存储空间。就是在显示给用户的方式有点不同外，int(M) 跟 int 数据类型是相同的。 例如： 1、int的值为10 （指定zerofill） 12int（9）显示结果为000000010int（3）显示结果为010 就是显示的长度不一样而已 都是占用四个字节的空间 Date 类型： 数据类型 描述 DATE() 日期。格式：YYYY-MM-DD注释：支持的范围是从 ‘1000-01-01’ 到 ‘9999-12-31’ DATETIME() *日期和时间的组合。格式：YYYY-MM-DD HH:MM:SS注释：支持的范围是从 ‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’ TIMESTAMP() *时间戳。TIMESTAMP 值使用 Unix 纪元(‘1970-01-01 00:00:00’ UTC) 至今的秒数来存储。格式：YYYY-MM-DD HH:MM:SS注释：支持的范围是从 ‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-09 03:14:07’ UTC TIME() 时间。格式：HH:MM:SS注释：支持的范围是从 ‘-838:59:59’ 到 ‘838:59:59’ YEAR() 2 位或 4 位格式的年。注释：4 位格式所允许的值：1901 到 2155。2 位格式所允许的值：70 到 69，表示从 1970 到 2069。 *即便 DATETIME 和 TIMESTAMP 返回相同的格式，它们的工作方式很不同。在 INSERT 或 UPDATE 查询中，TIMESTAMP 自动把自身设置为当前的日期和时间。TIMESTAMP 也接受不同的格式，比如 YYYYMMDDHHMMSS、YYMMDDHHMMSS、YYYYMMDD 或 YYMMDD。 MySQL支持所有标准SQL数值数据类型。 这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。 关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。 BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。 作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。 类型 大小 范围（有符号） 范围（无符号） 用途 TINYINT 1 byte (-128，127) (0，255) 小整数值 SMALLINT 2 bytes (-32 768，32 767) (0，65 535) 大整数值 MEDIUMINT 3 bytes (-8 388 608，8 388 607) (0，16 777 215) 大整数值 INT或INTEGER 4 bytes (-2 147 483 648，2 147 483 647) (0，4 294 967 295) 大整数值 BIGINT 8 bytes (-9,223,372,036,854,775,808，9 223 372 036 854 775 807) (0，18 446 744 073 709 551 615) 极大整数值 FLOAT 4 bytes (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) 0，(1.175 494 351 E-38，3.402 823 466 E+38) 单精度 浮点数值 DOUBLE 8 bytes (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 双精度 浮点数值 DECIMAL 对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2 依赖于M和D的值 依赖于M和D的值 小数值 日期和时间类型表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。 每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。 TIMESTAMP类型有专有的自动更新特性，将在后面描述。 类型 大小 ( bytes) 范围 格式 用途 DATE 3 1000-01-01&#x2F;9999-12-31 YYYY-MM-DD 日期值 TIME 3 ‘-838:59:59’&#x2F;‘838:59:59’ HH:MM:SS 时间值或持续时间 YEAR 1 1901&#x2F;2155 YYYY 年份值 DATETIME 8 1000-01-01 00:00:00&#x2F;9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 混合日期和时间值 TIMESTAMP 4 1970-01-01 00:00:00&#x2F;2038结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07 YYYYMMDD HHMMSS 混合日期和时间值，时间戳 字符串类型字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。 类型 大小 用途 CHAR 0-255 bytes 定长字符串 VARCHAR 0-65535 bytes 变长字符串 TINYBLOB 0-255 bytes 不超过 255 个字符的二进制字符串 TINYTEXT 0-255 bytes 短文本字符串 BLOB 0-65 535 bytes 二进制形式的长文本数据 TEXT 0-65 535 bytes 长文本数据 MEDIUMBLOB 0-16 777 215 bytes 二进制形式的中等长度文本数据 MEDIUMTEXT 0-16 777 215 bytes 中等长度文本数据 LONGBLOB 0-4 294 967 295 bytes 二进制形式的极大文本数据 LONGTEXT 0-4 294 967 295 bytes 极大文本数据 注意：char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。 CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。 BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。 BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。 有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。 Microsoft Access 数据类型 数据类型 描述 存储 Text 用于文本或文本与数字的组合。最多 255 个字符。 Memo Memo 用于更大数量的文本。最多存储 65,536 个字符。注释：无法对 memo 字段进行排序。不过它们是可搜索的。 Byte 允许 0 到 255 的数字。 1 字节 Integer 允许介于 -32,768 与 32,767 之间的全部数字。 2 字节 Long 允许介于 -2,147,483,648 与 2,147,483,647 之间的全部数字。 4 字节 Single 单精度浮点。处理大多数小数。 4 字节 Double 双精度浮点。处理大多数小数。 8 字节 Currency 用于货币。支持 15 位的元，外加 4 位小数。提示：您可以选择使用哪个国家的货币。 8 字节 AutoNumber AutoNumber 字段自动为每条记录分配数字，通常从 1 开始。 4 字节 Date&#x2F;Time 用于日期和时间 8 字节 Yes&#x2F;No 逻辑字段，可以显示为 Yes&#x2F;No、True&#x2F;False 或 On&#x2F;Off。在代码中，使用常量 True 和 False （等价于 1 和 0）。注释：Yes&#x2F;No 字段中不允许 Null 值 1 比特 Ole Object 可以存储图片、音频、视频或其他 BLOBs（Binary Large OBjects）。 最多 1GB Hyperlink 包含指向其他文件的链接，包括网页。 Lookup Wizard 允许您创建一个可从下拉列表中进行选择的选项列表。 4 字节 SQL Server 数据类型String 类型： 数据类型 描述 存储 char(n) 固定长度的字符串。最多 8,000 个字符。 Defined width varchar(n) 可变长度的字符串。最多 8,000 个字符。 2 bytes + number of chars varchar(max) 可变长度的字符串。最多 1,073,741,824 个字符。 2 bytes + number of chars text 可变长度的字符串。最多 2GB 文本数据。 4 bytes + number of chars nchar 固定长度的 Unicode 字符串。最多 4,000 个字符。 Defined width x 2 nvarchar 可变长度的 Unicode 字符串。最多 4,000 个字符。 nvarchar(max) 可变长度的 Unicode 字符串。最多 536,870,912 个字符。 ntext 可变长度的 Unicode 字符串。最多 2GB 文本数据。 bit 允许 0、1 或 NULL binary(n) 固定长度的二进制字符串。最多 8,000 字节。 varbinary 可变长度的二进制字符串。最多 8,000 字节。 varbinary(max) 可变长度的二进制字符串。最多 2GB。 image 可变长度的二进制字符串。最多 2GB。 Number 类型： 数据类型 描述 存储 tinyint 允许从 0 到 255 的所有数字。 1 字节 smallint 允许介于 -32,768 与 32,767 的所有数字。 2 字节 int 允许介于 -2,147,483,648 与 2,147,483,647 的所有数字。 4 字节 bigint 允许介于 -9,223,372,036,854,775,808 与 9,223,372,036,854,775,807 之间的所有数字。 8 字节 decimal(p,s) 固定精度和比例的数字。允许从 -10^38 +1 到 10^38 -1 之间的数字。p 参数指示可以存储的最大位数（小数点左侧和右侧）。p 必须是 1 到 38 之间的值。默认是 18。s 参数指示小数点右侧存储的最大位数。s 必须是 0 到 p 之间的值。默认是 0。 5-17 字节 numeric(p,s) 固定精度和比例的数字。允许从 -10^38 +1 到 10^38 -1 之间的数字。p 参数指示可以存储的最大位数（小数点左侧和右侧）。p 必须是 1 到 38 之间的值。默认是 18。s 参数指示小数点右侧存储的最大位数。s 必须是 0 到 p 之间的值。默认是 0。 5-17 字节 smallmoney 介于 -214,748.3648 与 214,748.3647 之间的货币数据。 4 字节 money 介于 -922,337,203,685,477.5808 与 922,337,203,685,477.5807 之间的货币数据。 8 字节 float(n) 从 -1.79E + 308 到 1.79E + 308 的浮动精度数字数据。n 参数指示该字段保存 4 字节还是 8 字节。float(24) 保存 4 字节，而 float(53) 保存 8 字节。n 的默认值是 53。 4 或 8 字节 real 从 -3.40E + 38 到 3.40E + 38 的浮动精度数字数据。 4 字节 Date 类型： 数据类型 描述 存储 datetime 从 1753 年 1 月 1 日 到 9999 年 12 月 31 日，精度为 3.33 毫秒。 8 字节 datetime2 从 1753 年 1 月 1 日 到 9999 年 12 月 31 日，精度为 100 纳秒。 6-8 字节 smalldatetime 从 1900 年 1 月 1 日 到 2079 年 6 月 6 日，精度为 1 分钟。 4 字节 date 仅存储日期。从 0001 年 1 月 1 日 到 9999 年 12 月 31 日。 3 bytes time 仅存储时间。精度为 100 纳秒。 3-5 字节 datetimeoffset 与 datetime2 相同，外加时区偏移。 8-10 字节 timestamp 存储唯一的数字，每当创建或修改某行时，该数字会更新。timestamp 值基于内部时钟，不对应真实时间。每个表只能有一个 timestamp 变量。 其他数据类型： 数据类型 描述 sql_variant 存储最多 8,000 字节不同数据类型的数据，除了 text、ntext 以及 timestamp。 uniqueidentifier 存储全局唯一标识符 (GUID)。 xml 存储 XML 格式化数据。最多 2GB。 cursor 存储对用于数据库操作的指针的引用。 table 存储结果集，供稍后处理。 References[^1]: 菜鸟教程——SQL 用于各种数据库的数据类型","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://justskim.github.io/categories/Mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://justskim.github.io/tags/mysql/"},{"name":"数据存储","slug":"数据存储","permalink":"http://justskim.github.io/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"}]},{"title":"express框架下使用ejs模板","slug":"express框架下使用ejs模板","date":"2021-09-03T10:14:57.108Z","updated":"2021-09-03T10:17:20.834Z","comments":true,"path":"2021/09/03/express框架下使用ejs模板/","link":"","permalink":"http://justskim.github.io/2021/09/03/express%E6%A1%86%E6%9E%B6%E4%B8%8B%E4%BD%BF%E7%94%A8ejs%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"express框架下使用ejs模板ejs模板ejs官方文档^1中，对于其的描述为： EJS 是一套简单的模板语言，帮你利用普通的 JavaScript 代码生成 HTML 页面。EJS 没有如何组织内容的教条；也没有再造一套迭代和控制流语法；有的只是普通的 JavaScript 代码而已。 利用 NPM 安装 EJS 很简单。 1$ npm install ejs References","categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"},{"name":"JavaScript","slug":"Programming-languages-and-projects/JavaScript","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/JavaScript/"},{"name":"Nodejs","slug":"Programming-languages-and-projects/JavaScript/Nodejs","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/JavaScript/Nodejs/"}],"tags":[{"name":"ejs","slug":"ejs","permalink":"http://justskim.github.io/tags/ejs/"},{"name":"express","slug":"express","permalink":"http://justskim.github.io/tags/express/"},{"name":"nodejs","slug":"nodejs","permalink":"http://justskim.github.io/tags/nodejs/"}]},{"title":"Git第一次与远程仓库关联并push时的报错","slug":"Git第一次与远程仓库关联并push时的报错","date":"2021-09-02T23:32:48.083Z","updated":"2021-09-02T23:51:18.357Z","comments":true,"path":"2021/09/03/Git第一次与远程仓库关联并push时的报错/","link":"","permalink":"http://justskim.github.io/2021/09/03/Git%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%85%B3%E8%81%94%E5%B9%B6push%E6%97%B6%E7%9A%84%E6%8A%A5%E9%94%99/","excerpt":"","text":"Git第一次与远程仓库关联并push时的报错关于该debug的过程描述当我们在github建立一个远程仓库时，github会给予我们相应的quick start提示： …or create a new repository on the command line1234567echo &quot;# ejs_express_demo&quot; &gt;&gt; README.mdgit initgit add README.mdgit commit -m &quot;first commit&quot;git branch -M maingit remote add origin https://github.com/JustSkim/ejs_express_demo.gitgit push -u origin main …or push an existing repository from the command line123git remote add origin https://github.com/JustSkim/ejs_express_demo.gitgit branch -M maingit push -u origin main …or import code from another repositoryYou can initialize this repository with code from a Subversion, Mercurial, or TFS project.Import code $ git initInitialized empty Git repository in E:&#x2F;JS练习&#x2F;ejs_demo&#x2F;.git&#x2F; 首先，创建一个 Git 仓库 User@TAPTOP-N6POI72B MNIWG19 &#x2F;e&#x2F;JS练习&#x2F;ejs_demo (master)$ git commit -m “no useful file first commit”On branch masterInitial commitUntracked files: .gitignore package.json nothing added to commit but untracked files present 然后，提交暂存区到本地仓库。事实上，我们第一次使用在该文件夹中使用该git commit命令出现了差错：**Untracked files … nothing added to commit but untracked files present **一般而言，第一次执行提交暂存区到本地仓库的操作，如果使用git commit -m &quot;description&quot; 而不是git commit -a -m &quot;description&quot;，是不会出现该错误的[^1]。 对于我们这种情况，出现该差错的原因在于：在我们每次使用 git commit 命令之前，使用 git add 跟踪一个文件，并且将其纳入暂存区。git add使用文件或者目录作为参数，如果参数是目录，那么会递归地跟踪该目录下左右文件（为”.”，则跟踪目录下所有未被.gitignore排除的文件）[^2]。 User@TAPTOP-N6POI72B MNIWG19 &#x2F;e&#x2F;JS练习&#x2F;ejs_demo (master)$git remote add origin &#x67;&#x69;&#x74;&#x40;&#103;&#x69;&#x74;&#x68;&#x75;&#x62;&#46;&#99;&#111;&#x6d;:JustSkim&#x2F;ejs_express_demo.git 添加名为origind 远程版本库： User@TAPTOP-N6POI72B MNIWG19 &#x2F;e&#x2F;JS练习&#x2F;ejs_demo (master)$ git push -u origin mainerror: src refspec main does not match any.error: failed to push some refs to ‘&#x67;&#105;&#x74;&#x40;&#103;&#105;&#116;&#x68;&#117;&#98;&#46;&#x63;&#x6f;&#x6d;:JustSkim&#x2F;ejs_express_demo.git’ 这里push失败，我们尝试改为https的连接方式（事实证明这对于解决问题是起不到帮助的）（但是当网络环境差导致多次Push失败时，建议更改连接方式） User@TAPTOP-N6POI72B MNIWG19 &#x2F;e&#x2F;JS练习&#x2F;ejs_demo (master)$ git remote set-url origin https://github.com/JustSkim/ejs_express_demo.git User@TAPTOP-N6POI72B MNIWG19 &#x2F;e&#x2F;JS练习&#x2F;ejs_demo (master)$ git push -u origin mastererror: src refspec master does not match any.error: failed to push some refs to ‘https://github.com/JustSkim/ejs_express_demo.git&#39; User@TAPTOP-N6POI72B MNIWG19 &#x2F;e&#x2F;JS练习&#x2F;ejs_demo (master)$ git branch -a 由于之前的错误，存在未被跟踪的文件导致提交失败，因此在这里，无论使用命令“git branch”还是”git branch -a“，都没有列出任何分支 User@TAPTOP-N6POI72B MNIWG19 &#x2F;e&#x2F;JS练习&#x2F;ejs_demo (master)$ git add .warning: LF will be replaced by CRLF in package.json.The file will have its original line endings in your working directory. User@TAPTOP-N6POI72B MNIWG19 &#x2F;e&#x2F;JS练习&#x2F;ejs_demo (master)$ git logfatal: your current branch ‘master’ does not have any commits yet 我们重新跟踪文件这里日志提示我们 ”该master分支下至今没有任何提交“ User@TAPTOP-N6POI72B MNIWG19 &#x2F;e&#x2F;JS练习&#x2F;ejs_demo (master)$ git commit -m “no file”[master (root-commit) 7bbefea] no filewarning: LF will be replaced by CRLF in package.json.The file will have its original line endings in your working directory.2 files changed, 16 insertions(+)create mode 100644 .gitignorecreate mode 100644 package.json 好了，这一次我们提交成功了 User@TAPTOP-N6POI72B MNIWG19 &#x2F;e&#x2F;JS练习&#x2F;ejs_demo (master)$ git branch*master 可以看到master分支存在 User@TAPTOP-N5PIO$ git push origin masterCounting objects: 4, done.Delta compression using up to 16 threads.Compressing objects: 100% (3&#x2F;3), done.Writing objects: 100% (4&#x2F;4), 445 bytes | 0 bytes&#x2F;s, done.Total 4 (delta 0), reused 0 (delta 0)To https://github.com/JustSkim/ejs_express_demo.git [new branch] master -&gt; master 代码成功推送到远程仓库 References[^1]: git commit -a -m “提交报错”[^2]: git提交报错nothing added to commit but untracked files present","categories":[{"name":"Git","slug":"Git","permalink":"http://justskim.github.io/categories/Git/"},{"name":"Git报错处理","slug":"Git/Git报错处理","permalink":"http://justskim.github.io/categories/Git/Git%E6%8A%A5%E9%94%99%E5%A4%84%E7%90%86/"}],"tags":[{"name":"git","slug":"git","permalink":"http://justskim.github.io/tags/git/"}]},{"title":"new Promise构造函数详解","slug":"new-Promise构造函数详解","date":"2021-08-31T07:27:48.096Z","updated":"2021-09-03T10:14:47.314Z","comments":true,"path":"2021/08/31/new-Promise构造函数详解/","link":"","permalink":"http://justskim.github.io/2021/08/31/new-Promise%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"new Promise构造函数详解Promise 对象是 JavaScript 的异步操作解决方案，为异步操作提供统一接口[^1]。它起到代理作用（proxy），充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口。Promise 可以让异步操作写起来，就像在写同步操作的流程（链式操作），而不必一层层地嵌套回调函数。 Promise是一个对象，也是一个构造函数，在ES6中，加入了Promise，其设计思想是：所有异步任务都返回一个 Promise 实例。而每个Promise 实例又都有一个then方法，用来指定下一步的回调函数。如果不使用Promise，我们往往要使用很多层回调的写法，下面做一个对比： 12345678910111213141516// 传统写法step1(function (value1) &#123; step2(value1, function(value2) &#123; step3(value2, function(value3) &#123; step4(value3, function(value4) &#123; // ... &#125;); &#125;); &#125;);&#125;);// Promise 的写法(new Promise(step1)) .then(step2) .then(step3) .then(step4); Promise的构造函数接收一个参数，是函数，并且传入两个参数：resolve，reject，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。按照标准来讲，resolve是将Promise的状态置为fullfiled，reject是将Promise的状态置为rejected。注意，Promise对象通过自身的状态来控制异步操作！ 根据mdn官方网站上的讲解： 一个 Promise 对象代表一个在这个 promise 被创建出来时不一定已知的值。它让您能够把异步操作最终的成功返回值或者失败原因和相应的处理程序关联起来。 这样使得异步方法可以像同步方法那样返回值：异步方法并不会立即返回最终的值，而是会返回一个 promise，以便在未来某个时候把值交给使用者。一个 Promise 必然处于以下几种状态之一： 待定（pending）: 初始状态，既没有被兑现，也没有被拒绝。 已兑现（fulfilled）: 意味着操作成功完成。 已拒绝（rejected）: 意味着操作失败。 其中，状态fulfilled和rejected合在一起称为resolved（已定型），这三种的状态的变化途径只有两种： 从“未完成”到“成功”——异步操作成功，Promise 实例传回一个值（value），状态变为fulfilled。 从“未完成”到“失败”——异步操作失败，Promise 实例抛出一个错误（error），状态变为rejected。 注意！一个Promise对象的状态发生一次变化，就凝固了，不会再有新的状态变化！这也是 Promise 这个名字的由来，它的英语意思是“承诺”，一旦承诺成效，就不得再改变了。这也意味着，Promise 实例的状态变化只可能发生一次。 当两个途径之一发生时，我们用 promise 的 then 方法排列起来的相关处理程序就会被调用。如果 promise 在一个相应的处理程序被绑定时就已经被兑现或被拒绝了，那么这个处理程序就会被调用，因此在完成异步操作和绑定处理方法之间不会存在竞争状态。 构造一个Promise实例12345678var promise = new Promise(function (resolve, reject) &#123; // ... if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; /* 异步操作失败 */ reject(new Error()); &#125;&#125;); resolve函数的作用是，将Promise实例的状态从“未完成”变为“成功”（即从pending变为fulfilled），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去。reject函数的作用是，将Promise实例的状态从“未完成”变为“失败”（即从pending变为rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 Reference[^1]: Promise 对象","categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"},{"name":"JavaScript","slug":"Programming-languages-and-projects/JavaScript","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/JavaScript/"},{"name":"Nodejs","slug":"Programming-languages-and-projects/JavaScript/Nodejs","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/JavaScript/Nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://justskim.github.io/tags/nodejs/"},{"name":"http","slug":"http","permalink":"http://justskim.github.io/tags/http/"}]},{"title":"nodejs中http相关方法","slug":"nodejs中http相关方法","date":"2021-08-31T06:25:35.662Z","updated":"2021-08-31T07:54:54.543Z","comments":true,"path":"2021/08/31/nodejs中http相关方法/","link":"","permalink":"http://justskim.github.io/2021/08/31/nodejs%E4%B8%ADhttp%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95/","excerpt":"","text":"nodejs中http相关方法response相关http.response.end原文链接https://www.jb51.net/article/58468.htm http.response.end结束响应，告诉客户端所有消息已经发送。当所有要返回的内容发送完毕时，该函数必须被调用一次。如果不调用该函数，客户端将永远处于等待状态。语法：response.end([data], [encoding])接收参数：data ： end()执行完毕后要输出的字符，如果指定了 data 的值，那就意味着在执行完 response.end() 之后，会接着执行一条 response.write(data , encoding);encoding： 对应data的字符编码 http.response.write原文链接：https://www.jianshu.com/p/ab0889a387e6response.write(chunk, [encoding])参数：chunk 是一个buffer 或 字符串，表示发送的内容encoding 如果chunk是字符串，就需要指定encoding来说明它的编码方式，默认utf-8该函数用于向请求的客户端发送响应内容。在 response.end() 之前，response.write() 可以被执行多次。 1234app.get(&#x27;/to&#x27;,(req,resp)=&gt;&#123; resp.write(&quot;JQK&quot;); resp.end(&quot;abc&quot;);&#125;) 后续的response.end(data)并不会覆盖之前response.write(data)的值","categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"},{"name":"JavaScript","slug":"Programming-languages-and-projects/JavaScript","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/JavaScript/"},{"name":"Nodejs","slug":"Programming-languages-and-projects/JavaScript/Nodejs","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/JavaScript/Nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://justskim.github.io/tags/nodejs/"},{"name":"http","slug":"http","permalink":"http://justskim.github.io/tags/http/"}]},{"title":"PYQT5绘图","slug":"PYQT5绘图","date":"2021-08-30T21:32:57.313Z","updated":"2021-08-30T21:33:03.986Z","comments":true,"path":"2021/08/31/PYQT5绘图/","link":"","permalink":"http://justskim.github.io/2021/08/31/PYQT5%E7%BB%98%E5%9B%BE/","excerpt":"","text":"PYQT5绘图绘图文本涂鸦12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：文本涂鸦ZetCode PyQt5 tutorial In this example, we draw text in Russian Cylliric.Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom PyQt5.QtWidgets import QWidget, QApplicationfrom PyQt5.QtGui import QPainter, QColor, QFontfrom PyQt5.QtCore import Qtclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.text = &quot;Лев Николаевич Толстой\\nАнна Каренина&quot; #写了一些文本上下居中对齐的俄罗斯Cylliric语言的文字 self.setGeometry(300, 300, 500, 500) self.setWindowTitle(&#x27;Drawing text&#x27;) self.show() def paintEvent(self, event): #在绘画事件内完成绘画动作 qp = QPainter() &#x27;&#x27;&#x27; QPainter是低级的绘画类。所有的绘画动作都在这个类的begin()和end()方法之间完成，绘画动作都封装在drawText()内部了。 &#x27;&#x27;&#x27; qp.begin(self) self.drawText(event, qp) qp.end() def drawText(self, event, qp): qp.setPen(QColor(168, 34, 3)) qp.setFont(QFont(&#x27;Decorative&#x27;, 10)) &#x27;&#x27;&#x27; 为文字绘画定义了笔和字体。 &#x27;&#x27;&#x27; qp.drawText(event.rect(), Qt.AlignCenter, self.text) #drawText()方法在窗口里绘制文本，rect()方法返回要更新的矩形区域if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_())","categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"},{"name":"Python3","slug":"Programming-languages-and-projects/Python3","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"},{"name":"PYQT5","slug":"Programming-languages-and-projects/Python3/PYQT5","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/PYQT5/"}],"tags":[{"name":"python3","slug":"python3","permalink":"http://justskim.github.io/tags/python3/"},{"name":"gui","slug":"gui","permalink":"http://justskim.github.io/tags/gui/"}]},{"title":"PYQT5拖拽","slug":"PYQT5拖拽","date":"2021-08-30T21:31:39.560Z","updated":"2021-08-30T21:31:57.703Z","comments":true,"path":"2021/08/31/PYQT5拖拽/","link":"","permalink":"http://justskim.github.io/2021/08/31/PYQT5%E6%8B%96%E6%8B%BD/","excerpt":"","text":"PYQT5拖拽简单的拖放1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：拖放ZetCode PyQt5 tutorialThis is a simple drag anddrop example. Author: Jan BodnarWebsite: zetcode.comLast edited: August 2017&quot;&quot;&quot;from PyQt5.QtWidgets import (QPushButton, QWidget, QLineEdit, QApplication)import sysclass Button(QPushButton): #用QPushButton上构造一个按钮实例 def __init__(self, title, parent): super().__init__(title, parent) self.setAcceptDrops(True) &#x27;&#x27;&#x27; 激活组件的拖拽事件 &#x27;&#x27;&#x27; def dragEnterEvent(self, e): &#x27;&#x27;&#x27; 重构了dragEnterEvent()方法。设定好接受拖拽的数据类型（plain text） &#x27;&#x27;&#x27; if e.mimeData().hasFormat(&#x27;text/plain&#x27;): e.accept() else: e.ignore() def dropEvent(self, e): #重构dropEvent()方法，更改按钮接受鼠标的释放事件的默认行为。 self.setText(e.mimeData().text()) class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): edit = QLineEdit(&#x27;line-edit&#x27;, self) &#x27;&#x27;&#x27; QLineEdit默认支持拖拽操作，所以我们只要调用setDragEnabled()方法使用就行了。 &#x27;&#x27;&#x27; edit.setDragEnabled(True) edit.move(30, 65) button = Button(&quot;Button&quot;, self) button.move(190, 65) self.setWindowTitle(&#x27;Simple drag and drop&#x27;) self.setGeometry(300, 300, 300, 150)if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() ex.show() app.exec_() 拖放按钮组件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：拖放按钮组件 注意是右键拖拽！！！ZetCode PyQt5 tutorialIn this program, we can press on a button with a left mouseclick or drag and drop the button with the right mouse click. Author: Jan BodnarWebsite: zetcode.comLast edited: August 2017例子中，窗口上有一个QPushButton组件。左键点击按钮，控制台就会输出press。右键可以点击然后拖动按钮。&quot;&quot;&quot;from PyQt5.QtWidgets import QPushButton, QWidget, QApplicationfrom PyQt5.QtCore import Qt, QMimeDatafrom PyQt5.QtGui import QDragimport sysclass Button(QPushButton): def __init__(self, title, parent): super().__init__(title, parent) &#x27;&#x27;&#x27; 从QPushButton继承一个Button类，然后重构QPushButton的两个方法: mouseMoveEvent()和mousePressEvent(). mouseMoveEvent()是拖拽开始的事件。 mousePressEvent()是鼠标给予压力的事件，分鼠标左键、右键、滚轮、前进键、后退键（不包含dpi键） &#x27;&#x27;&#x27; def mouseMoveEvent(self, e): #这里只劫持按钮的右键事件（Qt.RightButton），左键的操作还是默认行为 if e.buttons() != Qt.RightButton: return mimeData = QMimeData() drag = QDrag(self) &#x27;&#x27;&#x27; 创建一个QDrag对象，用来传输MIME-based数据。 &#x27;&#x27;&#x27; drag.setMimeData(mimeData) drag.setHotSpot(e.pos() - self.rect().topLeft()) dropAction = drag.exec_(Qt.MoveAction) def mousePressEvent(self, e): super().mousePressEvent(e) if e.button() == Qt.LeftButton: print(&#x27;press&#x27;) print(e.button()) &#x27;&#x27;&#x27; 左键点击按钮，会在控制台输出“press”。注意，我们在父级上也调用了mousePressEvent()方法， 不然的话，我们是看不到按钮按下的效果的。 mousePressEvent()是鼠标给予压力的事件，各个键有对应的int值（e.button()） 分鼠标左键（Qt.leftButton = 1）、右键（2）、滚轮（4）、前进键（16）、后退键（8） （不包含dpi键） &#x27;&#x27;&#x27;class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setAcceptDrops(True) self.button = Button(&#x27;Button&#x27;, self) self.button.move(100, 65) self.setWindowTitle(&#x27;Click or Move&#x27;) self.setGeometry(300, 300, 280, 150) def dragEnterEvent(self, e): e.accept() def dropEvent(self, e): position = e.pos() self.button.move(position) &#x27;&#x27;&#x27; 在dropEvent()方法里，我们定义了按钮按下后和释放后的行为，获得鼠标移动的位置，然后把按钮放到这个地方 &#x27;&#x27;&#x27; e.setDropAction(Qt.MoveAction) &#x27;&#x27;&#x27; 指定放下的动作类型为moveAction &#x27;&#x27;&#x27;if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() ex.show() app.exec_()","categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"},{"name":"Python3","slug":"Programming-languages-and-projects/Python3","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"},{"name":"PYQT5","slug":"Programming-languages-and-projects/Python3/PYQT5","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/PYQT5/"}],"tags":[{"name":"python3","slug":"python3","permalink":"http://justskim.github.io/tags/python3/"},{"name":"gui","slug":"gui","permalink":"http://justskim.github.io/tags/gui/"}]},{"title":"PYQT5控件","slug":"PYQT5控件","date":"2021-08-30T21:26:04.103Z","updated":"2021-11-03T01:53:59.969Z","comments":true,"path":"2021/08/31/PYQT5控件/","link":"","permalink":"http://justskim.github.io/2021/08/31/PYQT5%E6%8E%A7%E4%BB%B6/","excerpt":"","text":"PYQT5控件QCheckBox12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;ZetCode PyQt5 tutorial In this example, a QCheckBox widgetis used to toggle the title of a window.Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;from PyQt5.QtWidgets import QWidget, QCheckBox, QApplicationfrom PyQt5.QtCore import Qtimport sysclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): cb = QCheckBox(&#x27;Show title&#x27;, self) #QCheckBox的构造器，QCheckBox组件有两个状态：开和关 &#x27;&#x27;&#x27; QCheckBox构造一个三态复选框 名称 值 含义 Qt.Checked 2 组件没有被选中（默认） Qt.PartiallyChecked 1 组件被半选中 Qt.Unchecked 0 组件被选中 &#x27;&#x27;&#x27; cb.move(20, 20) print(&#x27;cb.toggle = &#x27;,cb.toggle()) &#x27;&#x27;&#x27; 检查单选框的状态。默认情况下，窗口没有标题，单选框未选中 PySide2.QtWidgets.QAbstractButton.toggled(checked)¶ Parameters checked – bool &#x27;&#x27;&#x27; cb.stateChanged.connect(self.changeTitle) &#x27;&#x27;&#x27; PySide2.QtWidgets.QCheckBox.stateChanged(arg__1)¶ Parameters arg__1 – int &#x27;&#x27;&#x27; self.setGeometry(300, 300, 250, 150) self.setWindowTitle(&#x27;QCheckBox&#x27;) self.show() def changeTitle(self, state): #根据状态实现窗口标题切换的功能 print(&quot;state = &quot;,state) &#x27;&#x27;&#x27; Qt.Checked为int类型，值为2，代表组件没有被选中 &#x27;&#x27;&#x27; if state == Qt.Checked: self.setWindowTitle(&#x27;QCheckBox&#x27;) else: self.setWindowTitle(&#x27; &#x27;)if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 切换按钮123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：切换按钮ZetCode PyQt5 tutorial In this example, we create three toggle buttons.They will control the background color of a QFrame. Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;from PyQt5.QtWidgets import (QWidget, QPushButton, QFrame, QApplication)from PyQt5.QtGui import QColorimport sysclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.col = QColor(0, 0, 0) redb = QPushButton(&#x27;Red&#x27;, self) redb.setCheckable(True) redb.move(10, 10) redb.clicked[bool].connect(self.setColor) greenb = QPushButton(&#x27;Green&#x27;, self) greenb.setCheckable(True) greenb.move(10, 60) greenb.clicked[bool].connect(self.setColor) blueb = QPushButton(&#x27;Blue&#x27;, self) blueb.setCheckable(True) blueb.move(10, 110) blueb.clicked[bool].connect(self.setColor) #每一种颜色都与这一个设置色彩（RGB三项分别）的函数点击关联 self.square = QFrame(self) &#x27;&#x27;&#x27; 容器中的Frame为一个矩形的框架对象，对应类QFrame， QFrame类是PyQt中带框架部件的所有类的基类，如菜单、进度条、Label标签 &#x27;&#x27;&#x27; self.square.setGeometry(150, 20, 100, 100) self.square.setStyleSheet(&quot;QWidget &#123; background-color: %s &#125;&quot; % self.col.name()) self.setGeometry(300, 300, 280, 170) self.setWindowTitle(&#x27;Toggle button&#x27;) self.show() def setColor(self, pressed): source = self.sender() if pressed: val = 255 else: val = 0 if source.text() == &quot;Red&quot;: self.col.setRed(val) #将RGB模式中红色值调为val=255 elif source.text() == &quot;Green&quot;: self.col.setGreen(val) else: self.col.setBlue(val) self.square.setStyleSheet(&quot;QFrame &#123; background-color: %s &#125;&quot; % self.col.name()) &#x27;&#x27;&#x27; 使用样式表（就是CSS的SS）改变背景色 此处self.square是一个QFrame类 PySide2.QtWidgets.QWidget.setStyleSheet(styleSheet)¶ Parameters： styleSheet – str This property holds the widget’s style sheet. The style sheet contains a textual description of customizations to the widget’s style, as described in the Qt Style Sheets document. 该函数可以设置样式（包括颜色、字体、边框等，类比于html中style属性） &#x27;&#x27;&#x27;if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 滑块12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：滑块ZetCode PyQt5 tutorial This example shows a QSlider widget.Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;from PyQt5.QtWidgets import (QWidget, QSlider, QLabel, QApplication)from PyQt5.QtCore import Qtfrom PyQt5.QtGui import QPixmapimport sysclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): sld = QSlider(Qt.Horizontal, self) &#x27;&#x27;&#x27; 创建一个水平的QSlider QSlider控件提供一个垂直或者水平的滑动条，滑动条是一个用于控制有界值典型的控件， 它允许用户沿水平或者垂直方向在某一范围内移动滑块，并将滑块所在的位置转换为一个合法范围内的整数值， 有时候这中方式比输入数字或者使用SpinBox（计数器·）更加自然，在槽函数中对滑块所在位置的处理相当于从整数之间的最小值和最高值进行取值 原文链接：https://blog.csdn.net/jia666666/article/details/81534588 &#x27;&#x27;&#x27; sld.setFocusPolicy(Qt.NoFocus) &#x27;&#x27;&#x27; setFocusPolicy(Policy) 设置焦点获取策略 Qt.TabFocus() 通过Tab键获取焦点 Qt.ClickFocus() 通过被单击获取焦点 Qt.StrongFocus() 可以通过上面两种方式获取焦点 Qt.NoFocus() 不能通过上面两种方式获取焦点 &#x27;&#x27;&#x27; sld.setGeometry(30, 40, 100, 300) &#x27;&#x27;&#x27; setGeometry()有两个作用： 把窗口放到屏幕上；设置窗口大小。 四个参数分别代表屏幕坐标的x、y和窗口大小的宽、高。 这个方法是resize()和move()的合体。 &#x27;&#x27;&#x27; sld.valueChanged[int].connect(self.changeValue) self.label = QLabel(self) self.label.setPixmap(QPixmap(&#x27;mute.png&#x27;)) &#x27;&#x27;&#x27; 创建一个QLabel组件并给它设置一个静音图标(作为图标的默认设置) PySide2.QtWidgets.QLabel.setPixmap(arg__1)¶ Parameters arg__1 – PySide2.QtGui.QPixmap This property holds the label’s pixmap.. Previously, Qt provided a version of pixmap() which returned the pixmap by-pointer. That version is now deprecated. To maintain compatibility with old code, you can explicitly differentiate between the by-pointer function and the by-value function: QPixmap类用于绘图设备的图像显示，它可以作为一个QPainterDevice对象，也可以加载到一个控件中，通常是标签或者按钮，用于在标签或按钮上显示图像 QPixmap可以读取的图像文件类型有BMP，GIF，JPG等 &#x27;&#x27;&#x27; self.label.setGeometry(160, 40, 1000, 800) self.setGeometry(100, 100, 2000, 1600) self.setWindowTitle(&#x27;QSlider&#x27;) self.show() def changeValue(self, value): if value == 0: self.label.setPixmap(QPixmap(&#x27;mute.png&#x27;)) elif value &gt; 0 and value &lt;= 30: self.label.setPixmap(QPixmap(&#x27;min.png&#x27;)) elif value &gt; 30 and value &lt; 80: self.label.setPixmap(QPixmap(&#x27;med.png&#x27;)) else: self.label.setPixmap(QPixmap(&#x27;max.png&#x27;))if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 进度条123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：进度条ZetCode PyQt5 tutorial This example shows a QProgressBar widget.Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;from PyQt5.QtWidgets import (QWidget, QProgressBar, QPushButton, QApplication)from PyQt5.QtCore import QBasicTimerimport sysclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.pbar = QProgressBar(self) #新建一个QProgressBar构造器。 self.pbar.setGeometry(30, 40, 200, 25) self.btn = QPushButton(&#x27;Start&#x27;, self) self.btn.move(40, 80) self.btn.clicked.connect(self.doAction)#点击绑定一个用来控制开始和停止的方法 self.timer = QBasicTimer() &#x27;&#x27;&#x27; 用时间控制进度条。 QBasicTimer类为对象提供计时器事件。这是Qt内部使用的一个快速，轻量级和低级别的类。 注意这个定时器是一个重复的定时器，除非调用stop()函数，否则它将发送后续的定时器事件。 当定时器超时时，它将向QObject子类发送一个timer事件。 &#x27;&#x27;&#x27; self.step = 0 self.setGeometry(300, 300, 280, 170) self.setWindowTitle(&#x27;QProgressBar&#x27;) self.show() def timerEvent(self, e): &#x27;&#x27;&#x27; 每个QObject和又它继承而来的对象都有一个timerEvent()事件处理函数。 为了触发事件，我们重载（≠重写）了这个方法。 &#x27;&#x27;&#x27; if self.step &gt;= 100: self.timer.stop() &#x27;&#x27;&#x27; PySide2.QtCore.QBasicTimer.stop()¶ No parameters. Stops the timer. &#x27;&#x27;&#x27; self.btn.setText(&#x27;Finished&#x27;) #改变按钮控件的text值 return self.step = self.step + 1 self.pbar.setValue(self.step)#设置值 def doAction(self): if self.timer.isActive(): self.timer.stop() self.btn.setText(&#x27;Start&#x27;) else: self.timer.start(100, self) &#x27;&#x27;&#x27; 调用start()方法加载时间事件，这个方法有两个参数：过期时间（单位：毫秒）和事件接收者 start(int, QObject) &#x27;&#x27;&#x27; self.btn.setText(&#x27;Stop&#x27;)#按钮文字改为“Stop”if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 日历1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：日历ZetCode PyQt5 tutorial This example shows a QCalendarWidget widget.Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;from PyQt5.QtWidgets import (QWidget, QCalendarWidget, QLabel, QApplication, QVBoxLayout)from PyQt5.QtCore import QDateimport sysclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): vbox = QVBoxLayout(self) &#x27;&#x27;&#x27; QHBoxLayout和QVBoxLayout类继承自QBoxLayout，采用QBOXLayout类可以在水平和垂直方向上排列控件， 本案例采用QHBoxLayout类，按照从左到右的顺序来添加控件， 详见博客https://blog.csdn.net/jia666666/article/details/81699900 &#x27;&#x27;&#x27; cal = QCalendarWidget(self) &#x27;&#x27;&#x27; 创建一个QCalendarWidge &#x27;&#x27;&#x27; cal.setGridVisible(False) #setGridVisible(bool)方法可以设置是否在日历上显示网格 cal.clicked[QDate].connect(self.showDate) &#x27;&#x27;&#x27; 选择一个日期时，QDate的点击信号就触发了，把这个信号和我们自己定义的showDate()方法关联起来 &#x27;&#x27;&#x27; vbox.addWidget(cal) self.lbl = QLabel(self) date = cal.selectedDate() &#x27;&#x27;&#x27; selectedDate()方法获取日历控件选中的日期(格式为一个QDate日期对象) PySide2.QtWidgets.QCalendarWidget.selectedDate()¶ Return type PySide2.QtCore.QDate This property holds the currently selected date.. The selected date must be within the date range specified by the minimumDate and maximumDate properties. By default, the selected date is the current date. &#x27;&#x27;&#x27; self.lbl.setText(date.toString())#将该日期对象转换为字符串 vbox.addWidget(self.lbl) self.setLayout(vbox) self.setGeometry(300, 300, 350, 300) self.setWindowTitle(&#x27;Calendar&#x27;) self.show() def showDate(self, date): self.lbl.setText(date.toString())if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 图片123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：图片处理ZetCode PyQt5 tutorial In this example, we dispay an imageon the window. Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;from PyQt5.QtWidgets import (QWidget, QHBoxLayout, QLabel, QApplication)from PyQt5.QtGui import QPixmapimport sysclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): hbox = QHBoxLayout(self) pixmap = QPixmap(&quot;exit.png&quot;) #创建一个QPixmap对象，接收一个文件作为参数。 &#x27;&#x27;&#x27; QPixmap类用于绘图设备的图像显示，它可以作为一个QPainterDevice对象，也可以加载到一个控件中，通常是标签或者按钮，用于在标签或按钮上显示图像QPixmap可以读取的图像文件类型有BMP，GIF，JPG等 &#x27;&#x27;&#x27; lbl = QLabel(self) lbl.setPixmap(pixmap) &#x27;&#x27;&#x27; 把QPixmap实例放到QLabel组件里。 注意，组件大小 必须大于等于 QPixmap这个控件大小（也即图片大小） PySide2.QtWidgets.QLabel.setPixmap(arg__1)¶ Parameters arg__1 – PySide2.QtGui.QPixmap This property holds the label’s pixmap.. Previously, Qt provided a version of pixmap() which returned the pixmap by-pointer. That version is now deprecated. To maintain compatibility with old code, you can explicitly differentiate between the by-pointer function and the by-value function: &#x27;&#x27;&#x27; hbox.addWidget(lbl) self.setLayout(hbox) self.move(300, 200) self.setWindowTitle(&#x27;Red Rock&#x27;) self.show() if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 行编辑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：行编辑让标签的文本与输入文本相同ZetCode PyQt5 tutorial This example shows text which is entered in a QLineEditin a QLabel widget.Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017例子中展示了一个编辑组件和一个标签，我们在输入框里键入的文本，会立即在标签里显示出来&quot;&quot;&quot;import sysfrom PyQt5.QtWidgets import (QWidget, QLabel, QLineEdit, QApplication)class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.lbl = QLabel(self) qle = QLineEdit(self) #创建一个QLineEdit对象。 qle.move(60, 100) self.lbl.move(60, 40) qle.textChanged[str].connect(self.onChanged) &#x27;&#x27;&#x27; 输入框的值有变化时调用我们自己创建的一个方法。 QLineEdit类中的常用信号textChanged：当修改文本内容时，这个信号就会发射 &#x27;&#x27;&#x27; self.setGeometry(300, 300, 280, 170) self.setWindowTitle(&#x27;QLineEdit&#x27;) self.show() def onChanged(self, text): #把文本框里的值赋值给了标签组件，然后调用adjustSize()方法让标签自适应文本内容 self.lbl.setText(text) #改变标签的文本 self.lbl.adjustSize() #adjustSize() 根据内容自适应大小if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) QSplitter1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：splitter 分束器————窗口分隔ZetCode PyQt5 tutorial This example showshow to use QSplitter widget.Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017QSplitter组件能让用户通过 拖拽分割线 的方式改变子窗口大小的组件。本例中我们展示用两个分割线隔开的三个QFrame组件。&quot;&quot;&quot;import sysfrom PyQt5.QtCore import Qtfrom PyQt5.QtWidgets import (QWidget, QHBoxLayout, QFrame, QSplitter, QApplication)class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): hbox = QHBoxLayout(self) topleft = QFrame(self) topleft.setFrameShape(QFrame.StyledPanel) &#x27;&#x27;&#x27; 为了更清楚的看到分割线，我们使用了设置好的子窗口样式。 QFrame的相关值与表现形式可见 http://allstack.net/wordpress/post-918.html 注意这里是 StyledPanel 而不是style! &#x27;&#x27;&#x27; topright = QFrame(self) topright.setFrameShape(QFrame.StyledPanel) bottom = QFrame(self) bottom.setFrameShape(QFrame.StyledPanel) splitter1 = QSplitter(Qt.Horizontal) splitter1.addWidget(topleft) splitter1.addWidget(topright) &#x27;&#x27;&#x27; 创建一个QSplitter组件，并在里面添加了两个框架 &#x27;&#x27;&#x27; splitter2 = QSplitter(Qt.Vertical) splitter2.addWidget(splitter1) &#x27;&#x27;&#x27; 在分割线里面再进行分割 &#x27;&#x27;&#x27; splitter2.addWidget(bottom) hbox.addWidget(splitter2) self.setLayout(hbox) self.setGeometry(300, 300, 300, 200) self.setWindowTitle(&#x27;QSplitter&#x27;) self.show() def onChanged(self, text): self.lbl.setText(text) self.lbl.adjustSize() if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 下拉选框12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：组合下拉框ZetCode PyQt5 tutorial This example shows how to use a QComboBox widget.Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;&#x27;&#x27;&#x27;QComboBox组件能让用户在 多个选择项 中 选择 一个combo 意为 组合的意思combobox: 组合框；下拉列表框&#x27;&#x27;&#x27;from PyQt5.QtWidgets import (QWidget, QLabel, QComboBox, QApplication)import sysclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.lbl = QLabel(&quot;Ubuntu&quot;, self) combo = QComboBox(self) combo.addItem(&quot;Ubuntu&quot;) #添加选项 combo.addItem(&quot;Mandriva&quot;) combo.addItem(&quot;Fedora&quot;) combo.addItem(&quot;Arch&quot;) combo.addItem(&quot;Gentoo&quot;) combo.addItems([&quot;CentOS&quot;,&quot;Alibaba linux&quot;]) &#x27;&#x27;&#x27; addItem() 添加一个下拉选项 addItems() 从列表中添加下拉选项 Clear() 删除下拉选项集合中的所有选项 count() 返回下拉选项集合中的数目 currentText() 返回选中选项的文本 itemText(i) 获取索引为i的item的选项文本 currentIndex() 返回选中项的索引 setItemText(int index,text) 改变序列号为index的文本 原文链接：https://blog.csdn.net/jia666666/article/details/81534260 &#x27;&#x27;&#x27; combo.move(50, 50) self.lbl.move(50, 150) combo.activated[str].connect(self.onActivated) self.setGeometry(300, 300, 300, 200) self.setWindowTitle(&#x27;QComboBox&#x27;) self.show() def onActivated(self, text): self.lbl.setText(text) self.lbl.adjustSize() if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_())","categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"},{"name":"Python3","slug":"Programming-languages-and-projects/Python3","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"},{"name":"PYQT5","slug":"Programming-languages-and-projects/Python3/PYQT5","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/PYQT5/"}],"tags":[{"name":"python3","slug":"python3","permalink":"http://justskim.github.io/tags/python3/"},{"name":"gui","slug":"gui","permalink":"http://justskim.github.io/tags/gui/"}]},{"title":"PYQT5对话框","slug":"PYQT5对话框","date":"2021-08-30T21:14:50.018Z","updated":"2021-08-30T21:14:50.022Z","comments":true,"path":"2021/08/31/PYQT5对话框/","link":"","permalink":"http://justskim.github.io/2021/08/31/PYQT5%E5%AF%B9%E8%AF%9D%E6%A1%86/","excerpt":"","text":"PYQT5对话框输入文字123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：输入文字ZetCode PyQt5 tutorial In this example, we receive data froma QInputDialog dialog. Aauthor: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;from PyQt5.QtWidgets import (QWidget, QPushButton, QLineEdit, QInputDialog, QApplication)import sysclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.btn = QPushButton(&#x27;Dialog&#x27;, self) self.btn.move(20, 20) self.btn.clicked.connect(self.showDialog) self.le = QLineEdit(self) self.le.move(130, 22) self.setGeometry(300, 300, 290, 150) self.setWindowTitle(&#x27;Input dialog&#x27;) self.show() def showDialog(self): print(&quot;the type of return is : &quot;,type(QInputDialog.getText(self, &#x27;Input Dialog&#x27;, &#x27;Enter your name:&#x27;))) text, ok = QInputDialog.getText(self, &#x27;Input Dialog&#x27;, &#x27;Enter your name:&#x27;) &#x27;&#x27;&#x27; 显示一个输入框的代码。第一个参数是输入框的标题，第二个参数是输入框的占位符。 对话框返回输入内容和一个布尔值，如果点击的是OK按钮，布尔值就返回True python的解构语法（逗号在左，与封装语法相反） 把线性结构(列表，元组，字符串，bytes，baitarry)的元素解开，并顺序的赋给其他变量； 左边接纳的变量数要和右边解开的元素个数一致； static PySide2.QtWidgets.QInputDialog.getText(parent, title, label[, echo=QLineEdit.Normal[, text=&quot;&quot;[, flags=Qt.WindowFlags()[, inputMethodHints=Qt.ImhNone]]]])¶ Parameters parent – PySide2.QtWidgets.QWidget title – str label – str echo – EchoMode text – str flags – WindowFlags inputMethodHints – InputMethodHints Return type：(str,bool)(QString, bool ok) QInputDialog.getText (QWidget parent, QString title, QString label, QLineEdit.EchoMode mode = QLineEdit.Normal, QString text = &#x27;&#x27;, Qt.WindowFlags flags = 0) &#x27;&#x27;&#x27; if ok: self.le.setText(str(text))if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 选取颜色123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：选择颜色ZetCode PyQt5 tutorial In this example, we select a color valuefrom the QColorDialog and change the backgroundcolor of a QFrame widget. Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;from PyQt5.QtWidgets import (QWidget, QPushButton, QFrame, QColorDialog, QApplication)from PyQt5.QtGui import QColorimport sysclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): col = QColor(222, 222, 0) &#x27;&#x27;&#x27; 这里通过rgb三项来设置默认的背景颜色为黄色，下面可以使用QColorDialog改变背景颜色 &#x27;&#x27;&#x27; self.btn = QPushButton(&#x27;Dialog&#x27;, self) self.btn.move(20, 20) self.btn.clicked.connect(self.showDialog) #点击事件绑定函数 self.frm = QFrame(self) &#x27;&#x27;&#x27; 容器中的Frame为一个矩形的框架对象，对应类QFrame， QFrame类是PyQt中带框架部件的所有类的基类，如菜单、进度条、Label标签 &#x27;&#x27;&#x27; self.frm.setStyleSheet(&quot;QWidget &#123; background-color: %s &#125;&quot; % col.name()) self.frm.setGeometry(130, 22, 100, 100) self.setGeometry(300, 300, 250, 180) self.setWindowTitle(&#x27;Color dialog&#x27;) self.show() def showDialog(self): col = QColorDialog.getColor() &#x27;&#x27;&#x27; 弹出一个QColorDialog对话框 Pops up a modal color dialog with the given window title (or “Select Color” if none is specified), lets the user choose a color, and returns that color. The color is initially set to initial . The dialog is a child of parent . It returns an invalid (see isValid() ) color if the user cancels the dialog. The options argument allows you to customize the dialog. 调出一个调色板窗口，用户选定颜色后，该函数会用name ()方法返回颜色值 Return type: PySide2.QtGui.QColor 返回一个class类型 &#x27;&#x27;&#x27; for item in dir(col): print(&#x27;-- &#x27;,item,&#x27; --&#x27;) #打印该class中的属性、方法名称 if col.isValid(): #PySide2.QtGui.QColor.isValid()¶ Returns true if the color is valid; otherwise returns false . print(&quot;RGB: &quot;,col.name()) #Returns the name of the color in the format “#RRGGBB”; i.e. a “#” character followed by three two-digit hexadecimal numbers. self.frm.setStyleSheet(&quot;QWidget &#123; background-color: %s &#125;&quot; % col.name())if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 选择字体12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：选择字体ZetCode PyQt5 tutorial In this example, we select a font nameand change the font of a label. Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QPushButton, QSizePolicy, QLabel, QFontDialog, QApplication)import sysclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): vbox = QVBoxLayout() &#x27;&#x27;&#x27; QHBoxLayout和QVBoxLayout类继承自QBoxLayout，采用QBOXLayout类可以在水平和垂直方向上排列控件， 本案例采用QHBoxLayout类，按照从左到右的顺序来添加控件， 详见博客https://blog.csdn.net/jia666666/article/details/81699900 &#x27;&#x27;&#x27; btn = QPushButton(&#x27;Dialog&#x27;, self) btn.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed) btn.move(20, 20) vbox.addWidget(btn) btn.clicked.connect(self.showDialog) self.lbl = QLabel(&#x27;Knowledge only matters&#x27;, self) self.lbl.move(130, 20) vbox.addWidget(self.lbl) self.setLayout(vbox) self.setGeometry(300, 300, 250, 180) self.setWindowTitle(&#x27;Font dialog&#x27;) self.show() def showDialog(self): font, ok = QFontDialog.getFont() &#x27;&#x27;&#x27; 创建了一个有一个按钮和一个标签的QFontDialog的对话框，我们可以使用这个功能修改字体样式. getFont()方法返回一个字体名称和状态信息。状态信息有OK和其他两种。 static PySide2.QtWidgets.QFontDialog.getFont([parent=None])¶ Parameters parent – PySide2.QtWidgets.QWidget Return type PyTuple &#x27;&#x27;&#x27; if ok: #如果点击OK，标签的字体就会随之更改 self.lbl.setFont(font)if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 选择文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：文件保存ZetCode PyQt5 tutorial In this example, we select a file with aQFileDialog and display its contentsin a QTextEdit.Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;from PyQt5.QtWidgets import (QMainWindow, QTextEdit, QAction, QFileDialog, QApplication)from PyQt5.QtGui import QIconimport sysclass Example(QMainWindow): &#x27;&#x27;&#x27; 设置了一个文本编辑框，文本编辑框是基于QMainWindow组件的。 本例中有一个菜单栏，一个置中的文本编辑框，一个状态栏。点击菜单栏选项会弹出一个QtGui.QFileDialog对话框， 在这个对话框里，你能选择文件，然后文件的内容就会显示在文本编辑框里。 &#x27;&#x27;&#x27; def __init__(self): super().__init__() self.initUI() def initUI(self): self.textEdit = QTextEdit() self.setCentralWidget(self.textEdit) self.statusBar() openFile = QAction(QIcon(&#x27;open.png&#x27;), &#x27;Open&#x27;, self) openFile.setShortcut(&#x27;Ctrl+O&#x27;) openFile.setStatusTip(&#x27;Open new File&#x27;) openFile.triggered.connect(self.showDialog) menubar = self.menuBar() fileMenu = menubar.addMenu(&#x27;&amp;File&#x27;) fileMenu.addAction(openFile) self.setGeometry(300, 300, 350, 300) self.setWindowTitle(&#x27;File dialog&#x27;) self.show() def showDialog(self): fname = QFileDialog.getOpenFileName(self, &#x27;Open file&#x27;, &#x27;/home&#x27;) &#x27;&#x27;&#x27; 弹出QFileDialog窗口。getOpenFileName()方法的第一个参数是说明文字， 第二个参数是默认打开的文件夹路径。默认情况下显示所有类型的文件。 &#x27;&#x27;&#x27; if fname[0]: f = open(fname[0], &#x27;r&#x27;) with f: data = f.read() self.textEdit.setText(data) &#x27;&#x27;&#x27; 读取选中的文件，并显示在文本编辑框内 注意只能读取二进制文件，如txt，html等 （但是打开HTML文件时，是渲染后的结果） 打开pdf,png格式图片时候，会报错如下： UnicodeDecodeError: &#x27;gbk&#x27; codec can&#x27;t decode byte 0x89 in position 24: illegal multibyte sequence &#x27;&#x27;&#x27; if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_())","categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"},{"name":"Python3","slug":"Programming-languages-and-projects/Python3","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"},{"name":"PYQT5","slug":"Programming-languages-and-projects/Python3/PYQT5","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/PYQT5/"}],"tags":[{"name":"python3","slug":"python3","permalink":"http://justskim.github.io/tags/python3/"},{"name":"gui","slug":"gui","permalink":"http://justskim.github.io/tags/gui/"}]},{"title":"PYQT5事件与信号","slug":"PYQT5事件与信号","date":"2021-08-30T21:07:47.378Z","updated":"2021-08-30T21:08:00.898Z","comments":true,"path":"2021/08/31/PYQT5事件与信号/","link":"","permalink":"http://justskim.github.io/2021/08/31/PYQT5%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BF%A1%E5%8F%B7/","excerpt":"","text":"PYQT5事件与信号事件根据发布在gitbook网站上的中文博客^1讲解： signals and slots 被其他人翻译成信号和槽机制，(⊙o⊙)…我这里还是不翻译好了。所有的应用都是事件驱动的。事件大部分都是由用户的行为产生的，当然也有其他的事件产生方式，比如网络的连接，窗口管理器或者定时器等。调用应用的exec_()方法时，应用会进入主循环，主循环会监听和分发事件。在事件模型中，有三个角色：事件源事件事件目标事件源就是发生了状态改变的对象。事件是这个对象状态改变的内容。事件目标是事件想作用的目标。事件源绑定事件处理函数，然后作用于事件目标身上。PyQt5处理事件方面有个signal and slot机制。Signals and slots用于对象间的通讯。事件触发的时候，发生一个signal，slot是用来被Python调用的。 信号(signal)与槽(slot)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子： 信号、槽ZetCode PyQt5 tutorial In this example, we connect a signalof a QSlider to a slot of a QLCDNumber. Author: Jan BodnarWebsite: zetcode.com Last edited: January 2017&quot;&quot;&quot;import sysfrom PyQt5.QtCore import Qtfrom PyQt5.QtWidgets import (QWidget, QLCDNumber, QSlider, QVBoxLayout, QApplication)class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): lcd = QLCDNumber(self) sld = QSlider(Qt.Horizontal, self) vbox = QVBoxLayout() vbox.addWidget(lcd) vbox.addWidget(sld) self.setLayout(vbox) sld.valueChanged.connect(lcd.display) #把滑块的变化和数字的变化绑定在一起 self.setGeometry(300, 300, 250, 150) self.setWindowTitle(&#x27;Signal and slot&#x27;) self.show()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 重构事件处理器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：重构事件处理器（用自己的覆盖库自带的）ZetCode PyQt5 tutorial In this example, we reimplement an event handler. Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom PyQt5.QtCore import Qtfrom PyQt5.QtWidgets import QWidget, QApplicationclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setGeometry(300, 300, 250, 150) self.setWindowTitle(&#x27;Event handler&#x27;) self.show() def keyPressEvent(self, e): &#x27;&#x27;&#x27; 替换了事件处理器函数keyPressEvent()，按下esc键会退出程序 &#x27;&#x27;&#x27; if e.key() == Qt.Key_Escape: self.close()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 事件对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：事件对象ZetCode PyQt5 tutorial In this example, we display the x and y coordinates of a mouse pointer in a label widget.Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom PyQt5.QtCore import Qtfrom PyQt5.QtWidgets import QWidget, QApplication, QGridLayout, QLabelclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): grid = QGridLayout() grid.setSpacing(10) x = 0 y = 0 self.text = &quot;x: &#123;0&#125;, y: &#123;1&#125;&quot;.format(x, y) #在一个组件里显示鼠标的X和Y坐标。 self.label = QLabel(&#x27;self.text&#x27;, self) &#x27;&#x27;&#x27; PySide2.QtWidgets.QLabel(text[, parent=None[, f=Qt.WindowFlags()]]) QLabel用于显示文本或图像。没有提供用户交互功能 Constructs a label that displays the text. The parent and widget flag f , arguments are passed to the QFrame constructor. 构建一个显示文本的标签，参数中父级和控件标志f会被传递给QFrame构造函数 &#x27;&#x27;&#x27; grid.addWidget(self.label, 0, 0, Qt.AlignTop) self.setMouseTracking(True) #事件追踪默认没有开启，当开启后才会追踪鼠标的点击事件 self.setLayout(grid) self.setGeometry(300, 300, 350, 200) self.setWindowTitle(&#x27;Event object&#x27;) self.show() def mouseMoveEvent(self, e): &#x27;&#x27;&#x27; 官方文档中的解释仅一句：Override this to handle mouse move events. 覆盖此操作以处理鼠标移动事件 这里的参数e为事件对象。里面有我们触发事件（鼠标移动）的事件对象。 下面的x()和y()方法可以得到鼠标在窗口中此刻的x和y坐标点，然后拼成字符串输出到QLabel组件里 &#x27;&#x27;&#x27; x = e.x() y = e.y() text = &quot;x: &#123;0&#125;, y: &#123;1&#125;&quot;.format(x, y) self.label.setText(text) &#x27;&#x27;&#x27; 注意qtcy中以很多个setText函数，这里是：PySide2.QtWidgets.QLabel.setText(arg__1) Parameters: arg__1 – str &#x27;&#x27;&#x27;if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 事件发送123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：事件发送ZetCode PyQt5 tutorial In this example, we determine the event senderobject.Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom PyQt5.QtWidgets import QMainWindow, QPushButton, QApplicationclass Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): btn1 = QPushButton(&quot;Button 1&quot;, self) btn1.move(30, 50) btn2 = QPushButton(&quot;Button 2&quot;, self) btn2.move(150, 50) btn1.clicked.connect(self.buttonClicked) btn2.clicked.connect(self.buttonClicked) self.statusBar() self.setGeometry(300, 300, 290, 150) self.setWindowTitle(&#x27;Event sender&#x27;) self.show() def buttonClicked(self): sender = self.sender() &#x27;&#x27;&#x27;Returns a pointer to the object that sent the signal, if called in a slot activated by a signal; otherwise(否则) it returns None . The pointer is valid only during the execution(执行) of the slot that calls this function from this object’s thread context.The pointer returned by this function becomes invalid if the sender(发送人) is destroyed, or if the slot is disconnected from the sender’s signal.sender()在QT里的原型是QObject::sender(),也就是对象，实例化的对象可以发送信号，返回发送信号的对象的指针，返回类型为QObject * &#x27;&#x27;&#x27; self.statusBar().showMessage(sender.text() + &#x27; was pressed&#x27;) &#x27;&#x27;&#x27; Returns the object that emitted the signal. 该函数没有参数，返回发送信号的那一个对象 用调用sender()方法的方式决定了事件源。状态栏显示了被点击的按钮. &#x27;&#x27;&#x27;if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 信号发送123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：信号发送ZetCode PyQt5 tutorial In this example, we show how to emit（发射，发送） a custom signal. Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom PyQt5.QtCore import pyqtSignal, QObjectfrom PyQt5.QtWidgets import QMainWindow, QApplicationclass Communicate(QObject): #创建了一个叫closeApp的信号，这个信号会在鼠标按下的时候触发，事件与QMainWindow绑定。 closeApp = pyqtSignal() class Example(QMainWindow): &#x27;&#x27;&#x27; class PySide2.QtWidgets.QMainWindow([parent=None[, flags=Qt.WindowFlags()]])¶ param parent PySide2.QtWidgets.QWidget param flags WindowFlags Constructs a QMainWindow with the given parent and the specified widget flags . QMainWindow sets the Window flag itself, and will hence always be created as a top-level widget. &#x27;&#x27;&#x27; def __init__(self): super().__init__() self.initUI() def initUI(self): self.c = Communicate() &#x27;&#x27;&#x27; Communicate类创建了一个pyqtSignal()属性的信号。 &#x27;&#x27;&#x27; self.c.closeApp.connect(self.close) &#x27;&#x27;&#x27; PySide2.QtGui.QWindow.close()¶ Return type bool 功能只有一个Close the window. &#x27;&#x27;&#x27; self.setGeometry(300, 300, 290, 150) self.setWindowTitle(&#x27;Emit signal&#x27;) self.show() def mousePressEvent(self, event): event.gg = &#x27;gg&#x27; print(&quot;event: &quot;,event.__dict__) #打印对象的全部属性 self.c.closeApp.emit()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) Reference","categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"},{"name":"Python3","slug":"Programming-languages-and-projects/Python3","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"},{"name":"PYQT5","slug":"Programming-languages-and-projects/Python3/PYQT5","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/PYQT5/"}],"tags":[{"name":"python3","slug":"python3","permalink":"http://justskim.github.io/tags/python3/"},{"name":"gui","slug":"gui","permalink":"http://justskim.github.io/tags/gui/"}]},{"title":"PYQT5布局管理","slug":"PYQT5布局管理","date":"2021-08-30T20:58:59.264Z","updated":"2021-08-30T20:58:59.264Z","comments":true,"path":"2021/08/31/PYQT5布局管理/","link":"","permalink":"http://justskim.github.io/2021/08/31/PYQT5%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86/","excerpt":"","text":"PYQT5布局管理绝对定位123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：绝对定位ZetCode PyQt5 tutorial This example shows three labels on a windowusing absolute positioning. Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom PyQt5.QtWidgets import QWidget, QLabel, QApplicationclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): &#x27;&#x27;&#x27; QLabel小部件提供文本或图像显示，没有交互功能！ &#x27;&#x27;&#x27; lbl1 = QLabel(text=&#x27;Zetcode&#x27;, parent=self) lbl1.move(15, 10) #使用move方法定位元素(也就是这个label部件) lbl2 = QLabel(&#x27;tutorials&#x27;, self) lbl2.move(35, 40) lbl3 = QLabel(&#x27;for programmers&#x27;, self) lbl3.move(55, 70) self.setGeometry(400, 400, 500, 250) &#x27;&#x27;&#x27; setGeometry()有两个作用： 把窗口放到屏幕上；设置窗口大小。 四个参数分别代表屏幕坐标的x、y和窗口大小的宽、高。 这个方法是resize()和move()的合体。 &#x27;&#x27;&#x27; self.setWindowTitle(&#x27;Absolute&#x27;) #为窗口添加了一个在标题栏展示的标题 self.show()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 盒布局123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：盒布局ZetCode PyQt5 tutorial In this example, we position two pushbuttons in the bottom-right corner of the window. Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom PyQt5.QtWidgets import (QWidget, QPushButton, QHBoxLayout, QVBoxLayout, QApplication)class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): okButton = QPushButton(&quot;OK&quot;) #创建一个继承自QPushButton的按钮(自然就是一个控件)。第一个参数text参数是想要显示的按钮名称，第二个参数parent是按钮的父级组件 cancelButton = QPushButton(&quot;Cancel&quot;) &#x27;&#x27;&#x27; 下面十行代码创建一个水平布局，并增加弹性空间和两个按钮。 addStretch函数的作用就是平分布局，它所带的参数就是所占的比例，这里为1占据了全部 &#x27;&#x27;&#x27; hbox = QHBoxLayout() &#x27;&#x27;&#x27; QHBoxLayout和QVBoxLayout类继承自QBoxLayout，采用QBOXLayout类可以在水平和垂直方向上排列控件， 本案例采用QHBoxLayout类，按照从左到右的顺序来添加控件， 详见博客https://blog.csdn.net/jia666666/article/details/81699900 &#x27;&#x27;&#x27; hbox.addStretch(1) hbox.addWidget(okButton) &#x27;&#x27;&#x27; PySide2.QtWidgets.QGridLayout.addWidget(arg__1, row, column, rowSpan, columnSpan[, alignment=Qt.Alignment()]) row:行位置 column：列位置 rowSpan：跨行数、行跨距（一般用于QTextEdit()文本输入组件） columnSpan：列跨距 alignment；对齐方式 if rowSpan and/or columnSpan is -1, then the widget will extend to the bottom and/or right edge, respectively. 如果这两项设置为-1，该小组件会分别沿两个方向延伸到底部/右边缘 这里增加了一个按钮 addwidget()方法用于向布局中添加控件（这里是按钮okButton） &#x27;&#x27;&#x27; hbox.addWidget(cancelButton) vbox = QVBoxLayout() vbox.addStretch(1) vbox.addLayout(hbox) &#x27;&#x27;&#x27; 为了布局需要，我们把这个水平布局放到了一个垂直布局盒里面。弹性元素会把水平布局挤到窗口的下边。 &#x27;&#x27;&#x27; self.setLayout(vbox) self.setGeometry(300, 300, 300, 150) self.setWindowTitle(&#x27;Buttons&#x27;) self.show()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 栅格布局123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：栅格化布局ZetCode PyQt5 tutorial In this example, we create a skeletonof a calculator using a QGridLayout.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015&quot;&quot;&quot;import sysfrom PyQt5.QtWidgets import (QWidget, QGridLayout, QPushButton, QApplication)class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): grid = QGridLayout(self) &#x27;&#x27;&#x27; QGridLayout（网格布局）是将窗口分割成行和列的网格来进行排列， 通常可以使用函数addWidget（）将被管理的控件（Widget）添加到窗口中，或者使用addLayout（）函数将布局（layout）添加到窗口中， 也可以通过addWIdget（）函数对所添加的控件设置行数与列数的跨越，最后实现网格占据多个窗格。 QGridLayout类中有以下三个常用方法： addWidget(QWidget Widget,int row,int col,int alignment=0) 给网格布局添加部件，设置指定的行和列，起始位置的默认值为（0,0） addWidget(QWidget widget,int fromRow,int fromColulmn,int rowSpan,int columnSpan,Qt.Alignment alignment=0) setSpacing(int spacing) 所添加的的控件跨越很多行或者列的时候，使用这个函数 setSpacing(int spacing) 设置软件在水平和垂直方向的间隔 详见https://blog.csdn.net/jia666666/article/details/81701176 &#x27;&#x27;&#x27; self.setLayout(grid) #创建一个QGridLayout实例，并把它放到程序窗口里 &#x27;&#x27;&#x27; 有些控件或者布局有addLayout和addWidget的函数,但是有些就没有, 比如QWidget这个控件就没有addLayout和addWidget这个函数,取而代之的是一个setLayout函数, 在addLayout函数中,我们可以多次使用addLayout来依次添加布局,addWidget亦是如此, 但是setlayout只能set一次 官方文档中对此的解释： Sets the layout manager for this widget to layout . If there already is a layout manager installed on this widget, QWidget won’t let you install another. You must first delete the existing layout manager (returned by layout() ) before you can call with the new layout. If layout is the layout manager on a different widget, will reparent the layout and make it the layout manager for this widget. 翻译过来就是： 为此小组件设置布局管理器以布局。 若您已经在此窗口小部件上安装了一个布局管理器，则QWidget这个控件不会允许您安装另一个布局管理器，除非删除现有的布局管理器（在使用新布局调用之前删除PlayOut（））。 如果布局是在不同的另一个窗口小部件上的布局管理器，那么将重新定义布局并使其成为此小部件的布局管理器。 &#x27;&#x27;&#x27; names = [&#x27;Cls&#x27;, &#x27;Bck&#x27;, &#x27;&#x27;, &#x27;Close&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;/&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;*&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;-&#x27;, &#x27;0&#x27;, &#x27;.&#x27;, &#x27;=&#x27;, &#x27;+&#x27;] #定义一个列表，存储将要使用的按钮的名称 positions = [(i,j) for i in range(5) for j in range(4)] #生成位置坐标，五行(i)四列(j) for position, name in zip(positions, names): #依次创建按钮位置列表 if name == &#x27;&#x27;: continue #为空的话，原本控件的位置会空出来，不会被后面的挤占 button = QPushButton(name) &#x27;&#x27;&#x27; www.zetcode.com的解释 QPushButton is a widget which executes an action when a user clicks on it. A QPushButton can display text and icons. &#x27;&#x27;&#x27; grid.addWidget(button, *position) &#x27;&#x27;&#x27; QGridLayout::addWidget ( QWidget * widget, int row, int column, Qt::Alignment alignment = 0 ) python中，*参数收集所有未匹配的位置参数组成一个tuple对象（元组），局部变量args指向此tuple对象 &#x27;&#x27;&#x27; self.move(300, 150) self.setWindowTitle(&#x27;Calculator&#x27;) self.show()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 制作提交反馈信息的布局123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：能反馈信息的布局ZetCode PyQt5 tutorial In this example, we create a more complicated window layout usingthe QGridLayout manager. Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom PyQt5.QtWidgets import (QWidget, QLabel, QLineEdit, QTextEdit, QGridLayout, QApplication)class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): title = QLabel(&#x27;Title&#x27;) author = QLabel(&#x27;Author&#x27;) review = QLabel(&#x27;Review&#x27;) titleEdit = QLineEdit() authorEdit = QLineEdit() reviewEdit = QTextEdit() &#x27;&#x27;&#x27; 用QGridLayout模块制作两个行编辑窗口和一个文本编辑窗口 &#x27;&#x27;&#x27; grid = QGridLayout() #一个QGridLayout类 #QGridLayout(parent)，在构建新网格布局时必须将其插入父布局，没有则为self。 grid.setSpacing(10) #各个控件之间的间距（包括上下左右）设置为10px &#x27;&#x27;&#x27; 在组件的排列中，行列均从0开始， 行缺失则后面的填上位置，所以从0或1开始无所谓， 但网格化布局中，列必须从0而不是1开始，也不能缺失 &#x27;&#x27;&#x27; grid.addWidget(title, 0, 0) #将该组件添加至第0行第0列 grid.addWidget(titleEdit, 0, 1) #将该组件添加至第0行第1列 grid.addWidget(author, 1, 0) grid.addWidget(authorEdit, 1, 1) grid.addWidget(review, 2, 0) grid.addWidget(reviewEdit, 2, 1, 5, 1) &#x27;&#x27;&#x27; PySide2.QtWidgets.QGridLayout.addWidget(arg__1, row, column, rowSpan, columnSpan[, alignment=Qt.Alignment()]) row:行位置 column：列位置 rowSpan：跨行数、行跨距（一般用于QTextEdit()文本输入组件） columnSpan：列跨距 alignment；对齐方式 这里文本编辑窗口跨5行，仍然只占一列 &#x27;&#x27;&#x27; self.setLayout(grid) #设置布局管理器，一个QWidget控件中只能设置一个 self.setGeometry(300, 300, 350, 300) self.setWindowTitle(&#x27;Review&#x27;) self.show()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_())","categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"},{"name":"Python3","slug":"Programming-languages-and-projects/Python3","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"},{"name":"PYQT5","slug":"Programming-languages-and-projects/Python3/PYQT5","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/PYQT5/"}],"tags":[{"name":"python3","slug":"python3","permalink":"http://justskim.github.io/tags/python3/"},{"name":"gui","slug":"gui","permalink":"http://justskim.github.io/tags/gui/"}]},{"title":"Pyqt5中的窗口与工具栏","slug":"Pyqt5中的窗口与工具栏","date":"2021-08-30T20:45:49.898Z","updated":"2021-08-30T20:55:29.290Z","comments":true,"path":"2021/08/31/Pyqt5中的窗口与工具栏/","link":"","permalink":"http://justskim.github.io/2021/08/31/Pyqt5%E4%B8%AD%E7%9A%84%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%B7%A5%E5%85%B7%E6%A0%8F/","excerpt":"","text":"Pyqt5中的窗口与工具栏主窗口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：主窗口ZetCode PyQt5 tutorial This program creates a skeleton ofa classic GUI application with a menubar,toolbar, statusbar, and a central widget. Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom PyQt5.QtWidgets import QMainWindow, QTextEdit, QAction, QApplicationfrom PyQt5.QtGui import QIconclass Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): textEdit = QTextEdit() self.setCentralWidget(textEdit) &#x27;&#x27;&#x27; 创建了一个文本编辑区域，并把它放在QMainWindow的中间区域，这个组件会占满所有剩余的区域。 &#x27;&#x27;&#x27; exitAct = QAction(QIcon(&#x27;exit24.png&#x27;), &#x27;Exit&#x27;, self) #当鼠标移至工具栏中的该图标时，会显示这里的文字‘Exit’ exitAct.setShortcut(&#x27;Ctrl+Q&#x27;) #设置该动作的相关快捷键 exitAct.setStatusTip(&#x27;Exit application&#x27;) exitAct.triggered.connect(self.close) self.statusBar() #创建一个状态栏 menubar = self.menuBar() #创建一个菜单栏 fileMenu = menubar.addMenu(&#x27;&amp;File&#x27;) #这里的符号&#x27;&amp;&#x27;不会在菜单栏选项中显示出来 fileMenu.addAction(exitAct) toolbar = self.addToolBar(&#x27;Exit&#x27;) #addToolBar()创建工具栏 toolbar.addAction(exitAct) #工具栏添加一个选项 self.setGeometry(300, 300, 350, 250) self.setWindowTitle(&#x27;Main window&#x27;) self.show()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 状态栏1234567891011121314151617181920212223242526272829303132333435363738394041424344#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例1：状态栏ZetCode PyQt5 tutorial This program creates a statusbar.Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom PyQt5.QtWidgets import QMainWindow, QApplication#状态栏由QMainWindow创建class Example(QMainWindow): def __init__(self): #super() 函数是用于调用父类(超类)的一个方法。super ().__init__ ()，就是继承父类的init方法 super().__init__() self.initUI() def initUI(self): self.statusBar().showMessage(&#x27;Ready&#x27;) &#x27;&#x27;&#x27; 调用QtGui.QMainWindow类的statusBar()方法，创建状态栏。 第一次调用会创建一个状态栏，而再次调用会返回一个状态栏对象。showMessage()方法在状态栏上显示一条信息。 &#x27;&#x27;&#x27; self.setGeometry(300, 300, 250, 150) self.setWindowTitle(&#x27;Statusbar&#x27;) self.show()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 菜单栏12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例2：菜单栏ZetCode PyQt5 tutorial This program creates a menubar. Themenubar has one menu with an exit action.Author: Jan BodnarWebsite: zetcode.com Last edited: January 2017&quot;&quot;&quot;import sysfrom PyQt5.QtWidgets import QMainWindow, QAction, qApp, QApplicationfrom PyQt5.QtGui import QIconclass Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): exitAct = QAction(QIcon(&#x27;exit.png&#x27;), &#x27;&amp;Exit&#x27;, self) exitAct.setShortcut(&#x27;Ctrl+Q&#x27;) exitAct.setStatusTip(&#x27;Exit application&#x27;) &#x27;&#x27;&#x27; QAction是菜单栏、工具栏或者快捷键的动作的组合。 上面三行中，前两行创建了一个图标、一个exit的标签和一个快捷键组合，都执行了一个动作； 第三行，创建了一个状态栏，当鼠标悬停在菜单栏的时候，能显示当前状态。 &#x27;&#x27;&#x27; exitAct.triggered.connect(qApp.quit) #当执行这个指定的动作时，就触发了一个事件。这个事件跟QApplication的quit()行为相关联，所以这个动作就能终止这个应用。 self.statusBar() menubar = self.menuBar() #创建一个菜单栏（位于顶部固定位置） &#x27;&#x27;&#x27; QMenu和QMenuBar是Qt中的菜单类(也就是右键菜单)和菜单栏类，其中，菜单QMenu挂载在菜单栏QMenuBar上 &#x27;&#x27;&#x27; fileMenu = menubar.addMenu(&#x27;&amp;File&#x27;) fileMenu.addAction(exitAct) &#x27;&#x27;&#x27; menuBar()创建菜单栏。这里创建了一个菜单栏，并用addMenu()在上面添加了一个file菜单， 用addAction()关联了点击退出应用的事件/动作（也就是可直接进行的选项而非子级菜单）。 &#x27;&#x27;&#x27; self.setGeometry(300, 300, 300, 200) self.setWindowTitle(&#x27;Simple menu&#x27;) self.show()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 子菜单1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例3：子菜单ZetCode PyQt5 tutorial This program creates a submenu.Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom PyQt5.QtGui import QIconfrom PyQt5.QtWidgets import QMainWindow, QAction, QMenu, QApplicationclass Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setWindowIcon(QIcon(&#x27;icon.png&#x27;)) #设置图标 menubar = self.menuBar() #菜单栏上一个没有子级菜单的纯粹选项（动作） GoAction = menubar.addAction(&quot;GOOOOOOOOoo&quot;) &#x27;&#x27;&#x27; 主菜单栏第一项为File，其下添加两个动作（addAction(impAct)）New和Save， 添加两个子级菜单(addMenu(impMenu))Import和Import2 &#x27;&#x27;&#x27; fileMenu = menubar.addMenu(&#x27;File&#x27;) impMenu = QMenu(&#x27;Import&#x27;, self) #定义一个子菜单 Import impAct = QAction(&#x27;Import mail&#x27;, self) #在子菜单Import下的子级菜单 Import mail impMenu.addAction(impAct) #用addAction()关联事件————悬浮在Import时会出现Import mail。 impMenu2 = QMenu(&#x27;Import2&#x27;, self) impAct2 = QAction(&#x27;Import mail2&#x27;, self) impMenu2.addAction(impAct2) newAct = QAction(&#x27;New一个&#x27;, self) save = QAction(&#x27;Save保存文件&#x27;,self) fileMenu.addAction(newAct)#添加了菜单下的一个动作（也就是可直接进行的选项而非子级菜单） fileMenu.addAction(save) #添加了动作“Save保存文件”，注意顺序在new之后 fileMenu.addMenu(impMenu)#添加了子菜单，注意函数addMenu是和添加主菜单一样的 fileMenu.addMenu(impMenu2) #定义菜单栏的选项edit editMenu = menubar.addMenu(&quot;Edit&quot;) impMenu_edit = QMenu(&quot;write in Chinese&quot;,self) editMenu.addMenu(impMenu_edit) impAct_edit = QAction(&quot;give up&quot;,self) editMenu.addAction(impAct_edit) self.setGeometry(300, 300, 300, 200) self.setWindowTitle(&#x27;Submenu&#x27;) self.show()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 勾选菜单1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例4：勾选菜单ZetCode PyQt5 tutorial This program creates a optional menu.Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom typing import ValuesViewfrom PyQt5.QtWidgets import QMainWindow, QAction, QApplicationclass Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): self.statusbar = self.statusBar() self.statusbar.showMessage(&#x27;Ready&#x27;) #状态栏显示 menubar = self.menuBar() #本例创建了一个行为菜单。这个行为／动作能切换状态栏显示或者隐藏。 viewMenu = menubar.addMenu(&#x27;View&#x27;) viewStatAct = QAction(text=&#x27;View statusbar&#x27;, parent=self, checkable=True) #checkable选项为True，意味着所创建的这一个 动作（父级菜单的子项） 能被选中 viewStatAct.setStatusTip(&#x27;View statusbar&#x27;) viewStatAct.setChecked(True) #设置该动作的默认状态为选中状态 viewStatAct.triggered.connect(self.toggleMenu)#绑定动作激活时的事件 viewMenu.addAction(viewStatAct) self.setGeometry(300, 300, 300, 200) self.setWindowTitle(&#x27;Check menu&#x27;) self.show() def toggleMenu(self, state): #根据是否打钩来决定是否显示底部的状态栏 if state: self.statusbar.show() else: self.statusbar.hide()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 右键菜单12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例5：右键菜单ZetCode PyQt5 tutorial This program creates a context menu.context有内容、上下文的意思，context menu意为右键菜单（上下文菜单）Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom PyQt5.QtWidgets import QMainWindow, qApp, QMenu, QApplicationclass Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setGeometry(300, 300, 300, 200) self.setWindowTitle(&#x27;Context menu&#x27;) self.show() &#x27;&#x27;&#x27; 利用右键菜单事件 QWidget::contextMenuEvent() 来处理右键事件，所以需要重写此函数 &#x27;&#x27;&#x27; def contextMenuEvent(self, event): &#x27;&#x27;&#x27; The QMenu class provides a menu widget for use in menu bars, context menus, and other popup menus &#x27;&#x27;&#x27; cmenu = QMenu(&#x27;这里的文字不会显示，有无均可&#x27;,self) #使用QMenu创建一个上下文菜单，即右键菜单 newAct = cmenu.addAction(&quot;New&quot;) #添加了一名为“New”的动作 opnAct = cmenu.addAction(&quot;Open&quot;) quitAct = cmenu.addAction(&quot;Quit&quot;) action = cmenu.exec_(self.mapToGlobal(event.pos())) &#x27;&#x27;&#x27; 使用exec_()方法显示菜单。从鼠标右键事件对象中获得当前坐标。mapToGlobal()方法把当前组件的相对坐标转换为窗口（window）的绝对坐标。 &#x27;&#x27;&#x27; &#x27;&#x27;&#x27; 如果点击右键菜单中的Quit动作，则退出 右键菜单里触发了事件，也就触发了退出事件，执行关闭菜单行为 &#x27;&#x27;&#x27; if action == quitAct: qApp.quit() else: print(&quot;现在执行的动作不是quitAct&quot;)if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 工具栏123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：工具栏ZetCode PyQt5 tutorial This program creates a toolbar.The toolbar has one action, whichterminates the application, if triggered.Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom PyQt5.QtWidgets import QMainWindow, QAction, qApp, QApplicationfrom PyQt5.QtGui import QIconclass Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): exitAct = QAction(icon=QIcon(&#x27;exit24.png&#x27;), text=&#x27;Exittttt&#x27;, parent=self) exitAct.setShortcut(&#x27;Ctrl+Q&#x27;) exitAct.triggered.connect(qApp.quit) #行为被触发的时候，会调用QtGui.QMainWindow的quit方法退出应用 self.toolbar = self.addToolBar(&#x27;Exit&#x27;)#addToolBar()创建工具栏 #‘Exit’不会显示在工具栏中，当鼠标移至该图标时，会显示文字‘Exittttt’而非‘Exit’ self.toolbar.addAction(exitAct) #将动作添加到工具栏 self.setGeometry(300, 300, 300, 200) self.setWindowTitle(&#x27;Toolbar&#x27;) self.show()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 主窗口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：主窗口ZetCode PyQt5 tutorial This program creates a skeleton ofa classic GUI application with a menubar,toolbar, statusbar, and a central widget. Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom PyQt5.QtWidgets import QMainWindow, QTextEdit, QAction, QApplicationfrom PyQt5.QtGui import QIconclass Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): textEdit = QTextEdit() self.setCentralWidget(textEdit) &#x27;&#x27;&#x27; 创建了一个文本编辑区域，并把它放在QMainWindow的中间区域，这个组件会占满所有剩余的区域。 &#x27;&#x27;&#x27; exitAct = QAction(QIcon(&#x27;exit24.png&#x27;), &#x27;Exit&#x27;, self) #当鼠标移至工具栏中的该图标时，会显示这里的文字‘Exit’ exitAct.setShortcut(&#x27;Ctrl+Q&#x27;) #设置该动作的相关快捷键 exitAct.setStatusTip(&#x27;Exit application&#x27;) exitAct.triggered.connect(self.close) self.statusBar() #创建一个状态栏 menubar = self.menuBar() #创建一个菜单栏 fileMenu = menubar.addMenu(&#x27;&amp;File&#x27;) #这里的符号&#x27;&amp;&#x27;不会在菜单栏选项中显示出来 fileMenu.addAction(exitAct) toolbar = self.addToolBar(&#x27;Exit&#x27;) #addToolBar()创建工具栏 toolbar.addAction(exitAct) #工具栏添加一个选项 self.setGeometry(300, 300, 350, 250) self.setWindowTitle(&#x27;Main window&#x27;) self.show()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_())","categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"},{"name":"Python3","slug":"Programming-languages-and-projects/Python3","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"},{"name":"PYQT5","slug":"Programming-languages-and-projects/Python3/PYQT5","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/PYQT5/"}],"tags":[{"name":"python3","slug":"python3","permalink":"http://justskim.github.io/tags/python3/"},{"name":"gui","slug":"gui","permalink":"http://justskim.github.io/tags/gui/"}]},{"title":"Pyqt5中的常用模块与组件","slug":"应用窗口初始化","date":"2021-08-29T14:29:42.426Z","updated":"2021-08-30T20:48:02.559Z","comments":true,"path":"2021/08/29/应用窗口初始化/","link":"","permalink":"http://justskim.github.io/2021/08/29/%E5%BA%94%E7%94%A8%E7%AA%97%E5%8F%A3%E5%88%9D%E5%A7%8B%E5%8C%96/","excerpt":"","text":"应用窗口初始化QApplication与QWidgetQWidget控件是一个用户界面的基本控件，它提供了基本的应用构造器。默认情况下，构造器是没有父级的，没有父级的构造器被称为窗口（window）。 窗口类型简介^1QMainWindow、QWidget、QDialog用于创建窗口，可以直接使用，也可以派生使用，这3个基类从名字上看分别是 “微件”、”对话框”、”主窗口。QMainWindow窗口包含菜单栏、工具栏、状态栏、标题栏等，是最常见的窗口形式。QDialog是对话框窗口的基类，主要用于执行短期任务，或与用户进行交互，可以是模态或非模态的。QDialog对话框没有菜单栏、工具栏、状态栏等。QWidget是Qt图形组件的基类，可以作为顶层窗口，也可以嵌入到其它组件中。 在创建Qt Gui Application时，总会让你选择在QWidget,QMainWindow和QDialog中选择一个Base Class。 这三个类具体有什么区别呢？在Qt的手册和网上找了一些资料。 先看官方的手册中的介绍： QWidget Class ReferenceThe QWidget class is the base class of all user interface objects.Inherits: QObject and QPaintDevice.Inherited by: ……, QDialog, ……,QMainWindow, …… QDialog Class ReferenceThe QDialog class is the base class of dialog windows.Inherits: QWidget. QMainWindow Class ReferenceThe QMainWindow class provides a main application window.Inherits: QWidget. 可以看到QMainWindow和QDialog都是继承自QWidget。再看看下面那段从网上转过来的介绍，大概就能了解三者之间的区别了。 QWidget类是所有用户界面对象的基类。 窗口部件是用户界面的一个原子：它从窗口系统接收鼠标、键盘和其它事件，并且在屏幕上绘制自己的表现。每一个窗口部件都是矩形，并且它们按Z轴顺序排列的。一个窗口部件可以被它的父窗口部件或者它前面的窗口部件盖住一部分。 QMainWindow 类提供一个有菜单条、锚接窗口（例如工具条）和一个状态条的主应用程序窗口。主窗口通常用在提供一个大的中央窗口部件（例如文本编辑或者绘制画布）以及周围菜单、工具条和一个状态条。QMainWindow常常被继承，因为这使得封装中央部件、菜单和工具条以及窗口状态变得更容易。继承使创建当用户点击菜单项或者工具条按钮时被调用的槽成为可能。你也可以使用Qt设计器来创建主窗口。 QDialog类是对话框窗口的基类。对话框窗口是主要用于短期任务以及和用户进行简要通讯的顶级窗口。QDialog可以是模式的也可以是非模式的。QDialog支持扩展性并且可以提供返回值。它们可以有默认按钮。QDialog也可以有一个QSizeGrip在它的右下角，使用setSizeGripEnabled()。 QDialog 是最普通的顶级窗口。不被嵌入到一个父窗口部件的窗口部件被叫做顶级窗口部件。通常情况下，顶级窗口部件是有框架和标题栏的窗口（尽管如果使用了一定的窗口部件标记，创建顶级窗口部件时也可能没有这些装饰。）在Qt中，QMainWindow和和不同的QDialog的子类是最普通的顶级窗口。 综上，如果是顶级对话框，那就基于QDialog创建，如果是主窗体，那就基于QMainWindow，如果不确定，或者有可能作为顶级窗体，或有可能嵌入到其他窗体中，则基于QWidget创建。当然了，实际中，你还可以基于任何其他部件类来派生。看实际需求了，比如QFrame、QStackedWidget等等。 根据官方对QApplication的解释：PyQt5.QtGui .QGuiApplication继承自QCoreApplication，由PyQt5.QtWidgets .QApplication继承。QApplication管理GUI程序的控制流和主要设置。QApplication包含窗口系统和其他来源处理过和发送过的主事件循环。它也处理应用程序的初始化和收尾工作，并提供对话管理。QApplication可以对系统和应用的大部分设置项进行设置。对于用Qt写的任何一个GUI应用，不管这个应用有没有窗口或多少个窗口，有且只有一QApplication对象。sys.argv是一组命令行参数的列表。Python可以在shell里运行，这个参数提供对脚本控制的功能每一个PyQt5项目都需要创建一个 QApplication 对象。 sys.argv 则提供了命令行的一些参数，这样 Python 脚本就能从 Shell 运行，这是我们控制脚本开始运行的方式。 至于为什么需要sys.argv，可以看stackoverflow上的这一个回答：This calls the constructor of the C++ class QApplication.It uses sys.argv (argc and argv in C++) to initialize the QT application.There are a bunch of arguments that you can pass to QT, like styles, debugging stuff and so on.以及官方文档：https://doc.qt.io/qt-5/qapplication.html#QApplication Hello World实例以下是一个来自技术网站zetcode的实例代码 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;ZetCode PyQt5 tutorial In this example, we create a simplewindow in PyQt5.author: Jan Bodnarwebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom PyQt5.QtWidgets import QApplication, QWidgetif __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) w = QWidget() w.resize(250, 150) w.move(300, 300) w.setWindowTitle(&#x27;Simple&#x27;) w.show() #QWidget类中的show()方法能让窗口在桌面上显示出来。注意窗口是在内存里创建，之后才能在显示器里显示出来 sys.exit(app.exec_()) &#x27;&#x27;&#x27; 调用exit()方法或直接销毁窗口时，主循环就会结束。sys.exit()方法能确保主循环安全退出。外部环境会收到窗口如何结束的信息。 这里的方法exec_()之所以有个下划线，是因为exec是一个Python的关键字。 &#x27;&#x27;&#x27; 几个名词之间的区分根据技术网站zetcode^2提供的相关英文文档，内容如下： Here we provide the necessary imports. The basic widgets are located in PyQt5.QtWidgets module. 1234app = QApplication(sys.argv) ```Every PyQt5 application must create an application object. The `sys.argv` parameter is a list of arguments from a command line. Python scripts can be run from the shell. It is a way how we can control the startup of our scripts. w &#x3D; QWidget()&#96;&#96;&#96; The QWidget widget is the base class of all user interface objects in PyQt5. We provide the default constructor for QWidget. The default constructor has no parent. A widget with no parent is called a window. 带图标的窗口12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例2 带图标的窗口ZetCode PyQt5 tutorial This example shows an iconin the titlebar of the window.Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom PyQt5.QtWidgets import QApplication, QWidgetfrom PyQt5.QtGui import QIconclass Example(QWidget): def __init__(self): super().__init__() self.initUI() #使用initUI()方法创建一个GUI(图形用户界面 Graphical User Interface)。 def initUI(self): self.setGeometry(300, 300, 300, 220) self.setWindowTitle(&#x27;Icon&#x27;) self.setWindowIcon(QIcon(&#x27;icon.png&#x27;)) &#x27;&#x27;&#x27; 三个方法都继承自QWidget类。 setGeometry()有两个作用： 把窗口放到屏幕上并且设置窗口大小。参数分别代表屏幕坐标的x、y和窗口大小的宽、高。 也就是说这个方法是resize()和move()的合体。 setWindowTitle(&#x27;Icon&#x27;)为窗口添加了一个在标题栏展示文字&#x27;Icon&#x27;的标题 最后一个方法是添加了图标。先创建一个QIcon对象，然后接受一个路径作为参数显示图标。 &#x27;&#x27;&#x27; self.show() #让控件在桌面上显示出来。控件在内存里创建，之后才能在显示器上显示出来。if __name__ == &#x27;__main__&#x27;: MyApplication = QApplication(sys.argv) #创建应用对象，名称无所谓，后续操作相同即可 ex = Example() sys.exit(MyApplication.exec_()) #销毁主控件 提示框1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;# 例3 提示框ZetCode PyQt5 tutorial This example shows a tooltip on a window and a button.Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom PyQt5.QtWidgets import (QWidget, QToolTip, QPushButton, QApplication) #引用相关模块from PyQt5.QtGui import QFont class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): #为应用创建了一个提示框，10px的SansSerif字体 QToolTip.setFont(QFont(&#x27;SansSerif&#x27;, 10)) #QToolTip.setFont(QFont(&#x27;SansSerif&#x27;, 10,QFont.Bold,italic=True)) #函数QFont具体使用见 https://doc.qt.io/qtforpython/PySide6/QtGui/QFont.html #参数：字体类型，大小（px），粗细，斜体... btn = QPushButton(text=&#x27;Button&#x27;,parent=self) &#x27;&#x27;&#x27; 创建一个继承自QPushButton的按钮。第一个参数text参数是想要显示的按钮名称， 第二个参数parent是按钮的父级组件，这个例子中，self所指的父级组件，就是我们创建的继承自Qwidget的Example类。 应用中的组件都是一层一层（继承而来的？）的，在这个层里，大部分的组件都有自己的父级， 没有父级的组件（parent=None,没有parent的QWidget类），是顶级的窗口，即被认为是最上层的窗体（通常是MainWindow）。 &#x27;&#x27;&#x27; #创建一个按钮，当鼠标悬浮于按钮时，提示&#x27;This is a QPushButton widget&#x27; btn.setToolTip(&#x27;This is a &lt;b&gt;QPushButton&lt;/b&gt; widget&#x27;) #调用setTooltip()创建提示框可以使用富文本格式的内容 #当鼠标悬浮于窗口中时，提示&#x27;This is a QWidget widget&#x27; self.setToolTip(&#x27;This is a &lt;b&gt;QWidget&lt;/b&gt; widget&#x27;) btn.resize(btn.sizeHint())#sizeHint()会自动给定一个合适的尺寸 btn.move(50, 50) self.setGeometry(300, 300, 300, 200) #setGeometry()把窗口放到屏幕上并且设置窗口大小，4个参数分别代表屏幕坐标的x、y和窗口大小的宽、高。 self.setWindowTitle(&#x27;Tooltips&#x27;) #设置标题 self.show()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 关闭窗口12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例4：关闭窗口ZetCode PyQt5 tutorial This program creates a quitbutton. When we press the button,the application terminates. Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom PyQt5.QtWidgets import QWidget, QPushButton, QApplicationfrom PyQt5.QtCore import QCoreApplication#程序需要QtCore对象class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): qbtn = QPushButton(text=&#x27;Quit&#x27;, parent=self) #创建一个继承自QPushButton的按钮。第一个参数text参数是想要显示的按钮名称，第二个参数parent是按钮的父级组件 #创建了一个点击之后就退出窗口的按钮。 qbtn.clicked.connect(QCoreApplication.instance().quit) &#x27;&#x27;&#x27; 事件传递系统在PyQt5内建的single（信号）和slot（槽）机制里面。 点击按钮之后，信号会被捕捉并给出既定的反应。 QCoreApplication包含了事件的主循环，它能添加和删除所有的事件，instance()创建了一个它的实例。 QCoreApplication是在QApplication里创建的。 点击事件和能终止进程并退出应用的quit函数绑定在了一起。 在发送者和接受者之间建立了通讯，发送者就是按钮，接受者就是应用对象。 QpushButton常用的三种响应有pressed，released和clicked 在Qt中，控件中的clicked（）信号和clicked（bool）信号是两个不同的信号，区别在于： 映射槽函数时，clicked（）信号映射到的槽函数是不带参的，clicked（bool）信号映射到的槽函数是带参数的。 &#x27;&#x27;&#x27; qbtn.resize(qbtn.sizeHint()) qbtn.move(50, 50) self.setGeometry(300, 300, 250, 150) self.setWindowTitle(&#x27;Quit button&#x27;) self.show()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 消息盒子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例5 消息盒子ZetCode PyQt5 tutorial This program shows a confirmation message box when we click on the closebutton of the application window. Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom PyQt5.QtWidgets import QWidget, QMessageBox, QApplicationclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setGeometry(300, 300, 250, 150) self.setWindowTitle(&#x27;Message box&#x27;) self.show() &#x27;&#x27;&#x27; QWidget在程序窗口关闭时会触发 closeEvent() 事件 因此我们这里药重写窗口方法closeEvent,添加关闭窗口触发的事件 &#x27;&#x27;&#x27; def closeEvent(self, event): reply = QMessageBox.question(self, &#x27;Message&#x27;, &quot;Are you sure to quit?&quot;, QMessageBox.Yes | QMessageBox.No, QMessageBox.No) &#x27;&#x27;&#x27; 创建了一个消息框，上面有俩按钮：Yes和No.第一个字符串显示在消息框的标题栏，第二个字符串显示在对话框，第三个参数是消息框的俩按钮，最后一个参数是默认按钮，这个按钮是默认选中的。返回值在变量reply里。 &#x27;&#x27;&#x27; if reply == QMessageBox.Yes: event.accept() else: event.ignore() &#x27;&#x27;&#x27; 关闭QWidget，就会产生一个QCloseEvent，并且把它传入到closeEvent函数的event参数中。 改变控件的默认行为，就是替换掉默认的事件处理。 &#x27;&#x27;&#x27; if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 窗口居中1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例6：窗口居中ZetCode PyQt5 tutorial This program centers a window on the screen. Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom PyQt5.QtWidgets import QWidget, QDesktopWidget, QApplicationclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.resize(250, 150) self.center() self.setWindowTitle(&#x27;Center&#x27;) self.show() def center(self): qr = self.frameGeometry() #这一句获得主窗口所在的框架，其中QtGui.QDesktopWidget提供了用户的桌面信息，包括屏幕的大小。 cp = QDesktopWidget().availableGeometry().center() #获取显示器的分辨率，然后得到屏幕中间点的位置。 qr.moveCenter(cp) #通过move函数把主窗口的左上角移动到其框架的左上角，实现窗口居中 self.move(qr.topLeft())if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) References","categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"},{"name":"Python3","slug":"Programming-languages-and-projects/Python3","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"},{"name":"PYQT5","slug":"Programming-languages-and-projects/Python3/PYQT5","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/PYQT5/"}],"tags":[{"name":"python3","slug":"python3","permalink":"http://justskim.github.io/tags/python3/"},{"name":"gui","slug":"gui","permalink":"http://justskim.github.io/tags/gui/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-08-29T14:29:42.425Z","updated":"2021-08-29T14:29:42.426Z","comments":true,"path":"2021/08/29/hello-world/","link":"","permalink":"http://justskim.github.io/2021/08/29/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Diary","slug":"Diary","permalink":"http://justskim.github.io/categories/Diary/"},{"name":"life","slug":"Diary/life","permalink":"http://justskim.github.io/categories/Diary/life/"}],"tags":[{"name":"llife","slug":"llife","permalink":"http://justskim.github.io/tags/llife/"}]},{"title":"Your first md","slug":"first","date":"2021-08-29T14:29:42.424Z","updated":"2021-08-29T14:29:42.424Z","comments":true,"path":"2021/08/29/first/","link":"","permalink":"http://justskim.github.io/2021/08/29/first/","excerpt":"","text":"light single page blog application theme, using Vue, Vuex, ElementUI and so on. 第一个使用的主题是一款基于Vue, Vuex 和 ElementUI 构建的轻量单页博客主题 Live DemoDemo | 在线演示 Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"typora中的锚点与引用","slug":"Reference","date":"2021-08-29T14:29:42.424Z","updated":"2021-09-02T23:48:45.283Z","comments":true,"path":"2021/08/29/Reference/","link":"","permalink":"http://justskim.github.io/2021/08/29/Reference/","excerpt":"","text":"在markdown编辑器Typora中使用锚点与引用点击链接，打开网页，跳转相关url在之前写博客的时候，一直被引用参考文献的问题所困扰，Markdown官方语法教程相关页面中给对于引用和链接跳转出了以下的方法， 引用类型链接引用样式链接是一种特殊的链接，它使URL在Markdown中更易于显示和阅读。参考样式链接分为两部分：与文本保持内联的部分以及存储在文件中其他位置的部分，以使文本易于阅读。 # 链接的第一部分格式引用类型的链接的第一部分使用两组括号进行格式设置。第一组方括号包围应显示为链接的文本。第二组括号显示了一个标签，该标签用于指向您存储在文档其他位置的链接。 尽管不是必需的，可以在第一组和第二组括号之间包含一个空格。第二组括号中的标签不区分大小写，可以包含字母，数字，空格或标点符号。 以下示例格式对于链接的第一部分效果相同： [hobbit-hole][1] [hobbit-hole] [1] # 链接的第二部分格式引用类型链接的第二部分使用以下属性设置格式： 放在括号中的标签，其后紧跟一个冒号和至少一个空格（例如[label]:）。 链接的URL，可以选择将其括在尖括号中。 链接的可选标题，可以将其括在双引号，单引号或括号中。 以下示例格式对于链接的第二部分效果相同： [1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle [1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle &quot;Hobbit lifestyles&quot; [1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle &#39;Hobbit lifestyles&#39; [1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle (Hobbit lifestyles) [1]: &lt;https://en.wikipedia.org/wiki/Hobbit#Lifestyle&gt; &quot;Hobbit lifestyles&quot; [1]: &lt;https://en.wikipedia.org/wiki/Hobbit#Lifestyle&gt; &#39;Hobbit lifestyles&#39; [1]: &lt;https://en.wikipedia.org/wiki/Hobbit#Lifestyle&gt; (Hobbit lifestyles) 可以将链接的第二部分放在Markdown文档中的任何位置。有些人将它们放在出现的段落之后，有些人则将它们放在文档的末尾（例如尾注或脚注）。 此处被“ctrl+鼠标左键”点击后，调用浏览器跳转至百度首页 点击此处不能实现跳转 References注意参考文献reference是可数名词 这种方式适合于带有链接的参考文献，如果想在点击链接后，跳转至markdown文件末尾的脚注中（再进一步决定是否跳转脚注指向的参考文献中的url链接），我们需要采用下面的办法。 实现页内跳转页内跳转：从一篇文章的一个地方（锚点）跳到该篇文章的另一个地方（页内链接） 一些网上资料中，介绍这样一种markdown文档中实现页面内部跳转的方式： 先定义要跳转的锚点——这一部分放在我们的正文中 &lt;span id=&quot;your_anchor&quot;&gt;在别处点击后，您要跳转到此锚点处&lt;/span&gt; 然后是定义链接（点击后跳转到对应的锚点）——这一部分通常放在末尾作为参考文献[锚点]（#your_anchor） 但实际上，在markdown编辑器typora中，这个方式存在缺陷，具体原因为：需要使用a标签而不能为其他标签，诸如span，div等，比如下面的例子： a标签中的文本，“ctrl+左键”可以跳转到锚点 在这一个链接中，a标签被嵌套于一个div标签中，也可以跳转到与上面链接一样关联的锚点。同时我们通过设置a标签的style属性来去除此链接的下划线 这一个span标签中的链接就没办法跳转了 Typora官方文档的此页面中给出了a标签在这种情况下的使用方法： HTML &lt;a&gt; tagYou could also use raw HTML to add links, for example 12345&lt;a href=&quot;http://www.google.com&quot; target=&quot;__blank&quot;&gt;Link to Google&lt;/a&gt;&lt;a name=&quot;anchor&quot;&gt;&lt;/a&gt; Anchor&lt;a href=&quot;#anchor&quot;&gt;Link to Anchor&lt;/a&gt; For link towards a website, we suggest you DO NOT ommit URL protocols like https:// or http://, or it may be interpreted as relative link by Typora or other Markdown egines, or after export&#x2F;publish. 这里是我们预先定义的锚点 注意，以上这几种方式只能实现单向跳转。如果想要实现word编辑论文中，参考文献式的双向跳转，需要参照markdown官方教程中的脚注语法^1： 脚注使您可以添加注释和参考，而不会使文档正文混乱。当您创建脚注时，带有脚注的上标数字会出现在您添加脚注参考的位置。读者可以单击链接（在typora编辑器中为”ctrl+左键”）以跳至页面底部的脚注内容。 要创建脚注参考，请在方括号（[^1]）内添加插入符号和标识符。标识符可以是数字或单词，但不能包含空格或制表符。标识符仅将脚注参考与脚注本身相关联-在输出中，脚注按顺序编号。 在括号内使用另一个插入符号和数字添加脚注，并用冒号和文本（[^1]: My footnote.）。您不必在文档末尾添加脚注。您可以将它们放在除列表，块引号和表之类的其他元素之外的任何位置。 1234567891011Here&#x27;s a simple footnote,[^1] and here&#x27;s a longer one.[^bignote][^1]: This is the first footnote.[^bignote]: Here&#x27;s one with multiple paragraphs and code. Indent paragraphs to include them in the footnote. `&#123; my code &#125;` Add as many paragraphs as you like. 呈现的输出如下所示： Here’s a simple footnote,^1 and here’s a longer one.[^bignote] ^1: This is the first footnote.[^bignote]: Here’s one with multiple paragraphs and code. 注意，这里末尾的参考文献中，编号为1的脚注之所以有两个箭头指向链接，是因为我们在本篇博客中使用了两个同名为“1”的链接，我们可以从这里看出，脚注具有顺序性。 一个值得注意的点 编写作为锚点的位于末尾的参考文献时，如果要附上url链接，格式写作如下形式： 1[^anchor]: [文章标题](url) 其中，不仅第二个方括号和冒号之间要空一格，由于**[文本](url)**是markdown的一种链接语法，为了让参考文献也拥有向url跳转的箭头功能，需要在(url)后空一格，箭头才能显现，否则就无法实现双向的跳转。 Reference","categories":[{"name":"MarkDown","slug":"MarkDown","permalink":"http://justskim.github.io/categories/MarkDown/"},{"name":"typora的特殊使用","slug":"MarkDown/typora的特殊使用","permalink":"http://justskim.github.io/categories/MarkDown/typora%E7%9A%84%E7%89%B9%E6%AE%8A%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://justskim.github.io/tags/markdown/"},{"name":"typora","slug":"typora","permalink":"http://justskim.github.io/tags/typora/"}]},{"title":"PYQT5介绍","slug":"PYQT5介绍","date":"2021-08-29T14:29:42.423Z","updated":"2021-08-29T14:29:42.423Z","comments":true,"path":"2021/08/29/PYQT5介绍/","link":"","permalink":"http://justskim.github.io/2021/08/29/PYQT5%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"PYQT5介绍PyQt5 是Digia的一套Qt5应用框架与python的结合，同时支持2.x和3.x。Qt库由Riverbank Computing开发，是最强大的GUI库之一 ，官方网站：https://riverbankcomputing.com/PyQt5是由一系列Python模块组成。超过620个类，6000函数和方法。能在诸如Unix、Windows和Mac OS等主流操作系统上运行。PyQt5有两种证书，GPL和商业证书。 PYQT和QTPyQt的介绍，以及其与Qt的不同，可见官网此页 Qt是一组c++库和开发工具，包括图形用户界面，网络，线程，正则表达式，SQL数据库，SVG, OpenGL, XML，用户和应用程序设置，定位和定位服务，短程通信(NFC和蓝牙)，web浏览，3D动画，图表、3D数据可视化以及与应用商店的交互。PyQt5作为一组Python模块实现了超过1000个这样的类。 PyQt5是一组来自Qt公司的用于Qt应用程序框架v5的Python绑定，由PyQt5本身和许多与Qt的附加库相对应的附加组件组成。每一个都提供了一个源代码发行版(sdist)和用于Windows、Linux和macOS的二进制轮。PyQt5支持Windows、Linux、UNIX、Android、macOS和iOS平台，需要Python v3.5或更高版本。(PyQt5还应该使用遗留的configure.py构建脚本在Python v2.7和Python v3的早期版本上构建，但这是不支持的。) PYQT的类别Pyqt的类别分为以下几个模块： QtCore:包含了核心的非GUI功能。此模块用于处理时间、文件和目录、各种数据类型、流、URL、MIME类型、线程或进程。 QtGui包含类窗口系统集成、事件处理、二维图形、基本成像、字体和文本。 QtWidgets模块包含创造经典桌面风格的用户界面提供了一套UI元素的类。 QtMultimedia包含的类来处理多媒体内容和API来访问相机和收音机的功能。 Qtbluetooth模块包含类的扫描设备和连接并与他们互动。描述模块包含了网络编程的类。这些类便于TCP和IP和UDP客户端和服务器的编码，使网络编程更容易和更便携。 Qtpositioning包含类的利用各种可能的来源，确定位置，包括卫星、Wi-Fi、或一个文本文件。 Enginio模块实现了客户端库访问Qt云服务托管的应用程序运行时。 Qtwebsockets模块包含实现WebSocket协议类。 QtWebKit包含一个基于Webkit2图书馆Web浏览器实现类。 QtWebkitwidgets包含的类的基础webkit1一用于qtwidgets应用Web浏览器的实现。 QtXml包含与XML文件的类。这个模块为SAX和DOM API提供了实现。 QtSvg模块提供了显示SVG文件内容的类。可伸缩矢量图形（SVG）是一种描述二维图形和图形应用的语言。 QtSql模块提供操作数据库的类。 QtTest包含的功能，使pyqt5应用程序的单元测试 Pyqt5与Pyside2这里有一篇英文文章讲述了这两个package之间的区别。简单地说，Pyqt的使用历史比较长，目前中文方面的资料也比较多，Pyside是后续由原先参与Pyqt项目的公司推出的，二者在使用协议方面由不同。在文档方面，Pyqt5与Pyside2大部分函数的构造都相同，详情可见以下网址：PyQt5官方文档Pyside2官方文档 安装与配置12345pip install pyqt5#使用pip下载该packagepip install pyqt5-tools#由于Qt Designer已经在Python3.5版本从PyQt5转移到了tools，因此我们还需要安装pyqt5-tools 验证是否成功安装qt designer是PyQt程序UI界面的实现工具，使用Qt Designer可以拖拽、点击完成GUI界面设计，并且设计完成的.ui程序可以转换成.py文件供python程序调用。Qt Designer的设计符合MVC的架构，其实现了视图和逻辑的分离，从而实现了开发的便捷。Qt Designer中的操作方式十分灵活，其通过拖拽的方式放置控件可以随时查看控件效果。Qt Designer生成的.ui文件（实质上是XML格式的文件）也可以通过pyuic5工具转换成.py文件。 同时按下win+s键，在cornata 中输入designer，可以定位到qt designer程序的地址，成功启动该程序，则说明PyQt5已经被安装。 另一种方法：在控制台中输入pyuic5，若返回信息为：Error: one input ui-file must be specified，说明 PyQt5已经被成功安装。","categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"},{"name":"Python3","slug":"Programming-languages-and-projects/Python3","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"},{"name":"PYQT5","slug":"Programming-languages-and-projects/Python3/PYQT5","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/PYQT5/"}],"tags":[{"name":"python3","slug":"python3","permalink":"http://justskim.github.io/tags/python3/"},{"name":"gui","slug":"gui","permalink":"http://justskim.github.io/tags/gui/"}]}],"categories":[{"name":"网络","slug":"网络","permalink":"http://justskim.github.io/categories/%E7%BD%91%E7%BB%9C/"},{"name":"Mysql","slug":"Mysql","permalink":"http://justskim.github.io/categories/Mysql/"},{"name":"安装","slug":"Mysql/安装","permalink":"http://justskim.github.io/categories/Mysql/%E5%AE%89%E8%A3%85/"},{"name":"服务器","slug":"网络/服务器","permalink":"http://justskim.github.io/categories/%E7%BD%91%E7%BB%9C/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Linux","slug":"Linux","permalink":"http://justskim.github.io/categories/Linux/"},{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"},{"name":"Python3","slug":"Programming-languages-and-projects/Python3","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"},{"name":"JavaScript","slug":"Programming-languages-and-projects/JavaScript","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/JavaScript/"},{"name":"Vue","slug":"Programming-languages-and-projects/JavaScript/Vue","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/JavaScript/Vue/"},{"name":"Git","slug":"Git","permalink":"http://justskim.github.io/categories/Git/"},{"name":"Github","slug":"Git/Github","permalink":"http://justskim.github.io/categories/Git/Github/"},{"name":"Data analysis","slug":"Data-analysis","permalink":"http://justskim.github.io/categories/Data-analysis/"},{"name":"web","slug":"Programming-languages-and-projects/JavaScript/web","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/JavaScript/web/"},{"name":"MarkDown","slug":"MarkDown","permalink":"http://justskim.github.io/categories/MarkDown/"},{"name":"typora的特殊使用","slug":"MarkDown/typora的特殊使用","permalink":"http://justskim.github.io/categories/MarkDown/typora%E7%9A%84%E7%89%B9%E6%AE%8A%E4%BD%BF%E7%94%A8/"},{"name":"Nodejs","slug":"Programming-languages-and-projects/JavaScript/Nodejs","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/JavaScript/Nodejs/"},{"name":"Git报错处理","slug":"Git/Git报错处理","permalink":"http://justskim.github.io/categories/Git/Git%E6%8A%A5%E9%94%99%E5%A4%84%E7%90%86/"},{"name":"PYQT5","slug":"Programming-languages-and-projects/Python3/PYQT5","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/PYQT5/"},{"name":"Diary","slug":"Diary","permalink":"http://justskim.github.io/categories/Diary/"},{"name":"life","slug":"Diary/life","permalink":"http://justskim.github.io/categories/Diary/life/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://justskim.github.io/tags/%E7%BD%91%E7%BB%9C/"},{"name":"nginx","slug":"nginx","permalink":"http://justskim.github.io/tags/nginx/"},{"name":"apache","slug":"apache","permalink":"http://justskim.github.io/tags/apache/"},{"name":"mysql","slug":"mysql","permalink":"http://justskim.github.io/tags/mysql/"},{"name":"服务器","slug":"服务器","permalink":"http://justskim.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"linux","slug":"linux","permalink":"http://justskim.github.io/tags/linux/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://justskim.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://justskim.github.io/tags/ubuntu/"},{"name":"vmware","slug":"vmware","permalink":"http://justskim.github.io/tags/vmware/"},{"name":"python3","slug":"python3","permalink":"http://justskim.github.io/tags/python3/"},{"name":"anaconda","slug":"anaconda","permalink":"http://justskim.github.io/tags/anaconda/"},{"name":"c语言","slug":"c语言","permalink":"http://justskim.github.io/tags/c%E8%AF%AD%E8%A8%80/"},{"name":"进程","slug":"进程","permalink":"http://justskim.github.io/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"vue","slug":"vue","permalink":"http://justskim.github.io/tags/vue/"},{"name":"vue-cli","slug":"vue-cli","permalink":"http://justskim.github.io/tags/vue-cli/"},{"name":"webpack","slug":"webpack","permalink":"http://justskim.github.io/tags/webpack/"},{"name":"store","slug":"store","permalink":"http://justskim.github.io/tags/store/"},{"name":"router","slug":"router","permalink":"http://justskim.github.io/tags/router/"},{"name":"安全证书","slug":"安全证书","permalink":"http://justskim.github.io/tags/%E5%AE%89%E5%85%A8%E8%AF%81%E4%B9%A6/"},{"name":"数据分析","slug":"数据分析","permalink":"http://justskim.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"python","slug":"python","permalink":"http://justskim.github.io/tags/python/"},{"name":"debug","slug":"debug","permalink":"http://justskim.github.io/tags/debug/"},{"name":"package","slug":"package","permalink":"http://justskim.github.io/tags/package/"},{"name":"scipy","slug":"scipy","permalink":"http://justskim.github.io/tags/scipy/"},{"name":"browser","slug":"browser","permalink":"http://justskim.github.io/tags/browser/"},{"name":"web","slug":"web","permalink":"http://justskim.github.io/tags/web/"},{"name":"markdown","slug":"markdown","permalink":"http://justskim.github.io/tags/markdown/"},{"name":"typora","slug":"typora","permalink":"http://justskim.github.io/tags/typora/"},{"name":"hexo","slug":"hexo","permalink":"http://justskim.github.io/tags/hexo/"},{"name":"数据存储","slug":"数据存储","permalink":"http://justskim.github.io/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"},{"name":"ejs","slug":"ejs","permalink":"http://justskim.github.io/tags/ejs/"},{"name":"express","slug":"express","permalink":"http://justskim.github.io/tags/express/"},{"name":"nodejs","slug":"nodejs","permalink":"http://justskim.github.io/tags/nodejs/"},{"name":"git","slug":"git","permalink":"http://justskim.github.io/tags/git/"},{"name":"http","slug":"http","permalink":"http://justskim.github.io/tags/http/"},{"name":"gui","slug":"gui","permalink":"http://justskim.github.io/tags/gui/"},{"name":"llife","slug":"llife","permalink":"http://justskim.github.io/tags/llife/"}]}