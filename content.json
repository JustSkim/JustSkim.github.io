{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://JustSkim.github.io","root":"/"},"pages":[{"title":"About me and this blog","date":"2021-08-28T00:28:35.000Z","updated":"2021-08-31T05:21:26.498Z","comments":true,"path":"about/index.html","permalink":"http://justskim.github.io/about/index.html","excerpt":"","text":"Hi~，你可以在这里看到我在此分享的一些的笔记总结，有什么有趣的事情也记得与我分享哦φ(．．) 写作业ing… 关于hexo命令的操作可以见 https://hexo.io/zh-cn/docs/commands简单地说，命令hexo g &amp;&amp; hexo s 可以方便我们在本地4000端口上查看博客效果使用命令hexo d可以将我们生成的.deploy_git文件夹推送到仓库上注意，hexo博客部署到github上名为username.github.io的仓库上，实际上是只推送.deploy_git中的文件而不是对整个项目使用push！建议每次编辑完成之后，使用hexo g &amp;&amp; hexo s先在本地查看效果，并生成相关文件再使用命令hexo d部署到Github上"},{"title":"tags","date":"2022-02-16T05:20:25.000Z","updated":"2022-02-16T05:25:53.976Z","comments":true,"path":"tags/index.html","permalink":"http://justskim.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-08-28T00:29:33.000Z","updated":"2021-08-29T14:29:42.427Z","comments":true,"path":"categories/index.html","permalink":"http://justskim.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Linux系统下的make编译和CMake","slug":"Linux系统下的make编译和CMake","date":"2022-04-29T10:14:31.675Z","updated":"2022-05-06T03:22:21.506Z","comments":true,"path":"2022/04/29/Linux系统下的make编译和CMake/","link":"","permalink":"http://justskim.github.io/2022/04/29/Linux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%9A%84make%E7%BC%96%E8%AF%91%E5%92%8CCMake/","excerpt":"","text":"起因博主在读论文”Hashedcubes: Simple, Low Memory, Real-Time Visual Exploration of Big Data”的时候，在末尾找到作者的源代码公开链接https://github.com/cicerolp/hashedcubes，在Centos 7系统上git clone代码后，按照作者README.md中的教程，无法正确地部署，产生报错。 原因Centos 7 系统中预装的gcc和g++版本都为较低的4.8，在编译时需要换用更高版本以上的gcc， 具体可以参见网上相关gcc版本升级的文章。 在升级之后，可以使用命令gcc --version来查看gcc编译器的版本。 如果在编译过程中，仍然提示-c++:std=14的报错，那么可能是编译时候使用的gcc-c++还是预装的4.8版本，可以在CMakeLists.txt文件的开头加上这么两句，来使用指定位置的gcc编译器： 12set(CMAKE_C_COMPLIER &quot;/usr/bin/gcc&quot;)set(CMAKE_CXX_COMPLIER &quot;/usr/bin/g++&quot;) boost的下载与安装cmake与CMakeList.txt文件","categories":[{"name":"Linux","slug":"Linux","permalink":"http://justskim.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://justskim.github.io/tags/linux/"}]},{"title":"Maven项目中JSP文件引用的静态资源无法加载问题","slug":"Maven项目中JSP文件引用的静态资源无法加载问题","date":"2022-04-13T15:17:24.517Z","updated":"2022-04-13T15:56:40.145Z","comments":true,"path":"2022/04/13/Maven项目中JSP文件引用的静态资源无法加载问题/","link":"","permalink":"http://justskim.github.io/2022/04/13/Maven%E9%A1%B9%E7%9B%AE%E4%B8%ADJSP%E6%96%87%E4%BB%B6%E5%BC%95%E7%94%A8%E7%9A%84%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E9%97%AE%E9%A2%98/","excerpt":"","text":"起因不使用框架，直接建造一个maven项目，并新建error和img等文件目录用于存放特定的jsp文件和图片。在500.jsp文件中引入一张图片，代码：&lt;img src=&quot;../img/500.jpg&quot;/&gt;，项目的文件结构为： 打开浏览器，在相关页面中可以看到图片未能正常显示，报错404： 排查问题步骤 将静态资源所在的文件夹标记为资源文件； 检查target文件夹和out文件夹中是否存在相关文件，如果无则更新资源或者重新部署； 重新部署或者重新更新服务器。 以上步骤都没有用，博主返回到软件中查看tomcat服务器设置，发现自己在tomcat服务器配置中的应用程序上下文 Application context，被默认设置为http://localhost:8080/javaweb_jsp_war_exploded/，因此，在导入静态资源的时候，也应当把项目路径加上，正确的写法为： 1&lt;img src=&quot;/javaweb_jsp_war_exploded/img/500.jpg&quot;/&gt; 注意我们修改了tomcat的配置，因此需要选择重启服务器来使新的配置生效。如果我们想要使用原来默认的jsp文件相对路径引入静态资源写法：&lt;img src=&quot;../img/500.jpg&quot;/&gt;，则在tomcat中修改应用程序上下文为：http://localhost:8080/即可，但不推荐这种方式，特别是在同时部署多个模块的时候。注意，要修改tomcat配置中 “deployment”下的“Application context”选项而不是URL项，URL项只是打开浏览器时使用的路径：![tomcat服务器中的Application context](&#x2F;images&#x2F;tomcat服务器中的Application context.PNG) 我们也可以使用绝对路径的方式引入静态资源：&lt;img src=&quot;$&#123;pageContext.request.contextPath&#125;/img/500.jpg&quot;/&gt;","categories":[{"name":"Java","slug":"Java","permalink":"http://justskim.github.io/categories/Java/"},{"name":"Maven","slug":"Java/Maven","permalink":"http://justskim.github.io/categories/Java/Maven/"}],"tags":[{"name":"java","slug":"java","permalink":"http://justskim.github.io/tags/java/"},{"name":"tomcat","slug":"tomcat","permalink":"http://justskim.github.io/tags/tomcat/"},{"name":"servlet","slug":"servlet","permalink":"http://justskim.github.io/tags/servlet/"},{"name":"maven","slug":"maven","permalink":"http://justskim.github.io/tags/maven/"},{"name":"IDEA","slug":"IDEA","permalink":"http://justskim.github.io/tags/IDEA/"}]},{"title":"IDEA中Maven项目的打包与tomcat服务器运行","slug":"IDEA中Maven项目的打包与tomcat服务器运行","date":"2022-04-12T11:06:52.334Z","updated":"2022-04-13T16:14:45.665Z","comments":true,"path":"2022/04/12/IDEA中Maven项目的打包与tomcat服务器运行/","link":"","permalink":"http://justskim.github.io/2022/04/12/IDEA%E4%B8%ADMaven%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%89%93%E5%8C%85%E4%B8%8Etomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E8%A1%8C/","excerpt":"","text":"起因以及解决方案在学习狂神说 Java web中的servlet项目时，学到第15课 javaweb的应用时，想跳转到的项目的发布路径一直显示404，页面的报错信息为： 12345HTTP Status 404 – Not FoundType Status ReportMessage 文.件[/request_war_exploded/success.jsp] 未找到Description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists.Apache Tomcat/9.0.62 经过多次检查代码，并没有发现错误的地方，最后发现是模块打包的target文件夹下，并没有success.jsp文件，即使多次重启或者重新部署tomcat服务器后依然未能解决该问题： 手动将success.jsp文件复制粘贴到打包的request文件夹下，问题解决！ maven项目打包机制与target文件夹maven项目创建完后，要打包并部署到服务器上。 Java打包Java中两种项目打包的格式：jar 包和 war包。 jar包，将项目看成一整个拼图，引入的每个jar包就是一个拼块，在依赖中经常使用，向项目中添加某些依赖就是下载相应的 jar 包添加到项目中。jar包中只是用java来写的项目打包来的，里面只有编译后的class和一些部署文件。 war包，在 Java web中通常都是将项目打包成war包再进行部署——这是因为war包不仅包含代码编译成的class文件，还有依赖的包、配置文件，以及包括html，jsp等等在内的资源文件。一个war包可以理解为一个web项目，里面有项目的所有东西。pom.xml文件中可以规定打包的相关要求，比如&lt;packaging&gt;war&lt;/packaging&gt;会要求打包成war格式包。 maven常用打包命令： mvn compile 编译,将Java 源程序编译成 class 字节码文件。 mvn test 测试，并生成测试报告 mvn clean 将以前编译得到的旧的 class 字节码文件删除 mvn pakage 打包,动态 web工程打 war包，Java工程打 jar 包。 mvn install 将项目生成 jar 包放在仓库中，以便别的模块调用 mvn clean install -Dmaven.test.skip=true 打成jar包，并且抛弃测试用例打包 mvn clean pakage -Dmaven.test.skip=true 动态 web工程打 war包，Java工程打 jar 包 ，并且抛弃测试用例打包 target文件夹是用来存放maven项目构建时生成的文件和目录、jar包、war包、编译的class文件 热加载和热部署热加载(Hot Reload)：实现方式是 Web 容器（Context组件）启动一个后台线程，定期检测类文件的变化，如果有变化，就重新加载类，即在运行时重新加载class。在这个过程中不会清空 Session，不安全，一般用在开发环境。Tomcat默认情况下不开启热加载功能，包括博主所用的tomcat 9 版本。如果需要用到热加载功能，则要在Tomcat安装路径下的 Context.xml文件中配置 reloadable 参数来开启。 **热部署(Hot Swap)**：原理类似，也由后台线程定时检测 Web 应用的变化，但会重新加载整个 Web 应用。这种方式会清空Session，比热加载更加干净、彻底，一般用在生产环境。本质区别：热加载的粒度比较小，主要是针对类文件的更新，通过创建新的类加载器来实现重新加载。而热部署是针对整个 Web应用的，重新部署 Web 应用，服务器如Tomcat，会将原来的 Context 对象（包括其所关联的一切资源，比如Session）整个销毁掉，再重新创建 Context 容器对象。相同的目的：在不重启 Tomcat 的情况下实现 Web 应用的更新。 tomcat服务器上的重启与热加载、重新部署IDEA的官方文档中介绍了tomcat服务器更新的四个选项区别所在： 更新资源 Update resources：更新所有更改的资源，例如 HTML、JSP、JavaScript、CSS 和图像； 更新类和资源 Update classes and resources：更新所有更改的资源并重新编译所有更改的 Java 类（EJB、servlet） 等； 以上两者都是热部署——在不重启tomcat服务器的前提下，将自己的项目部署到tomcat服务器中。 重新部署 redeploy：把当前的一个项目重新部署到Tomcat服务器上； 重启服务器 restart：在重新部署的基础上，对Tomcat的相关配置文件进行刷新。在tomcat为debug 模式下，修改当前正在用的类的定义（包括：类名，方法，方法名称，参数等等……），需要重启tomcat 因此，如果我们项目处于开发模式（即我们在之前的博客中讲到的 war exploded部署方式）下，如果只是修改了已有的JSP文件或者其他资源文件，采用第一个选项即可（无论tomcat处于运行模式还是调试模式）；如果修改了java代码，需要更新class类文件，且tomcat处于调试模式下，那么我们**可以选择第二个选项Update classes and resources**，处于运行模式下的tomcat服务器无法更新java程序，只能更新已有的被修改的资源文件。 但是注意以上两个方式，只能用于更新已经被部署到tomcat服务器上的资源和类文件，无论tomcat处于运行状态还是debug状态，对于我们新建的资源&#x2F;类文件都必须重新打包部署！使用“更新类和资源”操作，虽然可以在target文件夹中看到新建的资源文件和class类，但因为没有被部署到tomcat服务器上，会报告404的http转换码。同时，上述两个操作也无法应用于删除类文件或资源的情形，在项目中删除相关文件后，必须使用重新部署的方式，才能删除target包中的对应文件。 对于我们新建的文件，又或者是处于生产模式下，就需要采用 redeploy 方式重新部署了；若我们修改了tomcat服务器的相关配置，则应选择最后一个选项将服务器重启。 在前面我们说道，web.xml文件并非每个java web工程都必须的，但web.xml文件会被用于servlet程序等一系列配置，因此如果我们更新了web.xml文件，无论tomcat处于运行还是调试模式，更新类和资源操作都无法使web.xml中修改的配置生效，必须重新部署才行。","categories":[{"name":"Java","slug":"Java","permalink":"http://justskim.github.io/categories/Java/"},{"name":"Maven","slug":"Java/Maven","permalink":"http://justskim.github.io/categories/Java/Maven/"}],"tags":[{"name":"java","slug":"java","permalink":"http://justskim.github.io/tags/java/"},{"name":"tomcat","slug":"tomcat","permalink":"http://justskim.github.io/tags/tomcat/"},{"name":"servlet","slug":"servlet","permalink":"http://justskim.github.io/tags/servlet/"},{"name":"maven","slug":"maven","permalink":"http://justskim.github.io/tags/maven/"},{"name":"IDEA","slug":"IDEA","permalink":"http://justskim.github.io/tags/IDEA/"}]},{"title":"Python中graphviz包的安装与bug解决","slug":"Python中graphviz模块的安装与bug解决","date":"2022-04-12T03:33:44.869Z","updated":"2022-04-12T07:07:14.990Z","comments":true,"path":"2022/04/12/Python中graphviz模块的安装与bug解决/","link":"","permalink":"http://justskim.github.io/2022/04/12/Python%E4%B8%ADgraphviz%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8Ebug%E8%A7%A3%E5%86%B3/","excerpt":"","text":"问题描述按照学校课程要求，配合scikit-learn官方文档，学习机器学习的过程中，在决策树这一章，安装graphviz模块后运行程序产生报错： 1AttributeError: module &#x27;graphviz.backend&#x27; has no attribute &#x27;ENCODING&#x27; Graphviz是一款自动排版的绘图软件，而python graphviz则是该软件在python的实现，graphviz模块提供了Graph和Digraph两个类，分别以DOT语言为无向图和有向图创建图描述。 解决方案搜索该问题解决方案，相关中文博客中给出的以下两个解决方案： 下载模块python-graphviz； 本地下载安装graphviz软件，在系统变量中配置环境变量GRAPHVIZ_INSTALL_DIR（路径为bin文件夹）和GRAPHVIZ_DOT（路径为bin文件夹下的dot.exe程序），在用户变量中也要配置GRAPHVIZ_INSTALL_DIR，然后重启计算机； 但是经过以上尝试过后，该问题依旧没有解决，最后在stackoverflow上的相关问题中，发现问题的根源在于graphviz的版本，并摸索出了相关的解决方案： 使用命令conda uninstall graphviz后，还要将本地环境下的两个文件夹graphviz和graphviz-0.19.2.dist-info删除，否则使用第二步的命令时会被提示已安装； 使用命令pip install graphviz=0.19.2 下载符合要求的包； 在程序中，加入这么两句代码，添加路径： 12import osos.environ[&quot;PATH&quot;]+=os.pathsep+&quot;E:/download/Graphviz/bin&quot;","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://justskim.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"python","slug":"python","permalink":"http://justskim.github.io/tags/python/"},{"name":"machine learning","slug":"machine-learning","permalink":"http://justskim.github.io/tags/machine-learning/"}]},{"title":"IDEA中maven项目无法自动导入包的问题解决","slug":"IDEA中maven项目无法自动导入包的问题解决","date":"2022-04-09T08:50:55.411Z","updated":"2022-04-13T11:06:09.830Z","comments":true,"path":"2022/04/09/IDEA中maven项目无法自动导入包的问题解决/","link":"","permalink":"http://justskim.github.io/2022/04/09/IDEA%E4%B8%ADmaven%E9%A1%B9%E7%9B%AE%E6%97%A0%E6%B3%95%E8%87%AA%E5%8A%A8%E5%AF%BC%E5%85%A5%E5%8C%85%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/","excerpt":"","text":"问题描述在IDEA中创建项目工程后（父工程的src文件夹可以在创建后删除），再选择“module”创建子工程，发现无法自动导入依赖，具体表现为“HttpServlet”等不是java jdk自带的包会在代码中爆红，即使在pom.xml文件中按要求添加了相关依赖，也无法解决问题。按照网上教程所说的有以下方法： 在settings中设置maven相关项 点击“文件”-&gt; “清除缓存”； 点击界面最右边一侧的“maven”设置，clean后install，或者点击项目菜单中的“reimport”选项 以上做法均失效（对于引入jdk自带的包，比如java.lang中的包，可以采用上边的方式让其自动引入）。 排查问题查看父工程的外部库External libaries可以发现，其中只有jdk11自带的包，而没有出现我们需要引入的依赖包，成功引入的界面应该是长下面这样： 重新新建一个项目来探究问题所在，发现在选择骨架创建子工程后，下方maven控制台的运行中，会出现一项org.apache.maven.plugins:maven-archetype-plugin:RELEASE:generate一直处于加载的状态！有时候甚至加载了十分钟依然未能成功！ 这是因为子项目使用骨架创建时，需要从外部联网下载，因此由于网络的缘故导致工程骨架未能完全下载，进而导致功能不全的报错。 解决方案调整一下网络就可以成功创建项目。 将负责配置的xml文件下载到本地如果不想每次都让IDEA去联网下载archetype-catalog.xml文件（IDEA每次新建maven项目都会下载一次这个文件），可以将其下载到本地用户的.m2文件夹下，在新建maven项目时使用本地文件，并在IDEA的maven runner设置中的VM Options一栏输入：-DarchetypeCatalog=local 改变依赖的jar包的下载地址——采用国内镜像同样，IDEA的maven项目可以设置自动添加依赖功能，当我们的仓库中没有该jar包的时候可以设置让其自动下载。但是这样添加jar包时要连接网络仓库，为了更快的下载速度，需要更改maven的仓库地址——采用国内阿里云的镜像：在IDEA安装路径下，搜素“settings.xml”（不同版本该文件位置不同），然后在“mirrors”标签中添加我们的mirror标签，如下面的代码： 123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 重新创建项目，可以发现，使用镜像地址和本地文件后，下载骨架的速度很快，子模块中的文件夹和配置文件的加载也是很快就出来。同时，外部库中也自动地将maven所需的依赖如”maven:junit”引入。在父工程的pom.xml文件中设置servlet的相关依赖后，点击“maven”小图标加载maven变更，外部库中也成功地出现相关依赖jar包。 实际上，在maven的仓库配置这一块，IDEA软件是自带maven的，如果我们要使用本地计算机原有安装的不同版本的maven，只需要在设置中进行修改，然后在本地计算机的maven安装路径的xml配置文件中，同样设置镜像就可以了。 Maven 父子项目的依赖继承在父项目的pom.xml文件中，在depencyManagement结构体中添加相关依赖dependencies，然后在子项目的依赖文件中，只需要添加groupId和artifactId即可，版本号在父项目的pom.xml中已经定义好了： 1234567891011&lt;!--子项目的依赖--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 如果maven同步后显示子项目代码中引入相关包的报错，可以先在子项目中把version一项加上，同步一次之后再删除这一项。 Tomcat对IDEA开发项目的部署工件和外部源工件 Artifact：Artifact 是maven中的一个概念，表示某个module要如何打包，包括一个项目将要产生的文件，可以是jar文件，源文件，二进制文件，war文件，甚至是pom文件。每个artifact都由groupId:artifactId:version组成的标识符唯一识别。需要被使用(依赖)的artifact都要放在仓库(Repository)中。一个module有了 Artifacts 就可以部署到应用服务器中了。注意，当我们不使用任何框架来创建maven项目时，如果直接添加tomcat配置，会发现只有外部源，而没有工件这一个选项。我们需要右键单击项目，选择添加框架支持，并选择其中的web程序，这样，在配置中就可以看到工件并在其中选择我们的一个或者多个项目模块了。如果还是不行，可能问题出现在IDEA的配置问题中，更多maven概念名词可参见博客。 发布模式（生产环境）和开发模式（开发环境） 在IDEA中配置Tomcat服务器时，需要在部署deployment中手动二选一设置： servlet-01:war servlet-01:war exploded 这里的servlet-01是web工程的模块名称，两个部署方式在区别在于： war模式（发布模式）：将web工程以包的形式上传到服务器； war exploded模式（开发模式）：将web工程以当前文件夹的位置关系上传到服务器 很显然，在我们需要不断调试程序的开发过程中，更应使用war exploded模式，这种方式也支持热部署。 使用war exploded部署方式，还需要在tomcat配置中的Server选项中进行如下改动： 执行更新操作——On &#39;Update&#39; action项选择Update resources； 框架停用时——On frame deactivation项选择Update resources； maven工程框架的目录&#x2F;文件缺失问题即使我们使用了本地文件+国内镜像的相关配置，有时候使用框架创建maven项目依然可能出现目录&#x2F;文件缺失的情况，这里以webapp文件夹为例，如果我们使用框架搭建的maven项目缺失了该文件夹： 点击IDEA的第一个”File”选项，点击项目结构”Project Structure”； 修改Web资源目录和Web模块部署描述符 如果缺失了其他的文件，我们也可以手动增加。","categories":[{"name":"Java","slug":"Java","permalink":"http://justskim.github.io/categories/Java/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://justskim.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"java","slug":"java","permalink":"http://justskim.github.io/tags/java/"}]},{"title":"Tomcat服务器与Servlet程序","slug":"Tomcat服务器与Servlet程序","date":"2022-04-08T09:50:37.820Z","updated":"2022-04-08T16:05:53.645Z","comments":true,"path":"2022/04/08/Tomcat服务器与Servlet程序/","link":"","permalink":"http://justskim.github.io/2022/04/08/Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8EServlet%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"起因按照狂神的JavaWeb教程，在为Maven项目配置Servlet的映射时，出现了访问地址404的问题，检查文件web.xml的代码，发现在路径映射这一块并没有写错 123456789101112&lt;web-app&gt; &lt;!--注册Servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;servlet-class&gt;com.kuang.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!--servlet的请求路径--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; web.xml文件详解web.xml的模式文件是由Sun公司定义的，但不是必须的。web.xml文件是用来配置：欢迎页、servlet、filter等的。当创建的java web工程没用到这些功能时，可以不用web.xml文件来配置你的web工程。web.xml的模式(Schema)文件中定义了多少种标签元素，web.xml中就可以出现它的模式文件所定义的标签元素，它就能拥有定义出来的那些功能。 web项目启动的第一步 ——web.xml加载过程启动一个WEB项目时，容器包括（JBoss、Tomcat等）首先会读取项目web.xml配置文件里的配置，当这一步骤成功完成之后，项目才正常启动。更详细的加载过程和文件作用详见https://www.cnblogs.com/linhuaming/p/9464356.html。 排查问题首先在Intellj IDEA界面中查看程序逻辑，并没有运行报错的地方，然后查看tomcat服务器，可以看到Web应用被正常部署并启动： 在我们设置的 项目部署地址http://localhost:8080/kuang中，可以成功看到hello wordl的返回页面。但是在web.xml文件中Servlet的映射路径http://localhost:8080/kuang/hello中，我们第一次刷新到此页面时，可以看得到HTTP状态码500的报错页面： 如果再次刷新或者选择其他前缀相同的地址输入，则返回的只是404页面： 排查问题注意我们一开报错的状态码500界面，里面提示jakarta.servlet.ServletException:实例化[com.kuang.servlet.HelloServlet]异常，后面的类是我们自己编写的程序，那么前面的jakarta.servlet包又是怎么回事呢？ Tomcat与Servlet的关系Tomcat是Web应用服务器Server，也是一个Servlet&#x2F;JSP容器，处理Client发来的请求，将请求传递给Servlet，并将Servlet的响应Response传递给Client。 Servlet 是Java编写的服务端程序，与协议、平台均无关，可以动态地扩展Server的能力，像上边说的用请求-响应模式提供Web服务。编写一个Servlet，实际就是按照Servlet规范编写一个Java类。由于Servlet没有main方法，不能独立运行，因此其必须被部署到Servlet容器中，由容器来实例化并调用Servlet的方法（例如doGet()和doPost()）。 Servlet容器又称为Servlet引擎，在Servlet的生命周期内包容和管理Servlet——JSP技术推出后，管理和运行Servlet&#x2F;JSP的容器也称作Web容器。Tomcat就是一个免费开源的Servlet容器。 Tomcat 10的版本问题在IDEA的服务界面中，打开Tomcat Localhost log可以看到这么一句报错信息： 12org.apache.catalina.core.StandardWrapperValve.invoke 分配异常的servlet [hello] java.lang.ClassNotFoundException: javax.servlet.http.HttpServlet 经过查询，发现问题的原因在于Tomcat 10中Servlet无法正常使用，教学视频中演示所用的是tomcat 9，出在了服务器版本问题： 在Tomcat 10中把包名从以往版本的javax改成了jakarta，而maven导包的时候依旧使用原来的javax，导致Tomcat 10服务器的Servlet接口和我写的servlet文件不匹配，从而无法正常运行。 截止至2022年，tomcat 10是最新的版本，这里要提醒踩坑，因为(Jakarta EE)[https://www.cnblogs.com/amon2021/p/15622511.html]的缘故。在Tomcat10.0版本中，里面的javax.servlet中的包名已经改为jakarta.servlet最好不要使用最新版的tomcat 10。对于一切 Java EE，无论是哪个JDK版本，只推荐使用tomcat 9。 换用tomcat 9之后，重新配置，成功启动！ 这里注意tomcat 9的安装尽可能选择安装版而非压缩包，可以省去环境变量手动配置的麻烦——可能start.bat文件打开后会闪退，但不影响在电脑中的运行。 端口号8080被占用导致无法启动tomcat服务器使用命令 netstat -ano|findstr 端口号 查看占用端口号8080的进程，最右边一列为进程PID，使用命令taskkill /T /F /PID 进程pid终止进程，如果无法终止则在IDEA中改用其他端口。","categories":[{"name":"Java","slug":"Java","permalink":"http://justskim.github.io/categories/Java/"},{"name":"Servlet","slug":"Java/Servlet","permalink":"http://justskim.github.io/categories/Java/Servlet/"}],"tags":[{"name":"java","slug":"java","permalink":"http://justskim.github.io/tags/java/"},{"name":"tomcat","slug":"tomcat","permalink":"http://justskim.github.io/tags/tomcat/"},{"name":"servlet","slug":"servlet","permalink":"http://justskim.github.io/tags/servlet/"}]},{"title":"计算机的各类期刊分级与介绍","slug":"计算机的各类期刊分级与介绍","date":"2022-03-31T10:34:55.244Z","updated":"2022-05-07T13:25:05.394Z","comments":true,"path":"2022/03/31/计算机的各类期刊分级与介绍/","link":"","permalink":"http://justskim.github.io/2022/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%90%84%E7%B1%BB%E6%9C%9F%E5%88%8A%E5%88%86%E7%BA%A7%E4%B8%8E%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"会议论文和期刊论文会议论文和期刊论文是两种主要的论文形式： 会议论文：针对某个学术会议投稿，由学术会议的会务组决定是否录用； 期刊论文：针对某学术期刊投稿，由期刊编辑部决定是否录用，审稿专家只负责审稿并返回意见，真正决定录用权在期刊编辑手上。 二者的不同还有以下几点： 审稿周期上：会议论文一般都比较短，在2周左右，甚至快的只需1周；期刊论文相对慢，国内中文核心期刊一般2个月，普刊在1到3周左右，部分水刊录用速度很快。 权威性上：会议论文现在很多都比较水，期刊的话也有水刊，这些都难以被单位认可。有论文集出版的会议论文，在国内的认可度相对较好。要学会如何判断EI会议权威性。 尚未被会议论文集出版的会议论文可以发期刊（出版了就有版权），但是需要在会议论文的基础上进行再次加工——这是因为会议论文基本上没有完成，在会议上发表论文的用意是为了让其他人知道自己的研究并取得反馈。扩充的比例依期刊审稿严格程度而定，多数要求扩充30%以上。 A类、B类、C类期刊A、B、C类期刊是科研单位自主对学术期刊的简单认定，标准由单位自定。A类最好，B类其次，C类刊物有时会称之为C刊（注意，和人文社科期刊中的C刊——CSSCI期刊要划分开来，同名不同意）。以上三类在一些单位也会被分为一二三类期刊。D刊较为少见，一些有刊号非核心的期刊会被称为省级期刊，不会被科研单位算入成绩。计算机领域通常的A、B、C类期刊，是CCF（中国计算机学会）推荐的高水平期刊，也就是CCF 1，CCF B，CCF C——CCF A非常难，一篇足以博士毕业了——其划分可参考该文章。 SCI，SSCI，EI国际三大科技文献检索分别是 SCI（科学引文索引）、EI（工程索引）和ISTP（科技会议录索引）。 SCISCI即《科学引文索引》（Science Citation Index），从来源期刊数量分为： SCI：来源期刊为3500多种的SCI印刷版和SCI光盘版（SCI Compact Disc Edition，简称SCI CDE） SCI-E：即SCI Expanded，是SCI的扩展库，收录更多，接近6000种来源期刊，可通过联网进行检索。 SSCISSCI即社会科学引文索引（Social Sciences Citation Index），收录社会科学类期刊。 CSSCICSSCI是南京大学的“中文社会科学引文索引”，也被称为C刊（注意和C类刊物分开），又称为南大核心。工科学生了解这个名词就行。 EIEI 即《工程索引》（The Engineering Index）。国内的EI期刊有自动化学报、软件学报、通信学报、计算机辅助设计与图形学学报等，EI检索到的通常是这些刊物的英文版。EI期刊的发表要求和学术价值都高于EI会议。 能被上述索引检索到的中文期刊能够被以上这些国际学术检索系统检索到的中文刊物，其发表难度要求与其他英文期刊也是一视同仁的！由于中文稿投稿SCI也要翻译成英文，因此有些作者一开始就用英文写作可以提高效率。国内的EI期刊：自动化学报、软件学报、通信学报、计算机辅助设计与图形学学报等。中文SCI期刊： 一区，二区一区、二区等指中科院对SCI的分区（不同地方可能有所不同，但大部分常用中科院的标准），按照各类期刊影响因子划分，前5%为该类一区，前6%20%为二区，21%50%为三区，其余为四区，越靠前自然质量越高。 CCF ABC与SCI的分区关系二者之间没有必然练习，CCF是计算机行业权威人士排行，因此计算机学科比较注重CCF的分类。 可视化方向的期刊IEEE Transactions on Visualization and Computer Graphics，可视化领域最权威的期刊 谷歌学术中搜索：visualization source:(&quot;IEEE Transactions source:on source:Visualization source:and source:Computer source:Graphics&quot;) source:前面的是要搜索的关键字 注意！不能搜hadoop source:(&quot;IEEE Transactions Visualization and Computer Graphics&quot;)，会得到错误或者空白的结果。 VIS顶会——全称 IEEE Visualization and Visual Analytics 注意，上面两个名词，一个是期刊，一个是会议，有厉害的文章可以两个都进。 info和vast都是年会的重要组成部分，收录的文章相似，但还是有些区别。具体细节可参考VIS会议的官方网站: InfoVis和VAST。具体的二者差别：VAST(IEEE Visual Analytics Science and Technology)—— IEEE 视觉分析科学与技术会议 ( VAST 2017) 是领先的国际会议，致力于 视觉分析的进步。 会议范围，同地 在 VIS 与年度 IEEE 科学可视化会议和 IEEE 信息可视化会议，包括 可视化分析中的基础研究贡献以及 视觉分析在科学、工程、医学中的应用， 健康、媒体、商业、社交互动、安全和 调查分析等学科。INFO(IEEE Information Visualization)——IEEE 信息可视化 (InfoVis) 原创研究论文。 论文可能会贡献新的或改进的视觉编码或交互技术； 评估技术和工具； 与可视化相关的模型或理论； 支持可视化数据分析的系统； 以及将可视化应用于广泛的现实世界环境和领域。 ChinaVis——中国可视化与可视分析大会，宗旨是促进中国及周边地区的可视化与可视分析研究与应用的交流，探讨在大数据时代可视化与可视分析发展的方向与机遇，每年均有论文征稿，可见官网详细征稿信息。2022年大会录取的英文研究论文将发表到 SCI期刊《Journal of Visualization》，中文论文将发表到CCF中文A类期刊《计算机辅助设计与图形学学报》。大会录取的英文综述论文将在SCI期刊《Visual Informatics》上发表，中文综述论文将在CCF中文A类期刊《计算机辅助设计与图形学学报》上发表。该会议每年还会举办数据可视化竞赛 。 如何使用IEEE搜索指定期刊&#x2F;会议？ 在2022年的新版页面设计中，”calls a paper”这个选项要到页面底部去查找，我们点击该选项后，可以在“Search for upcoming call for paper deadlines in your field of interest”中选择会议（Conferences）或者期刊（Periodicals），中间白色输入框内输入检索关键字，然后点击“Get Recommendation”。 如果我们搜的是期刊“IEEE Transactions Visualization and Computer Graphics”（注意，呈现的结果是“Visualization and Computer Graphics, IEEE Transactions on”），点击进入页面中，可以看到IEEE TVCG 的影响因子（Impact factor）为4.579，相当高了。页面中会提示期刊主页(IEEE Periodical home page)——IEEE Transactions on Visualization and Computer Graphics，但是在”current issue”中可以采用左边的搜索框只能搜索到该年的文献，在”all issue”中则无法进行检索。 IEEE检索某个期刊下全部符合条件的文章 在搜索框中输入关键词后，在左侧过滤选项的“Publication Title”中选择期刊，我们可以看到最顶上的就是TVCG。 如果我们搜的是会议“IEEE Visualization and Visual Analytics”，会发现会议是没有影响因子的，就如我们之前说的，会议论文往往尚未完成。在导向的网站中没有可以看论文的地方，详见如下： 如何使用谷歌学术搜索指定期刊？在谷歌学术中找不到VIS的论文——因为大部分论文完成后，都会被推荐到期刊发表（比如顶级的TVCG）。 检索综述某个类型的文献 以知识图谱的综述为例，在www.scopus.com中搜索&quot;Knowledge Graph”后，可以在左侧栏目中，找到文献类型一栏，点击其中的“review”，限制范围后得到关于知识图谱的综述类论文。 或者在搜索中添加相关字段，如“overview”“survey”“review”","categories":[{"name":"Diary","slug":"Diary","permalink":"http://justskim.github.io/categories/Diary/"}],"tags":[{"name":"life","slug":"life","permalink":"http://justskim.github.io/tags/life/"}]},{"title":"Java Reflection反射机制","slug":"Java-Reflection反射机制","date":"2022-03-30T10:20:57.484Z","updated":"2022-03-30T15:11:17.145Z","comments":true,"path":"2022/03/30/Java-Reflection反射机制/","link":"","permalink":"http://justskim.github.io/2022/03/30/Java-Reflection%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/","excerpt":"","text":"介绍Java 反射机制可以让我们在编译期（Compile Time）之外的运行期（Runtime）获得任何一个类的字节码。 包括接口、变量、方法等信息。 编译期：把源码交给编译器编译成计算机可以执行的文件的过程。在 Java 中也就是把 Java 代码编成 class 文件的过程。编译期只是做了一些翻译功能，并没有把代码放在内存中运行起来，而只是把代码当成文本进行操作，比如检查错误； 运行期：把编译后的文件交给计算机执行，直到程序运行结束。运行期中会把在磁盘中的代码放到内存中执行起来。 使用背景为什么需要Java反射？我们先看一下Java的内存模型 class对象：不是new出来的对象o，而是类的类型对象，每个类只有一个class对象，作为方法区类的数据结构的接口。jvm创建对象前，会先检查类是否加载，寻找类对应的class对象，若加载好，则为你的对象分配内存，初始化也就是代码:new Object()。 方法区存的是类的信息，不是存类对象的。 类加载器加载类是通过方法区上类的信息在堆上创建一个类的Class对象，这个Class对象是唯一的，由JVM保证唯一，之后对这个类的创建都是根据这个Class对象来操作的 程序对象是自己new的，程序相当于写死了给jvm去跑。假如一个服务器上突然遇到某个请求要用到某个类但没加载进jvm，还要停下来自己写段代码，new一下，重新启动一下服务器 因此需要使用到反射：当我们的程序在运行时，需要动态的加载一些类，这些类可能之前用不到所以不用加载到jvm，而是在运行时根据需要才加载，这样的好处对于服务器来说不言而喻。 动态语言（弱类型语言）：在运行时可以改变数据类型，变量在使用之前无需声明类型，通常变量的值是被赋值的那个值的类型。包括：PHP，JavaScript，Python。 静态语言（强类型语言）：编译时变量的数据类型即可确定，其中大多数会要求在使用变量之前声明其数据类型，包括：C&#x2F;C++，Java。 尽管Java是静态语言，但反射机制的存在使Java被称为“准动态语言”，可以利用反射机制获得类似动态语言的特性。反射机制允许程序在运行期借助于 Reflection API 取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。加载完类之后，在堆内存的方法区中产生一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。这个对象就像一面镜子一样，我们可以通过这个对象看到类的结构，因此，称之为：反射。正常方式： 123graph LRA[引入需要的包类名称] --&gt; B[通过new实例化]B--&gt;C[取得实例化对象] 反射方式： 123graph LRA[实例化对象] --&gt;B[&quot;getClass()&quot;方法]B--&gt;C[得到完整的包类名称]","categories":[{"name":"Java","slug":"Java","permalink":"http://justskim.github.io/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://justskim.github.io/tags/java/"}]},{"title":"LaTex,mikTex与word中auora插入","slug":"LaTex,mikTex与word中auora插入","date":"2022-03-27T02:48:02.292Z","updated":"2022-03-27T02:48:02.296Z","comments":true,"path":"2022/03/27/LaTex,mikTex与word中auora插入/","link":"","permalink":"http://justskim.github.io/2022/03/27/LaTex,mikTex%E4%B8%8Eword%E4%B8%ADauora%E6%8F%92%E5%85%A5/","excerpt":"","text":"latex和tex及相关软件都是跨平台、免费、开源的。LaTeX是基于TeX的一组宏集，相当于对TeX进行了一次封装。我相信使用LaTeX的用户一定对编程语言有一定了解，可以对某些功能进行封装，屏蔽一些细节，LaTeX是在TeX基础上，规范化出了一种格式，一种编写风格。 在word中插入算法伪代码需要安装miktex和aurora。注意路径\\miktex\\bin\\x64下有mitkex-console.exe的控制台启动文件。 在windows系统中编写latex文件有多种方式，基于我们上边已经安装了mikTex，可以选择下载并安装texStudio工具来作为latex文件的编辑器。","categories":[{"name":"Latex","slug":"Latex","permalink":"http://justskim.github.io/categories/Latex/"}],"tags":[{"name":"latex","slug":"latex","permalink":"http://justskim.github.io/tags/latex/"}]},{"title":"Java多线程编程","slug":"Java多线程编程","date":"2022-03-26T08:42:38.194Z","updated":"2022-03-30T10:03:10.437Z","comments":true,"path":"2022/03/26/Java多线程编程/","link":"","permalink":"http://justskim.github.io/2022/03/26/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/","excerpt":"","text":"jdk11API中文文档中对java.lang.Thread类的介绍： java.lang.Object java.lang.Thread 实现的所有接口 Runnable 已知直接子类： ForkJoinWorkerThread public class Thread extends Objectimplements Runnable线程是程序中执行的线程。 Java虚拟机允许应用程序同时运行多个执行线程。 操作系统中，我们了解到当CPU的核数&lt;当前任务运行数量的时候，多任务的执行其实是轮流交替的。一个任务&#x3D;一个进程，而进程内至少有一个线程，即子任务。多线程模型是Java程序最基本的并发模型，数据库处理和Web操作等都要依赖它： Java语言内置了多线程支持：一个Java程序实际上是一个JVM进程，JVM进程用一个主线程来执行main()方法，在main()方法内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。 进程和线程是包含关系，但是多任务既可以由多进程实现，也可以由单进程内的多线程实现，还可以混合多进程＋多线程。 具体采用哪种方式，要考虑到进程和线程的特点。 和多线程相比，多进程的缺点在于： 创建进程比创建线程开销大，尤其是在Windows系统上； 进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。 而多进程的优点在于： 多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。 我们创建一个程序来新建一个线程： 1234567891011121314151617181920212223public class TestThread1 extends Thread&#123; //可以重写父类的run()方法 @Override public void run()&#123; for(int i=0;i&lt;20;i++)&#123;System.out.println(&quot;run()方法中执行&quot;+i);&#125; &#125; public static void main(String []args)&#123; TestThread1 testThread1 = new TestThread1(); //建一个新线程非常容易，我们需要实例化一个Thread实例，然后调用它的start()方法，start()方法会在内部自动调用实例的run()方法 testThread1.start(); //start()方法被调用时，JVM就创建了一个新线程，线程开启不一定立即执行，由CPU调度执行，所以我们可以看到控制台交替打印“run()...”“main()...” /* testThread1.run(); 注意，如果我们把上面的start语句注释掉，直接调用run方法，相当于调用了一个普通的Java方法，当前线程并没有任何改变，也不会启动新线程。 必须调用Thread实例的start()方法才能启动新线程，如果我们查看Thread类的源代码，会看到start()方法内部调用了一个private native void start0()方法， native修饰符表示这个方法是由JVM虚拟机内部的C代码实现的，不是由Java代码实现的。 */ for(int i=0;i&lt;222;i++)&#123; System.out.println(&quot;main()方法中执行&quot;+i); &#125; &#125;&#125; 可以使用Thread.setPriority(int n)来设置线程优先级，但注意！优先级高的线程被操作系统调度的优先级较高，操作系统对高优先级线程可能调度更频繁，但我们决不能通过设置优先级来确保高优先级的线程一定会先执行。 注意，Java用一个Thread对象表示一个线程，通过调用start()启动一个新线程，像进程的创建状态一样一个线程对象只能调用一次start()方法。无论采用何种方法创建线程，都要将线程的执行代码写在重写的run()方法中： 如果此线程是使用单独的Runnable运行对象构造的，则调用该Runnable对象的run方法; 否则，此方法不执行任何操作并返回。 这很好理解，创建线程必然是要赋予其功能的，采用Thread类创建的线程默认没有任务功能，自然不进行任何操作，相当于无效占用资源。 线程调度由操作系统决定，程序本身无法决定调度顺序； Thread.sleep()可以把当前线程暂停一段时间。 使用getState()可以返回线程的状态，返回值是一个java.lang.Thread.State 的枚举类型（注意java.lang.Enum 类是所有Java语言枚举类型的公共基类） 线程的各种状态变化如下图： 这里注意一下WAITING、TIMED_WAITING与BLOCKED的区别： WAITING：进入等待状态，方式：wait&#x2F;join&#x2F;park方法进入无限等待，通过notify&#x2F;notifyAll&#x2F;unpark唤醒； TIMED_WAITING：与WAITING类似，方式：a. 给定等待时间的wait&#x2F;join&#x2F;park方法；b. sleep方法； BLOCKED：被动进入等待状态，方式：进入Synchronized块。 进程的结束Java程序入口就是由JVM启动main线程，main线程又可以启动其他线程。当所有线程都运行结束时，JVM退出，进程结束。 如果有一个线程没有退出，JVM进程就不会退出。所以，必须保证所有线程都能及时结束。 但是这样引发一个问题，比如有一些线程是定时执行或者随时都在执行的，不结束就无法结束JVM进程，同时也没有专门的线程用来负责结束这一类线程。这时候就要使用守护线程（Daemon Thread）——为其他线程服务的线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。创建守护线程，只需在start()函数前调用setDaemon(true)把该线程标记为守护线程即可。 123Thread t = new MyThread();t.setDaemon(true);t.start(); 使用接口创建线程12345class MyRunnable implements Runnable &#123; //线程的主体类 @Override public void run() &#123;System.out.println(&quot;start new thread!&quot;);&#125; //线程的主体方法&#125; 在文章开头我们给出了jdk11文档中Thread类的说明，反应到代码中就是： 1public class Thread extends Object implements Runnable &#123;&#125; 可知，继承Thread类时覆写的还是Runnable接口的run()方法。 如果一个类继承Thread，则不适合资源共享（注意并不是不能，当以Thread方式去实现资源共享时，实际上源码内部是将thread向下转型为了Runnable，实际上内部依然是以Runnable形式去实现的资源共享），但若实现了Runable接口的话，则很容易的实现资源共享。 继承Thread类： 子类继承Thread类具备多线程能力 启动线程：子类对象.start() 不建议使用：避免OOP单继承局限性 实现Runnable接口： 实现Runnable接口具有多线程能力 启动线程：传入目标对象+Thread对象.start() 推荐使用：避免单继承局限性，方便同一个对象被多个线程使用 java中的单继承是指一个子类最多只能有一个父类，不支持多继承。单继承使JAVA的继承关系很简单，一个类只能有一个父类，易于管理程序。但一个类可以实现多个接口，从而克服单继承的缺点。 还有一种比较少用的，Java1.5之后才出现的Callable接口方式，Callable接口和Runnable接口的异同： 都是 Functional 接口（函数式接口），因此可以直接使用Lamba表达式来实现线程函数，而不一定非得实现一个类来实现接口。 Runnable 可以直接传给 Thread 构造方法，Callable 不可以; Callable 只能使用 ExecutorService，但是Callable可以返回线程的运行结果，Runnable 不可以。 附注：函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口，函数式接口可以被隐式转换为 lambda 表达式。 Thread类中的静态方法Thread类中的静态方法表示操作的线程是”正在执行静态方法所在的代码块的线程“。用处：能对CPU当前正在运行的线程进行操作。下面来看一下Thread类中的静态方法 1234567891011121314151617181920212223public class Race implements Runnable&#123; //winner private static String winner; @Override public void run()&#123; //获取现在正在运行的进程，currentThread会返回一个Thread对象的引用，getName是实例（非静态）方法，会返回一个String类型的线程对象的名称 if(Thread.currentThread().getName().equals(&quot;rabbit&quot;))&#123; try &#123; Thread.sleep(2); //sleep是一个静态方法，让线程休眠2毫秒 &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; Race race = new Race(); new Thread(race,&quot;rabbit&quot;).start();//新建一个线程并随之启动 new Thread(race,&quot;tortoise&quot;).start(); &#125;&#125; 在Java5之后，并发线程这块发生了根本的变化，最重要的莫过于新的启动、调度、管理线程的一大堆API了。在Java5以后，通过Executor来启动线程比用Thread的start()更好。在新特征中，可以很容易控制线程的启动、执行和关闭过程，还可以很容易使用线程池的特性。 线程池背景：经常创建、销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大 思路：提前创建好多个线程，放入线程池ThreadPool中，使用时直接获取，使用完放回池中，避免频繁创建销毁，实现重复利用，类似路上的公共交通工具。从JDK5.0开始提供了线程池的两个相关API：ExecutorService和Executors ExecutorService：真正的线程池接口，实现该接口的最常见子类**ThreadPoolExecutor**，有以下三个常用方法： void execute(Runnable command)：执行任务&#x2F;命令，没有返回值，一般用来执行Runnable &lt;T&gt; Fulture&lt;T&gt;submit(Callable&lt;T&gt; task)：执行任务，且有返回值 void shutdown()：关闭连接池 Executors：工具类、线程池的工厂类，作用：创建并返回不同类型的线程池。 ThreadPoolExecutor()类构造方法中有以下三个重要参数： corePoolSize：池中保留的线程数，即核心池的大小 maximumPoolSize：最大线程数 keepAliveTime：线程没有任务时最多保持多长时间后会终止 1234567891011121314151617181920public class TestPool &#123; public static void main(String[] args) &#123; //创建服务，创建线程池，参数为：线程池大小 ExecutorService service = Executors.newFixedThreadPool(10); System.out.println(service.getClass()); //输出结果为：class java.util.concurrent.ThreadPoolExecutor 是ExecutorService接口下的一个实现类 //执行 service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); //关闭链接 service.shutdown(); &#125;&#125;class MyThread implements Runnable&#123; @Override public void run()&#123;System.out.println(Thread.currentThread().getName());&#125;&#125; 我们在前面讲到了通过接口Runnable创建线程的方式，这里使用Executors类的静态方法newFixedThreadPool(int nThreads)来创建一个线程池，该方法会返回一个接口类型——实际是返回值付给一个实现了此接口的实现类的实例。 Executors类中定义的newFixedThreadPool方法： 12public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 我们查看newFixedThreadPool方法的源代码，可以发现，返回值是一个ExecutorService接口下的ThreadPoolExecutor类对象 该类中有一方法void execute(Runnable command)，用于在将来某个时期执行给定的任务。 同步方法private 关键字可以保证数据对象智能被方法访问。synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符(public、protected、default、private)。synchronized关键字包括两种用法：synchronized方法和synchronized块 同步方法：public synchronized void method(int args[])&#123;&#125; synchronized方法控制对“对象”的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程阻塞。而方法一旦执行，就独占该锁，知道该方法返回才将该锁释放，后面被阻塞的线程才能获得这个锁，继续执行。由synchronized关键字声明的方法同一时间只能被一个线程访问。 123public synchronized void showDetails()&#123;.......&#125; 注： synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类 Java并发包“并发包”指的是 JDK 1.5 版本引入的java.util.concurrent包，简称 J.U.C，其中包含大量多线程和并发编程的工具，其中有以下几个常用类： CopyOnWriteArrayList是ArrayList的线程安全版本，在有写操作的时候会copy一份数据，然后写完再设置成新的数据，适用于读多写少的并发场景。CopyOnWriteArraySet是线程安全版本的Set实现，它的内部通过一个CopyOnWriteArrayList来代理读写等操作，使得CopyOnWriteArraySet表现出了和CopyOnWriteArrayList一致的并发行为，他们的区别在于数据结构模型的不同，set不允许多个相同的元素插入容器中。 Seamphore（信号量），在多线程环境下使用的一种设施。类似于控制并发的时候用到的“令牌桶”算法，负责协调各个线程，通过控制信号总数，不断释放和回收信号来控制并发数量，以保证它们能够正确、合理的使用公共资源。","categories":[{"name":"Java","slug":"Java","permalink":"http://justskim.github.io/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://justskim.github.io/tags/java/"}]},{"title":"编程语言的文档注释","slug":"编程语言的文档注释","date":"2022-03-18T13:51:04.790Z","updated":"2022-03-19T03:03:14.052Z","comments":true,"path":"2022/03/18/编程语言的文档注释/","link":"","permalink":"http://justskim.github.io/2022/03/18/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A/","excerpt":"","text":"Java 文档注释Java 支持三种注释方式。前两种和C++的注释一样，分别是 // 和 /* */。第三种被称作说明注释，它以 /**开始，以 */结束。 说明注释允许我们在程序中嵌入关于程序的信息，也可以使用 javadoc 工具软件来生成信息，并输出到HTML文件中。 菜鸟教程给出了以下的javadoc标签： 标签 描述 示例 @author 标识一个类的作者 @author description @deprecated 指名一个过期的类或成员 @deprecated description {@docRoot} 指明当前文档根目录的路径 Directory Path @exception 标志一个类抛出的异常 @exception exception-name explanation {@inheritDoc} 从直接父类继承的注释 Inherits a comment from the immediate surperclass. {@link} 插入一个到另一个主题的链接 {@link name text} {@linkplain} 插入一个到另一个主题的链接，但是该链接显示纯文本字体 Inserts an in-line link to another topic. @param 说明一个方法的参数 @param parameter-name explanation @return 说明返回值类型 @return explanation @see 指定一个到另一个主题的链接 @see anchor @serial 说明一个序列化属性 @serial description @serialData 说明通过writeObject( ) 和 writeExternal( )方法写的数据 @serialData description @serialField 说明一个ObjectStreamField组件 @serialField name type description @since 标记当引入一个特定的变化时 @since release @throws 和 @exception标签一样. The @throws tag has the same meaning as the @exception tag. {@value} 显示常量的值，该常量必须是static属性。 Displays the value of a constant, which must be a static field. @version 指定类的版本 @version info C语言中文网中有着更详细的Javadoc介绍： 对两种标签格式的说明： @tag 格式的标签（不被&#123; &#125;包围的标签）为块标签，只能在主要描述（类注释中对该类的详细说明为主要描述）后面的标签部分（如果块标签放在主要描述的前面，则生成 API 帮助文档时会检测不到主要描述）。 {@tag} 格式的标签（由&#123; &#125;包围的标签）为内联标签，可以放在主要描述中的任何位置或块标签的注释中。 Javadoc标签注意事项： Javadoc 标签必须从一行的开头开始，否则将被视为普通文本。 一般具有相同名称的标签放在一起。 Javadoc 标签区分大小写，代码中对于大小写错误的标签不会发生编译错误，但是在生成 API 帮助文档时会检测不到该注释内容。 Javadoc命令Javadoc 用法格式如下： javadoc [options] [packagenames] [sourcefiles] 其中options 表示Javadoc 命令的选项，packagenames表示包名，这两个是可选项。 如果我们的代码中有中文的注释，可以使用命令javadoc -encoding UTF-8 -charset UTF-8 Javadoc_demo.java编译出相应的Html文档让我们阅读。 java说明注释——javadoc标签的使用以IDEA软件为例，由于其自动补全的功能，我们只需要输入/**然后回车即可，每一行都会智能地为我们的注释文字在开头补上*符号。我们不仅可以在主类外写说明注释，还可以先写上类中的成员函数，然后在成员函数上头输入/**，IDEA将会自动为我们补全相关信息，比如参数 param： 12345678910111213141516/** * @author Mike * @version 1.0 * @since 1.8 * */public class Javadoc_test &#123; /** * * @param name * @return */ public String test(String name)&#123; return name; &#125;&#125; JSDoc——JavaScript之注释规范化原生的JavaScript语法中并没有像Java那样的说明注释，JSDoc 是一个针对 JavaScript 的 API 文档生成器，可以在其官网查看介绍，类似于 Java 中的 Javadoc 或者 PHP 中的 phpDocumentor。我们在js格式代码中添加像javadoc标签般的注释，即可被JSDoc工具自动扫描并生成API文档。这位博主的博客文章中介绍了该工具的使用： 首先要使用npm进行安装，我们选择全局安装较为方便： 1npm install -g jsdoc 书写符合形式的代码及说明注释，在js文件的当前目录下执行命令： 1jsdoc doc.js 就会在当前目录下生成一个名为 out 的目录（也可以另外指定目录），然后我们就可以通过浏览器访问这个 out 目录中的相关网页。 对于JavaScript的业务开发，我们可以参考这一篇掘金的文章。尤其是针对参数的描述，要注意格式为： @param &#123;paramDataType&#125; p1 descriptionStatements 其中： p1代表必选参数 [p1]代表可选参数 [p1=xxx]代表带默认值的参数 对于typescript，JSDoc 的提供的注释标记类型可以参考Block Tags, 但是到现在为止，TypeScript 只支持了部分标记。 在语法方面，由于JSDoc 主要借鉴于 closure-compiler, 而 TypeScript 则有自己的一套类型语法，因此存在部分的差异。 Python中的注释和文档单行注释和多行注释都是基本语法知识，需要注意的是由于Python按缩进来划分代码块的语法特性，编写多行注释的时候要注意首尾&#39;&#39;&#39;符号的对齐和缩进，多行注释可以用三个单引号 ‘’’ 或者三个双引号 “”” 将注释括起来。 Docstring——Python的文档注释按照gitbook上Python的指导文档可以看到： 作为文档的Docstring一般出现在模块头部、函数和类的头部，这样在python中可以通过对象的__doc__对象获取文档，编辑器和IDE也可以根据Docstring给出自动提示。文档注释中对函数参数、返回值等的说明采用numpy标准。文档注释以 &quot;&quot;&quot; 开头和结尾，首行不换行，如有多行，末行必需换行 注意！为了代码的效率和信息不冗余，不要在文档注释复制函数定义原型，而要具体地描述其具体内容，解释具体参数和返回值等，如下面的示例写法： 12345678# 不推荐的写法(不要写函数原型等废话)def function(a, b): &quot;&quot;&quot;function(a, b) -&gt; list&quot;&quot;&quot; ... ...# 正确的写法def function(a, b): &quot;&quot;&quot;计算并返回a到b范围内数据的平均值&quot;&quot;&quot; ... ... pydoc是python自带的一个文档生成工具，可以提取注释。在控制台中，我们可以使用命令pydoc pydoc_demo &gt; doc.md来生成文档。之后使用python pydoc_demo.py命令启动pydoc_demo.py文件，就可以看得到相关的文档注释。 使用命令pydoc -w pydoc_demo可以生成html格式文件pydoc_demo.html，更具体的使用可以参考pydoc用法。 Python文件头注释我们以一个常见的Python开头注释为例： 123#!/usr/bin/env python# -*- coding:utf-8 -*-# Author:XXX 第一行#!/usr/bin/env python的意义： 这些注释并不仅仅是写给读者看的注释，它也写给操作系统看的，这些注释决定了系统将如何运行这些文件。 Linux系统自带python解释器（通常是Python 2的版本，比如Centos 7中就是如此）。在编写.py文件时，只要写上了#!&#x2F;usr&#x2F;bin&#x2F;python这行注释，用户就可以直接在命令行用文件名来执行py文件，例如： testmode.py 意义：指定系统环境变量设定的解释器路径。类似于在window命令行中，你必须得写 python testmode.py 或 javac testmode.java 或 java testmode.class 来运行文件，你要通过文件名前面的关键字才能去启动对应的解释器。而有了这行注释，Linux系统就知道了你要用什么来执行这个文件，你就可以直接用文件名去跑它了。 #!/usr/bin/python注释的问题：Linux只会使用系统默认的py解释器（也就是自带的那个）来运行文件。这样用户就无法使用自己的python版本了，不同的py版本之间语法有些差异，尤其是变动比较大的py2和py3，这些差异会使得整个程序无法正常运行。而#!&#x2F;usr&#x2F;bin&#x2F;env python 的出现可则让用户可以自行选择python版本，用户可以在环境变量中配置自己的py解释器（ps：用户安装的版本默认定位在Linux的local文件夹中）。#!/usr/bin/env python这行注释，会使linux在解析文件时，知道要去使用环境变量中的py解释器而非系统自带的那个。 所以如果你要使用该注释，推荐使用#!/usr/bin/env python的注释，而非#!/usr/bin/python。 第二行# -*- coding:utf-8 -*-作用是在Linux下指定文件的编码方式，用于支持中文。由于Python 3 默认支持中文，因此该行注释可以省略。 在windows系统的Python 3环境下运行我们的程序，可以不写上面的两行注释，但为了跨平台以及兼容，还是应该写上。","categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"}],"tags":[{"name":"python","slug":"python","permalink":"http://justskim.github.io/tags/python/"},{"name":"java","slug":"java","permalink":"http://justskim.github.io/tags/java/"},{"name":"javascript","slug":"javascript","permalink":"http://justskim.github.io/tags/javascript/"}]},{"title":"知识图谱专业术语与基本知识","slug":"知识图谱专业术语与基本知识","date":"2022-03-16T07:04:43.745Z","updated":"2022-05-08T19:04:47.355Z","comments":true,"path":"2022/03/16/知识图谱专业术语与基本知识/","link":"","permalink":"http://justskim.github.io/2022/03/16/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/","excerpt":"","text":"知识图谱的应用：我们为什么要做知识图谱 语义搜索 智能问答 个性化推荐 辅助决策 起源和基本概念在这篇知识图谱的介绍专栏中，可以知道，知识图谱起源于语义网络（semantic nets or semantic networks），语义网络一种用互联的的节点和弧来表示知识的一个结构，节点可以代表一个概念(concept)、一个属性(attribute)、一个事件(event)或者一个实体(entity)，而弧则用来表示节点之间的关系，弧的标签指明了关系的类型。知识图谱不能仅理解为一个图，应该说：知识图谱是一种采用图模型（即由点和线组成的图形）来对人类知识进行表示的知识库或者知识的集合，并且符合某种语法和语义。 知识图谱的图模型是一个有向图G&#x3D;&lt;O,E&gt;，这里O是一个实体或者字面量（literal）的集合，一般有以下几种： 实例，即一个现实世界中具体的实物，比如说图1中的resource&#x2F;2019新型冠状病毒感染肺炎； 概念，可以看成是实例的集合，比如说图1中的class&#x2F;疾病； 字面量（literal），主要分为字符串和数据类型，这里数据类型包括日期值、高度等。 知识图谱中一条知识称为三元组，即**&lt;o1, e, o2&gt;的格式，这里o1和o2是实体或者字面量，而e则是带标签的边（类似图结构中我们要用两个点，一条边来表示）。一个三元组可以等价于一条主谓宾的知识，即o1和o2分别对应主语和宾语，e对应谓语**。 三元组的基本组成部分： 实体（Entity）：实体是对客观个体的抽象，一个人、一部电影、一句话都可以看作是一个实体。例如：姚明，李安，我不是潘金莲 类型（type）：类型是对具有相同特点或属性的实体集合的抽象。举例：中国是一个实体，美国是一个实体，法国是一个实体。这些实体都有首都、人口、面积等共同特征，因此例如像中国、美国、法国等都有首都、人口、面积等特征的实体可以抽象为“国家”类型 属性（property）：属性是对实体与实体之间关系的抽象，例如李安是一个实体，李安是一个人物（type），少年派的奇幻漂流是一个实体，少年派的奇幻漂流是一个电影（type），很明显两个实体之间存在着关系即为：李安→导演→少年派的奇幻漂流因此李安与少年派的奇幻漂流之间的关系可以用属性“导演”刻画。那么可以根据属性构建一层关系，人物（type）→导演（property）→电影（type）。 关系（relation）：关系是实体与实体之间关系的抽象，李安（entity）→导演（relation）→少年派的奇幻漂流（entity），导演这个relation则是描述李安和少年派的奇幻漂流的关系。 域（domain）：域是类型的集合，凌驾于类型之上，是对某一领域所有类型的抽象，例如：国家是对中国、美国这样实体的一种抽象，是一种类型，而一个地理位置除了国家类型之外，还包括其他类型：城市、区域、洲等等，而把这些所有类型：洲、国家、城市、区域等类型抽象起来，就形成了地理位置域。 值（value）：值是用来描述实体的，可以分为文本型和数值型，EG：姚明（entity）→身高（relation）→ 226 cm（value）。 想要系统学习知识图谱，基础阶段可以看一下知乎上这一位博主的知识图谱专栏学习笔记，比如他这里介绍的知识图谱构建方法： 建立知识图谱的第一步是获得数据，根据数据的类型可以分为： 结构化的数据：表格、数据库等按照一定格式表示的数据，通常可以直接用来构建知识图谱； 非结构化的数据：文本、音频、视频、图片等，需要对它们进行信息抽取才能进一步建立知识图谱； 半结构化数据是介于结构化和非结构化之间的一种数据，也需要进行信息抽取才能建立知识图谱。 连续型数据和非连续型数据： 离散型数据都是类别值，如：男生，女生，商务座，一等座，二等座等等。连续型数据基本上都是数值型数据，如年龄（10岁，11岁…），身高（110cm, 175cm…），海拔，薪资等等。既然连续型数据都是数值，是可以直接拿来供计算机使用的，那么连续型数据该如何处理？这里我们提出一个处理思想：连续型数据离散化。连续型数据离散化以后的建模效果一定会比原来的好吗？这个答案是不一定的 信息抽取（知识抽取） 可以分为实体识别、关系抽取、属性抽取等。目前结构化的数据时最主要的知识来源。针对结构化的数据，知识图谱通常可以直接利用和转化，形成基础数据集，再利用知识图谱补全技术进一步扩展知识图谱。 针对文本型数据这种非结构化数据，知识获取的方式主要包括实体识别、关系抽取、属性抽取等。具体的方法又包括基于特征模版的方法、基于核函数的监督学习方法、基于深度学习的方法等 实体识别：指在一段文本中识别哪些词代表实体，并打上标签（进行分类）。例如“演员于和伟出演了电视剧《觉醒年代》”这句话中，“于和伟”和“《觉醒年代》”就是两个实体 关系抽取：识别文本（或其他数据）中实体之间的关系。例如“演员于和伟出演了电视剧《觉醒年代》”这句话中，“出演”为“演员于和伟”与“电视剧《觉醒年代》”之间的关系 知识表示与建模知识表示 用一定的结构和符号语言来描述知识，并且能够用计算机进行推理、计算等操作的技术。知识表示的方法：谓词逻辑表示法、框架表示法、基于语意网路的表示法等。 知识融合 Knowledge fusion 由于得到的数据可能会存在交叉和重叠，因此同一个概念、实体可能会反复出现，知识融合的目的就是把表示相同概念的实体进行合并。根据专栏作者的解释： 主要任务包括实体消歧和指代消解，它们都用来判断知识库中的同名实体是代表同一含义、是否有其他实体也表示相同含义。实体消歧专门用于解决同名实体产生歧义的问题，通常采用聚类法、空间向量模型、语义模型等。指代消解则为了避免代词指代不清的情况。 知识推理 Knowledge Reasoning 知识推理是根据已有的数据模型和数据，依据推理规则，获取新的知识或者结论，新的知识或结论应该是满足语义的。知识推理，依据描述逻辑系统实现。描述逻辑(Description Logic)是基于对象的知识表示的形式化，也叫概念表示语言或术语逻辑，是一阶谓词逻辑的一个可判定子集。 一个描述逻辑系统由四个基本部分组成： 最基本的元素：概念、关系、个体；TBox术语集：概念术语的公理集合； Abox断言集：个体的断言集合；TBox 和 ABox上的推理机制。 描述逻辑涉及到的内容也比较多，此处举几个例子，比如实体的分类包含关系，一个电脑椅是椅子，椅子是家具，可以说，一个电脑椅是家具。常识规则的推理，一个男人的孩子是A，一个女人的孩子是A，可以知道，这个男人和女人是配偶。 简单地说，推理任务主要有：通过规则挖掘对知识图谱进行补全（Knowledge Base Completion,KBC）与质量校验、链接预测、关联关系推理与冲突检测等。 基于规则的推理通过定义或学习知识中存在的规则进行挖掘与推理，从早期的ILP(Inductive Logic Programming)系统中衍生的AMIE、AMIE+算法， 强调通过自动化的规则学习方法，快速有效的从大规模知识图谱中学习出置信度较高的规则，并且应用于推理任务。 Trans E 算法细说transE算法就是一个非常经典的知识表示学习，用分布式表示（distributed representation）来描述知识库中的三元组，这里可以看下其简单的算法思想： 知识图谱中的事实是用三元组 ( h , l , t ) (h,l,t)(h,l,t) 表示的，那么如何用低维稠密向量来表示它们，才能得到这种依赖关系呢？transE算法的思想非常简单，它受word2vec平移不变性的启发，希望h + l ≈ t h+l≈th+l≈t（此为归纳偏差？）。 光有这一个约束可不够。想让h + l ≈ t h+l≈th+l≈t，如何设置损失函数是个关键。我们发现表示学习都没有明显的监督信号，也就是不会明确告诉模型你学到的表示正不正确，那么想要快速收敛就得引入“相对”概念，即相对负例来说，正例的打分要更高，方法学名：“negative sampling”，也就是负采样。 转移距离模型（Translational Distance Model）的主要思想是将衡量向量化后的知识图谱中三元组的合理性问题，转化成衡量头实体和尾实体的距离问题。这一方法的重点是如何设计得分函数，得分函数常常被设计成利用关系把头实体转移到尾实体的合理性的函数。 受词向量的启发，由词与词在向量空间的语义层面关系，可以拓展到知识图谱中头实体和尾实体在向量空间的关系。也就是说，同样可以 考虑把知识图谱中的头实体和尾实体映射到向量空间中，且它们之间的 联系也可以考虑成三元组中的关系。 TransE便是受到了词向量中平移不变性的启发，在 TransE 中，把实体和关系都表示为向量，对于某一个具体的关系（head, relation, tail），把关系的向量表示解释成头实体的向量到尾实体的向量的转移向量（Translation vector）。也就是说， 如果在一个知识图谱中，某一个三元组成立，则它的实体和关系需要满 足关系head+relation≈tail。 知识图谱的嵌入知识图谱通常存在链接缺失问题，这限制了知识图谱在相关下游任务中的应用。为解决该问题，知识图谱补全任务应运而生。知识图谱补全旨在根据知识图谱中已有事实推断出新的事实，从而使得知识图谱更完整。 知识图谱嵌入 (Knowledge Graph Embedding) 是解决知识图谱补全问题的重要方法之一，它通过将知识图谱中的实体 (Entity) 和关系 (Relation) 嵌入到连续向量空间，从而在方便计算的同时保留知识图谱中的结构信息。知识图谱嵌入模型大致可以分为三类： 知识图谱补全任务符号定义知识图谱通常以三元组 (Triple) 来表示知识，三元组的一般格式为 (头实体，关系，尾实体)，如“金庸的表兄是徐志摩”表示成三元组为 (金庸，表兄，徐志摩)，其中金庸为头实体，徐志摩为尾实体，表兄是这两个实体之间的关系。我们使用小写的字母 来分别表示头实体、关系和尾实体， 表示知识图谱中的一个三元组。相应地，小写加粗字母 分别表示头实体、关系和尾实体对应的嵌入向量。向量 的第 个元素记作 。 表示嵌入向量的维度。 表示两个向量间的 Hadamard (element-wise) product。另外，我们使用 来分别表示 和 范数。 补全任务与性能指标知识图谱补全 (Knowledge Graph Completion)，是根据知识图谱中已有的三元组去对未知三元组进行预测。我们使用 表示已知头实体和关系来预测尾实体， 表示已知关系和尾实体来预测头实体，其中 和 被称为查询 (Query)。实际上，知识图谱补全任务，本质上给定查询下的排序问题。比如，对于图2所示的查询 (陆小曼，丈夫，？)，返回的是预测答案的排序列表，正确答案排名越高，预测的效果就越好。 质量评估在知识推理完了之后，我们也不能忘记质量评估这一个最后的步骤： 质量评估就是对最后的结果数据进行评估，将合格的数据放入知识图谱中。质量评估的方法，根据所构建的知识图谱的不同，对数据要求的差异而有所差别。总的目的是要获得合乎要求的知识图谱数据，要求的标准根据具体情况确定。 比如对于公共领域的知识图谱，知识的获取采用了众包的方法，对于同一个知识点，可能会有很多人来完成，如果这个知识点只有一个答案，可以采用的一种策略是，将多人的标注结果进行比较，取投票多的结果作为最终的结果。当然，这是不严谨的，因为真理往往掌握在少数人的手里，特别是针对一些行业的知识图谱，表现尤为突出。行业内的一条知识，可能只有行业专家能够给出权威正确的答案，如果让大众投票来决定，可能会得到一条错误的知识。所以，针对行业知识图谱，可能会采用不同于公共知识图谱的策略，来进行知识的质量评估。 NLP中的负采样（Negative Sampling）负采样是NLP领域一个出现频次极高的词，负抽样的目的是为了最终输出的上下文单词（正样本），在采样过程中应该保留下来并更新，同时也需要采集部分负样本（非上下文单词）。通过负采样，在更新隐层到输出层的权重时，只需更负采样的单词，而不用更新词汇表所有单词，对负采样理解来自于word2vec算法： 比如说 love 和me两个单词；使用特殊思维模式；假设整个词汇表只有100个单词；love 表示成one-hot向量； me表示成one-hot向量；模型输入为love的one-hot向量；模型输出为me的one-hot向量；假设模型的神经网络结构为10010100；输出层100个；输出层中除了me对应位置的1外，其他全是0；称这为负样本；参数数量为10100采样就是从这样负样本中抽样；比如说抽取5个；那么在此次梯度更新中就只更新105；更新数量为原来的1&#x2F;20 因此，可以看到负采样的本质：每次让一个训练样本只更新部分权重，其他权重全部固定；减少计算量；（一定程度上还可以增加随机性）","categories":[{"name":"知识图谱","slug":"知识图谱","permalink":"http://justskim.github.io/categories/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"}],"tags":[{"name":"知识图谱","slug":"知识图谱","permalink":"http://justskim.github.io/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"}]},{"title":"visual studio code中无法切换Python版本的解决","slug":"visual-studio-code中无法切换Python版本的解决","date":"2022-03-07T01:50:49.323Z","updated":"2022-03-07T02:05:47.908Z","comments":true,"path":"2022/03/07/visual-studio-code中无法切换Python版本的解决/","link":"","permalink":"http://justskim.github.io/2022/03/07/visual-studio-code%E4%B8%AD%E6%97%A0%E6%B3%95%E5%88%87%E6%8D%A2Python%E7%89%88%E6%9C%AC%E7%9A%84%E8%A7%A3%E5%86%B3/","excerpt":"","text":"起因使用Python进行机器学习，需要引入sklearn模块，因此在我们建立的anaconda环境（名称py378，用的Python 3.7.8的版本）中activate该环境，并安装scikit-learn库（安装的模块名和导入的库名称不一样，这个见网上详细解释，scikit-learn其实就是其工具包）。但来到软件visual studio code界面中却发现无法正常切换Python版本，工作区也未能生成.vscode文件夹： ![visual studio code无法切换python环境](&#x2F;images&#x2F;visual studio code无法切换python环境.PNG) 我们可以看到，在左下角并没有加载出Python Interpreter，终端中手动输入命令切换环境也依然无法奏效。 尝试步骤 按住ctrl+shift+p，输入Python Interpreter切换环境，发现已经被切换到py378 打开Preferences中的设置，在settings.json中找到python.defaultInterpreterPath，由于之前博主为了能像anaconda那般切换环境，在visual studio code进行配置，此项为anaconda下的python.exe文件，博主手动将其修改为C:\\\\Users\\\\YourUserName\\\\Anaconda3\\\\envs\\\\py378\\\\python.exe 在上边的设置中，搜索cmd，查看终端terminal是否为cmd而不是powershell（据网上说法powershell较不稳定），但博主这里的设置无误： 经过以上步骤依然无效","categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"},{"name":"Python3","slug":"Programming-languages-and-projects/Python3","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"}],"tags":[{"name":"python","slug":"python","permalink":"http://justskim.github.io/tags/python/"},{"name":"visual studio code","slug":"visual-studio-code","permalink":"http://justskim.github.io/tags/visual-studio-code/"}]},{"title":"Eclipse web 工程的项目目录结构","slug":"Eclipse-web-工程的项目目录结构","date":"2022-03-06T10:10:07.896Z","updated":"2022-03-19T03:14:27.784Z","comments":true,"path":"2022/03/06/Eclipse-web-工程的项目目录结构/","link":"","permalink":"http://justskim.github.io/2022/03/06/Eclipse-web-%E5%B7%A5%E7%A8%8B%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/","excerpt":"","text":"在使用Eclipse学习Java开发的过程中，发现我自己新建dynamic web project的项目目录结构和视频中演示的不同，最明显的区别是没有Java Resources和JavaScript Resources这两个文件夹： 查阅多方资料显示，这种项目结构的不同对于程序执行并没有大问题，要参考项目中各个文件和目录的功能，可以见以下三篇博客： https://blog.csdn.net/yyuanxiwen/article/details/94600630 https://blog.csdn.net/Alan_Wdd/article/details/90514928 https://www.cnblogs.com/jetdl/p/9724651.html 在webapp下有一个WEB-INF文件夹。该目录是一个专用区域， 容器不能把此目录中的内容提供给用户。这个目录下的文件只供容器使用，里面包含不应该由客户直接下载的资源。Web 容器要求在你的应用程序中必须有 WEB-INF 目录。WEB-INF 中包含着发布描述符（也就是 web.xml 文件）, 一个 classes 目录和一个 lib目录, 以及其它内容。注意： 如果你的 Web 应用程序中没有包含这个目录, 它可能将无法工作 。 web.xml文件在 J2EE Web 应用程序发布之后帮助管理 Web 应用程序的配置。在web.xml文件中会设置welcome-file标签，这是因为&#x2F;WEB-INF目录下的文件本来是不允许直接访问的，但如果在web.xml中配置了如上欢迎页面，并且在&#x2F;WEB-INF目录下放置了index.html，那么在浏览器地址栏输入http://127.0.0.1:8080/myWeb可以访问index.html页面，路径中的myWeb是项目文件名。 在web.xml文件下需要添加约束，约束文件可以在我们tomcat安装目录下的/conf子文件夹中的web.xml文件中拷贝。 我们打开eclipse时，会要求我们设定workspace。在我们设定workspace的那个文件夹下，我们可以发现一个**隐藏文件夹.metadata**，它存在于eclipse第一次启动时指定的workspace目录下， project name 和 workspace 分别对应的目录不能是同一个目录，否则无法建立project name。 当我们通过eclipse启动tomcat运行工程时，eclipse会将工程发布到org.eclipse.wst.server.core中，就像发布到tomcat中一样。使用tomcat服务器的话，默认的部署路径为.metadata/.plugins/org.eclipse.wst.server.core/tmp0，可以看到有一个server.xml，可以看到deployDir=&quot;wtpwebapps&quot;。 因此在该路径下的wtpwebapps文件夹（注意最后不是webapps）下可以看到发布的项目。 当我们为Eclipse配置默认使用的本机tomcat服务器后，我们可以在Project Explorer窗口中找到一个Servers目录，其中有一个server.xml。Service标签代表包含着一个服务（默认情况下name&#x3D;”Catalina”)，一个服务器可以包含多个服务，就对应着多个Service标签。因为是web项目，我们这里的服务要给浏览器使用，因此需要用到连接器Connector，并在其中配置端口号（默认为port&#x3D;”8080”）","categories":[{"name":"Java","slug":"Java","permalink":"http://justskim.github.io/categories/Java/"},{"name":"Eclipse","slug":"Java/Eclipse","permalink":"http://justskim.github.io/categories/Java/Eclipse/"}],"tags":[{"name":"java","slug":"java","permalink":"http://justskim.github.io/tags/java/"},{"name":"eclipse","slug":"eclipse","permalink":"http://justskim.github.io/tags/eclipse/"}]},{"title":"重新安装JDK后Eclipse更改配置","slug":"重新安装JDK后Eclipse更改配置","date":"2022-03-06T00:42:59.456Z","updated":"2022-03-06T09:16:31.632Z","comments":true,"path":"2022/03/06/重新安装JDK后Eclipse更改配置/","link":"","permalink":"http://justskim.github.io/2022/03/06/%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85JDK%E5%90%8EEclipse%E6%9B%B4%E6%94%B9%E9%85%8D%E7%BD%AE/","excerpt":"","text":"博主在将原先的JDK卸载，又重新安装JDK11后，发现了Eclipse软件无法正常打开的情况： 这种情况下我们一般先检查环境变量，通过命令行和系统环境的Java变量配置查看均无异常。我们查询当时Eclipse的安装教程，看是否有Eclipse软件相关的环境变量需要重新配置，结果的no。 那么，问题很明显，Eclipse软件会在第一次使用的时候获取系统的Java相关环境变量，然后将其存入自己的相关配置文件中，之后就不必获取了。在网上搜索得到Eclipse软件的配置文件为安装目录下bin文件夹中的eclipse.ini文件，我们打开搜索，可以看到vm（virtual machine 虚拟机）选项下有个旧版本JDK安装路径的bin文件夹： 我们将其修改为重新安装的JDK路径下bin文件夹：C:\\Program Files\\Java\\jdk-11.0.2\\bin，重新打开Eclipse软件，可以成功运行！ 这里顺便提一下，很多软件安装完之后都有一个bin文件夹，bin是binary的缩写，代表的意思是二进制，该文件夹下一般都存放二进制可执行文件。 ini 文件，全称 “Initialization File”，即初始化文件，是windows的系统配置文件所采用的存储格式，统管windows的各项配置。配置文件的好处在于，能够通过直接编辑ini文件来修改配置： 如果我们的程序没有任何配置文件时，这样的程序对外是全封闭的，一旦程序需要修改一些参数必须要修改程序代码本身并重新编译，这样很不好，所以要用配置文件，让程序出厂后还能根据需要进行必要的配置；配置文件有很多，如INI配置文件，XML配置文件，还有就是可以使用系统注册表等。","categories":[{"name":"Java","slug":"Java","permalink":"http://justskim.github.io/categories/Java/"},{"name":"Eclipse","slug":"Java/Eclipse","permalink":"http://justskim.github.io/categories/Java/Eclipse/"}],"tags":[{"name":"java","slug":"java","permalink":"http://justskim.github.io/tags/java/"},{"name":"eclipse","slug":"eclipse","permalink":"http://justskim.github.io/tags/eclipse/"}]},{"title":"CentOS7系统安装python3.7.8","slug":"CentOS7系统安装python3.7.8","date":"2022-03-05T17:17:00.722Z","updated":"2022-03-07T01:33:57.245Z","comments":true,"path":"2022/03/06/CentOS7系统安装python3.7.8/","link":"","permalink":"http://justskim.github.io/2022/03/06/CentOS7%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85python3.7.8/","excerpt":"","text":"首先在Python官方网站中找到我们特定版本的安装包，这里我们要选择适合Linux系统的tar.xz格式压缩包。我们要注意，大部分Linux系统发行版，比如博主所用的Centos7都预装了python2，可以使用命令python -V查看其版本为2.7.5，但可能没有装pip工具。但是这样也有个好处，下载包的时候免得我们混淆。我们注意pip2和pip3的关系： pip是python的包管理工具，pip和pip3版本不同，都位于Scripts\\目录下； 如果系统中只安装了Python2，那么就只能使用pip； 如果系统中只安装了Python3，那么既可以使用pip也可以使用pip3，二者是等价的； 如果系统中同时安装了Python2和Python3，则pip默认给Python2用，pip3指定给Python3用； 使用pip install XXX安装的库会位于路径python2.X/site-packages中，而使用pip3 install XXX安装的库会放在目录python3.X/site-packages下。 博主按照网上常见的教程安装后，一直显示的是python 3.6.8，跑到路径/usr/bin下使用命令rm -rf python3*删除了旧的python文件（前缀为python3的，前缀为python没有3的是python2版本的文件），再重新安装，编译，成功启动程序。 which python3 命令在PATH变量指定的路径中，搜索系统命令python的位置，并且返回第一个搜索结果（使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令）","categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"},{"name":"Python3","slug":"Programming-languages-and-projects/Python3","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://justskim.github.io/tags/linux/"},{"name":"python","slug":"python","permalink":"http://justskim.github.io/tags/python/"}]},{"title":"Windows系统下环境变量配置与计算机重启","slug":"Windows系统下环境变量配置与计算机重启","date":"2022-03-05T08:50:11.668Z","updated":"2022-03-05T09:59:52.900Z","comments":true,"path":"2022/03/05/Windows系统下环境变量配置与计算机重启/","link":"","permalink":"http://justskim.github.io/2022/03/05/Windows%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E5%90%AF/","excerpt":"","text":"我们来看一下对于Windows不重启使环境变量修改生效的解释： 一个程序启动时，环境变量被复制到该程序所在的环境中，在该程序执行过程中不会被除该程序以外的其他程序所改变。也就是说，假设我们启动了一个cmd程序，然后通过控制面板修改了环境变量设置，但是已经启动了的cmd所拥有的环境变量并不会被改变。如果我们在修改环境变量之后启动cmd程序，则该程序将拥有新的环境变量。那么结论就很明显了：修改环境变量之后，如果受影响的是应用程序，那么只要简单地重新启动此应用程序，环境变量的修改就会反映到该程序中，而不必重新启动计算机；但是，如果受影响的是系统服务，就必须重新启动才能将环境变量的修改反映到系统服务中（因为没有办法在不重启计算机的情况下重新启动系统服务管理器） 那么有没有什么办法可以不重启就使一切修改的环境变量配置生效呢？有，当我们很不想重启windows系统时可以尝试这么做： 以修改环境变量“PATH”为例，修改完成后，进入DOS命令提示符，输入： 1set PATH=C: 1 关闭DOS窗口。再次打开DOS窗口，输入： 1echo %PATH% 1 可以发现“我的电脑”-&gt;“属性”-&gt;“高级”-&gt;“环境变量”中设置的 PATH 值已经生效。不用担心DOS窗口中的修改会影响环境变量的值，DOS窗口中的环境变量只是Windows环境变量的一个副本而已。但是对副本的修改却会引发Windows环境变量的刷新，这正是我们想要的！","categories":[{"name":"Windows","slug":"Windows","permalink":"http://justskim.github.io/categories/Windows/"}],"tags":[{"name":"windows","slug":"windows","permalink":"http://justskim.github.io/tags/windows/"}]},{"title":"Java基础语法学习要注意的小细节","slug":"java基础语法学习要注意的小细节","date":"2022-03-01T19:38:13.360Z","updated":"2022-04-02T07:38:18.936Z","comments":true,"path":"2022/03/02/java基础语法学习要注意的小细节/","link":"","permalink":"http://justskim.github.io/2022/03/02/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%B0%8F%E7%BB%86%E8%8A%82/","excerpt":"","text":"Java基础语法学习要注意的小细节最最基本的 Java8和11是两个最常用的版本，也是推荐新手起步安装的版本，博主一开始使用最新的JDK17，但很多文件位置和环境配置都不同，看使用旧版本的开发教程时很麻烦。Java平台包括Java se(J2SE，标准版) Java ee(J2EE，企业版，J2SE是其子集) Java me(J2ME，用于嵌入式的，比较少)。普通用户只需安装JER(Java Runtime Environment)来运行Java程序，而开发者必须安装JDK来对程序进行编译调试。版本的关系对应为：Java X &#x3D; Java SE X &#x3D; JDK 1.X 。 对于Java SE，各大厂商的JDK有所区别。官网的下载速度很慢还要注册账号，我们可以在推荐的三家国内jdk镜像站中下载相应的JDK。其中，清华大学开源软件镜像站的JDK为Eclipse Temurin Java SE，由Eclipse基金会发布，即OpenJDK的”生产就绪“构建，免费试用，且所有版本都通过了Oracle的Java SE技术兼容性工具包测试以及Eclipse AQAvit互操作性和性能测试。不过博主还是选择了传统的OpenJDK11版本，在之后可能会再使用探究（尽可能省去麻烦）。安装JDK时，路径中不能有中文和空格，并且要单独取消外部公共JRE的安装。 虚拟机 JVM ⫋ 运行环境 JRE ⫋ 开发工具 JDK 编译的编码与修改环境变量 使用命令javac 编译java文件，可能会出现中文信息乱码的情况，我们首先选择添加参数-encoding UTF8来解决问题。但博主在卸载Java11，转而安装Java9后出现的乱码问题却无法通过此方式解决。但是博主看到在一大堆的乱码报错信息前有这么一条： 1Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF-8 这可能是博主先前想通过startup.bat文件来启动tomcat10，而千方百计设置Java11环境变量遗留下来的，于是博主在环境变量中将此系统变量移除。 重新打开一个cmd窗口，执行编译命令依然乱码。只好在重启后重来一次，才成功编译。 文件名和类名 一个java文件中可以有很多类，但最多只能有一个类的类名和文件名相同——如果该类被public修饰，那么其类名必须和文件名相同，一个java文件中也最多只有一个类被public修饰。 尽管windows系统下文件名不区分大小写，但为了方便起见，以及在Linux操作系统下文件能被顺利编译执行，我们所有的java文件名及public修饰类，以及在windows控制台下运行时输入的文件名，都要保持一致的大小写！ 1234567891011E:\\Java_practice&gt;javac DEMOCONST.javaE:\\Java_practice&gt;java DEMOCONST错误: 找不到或无法加载主类 DEMOCONST原因: java.lang.NoClassDefFoundError: DemoConst (wrong name: DEMOCONST)E:\\Java_practice&gt;java DemoConstthe name of class is democonsttruefalse#可以看到，对于文件Democonst.java，大小写不一致情况下javac命令能编译，但java命令不能执行 引用路径和包在学习类和对象的时候，博主定义了两个程序，并将其放在同一个文件夹(cn)下，首先是定义一个类： 12345678910111213141516//package cn;public class Student&#123; //成员变量 String name; int age; //成员方法 public void eat()&#123; System.out.println(&quot;eat now!&quot;); &#125; public void sleep()&#123; System.out.println(&quot;sleep now!&quot;); &#125; public void study()&#123; System.out.println(&quot;study now!&quot;); &#125;&#125; 然后，是在另一个Java程序中使用这个类创建对象： 123456789//package cn;import java.io.*;//这一行可以让我们引用同一个目标文件夹下的java类public class demoStudent&#123; public static void main(String args[])&#123; Student stu = new Student(); System.out.println(&quot;student&#x27;s name is &quot;+stu.name); System.out.println(&quot;student&#x27;s age is &quot;+stu.age); &#125;&#125; 最后，我们在控制台可以编译后执行程序，注意，声明后没有被赋值的成员变量会有一个默认值（但是Java中局部变量未赋值将无法通过编译） 1234E:\\Java_practice\\cn&gt;javac -encoding UTF-8 demoStudent.javaE:\\Java_practice\\cn&gt;java demoStudentstudent&#x27;s name is nullstudent&#x27;s age is 0 而如果我们取消注释的代码，并将import java.io.*;这一行注释掉，会发现，第二个程序编译时会报错： 12345678E:\\Java_practice\\cn.itcast.demo&gt;javac -encoding UTF-8 demoStudent.javademoStudent.java:5: 错误: 无法访问Student Student stu = new Student(); ^ 错误的源文件: .\\Student.java 文件不包含类Student 请删除该文件或确保该文件位于正确的源路径子目录中。1 个错误 但是这样的写法在Eclipse软件的Java项目中又是能正常运行的，因此，博主决定探究一下Java的package机制，以及其在Windows系统下的编译机制，来确定我们命令语句该怎么输入（Eclipse和IDEA这类软件肯定是把这个步骤封装好的，不过我还是要了解这个原理）。 类是Java中一种引用数据类型（Java中除了八种基本数据类型，其它的都是对象，也就是引用类型，包括数组和字符串），对其使用以下三步走： 导包： 如果要使用的目标类，和当前类（含有main方法）位于同一个包下，可以省略导包不写； 否则需要使用import导包语句。 创建对象：类名称 对象名 &#x3D; new 类名称(); 使用。 最后，我们根据该博客提出的方法，能在命令行中正确编译并执行以上的Java文件——配置参数，编译后，返回到包名父目录，运行程序。 12345678910111213141516E:\\Java_practice\\cn&gt;javac -encoding UTF-8 -sourcepath E:/Java_practice demoStudent.java#注意！sourcepath参数这里不能带上任何一级的包名，就能正确编译E:\\Java_practice\\cn&gt;java demoStudent错误: 找不到或无法加载主类 demoStudent原因: java.lang.NoClassDefFoundError: cn/demoStudent (wrong name: demoStudent)E:\\Java_practice\\cn&gt;java cn.demoStudent错误: 找不到或无法加载主类 cn.demoStudent原因: java.lang.ClassNotFoundException: cn.demoStudentE:\\Java_practice\\cn&gt;cd ..E:\\Java_practice&gt;java cn.demoStudentstudent&#x27;s name is nullstudent&#x27;s age is 0#在控制台编译运行，使用java命令运行时要加上包名：java 包名.类名 我们重新写一下两个文件，这次弄的复杂点，我们两个文件是在多级包(cn.demo)下的： 在控制台中使用tree命令查看目录结构树，可以看到，这两个文件都放在demo文件夹下： 在控制台中的正确编译运行命令如下： 1234567891011121314E:\\Java_practice\\cn\\demo&gt;javac -encoding UTF-8 -classpath E:/Java_practice Student.javaE:\\Java_practice\\cn\\demo&gt;javac -encoding UTF-8 -classpath E:/Java_practice demoStudent.javaE:\\Java_practice\\cn\\demo&gt;cd ..E:\\Java_practice\\cn&gt;java demo.demoStudent错误: 找不到或无法加载主类 demo.demoStudent原因: java.lang.NoClassDefFoundError: cn/demo/demoStudent (wrong name: demo/demoStudent)#注意，是要在最顶级包的父文件夹下才能运行E:\\Java_practice\\cn&gt;cd ..E:\\Java_practice&gt;java cn.demo.demoStudentstudent&#x27;s name is nullstudent&#x27;s age is 0 main方法的参数args[] 所有的 Java 程序，都由 public static void main(String[] args) 方法开始执行，在一般情况下我们不会用到main方法的这个形参，但一定要加上！否则可以通过编译，但在运行时会报错： 123错误: 在类 mainFunction 中找不到 main 方法, 请将 main 方法定义为: public static void main(String[] args)否则 JavaFX 应用程序类必须扩展javafx.application.Application 我们下面来尝试下这个方法： 12345678public class mainFunction&#123; public static void main(String[] args)&#123; System.out.println(&quot;打印main方法中的输入参数：&quot;); for(String element: args)&#123; System.out.println(element); &#125; &#125;&#125; 执行结果为： 1234567891011121314151617181920E:\\Java_practice&gt;java mainFunction gogoing,ukr,xibanya...ufo -sss STK1打印main方法中的输入参数：gogoing,ukr,xibanya...ufo-sssSTK1E:\\Java_practice&gt;java mainFunction gogo--|ukr &quot;xibanya&quot; &#x27;s&#x27; ufo -sss STK1&#x27;ukr&#x27; 不是内部或外部命令，也不是可运行的程序或批处理文件。#注意这里，符号“|”会被windows控制台识别为过滤命令！所以报错E:\\Java_practice&gt;java mainFunction gogo-- ukr &quot;xibanya&quot; &#x27;s&#x27; ufo -sss STK1打印main方法中的输入参数：gogo--ukr0xibanya&#x27;s&#x27;ufo-sssSTK1#我们可以看到，输入字符串参数，是按照空格来隔开的，注意双引号的使用，单引号会正常打印 编译并执行程序 javac 可以将java格式源文件编译为class字节码文件，也就是把我们写的java代码编译成计算机能识别的内部代码；java则可以运行该class字节码文件。 在命令行中输入javac -help可以看到其用法： 用法: javac options命令行选项。sourcefiles一个或多个要编译的源文件（例如 MyClass.java） 如果源文件数量少，在命令行上列出文件名即可。 如果源文件数量多，则将源文件名列在一个文件中，名称间用空格或回车行来进行分隔。然后在 javac 命令行中使用该列表文件名，文件名前冠以 @ 字符 其中，**-encoding**，设置源文件编码名称，不设置则默认为操作系统默认的字符编码（windows下为GBK），因此我们常常发现有关编码的报错信息，我们可以使用命令javac -encoding UTF8 myclass.java来成功编译。 能为空的，是字符串（String）还是字符（Character）? Java语言提供了八种基本类型：六种数字类型（四个整数型，两个浮点型），一种字符类型（char），还有一种是布尔型。 和C语言类似，Java中的char 类型是一个单一的 16 位 Unicode 字符，最小值是 **\\u0000**（十进制等效值为 0），最大值是 **\\uffff**（十进制下等效于 65535）； Character 类用于对单个字符进行操作，在对象中包装一个基本类型 char 的值： 12345char ch = &#x27;a&#x27;;// Unicode 字符表示形式char uniChar = &#x27;\\u039A&#x27;//Character类提供了一系列方法来操纵字符，我们可以使用Character的构造方法创建一个Character类对象Character ch_object = new Character(&#x27;a&#x27;); 在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。有两种方法：使用关键字或者构造方法来创建 String 对象： 12String str = &quot;SKT&quot;;String str2=new String(&quot;SSW&quot;); 这两种方法的区别在于：String 创建的字符串存储在公共池中，而 new 创建的字符串对象在堆上。 关于这一点我们日后再进行深入探究，并和JavaScript中String()与new String()的区别做对比。 我们要注意，单个字符的char类型不能为空，但String对象可以为一个空字符串。跟C语言一样，单引号中的只能是一个字符，双引号中的只能是字符串，但该字符串可以只有单个字符！。我们在程序中依次对下面几行进行注释，然后将java文件编译执行： 12345678910111213141516171819System.out.println(&quot;&quot;);//输出一行空行System.out.println(&#x27;&#x27;);/*编译时就无法通过，会报错DEMOCONST.java:5: 错误: 空字符文字 System.out.println(&#x27;&#x27;); ^1 个错误*/System.out.println(true);//输出字符串trueSystem.out.println(false);//输出字符串falseSystem.out.println(null); //null代表空，什么都没有/*DemoConst.java:8: 错误: 对println的引用不明确 System.out.println(null); ^ PrintStream 中的方法 println(char[]) 和 PrintStream 中的方法 println(String) 都匹配1 个错误*/ for-each循环 JDK1.5 中引进的一种新的循环类型，能在不使用下标的情况下遍历数组，在Python和JavaScript中也有类似语法。注意，数组索引从0开始，不能像Python那样使用负数索引！ 1234567891011public class team &#123; public static void main(String[] args) &#123; double[] teamList = &#123;1.2, 3.4, 9.3, 5.5&#125;; // 打印所有数组元素，这里的i只是一个指代其中任一元素的作用 for (double i: teamList) &#123; System.out.println(i); &#125; System.out.println(teamList.length);//打印数组长度 System.out.println(teamList[99]);//数组越界，编译不会报错，但运行时会报错 &#125;&#125; 方法重载 类似于C语言，Java也有方法重载的效果，允许在一个类中,存在多个方法拥有不同的参数（无论是参数的个数还是类型、顺序），而却有相同的名字。比如我们要想用一个函数来实现数字相加和字符串拼接两个功能： 123456789101112131415public class mainFunction&#123; public static void main(String args[])&#123; int sum = sum(100,200); //注意！！变量的名称可以跟方法的一样，但不推荐这么写！ //不必像c语言中声明方法 System.out.println(&quot;sum(100+200) = &quot;+sum); System.out.println(sum(&quot;ssudi&quot;,&quot;+ jhderhyiu&quot;)); &#125; public static int sum(int a,double b)&#123; int result = a+b; //注意！！要运算的数据类型不一样时，结果为数据范围大的那一个类型！！ return result; &#125; public static String sum(String a,String b)&#123; return a+b; &#125;&#125; 编译后，运行结果为： 123E:\\Java_practice&gt;java mainFunctionsum(100+200) = 300ssudi+ jhderhyiu 在其他编程语言中，Python由于可以接受任何类型的参数，对于缺少的参数也可以设置为缺省参数，因此不需要也不支持函数重载。而在JavaScript中，同一个作用域内，两个名称相同的函数，后来居上——后面的函数会覆盖前面的，这是因为声明提升——函数声明和变量声明总会被解释器提升到作用域的最顶端去执行。不过，我们可以在JavaScript中实现模拟重载的效果。 局部变量和成员变量 不同之处： 定义的位置不同：局部变量定义在方法内部；成员变量直接定义在类当中，在方法外面； 内存中的位置不一样：局部变量在栈内存中，成员变量在堆内存中； 生命周期不同：局部变量随着方法的进栈而出现，方法出栈时消失；成员变量当对象被创建时出现，在对象被JVM回收，也就是垃圾回收时消失; 默认值不同：局部变量没有默认值，必须赋值后才可使用，成员变量声明后自动有一个默认值。 类方法，static修饰符 变量，可以按照两种方式划分： 按位置来分：成员变量——类中方法外的变量（有默认值），局部变量——类中方法内的变量； 按是否使用static关键字声明来分： 类变量(静态变量)：在类中使用static关键字声明，但位于方法、构造函数、块之外。无论一个类实例化多少对象，它的静态变量只有一份拷贝。为了加以区分，我们用static声明的局部变量称之为静态局部变量； 实例变量：由类生成对象时，才分配存储空间。各对象间的实例变量互不干扰，能通过对象的引用来访问实例变量。但在Java多线程中，实例变量是多个线程共享资源，要注意同步访问时可能出现的问题。 注意：static修饰的成员（字段和方法）应该使用类名.成员名访问，也可以使用对象名.成员名，但是不推荐。 成员方法：类中的方法，包含： 静态方法：被static修饰的成员方法，不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据； 实例方法：没有用关键字static修饰的成员方法。 构造方法：类中专门用来创建对象的方法，通过new关键字创建对象时就是在调用构造方法，注意一下两点： 构造方法不能写返回值类型！包括void也不能写！ 构造方法的名称必须和所在的类名称完全一致（包括大小写一致） 被static修饰的成员变量和成员方法独立于该类的任何对象。也就是说，它不依赖类特定的实例，被类的所有实例共享。只要这个类被加载，Java虚拟机就能根据类名在运行时数据区或者方法区内找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。 而用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它类的对象时，不生成static变量的副本，而是类的所有实例共享同一个static变量。 这也就意味着我们可以通过类&#x2F;对象来修改静态变量的值，比如： 1234567891011public class Cat extends Animal&#123; static String name=&quot;cattt&quot;;&#125;public class Person extends Animal&#123; public static void main(String[] args) &#123; Cat ct1 = new Cat(); ct1.name=&quot;sss&quot;; //这一句也可以换成 Cat.name=&quot;sss&quot;; System.out.println(Cat.name);//结果为sss &#125;&#125; 没有加public/private修饰符的变量，默认为public公开类型，可以被外部调用，当然这样不安全，一般采用加private修饰符，配合特定setter/getter方法的使用。 我们接着来看一下，static修饰符在类中的应用： 12345678910111213141516171819public class Person&#123; String name;String address;int age; static String country = &quot;大清&quot;; //被static修饰的静态变量 //构造方法的名称必须跟类名称相同！ public Person(String name,String address)&#123; this.name = name; this.address = address; &#125; public static void main(String[] args)&#123; Person p1 = new Person(&quot;张三&quot;,&quot;北平&quot;); Person p2 = new Person(&quot;李四&quot;,&quot;南昌&quot;); //下面我们对数值分别进行更改 p1.country = &quot;民国&quot;; //不推荐这样使用静态变量 p1.address = &quot;北京&quot;; System.out.println(&quot;p1.country = &quot;+p1.country+&quot;\\np1.address = &quot;+p1.address+&quot;\\np1.age = &quot;+p1.age); System.out.println(&quot;p2.country = &quot;+p2.country+&quot;\\np2.address = &quot;+p2.address+&quot;\\np2.age = &quot;+p2.age); &#125;&#125; 运行结果为： 1234567E:\\Java_practice\\cn\\demo&gt;java Personp1.country = 民国 p1.address = 北京p1.age = 0 #int类型的成员变量默认值为0p2.country = 民国p2.address = 南昌p2.age = 0 可以看到，我们只更改了对象p1中的country属性，但因为这是个被static修饰的静态变量，因此所有由Person类所构造的对象中，这一项属性都改变了。 静态变量与实例化我们首先写一个程序，这里有静态变量和静态方法： 123456789101112public class staticFunction&#123; int count = 0; //实例变量 static int age = 99; //静态变量 public void printCountpublic()&#123; count++; System.out.println(&quot;Now,count = &quot;+count+age); &#125; static void printCountstatic()&#123; count+=10; System.out.println(&quot;Now,count = &quot;+count); &#125;&#125; 这个程序将无法编译通过，并报错： 12345678E:\\Java_practice\\cn\\demo&gt;javac -encoding UTF-8 staticFunction.javastaticFunction.java:9: 错误: 无法从静态上下文中引用非静态变量 count count+=10; ^staticFunction.java:10: 错误: 无法从静态上下文中引用非静态变量 count System.out.println(&quot;Now,count = &quot;+count); ^2 个错误 报错原因是：静态方法只能访问静态变量；如果要让静态方法访问动态变量，必须将动态变量实例化。 继承与静态 我们创建一个父类LiYua和一个继承它的子类LiShiMing，并在父类中定义了静态变量，静态方法与实例变量，实例方法。可以看到，IDEA软件会智能提示能否使用该类&#x2F;对象的属性&#x2F;方法（在我们输入的时候可以看到在其智能提示输入中是否存在该项），时刻牢记，static修饰的静态变量&#x2F;方法，只存在一份拷贝，可以被类&#x2F;对象调用，我们可以通过子类使用它们，但这不是继承！原因：继承是对于实体而言的，而静态的东西不属于实体，也可以说，静态与类是一个级别。 但是实例变量只能在创建对象（也就是实例化）之后通过该对象进行调用： 多态，向上&#x2F;下转型 在学会继承之后，我们可以定义一个父类Animal，在其中定义一个实例方法eat，这样，无论我们定义多少个该父类下的子类（比如猫狗鸡鸭鹅），都有一个继承来的eat方法，就不必在这些子类的Java代码中编写了。那么，问题来了，如果我们要编写一个feed方法来代表喂养动物，由于这些动物的子类是不同的，意味着作为传入到feed函数中的参数也是不同的类，那我们岂不是要在代码中重载（在一个类中的叫重载，子类对父类方法的叫重写）很多个feed方法？ 123public void feed(Cat cat01)&#123;&#125;public void feed(Dog dg01)&#123;&#125;... 事实上我们不用这么干，只需要利用多态的向上转型：类的对象赋给了父类的引用，这样的缺点是屏蔽掉子类中特有的方法，然后我们只定义参数为父类Animal型对象的一个feed函数即可，比如： 123Animal ani1 = new Cat();Animal ani2 = new Dog();public void feed(Animal ani)&#123;ani.eat();&#125; 但是，这样子，对象ani2这只狗只是被当作动物看待，无法使用Dog子类中的一个特有方法guard，为了解决这一点，我们可以使用向下转型： 123456789101112131415161718192021public class Person extends Animal&#123; static Animal ani1 = new Cat(); //向上转型——子类的对象赋给了父类的引用，猫狗当做动物来看，会屏蔽掉类中特有的方法 Animal ani2 = new Dog(); public static void main(String[] args) &#123; Animal ani0 = new Person(); Person pr = new Person(); //ani0.feed(ani1);这一个就报错了，原因在于ani0已经向上转型成父类型Animal，没有了feed函数 pr.feed(ani1); //pr.feed(ani2);这一处的错误在于ani2没有被我们定义成静态变量而是实例化变量 Animal ani3 = new Dog(); //ani3.guard(); 输入ani3后，在IDEA给的输入提示里面选择guard，会自动将ani3.guard修改为((Dog) ani3).guard(); Dog dg = (Dog) ani3;//向下转型 dg.guard(); &#125; public void feed(Animal ani)&#123; ani.eat(); &#125; public void feed(Cat ct)&#123;ct.eat();&#125;&#125; 在Java中由于继承和向上转型的存在，子类型可以非常自然地转成父类，但向下转型，即父类转子类，必须强制转型。Java中的基本数据转型也是强制转型。 注意，如果子类重写了父类的方法，子类对象向上转型之后，调用的还是重载之后的子类方法。 一个子类，只能继承一个父类，但可以实现多个接口 接口这一块主要是架构师来负责的内容。我们定义两个接口Valuable和Protectable，由类Panda来继承父类Animal，并实现这两个接口，如上面所说的，执行的是子类Panda对象的eat方法，重写后将父类的覆盖了： 注意，无论抽象类还是实体类都只能implements实现接口，能extends继承接口的只能是接口，接口可以继承多个接口。 instanceof关键字与父子类 根据相关定义： instanceof 是 Java 的一个二元操作符，类似于 &#x3D;&#x3D;，&gt;，&lt; 等操作符。作用是测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型。 我们用下面一个例子来说明，Panda是继承自Animal的子类，可以看到，子类对象既是子类的实例，又是父类的实例，但反过来就不是了： 12345678910Panda panda = new Panda();System.out.println(panda instanceof Panda);//trueSystem.out.println(panda instanceof Animal);//trueAnimal animal = (Animal)panda;System.out.println(animal instanceof Panda);//trueAnimal yuan = new Animal();//Panda panda1 = (Panda)yuan; 这种做法是不被允许的！System.out.println(yuan instanceof Panda);//falsePanda panda2 = (Panda)animal;System.out.println(panda2 instanceof Panda);//true 被注释掉的那行代码Panda panda1 = (Panda)yuan会报错，是因为这并不是向下转型——Java中，只有是由子类对象向上转型转成的父类对象，才能向下转型又再次成为子类对象！！ 静态构造器又称静态构造函数，是实现对一个类进行初始化的方法成员，一般用于对静态数据的初始化（静态变量也是最先初始化的）。静态构造函数不能有参数，不能有修饰符，不能被调用。当类被加载时，类的静态构造函数自动被调用。因此，在一个程序的执行过程中，静态构造器最多执行一次。注意执行顺序： 静态构造器在任何类的静态成员被引用之前执行； 静态构造器在任何类的实例变量被分配之前执行； 静态构造器在类的静态成员初始化之后执行，或者说编译器会将静态成员初始化语句转换成赋值语句放在静态构造器执行的最开始。 我们用下面这个例子来实践一下： 123456789101112131415public class staticTest&#123; &#123; System.out.println(&quot;这里是通用构造器&quot;); &#125; static&#123; System.out.println(&quot;静态构造器&quot;); &#125; public staticTest()&#123; System.out.println(&quot;构造方法&quot;); &#125; public static void main(String[] args)&#123; //在主方法中调用构造方法，创建一个对象，就不用再写一个java程序来验证了 new staticTest(); &#125;&#125; 运行结果如下，可以看到，静态构造器是最先被执行的。 1234E:\\Java_practice\\cn\\demo&gt;java staticTest静态构造器这里是通用构造器构造方法 在有继承的情况下，执行顺序为：父类静态代码块 &gt; 子类静态代码块 &gt; 父类构造代码块 &gt; 父类构造器 &gt; 子类构造代码块 &gt; 子类构造器 Java语言中，标准类（pojo类） POJO的全称为plain old java object，可以翻译成：普通Java类。主要用于数据的临时传递，但它只能装载数据， 作为数据存储的载体，而不具有业务逻辑处理的能力，也就是说，POJO类中不允许有业务方法，也不能携带connection之类的方法。 **标准类的四个必要组成部分**（四个必要条件） 所有的成员变量都要使用 private 关键字进行修饰； 为每一个成员变量编写 set、get 方法； 创建一个无参数的构造方法； 创建一个有参数的构造方法。 pojo类和java bean的关系 博客 按着Sun公司的定义，Java Bean是一个可重复使用的软件组件。实际上Java Bean是一种Java类，通过封装属性和方法成为具有某种功能或者处理某个业务的对象，简称bean。 JavaBean 是一种JAVA语言写成的可重用组件，不是一种技术，而是一种规范，它的方法命名，构造及行为必须符合特定的约定： 这个类必须有一个公共的缺省构造函数； 这个类的属性使用getter和setter来访问，其他方法遵从标准命名规范; 这个类应是可序列化的（一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象——详见类的序列化）。 Java Bean的任务可以概括为: “Write once, run anywhere, reuse everywhere”，即“一次性编写，任何地方执行，任何地方重用”。可分为两种： 是有用户界面（UI，User Interface）的Java Bean； 没有用户界面，主要负责处理事务（如数据运算，操纵数据库）的Java Bean（部署于网络服务器上的JSP，又称JavaServer Pages，通常访问的是这一种Java Bean）。 简而言之，当一个PoJo可序列化，有一个无参的构造函数，使用getter和setter方法来访问属性时，他就是一个Java Bean。 然而，通常情况下，由于 Java Bean 是被容器所创建（如 Tomcat) 的，所以 Java Bean 应具有一个无参的构造器，另外，通常 Java Bean 还要实现 Serializable 接口用于实现 Bean 的持久性。 Java Bean 是不能被跨进程访问的。一般在web应用程序中建立一个数据库的映射对象时，我们只能称它为POJO——一个普通Java对象，而不是一个特殊的对象，其主要用来指代那些没有遵从特定的Java对象模型、约定或框架（如EJB）的Java对象。理想地讲，一个POJO是一个不受任何限制的Java对象（除了Java语言规范） Java中还有很多特定类（entity、 VO 、DTO等）的概念和作用，我们详见好心人整理的专栏和博客。 我们再顺便了解另一个概念：entity(实体类) 通常定义在model层里面，一个实体映射一张表，其中的属性对应数据表中的字段，，一般无业务逻辑代码。 entity类也要满足普通JavaBeans类的四个必要条件，这篇博客还介绍了entity的其他优点： 对象实体的封装，体现OO(Object Oriented面向对象)思想——Java是面向对象的语言，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，并使系统更加灵活和易于维护，缺点是性能比面向过程的低； entity类中的属性可以对字段定义和状态进行判断和过滤； 一个数据库表映射成一个实体类，对数据库操作起来方便（在程序中可以把实体类作为参数传递），使程序员程序员在对数据库操作的时候不用写SQL语句,专注逻辑关系。换句话说，实体类就是把对某一个数据表（table）的操作全写在一个类里面：创建一个Entity Bean对象相当于创建一条记录，删除一个Entity Bean对象会同时从数据库中删除对应记录，修改一个Entity Bean时，容器会自动将Entity Bean的状态和数据库同步。 另外，在Java开发中对于定义entity类的总结经验如下： 实体类的名字尽量和数据库的表的名字对应相同； 实体类应该实现java.io.Serializable接口； 实体类应该有个无参的构造方法； 实体类应该至少有一个有参数的构造方法； 实体类有属性和方法，属性对应数据库中表的字段，主要有getter和setter方法。 实体类还应该有个属性serialVersionUID。例如：private static final long serialVersionUID = -6125297654796395674L; 在实体类中，属性一般是private类型，而方法为public类型，对于数据库自动生成的ID字段对应的属性的set方法应为private。 引用和引用数据类型Java中的数据类型可以分为两类，基本数据类型（只有八种），其他的都是**引用数据类型：类(class)、 接口类型(interface)、 数组类型(array)、 枚举类型(enum)、 注解类型(annotation)、 字符串型(string)**（这些都在java.lang.*下），如果我们不定义的话，这些都默认为强引用基本数据类型和引用数据类型区别： 存储位置： 基本变量类型：在方法中定义的非全局基本数据类型变量的具体内容是存储在栈中的 引用变量类型：具体内容都是存放在堆中的，而栈中存放的是其具体内容所在内存的地址（通过变量地址可以找到变量的具体内容，就如同通过房间号可以找到房间一般） 传递方式： 基本类型变量：在方法中定义的非全局基本数据类型变量，调用方法时作为参数是按数值传递的 引用类型变量：调用方法时作为参数是按引用传递的，传递的是引用的副本 Java注解 Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。在编译时注解会被检查，但执行的时候不会被执行到。 Java 语言中的类、方法、变量、参数和包等都可以被标注。和 Javadoc 不同，Java 标注可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 ，Java也支持自定义 Java 标注。 Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。 作用在代码的注解是 @Override - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。 @Deprecated - 标记过时方法。如果使用该方法，会报编译警告。 @SuppressWarnings - 指示编译器去忽略注解中声明的警告。 作用在其他注解的注解(或者说 元注解)是: @Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。 @Documented - 标记这些注解是否包含在用户文档中。 @Target - 标记这个注解应该是哪种 Java 成员。 @Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类) 从 Java 7 开始，额外添加了 3 个注解: @SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。 @FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。 @Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。 以重写的@Override注解为例，即使我们不在重写方法的上一行加上此注解，依然可以运行，只是不方便后续程序维护（比如重写的函数名写错的情况） 包装类 包装类：将基本数据类型封装成一个类，包含的方法基本相同。java中的包装类提供了将原始数据类型转换为对象，以及将对象转换为原始数据类型的机制。包装类属于引用数据类型， 其中6个包装类（Double、Float、Byte、Short、Integer 以及 Long）都是 Number 这一个抽象类（因此其不能直接实例化，而是必须实例化其具体的子类）的子类。java.lang.Number的父类是Object类。 Object 类存储在**java.lang.包中，是所有java类 (Object 类除外)的终极父类。Java中规定：如果一个类没有显式声明它的父类，那么默认这个类的父类就是java.lang.Object 。注意，子类是抽象类，父类也不一定是抽象类*（比如Object 是具体类，却是Number的父类，只要子类添加了自己的抽象方法，子类就必须是抽象类而无论其父类是不是。不过父类是具体类，而其唯一的子类是抽象类的情况没有使用的必要） 原始类型不能为null，但包装类可以为null，因此包装类可用于实现多态性。 基本数据类型 包装类型 该包装类的父类 byte java.lang.Byte java.lang.Number short java.lang.Short java.lang.Number int java.lang.Integer java.lang.Number long java.lang.Long java.lang.Number float java.lang.Float java.lang.Number double java.lang.Double java.lang.Number boolean java.lang.Boolean java.lang.Object char java.lang.Character java.lang.Object 包装类的构造方法： Integer(int number);传入一个int值.获取一个Integer类.来操作； Integer(String str); 传入一个字符串.用字符串来获取Integer对象我们要注意两个名词：装箱和拆箱 装箱：基本数据类型–(转换为)–&gt;引用数据类型拆箱：引用数据类型–(转化为)–&gt;基本数据类型在JDK1.5之后，支持自动装箱和自动拆箱机制了。自动装箱：基本数据类型自动转换成包装类。自动拆箱：包装类自动转换成基本数据类型。 Java集合类 Java集合类存放于 java.util 包中（需要收到import引入），是一个用来存放对象的容器。 注意：①、集合只能存放对象。比如你存一个 int 型数据 1放入集合中，其实它是自动转换成 Integer 类后存入的，Java中每一种基本类型都有对应的引用类型。 ②、集合存放的是多个对象的引用，对象本身还是放在堆内存中。 ③、集合可以存放不同类型，不限数量的数据类型。 定义集合的示例：ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); 集合类体系结构 12345678910111213graph TDA(集合)--&gt;B1(Collection)A--&gt;B2(Map) B1--&gt;C1(List) C1--&gt;E1(ArrayList) C1--&gt;E2(LinkedList) C1--&gt;E3(.....) B1--&gt;C2(Set) C2--&gt;F1(HashSet) C2--&gt;F2(TreeSet) C2--&gt;F3(.....) B2--&gt;D1(HashMap) B2--&gt;D2(....) 其中，最底层的是具体的实现类，而第二、三层的诸如Collection，Map，List，Set和HashMap等实际只是接口。Set和List区别在于其中元素能否重复。和单列的Collection不同，Map是“key -&gt; value”对的存储方式，即双列结构。runoob网站中对此有一个简单的介绍： Java 集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键&#x2F;值对映射。Collection 接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap 等等。 注意，JDK不提供单例集合的顶层接口——Collection的任何直接实现，而只提供更具体的子接口（Set和List等）的实现，这很正常，毕竟这些数据结构差别太大。注意Collection和Collections的区别： java.util.Collection 是一个 集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。 而java.util.Collections 是一个包装类。它包含有各种有关集合操作的 静态多态方法。此类 不能实例化，就像一 个工具类，服务于Java的Collection框架。 创建Collection集合对象的方式有以下两种： 通过多态：比如Collection &lt;String&gt; c = new ArrayList&lt;String&gt;();其中“&lt;&gt;”中是集合汇总元素的类型。集合类的定义： 集合类是放在java.util.*；这个包里。集合类存放的都是对象的引用，而非对象本身，为了说起来方便些，我们称集合中的对象就是指集合中对象的引用(reference)。引用的概念大家不会忘了吧，在前边我们讲数据类型时讲的。 集合类型主要有3种：set(集)、list(列表)、map(映射)和Queue(队列)。&#x2F;&#x2F;队列为jdk5中的加上的 12345678910111213141516public class collection_demo &#123; public static void main(String[] args) &#123; ArrayList arrayList = new ArrayList(); arrayList.add(&quot;adc&quot;); arrayList.add(1222); System.out.println(arrayList); Collection ap = new ArrayList&lt;Integer&gt;();//这么写没有问题 //Collection是一个接口，new的是接口的实现类ArrayList，像我们上边所讲的 ap.add(&quot;jdsi&quot;); System.out.println(ap); Collection &lt;Integer&gt; ad = new ArrayList&lt;Integer&gt;(); ad.add(&quot;jdsi&quot;);//会报错 java: 不兼容的类型: java.lang.String无法转换为java.lang.Integer ad.add(8); System.out.println(ap); &#125;&#125; 使用具体的实现类ArrayList Collection集合的遍历——迭代器的使用 runoob的集合框架中这么描述迭代器： Java Iterator（迭代器）不是一个集合，它是一种用于访问集合的方法，可用于迭代 ArrayList 和 HashSet 等集合。 Iterator 是 Java 迭代器最简单的实现，ListIterator 是 Collection API 中的接口， 它扩展了 Iterator 接口。 在JDK 11文档中Collection集合的方法下可以找到一个iterator方法，是返回此集合中元素的迭代器。其返回值的变量类型为Iterator&lt;E&gt;。 Iterator&lt;E&gt;中常用的方法有： 变量和类型 方法 描述 default void forEachRemaining(Consumer&lt;? super E&gt; action) 对每个剩余元素执行给定操作，直到处理完所有元素或操作引发异常。 boolean hasNext() 如果迭代具有更多元素，则返回 true 。 E next() 返回迭代中的下一个元素。 default void remove() 从底层集合中移除此迭代器返回的最后一个元素（可选操作）。 其中，java中&lt;E**&gt;是表示泛型，就是指任意类型，这也符合next函数返回迭代中下一个元素的作用。类似的java 中泛型标记符：**为了易于分辨，约定俗成的写法有以下这几种： E - Element (在集合中使用，因为集合中存放的是元素) T - Type（Java 类） K - Key（键） V - Value（值） N - Number（数值类型） ？ - 表示不确定的 java 类型 Java中迭代器的使用： 1234567Collection&lt;String&gt; c = new ArrayList&lt;String&gt;();//创建集合对象，这里的对象是String类型，我们当然也可以用自定义的类，比如Collection&lt;Student&gt;创建学生类的集合对象c.add(&quot;hello&quot;);c.add(&quot;world&quot;);c.add(&quot;java&quot;);Iterator&lt;String&gt; it = c.iterator();//通过集合对象获取迭代器对象，注意类型要相同System.out.println(&quot;it = &quot;+it);//it = java.util.ArrayList$Itr@5ebec15System.out.println(it.next());//helloSystem.out.println(it.next());//worldSystem.out.println(it.next());//java 如果迭代没有更多元素，那么next方法将会抛出异常NoSuchElementException。 注意，如果给Set集合添加两个相同的元素，不会报错，但Set集合中只会存在一个元素。 Java中有四种引用——引用强度和生命周期长度依次为：强引用&gt;软引用＞弱引用＞虚引用。（JDK1.2之后的引用概念扩充） 强引用默认声明的就是强引用，比如Object obj = new Object()，只要obj还指向Object对象（也就是强引用还存在），Object对象就不会被垃圾回收器回收。即使内存不足时，JVM也会直接抛出OutOfMemoryError而不会去回收。若想中断强引用与对象之间的联系，可以将强引用赋值为null。另外的，字符串String str = new String();也是强引用类型，不过使用时是默认导入了java.lang.String包（java.lang.*不用我们导入，编译器会自动导入） 软引用描述一些非必需但仍有用的对象。在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。在 JDK1.2 之后，用java.lang.ref.SoftReference类来表示软引用。 弱引用在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存——也就是说，无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收。在 JDK1.2 之后，用 java.lang.ref.WeakReference 来表示弱引用。 虚引用又称为“幽灵引用”或“幻影引用”，最弱的一种引用关系，其存在与否，不会对对象的生存产生任何影响，且也无法通过虚引用来获得对象实例。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收。创建虚引用需要使用java.lang.ref.PhantomReference。这个类的源码中只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象。与软引用、弱引用不同的是，虚引用必须要和 ReferenceQueue 引用队列一起使用。 引用队列引用队列可以与软引用、弱引用以及虚引用一起配合使用（强引用自然不行），当垃圾回收器准备回收一个对象时，如果发现它还有引用，那么就会在回收对象之前，把这个引用加入到与之关联的引用队列中去。程序可以通过判断引用队列中是否已经加入了引用，来判断被引用的对象是否将要被垃圾回收，这样就可以在对象被回收之前采取一些必要的措施。牢记：虚引用必须和引用队列一起使用。 接口类型的变量 Java中接口不能实例化对象，但可以使用接口类型来声明一个变量，使其成为一个空指针，或是被绑定在一个以此接口实现的对象。 12345678910111213/*！这种方式是错误的，能实例化对象的必须是具体类！public interface Person&#123;&#125;Person person = new Person();*///实现接口的子类可以通过创建对象赋值给接口//声明变量被绑定在一个以此为接口实现的对象public interface Anim&#123;&#125;public class Cat implements Anim&#123;&#125;Anim anim = new Cat();//注意，子类创建对象赋值给接口后，接口再赋值给子类需要强制转换Anim anim = new Cat();Cat cat = (Cat)anim; 类与导包import所有的类都需要导包才能使用，除了两种情况： 要使用的目标类，和当前类位于同一个包（package）下； 要使用的目标类，位于java.lang包下，但是不包含子包内容（比如路径C:\\Program Files\\Java\\jdk-11.0.2\\lib\\src\\java.base\\java\\lang\\reflect下的Field.java这一个类，就需要引用） 我们使用的字符串对象，是String类，其实就属于第二种情况，在博主使用的JDK11版本中，我们可以在路径C:\\Program Files\\Java\\jdk-11.0.2\\lib\\src\\java.base\\java\\lang看到文件String.java。 字符串是对象，却可以原封不动打印出来，是因为println方法的判断逻辑： 若是字符串类型，直接显示内容； 若不是字符串类型，就将其内部通过某些方法转换成字符串再显示（参考定义println方法的源码可知，比如int基本数据类型的会被String.valueOf方法转换为字符串类型）； 最终打印出来的一定是字符串类型。 比方说，我们引入一个使用自定Employee类的程序： 1234567import java.io.*;public class Demo_println&#123; public static void main(String[] args)&#123; Employee adc = new Employee(&quot;adcssss&quot;); System.out.println(adc); &#125;&#125; 控制台中的打印结果： 123E:\\Java_practice&gt;java Demo_printlnEmployee@512ddf17#一般的对象都是使用“类型信息+@+地址值”来作为字符串内容 类、实例与Class类、Class对象通俗约定，Java中类用class(首字母小写)来表示。前面我们知道，new 一个对象，就是对类的实例化。 类的生命周期：加载—验证—准备—解析—初始化—使用—卸载 Class，注意首字母大写！在java中是一个实际存在的类，在包java.lang下，有一个Class.java文件，jdk 11文档中对其有如下描述： 模块 java.base 软件包 java.lang Class Class java.lang.Object java.lang.Class 参数类型 T - 此类对象建模的类的类型。 例如， String.class的类型是Class&lt;String&gt; 。 如果正在建模的类未知，请使用Class&lt;?&gt; 。 实现的所有接口 Serializable ， AnnotatedElement ， GenericDeclaration ， Type 123public final class Class&lt;T&gt;extends Objectimplements Serializable, GenericDeclaration, Type, AnnotatedElement 类类实例表示正在运行的Java应用程序中的类和接口。枚举类型是一种类，注释类型是一种接口。每个数组也属于一个类，该类反映为类对象，由具有相同元素类型和维数的所有数组共享。原始Java类型（ boolean ， byte ， char ， short ， int ， long ， float ，和double ），以及关键字void也表示为类对象。 类没有公共构造函数。 而是当类加载器调用defineClass方法之一并传递class文件的字节时，Java虚拟机会自动构造类对象。 类类的方法暴露了类或接口的许多特征。 大多数特性派生自类加载器传递给Java虚拟机的class文件。 一些特性由运行时的类加载环境决定，例如getModule()返回的模块。 类类某些方法公开Java源代码中的类或接口的声明是否包含在另一个声明中。 其他方法描述了类或接口如何位于嵌套中 。 nest是一组类和接口，在同一运行时包中，允许相互访问其private成员。 类和接口称为nestmates 。 一个巢穴充当巢主 ，并列举属于巢的其他巢穴; 它们中的每一个又将其记录为嵌套主机。 属于嵌套的类（包括其主机）的类和接口是在生成class文件时确定的，例如，Java编译器通常会将顶级类记录为嵌套的主机，其中其他成员是类，声明包含在顶级类声明中的接口。 在Java里，所有的类，包括Class类（又称为“类类”）的根源都是Object类。Class是继承自Object的一个特殊的类，内部可以记录类的成员、接口等信息——在Java中，Class是一个用来表示类的类，可以为其创建实例——Class对象（Class实例）。 Java中对象可分为两种：实例对象和Class对象。每个类的运行时的类型信息就是用Class对象表示的。它包含了与类有关的信息。实例对象其实是通过Class对象来创建的。Java使用Class对象执行其RTTI（运行时类型识别，Run-Time Type Identification），多态是基于RTTI实现的。 每一个类都有一个Class对象，每当编译一个新类就产生一个Class对象，基本类型 (boolean, byte, char, short, int, long, float, and double)有Class对象，数组有Class对象，就连关键字void也有Class对象（void.class）。Class对象对应着java.lang.Class类，如果说类是对象抽象和集合的话，那么Class类就是对类的抽象和集合。 Class对象只能由系统建立对象，没有公共的构造方法，Class对象是在类加载的时候由Java虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的，因此不能显式地声明一个Class对象。一个加载的类在JVM中只会有一个Class实例，一个Class对象对应的是一个加载到JVM中的一个.class文件。每个类的实例都会记得自己是由哪个Class实例所生成，因此通过Class可以完整地得到一个类中所有被加载的结构。每一个一个类被加载到内存并供我们使用需要经历如下三个阶段：加载-&gt;链接-&gt;初始化： 加载：由类加载器（ClassLoader）执行的。通过一个类的全限定名来获取其定义的二进制字节流（Class字节码），将这个字节流所代表的静态存储结构转化为方法去的运行时数据接口，根据字节码在java堆中生成一个代表这个类的java.lang.Class对象。 链接：在链接阶段将验证Class文件中的字节流包含的信息是否符合当前虚拟机的要求，为静态域分配存储空间并设置类变量的初始值（默认的零值），并且如果必需的话，将常量池中的符号引用转化为直接引用。 初始化：此阶段才真正开始执行类中定义的java程序代码。执行该类的静态初始器和静态初始块，如果该类有父类的话，则优先对其父类进行初始化。 注意，所有的类都是在对其第一次使用时，动态加载到JVM中的（懒加载）。当程序创建第一个对类的静态成员的引用时，就会加载这个类。使用new创建类对象的时候也会被当作对类的静态成员的引用。因此java程序程序在它开始运行之前并非被完全加载，其各个类都是在必需时才加载的，这一点与许多传统语言如C++，都不同。 Class类是Java反射机制的根源，对于任何我们想动态加载运行的类，必须先获得其相应的Class对象。 Java中提供了下面3种获取到类的Class对象的方法： 利用对象实例，调用getClass()方法获取该对象的Class实例：Class cla=Person.getClass()； 使用Class类的静态方法forName(“包名+类名”)，用类的名字获取一个Class实例，注意要抛出异常ClassNotFoundException：Class cla =Class.forName(&quot;demo01.Student&quot;) ； 运用“类名.class”的方式来获取Class实例，最安全可靠，性能高：Class clazz = Person.class； 对于内置基本数据类型，都有一个TYPE属性： 12Integer go = 99;System.out.println(int.class);//int 使用ClassLoader 一些重要的Class类方法 getname()：以string类型返回class对象表示的实体（类，接口，数组，基本类型，void等）名称 newInstance():创建一个实例，只能调用默认构造器。（JDK1.9版本，即Java9之后被弃用） getSuperclass():返回class表示的实体超类(父类)的名称 getSimpleName()。不办含包名的类名。 isInterfence:告诉你这个class对象是否表示某个接口。 Class.forName():返回一个类对象，会引发加载过程，也就是说JVM会执行该类的静态代码段，静态代码是和class绑定的，class装载成功就表示执行了你的静态代码了。执行了”加载—验证—准备—解析—初始化（类的初始化）“，即将一个类加载到内存中，并最终形成虚拟机直接使用的Java类型。这个过程会执行static块。 简单地说，一个类在内存中只有一个Class对象，该类被加载后，类的整个结构都会被封装在Class对象中。 怎么理解呢？比方我们创建一个test02.java文件，在其中通过反射获取类的Class对象： 12345678910package com.kuang.demo01;public class test02 &#123; public static void main(String[] args) throws ClassNotFoundException&#123; //forName方法会抛出异常java.lang.ClassNotFoundException Class c1 = Class.forName(&quot;com.kuang.demo01.User&quot;); System.out.println(c1);//打印：class com.kuang.demo01.User System.out.println(c1.hashCode());//返回Java对象唯一的hash值 &#125;&#125;class User&#123;/*这里是一个实体类，不用定义什么*/&#125; java中hash值，“&#x3D;&#x3D;”符号与equals方法 “&#x3D;&#x3D;”符号直接比较两个对象的堆内存地址，相等则说明两个引用是指向同一个对象地址的。对于8种基本数据类型，在常量池中，一个常量只会对应一个地址。对于基本数据的包装类型（Byte，Short，Character，Integar，Float，Double，Long，Boolean），其中除了Float和Double外，也都实现了常量池，因此一般也可以直接通过“&#x3D;&#x3D;”符号来判断是否相等 注意，常量池中的存储范围！ 网上大部分博客，认为equals方法比较的是对象的内容，这不完全准确，在java.lang.Object包，源代码Object.java文件中是这么描述这个函数的： 123public boolean equals(Object obj) &#123; return (this == obj);//直接通过“==”运算符来比较，二者没有任何区别&#125; 之所以说equals方法与“&#x3D;&#x3D;”运算符有所不同，是因为可以自己重写equals方法，比如： 123456789101112@Overridepublic boolean equals(Object obj) &#123;//形参类型Object，重载 if(this == obj)return true; if((obj==null)||(obj.getClass()!=this.getClass()))return false;//返回此Object的运行时类 test02 test = (test02) obj;//向下转型 return num==test.num &amp;&amp; (data==test.data||(data!=null&amp;&amp;data.equals(test.data)));&#125;@Overridepublic int hashCode() &#123; return Objects.hash(num,data);&#125; 重写equals方法的同时也要重写hashCode方法原因如下： 要维护hashCode方法的常规约定：值相同的对象必须有相同的hashCode(输入的值相同，采用一样的hash算法，所得出的结果也必须相同)； 向一个Hash结构的集合中添加某个元素，集合会首先调用hashCode方法，以直接定位该元素存储的位置，若该处没有其他元素，则直接保存；若已有其他元素存在，就调用equals方法判断两个元素是否相同，相同则不存，不同则散列到其他位置——hashCode为一个int值，比较起来速度更快，效率更高。 1public native int hashCode(); native 修饰符主要用于方法上： Java本身不能对操作系统底层进行访问和操作，但可以通过Java Native Interface(即JNI，Java本机接口)调用其他语言来实现对底层的访问； 一个native方法就是一个Java程序调用非Java代码的接口，native方法由其他编程语言来实现； 定义一个native方法时，不提供实现体。 可见，Java原生的hashCode是一个本地方法，其实现与本地机器有关。 new 方式和Class.forName()的区别： newInstance( )是一个方法，而new是一个关键字。创建对象的方式也不一样，前者是使用类加载机制，后者是创建一个新类； Class下的newInstance()的使用有局限，因为它生成对象只能调用无参的构造函数，而使用 new关键字生成对象没有这个限制； 简言之： newInstance(): 弱类型，低效率，只能调用无参构造。 new: 强类型，相对高效，能调用任何public构造。 Class.forName(“”)返回的是类。 Class.forName(“”).newInstance()返回的是object 。 IO流与其他语言相比，Java具有独特的输入和输出机制，Java的I&#x2F;O建立在流（stream）之上： 输入流读取文件，输出流写入文件，不同的流类，如java.io.FileInputStream和sun.net.TelnetOutputStream会读&#x2F;写某个特定的数据源，但是所有的输出流都有相同的基本方法来写入数据，所有的输入流使用相同的基本方法来读取数据。创建一个流之后，读&#x2F;写时通常可以忽略读&#x2F;写的具体细节。 过滤器流（filter）可以串链到输入流或输出流上。读&#x2F;写数据时，过滤器可以修改数据（例如，通过加密或压缩），或者只是提供额外的方法，将读&#x2F;写的数据转换为其他格式。例如，java.io.DataOutputStream类就提供了一个方法，将int转换为4字节，并把这些字节写入底层的输入流。 阅读器（reader）和书写器（writer）可以串链到输入和输出流上，允许程序读&#x2F;些文本（即字符） 而不是字节。只要正确的使用，阅读器和书写器可以处理很多字符编码，包括多字节字符即SJIS和UTF-8。 流是同步的，也就是说，当程序（确切的讲是线程）请求一个流读&#x2F;写一段数据时，在任何其他操作时，它要等待所读&#x2F;写的数据。 Java还支持使用通道和缓冲区的非阻塞I&#x2F;O。非阻塞I&#x2F;O稍微有些复杂，但在某些高吞吐量的应用程序中（如web服务器），非阻塞I&#x2F;O要快的多。通常情况下，基本流模型就是实现客户端所需要和应当使用的全部内容。由于通道和缓冲区依赖于流，下面首先介绍流和客户端。 IO流分类： 按照数据流向分： 输入流：写数据 输出流：读数据 按照数据类型分： 字节流：字节输入流，字节输出流 字符流：字符输入流，字符输出流 IO流的分类一般按照数据类型划分，区别使用字节流和字符流的一个小技巧： 如果数据能通过Window系统自带的记事本软件打开，且其中的内容没有乱码则使用字符流；否则使用字节流。当不确定使用哪种类型的流时，使用字节流。 输入流写数据 打开jdk11API中文文档，在“搜索”一栏输入InputStream可以查看该类相关信息： wiki12345678910模块 java.base 软件包 java.io Class InputStreamjava.lang.Object java.io.InputStream 实现的所有接口 Closeable ， AutoCloseable 已知直接子类： AudioInputStream ， ByteArrayInputStream ， FileInputStream ， FilterInputStream ， ObjectInputStream ， PipedInputStream ， SequenceInputStream ， StringBufferInputStream 该抽象类java.io.InputStream位于java.io这个package下，是表示输入字节流的所有类的超类 可以使用字符串类型的文件名来创建一个输入流对象来读取文件： 12InputStream f = new FileInputStream(&quot;C:/java/hello&quot;);//如上所示，这里用的是向上转型的方法，子类转父类 注意，IO类的定义要搭配异常处理（比如在函数签名尾部用throws关键字声明 IOException） 原因在于：FileInputStream、FileOutputStream的构造器用throws关键字声明了FileNotFoundException异常，而且该构造器的代码中判定如果文件无效就用throws关键字抛出异常对象，这是因为Java设计考虑到IO操作时文件路径不存在等异常情况。这一块我们也可以参考Java的父子异常处理。 123456789101112131415161718192021import java.io.FileOutputStream;import java.io.IOException;//注意，IO类要我们手动导入public class FileOutputStreamDemo01 &#123; public static void main(String[] args) throws IOException &#123; //创建字节流输出对象，这里的路径命名要注意 FileOutputStream fos = new FileOutputStream(&quot;E:\\\\Java_practice\\\\web_study\\\\fos.txt&quot;); /* * 做了三件事情： * 1. 调用系统功能创建了文件 * 2. 创建了字节输出流对象 * 3. 让字节输出流对象指向创建好的文件 * */ //将指定的字节写入此文件输出流 fos.write(98); //所有和IO相关的方法最后都要释放资源 fos.close(); &#125;&#125; 代理 Java 的代理——客户类不再直接和委托类打交道, 而是通过一个中间层来访问, 这个中间层就是代理，代理有 2 个优势： 可以隐藏委托类的实现； 可以实现客户与委托类之间的解耦, 在不修改委托类代码的情况下能够做一些额外的处理 静态代理 方式：开发者自己手动创建或者在程序运行前就已经存在的代理类 场景：需求增强的需要——假设已经有学生、老师两个类，均继承Person接口的chifan()方法，现有一程序Test.java将会定义一个Student类，并运行其chifan()函数。现要增强功能，比如“学生吃饭前要跑步一圈”，而我们不应在Student这一委托类中加上该功能。 使用静态代理方法，要求我们新建一个代理类ProxyStudent，在其中添加要增强的功能，该类同样要实现Person接口： 1234567891011121314public class ProxyStudent implements Person&#123; private Student s; //初始化 public ProxyStudent()&#123; this.s = new Student(); &#125; @Override public void chifan()&#123; //这里可以定义我们要增强的功能，而不必去修改Student类 System.out.println(&quot;学生吃饭前先跑一圈&quot;); //函数核心功能还是Student对象的 s.chifan(); &#125;&#125; 动态代理 Java 的动态代理中, 主要涉及 2 个类，java.lang.reflect下的InvocationHandler和Proxy。详见文章 Lambda表达式 也称为闭包，是Java8之后的特性， 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。使用条件： 接口中只有一个抽象方法的接口(函数式接口) 分为两种：显示Lambda表达式会声明参数类型，隐式Lambda表达式则不声明所有参数类型，由编译器自己推断。 12345(String msg) -&gt; &#123;System.out.println(msg);&#125; //后边一段即lambda表达式，可以用隐式写法，省略参数类型(msg)-&gt;&#123;System.out.println(msg);&#125;//对于单个参数lambda表达式，我们在省略了参数类型的前提下，还可以省略括号。msg-&gt;&#123;System.out.println(msg);&#125; 注意！对于没有参数的lambda表达式，我们仍然需要括号，如: () -&gt; &#123; System.out.println(&quot;hi&quot;); &#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://justskim.github.io/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://justskim.github.io/tags/java/"}]},{"title":"tomcat下startup.bat启动报错详解","slug":"tomcat下startup.bat启动报错详解","date":"2022-03-01T03:10:04.038Z","updated":"2022-04-09T09:12:54.075Z","comments":true,"path":"2022/03/01/tomcat下startup.bat启动报错详解/","link":"","permalink":"http://justskim.github.io/2022/03/01/tomcat%E4%B8%8Bstartup.bat%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"tomcat下startup.bat启动报错详解起因博主在tomcat服务器的安装启动时，遇到问题：在官网下载的tomcat10压缩包版本，解压后可以在bin文件夹中双击tomcat10.exe并成功运行，但是双击startup.bat会闪退。而在网上找到的博客所遇到的问题都跟博主的相反，都是tomcat.exe不能运行。在控制台运行该程序，会得到信息如下： 博主也检测了主机安装java的配置以及环境变量，使用命令netstat -ano|findstr 8080也没有发现占用端口的程序，在控制台中使用命令java -version打印结果也正常，因此查询tomcat相关资料，探究该问题。 startup与catalina我们在tomcat安装目录的bin目录下，可以看到有四个文件：startup.bat，startup.sh，catalina.bat，catalina.sh。 这其中，sh格式的文件是linux系统下的脚本文件，在Windows系统下无需理会。我们只看另外两个bat文件就行——bat是dos下的批处理文件。我们要启动tomcat除了双击startup.bat和tomcat.exe，还有一种方式就是在该目录下的命令行中输入catalina.bat run或者catalina run。startup.bat在执行时也会在最后调用catalina.bat，并且传递了start参数，设置了CATALINA_HOME和CURRENT_DIR俩个临时环境变量，当然我们也可以在系统中自行添加这两个变量。这两个文件的另一个区别在于：startup是在新界面运行，而catalina run命令会使相关程序在当前界面运行，会有更多的报错信息： 原因查询原因可能是JDK版本过高（博主所用的JDK17）所导致的，AVA11以后大大简化了JAVA环境配置方式，也没有jre文件夹，不过我们可以在jdk目录下使用命令bin\\jlink.exe --module-path jmods --add-modules java.desktop --output jre来自动生成。JAVA_HOME/lib目录下没有tool.jar, dt.jar这两个文件，因此我们需要在配置环境变量的时候，要写成: 1PATH ;%JAVA_HOME%\\bin\\;%JAVA_HOME%\\jre\\bin\\; CLASSPATH=.;%JAVA_HOME%\\lib;%JAVA_HOME%\\jre\\lib; 即使如此，博主还是依然无法通过startup.bat或者catalina.bat来启动tomcat，依旧只能选择tomcat.exe的启动方式┓( ´∀&#96; )┏","categories":[{"name":"服务器","slug":"服务器","permalink":"http://justskim.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Tomcat","slug":"服务器/Tomcat","permalink":"http://justskim.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Tomcat/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://justskim.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"java","slug":"java","permalink":"http://justskim.github.io/tags/java/"},{"name":"tomcat","slug":"tomcat","permalink":"http://justskim.github.io/tags/tomcat/"}]},{"title":"Linux服务器上的nginx与apache","slug":"linux服务器上的nginx与apache","date":"2022-02-26T11:00:54.169Z","updated":"2022-02-26T17:45:10.530Z","comments":true,"path":"2022/02/26/linux服务器上的nginx与apache/","link":"","permalink":"http://justskim.github.io/2022/02/26/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84nginx%E4%B8%8Eapache/","excerpt":"","text":"Linux服务器上的nginx与apache起因博主在进行django框架的web项目练习时，参考相关教程进行django项目在Linux云服务器上的部署。nginx无法启动服务，需要修改路径/etc/nginx/nginx.conf（使用命令yum -y install nginx默认安装）下的nginx.conf文件。而在浏览器上的web端阿里云控制台上，使用linux系统自带的vim编辑器，不像在桌面系统上编辑那么容易。因此打算使用第三方工具（如win-scp，Xshell），在本地编辑文件后直接拖拽进去替代。但是在这些终端模拟器上无法与阿里云服务器建立ssh连接，但却可以ping通云服务器的公网ip地址，如下图所示。因此博主决定深入探究，并解决该问题。 没有公网ip地址&#x3D;端口被屏蔽？博主遇到的这一个离谱的问题，当阿里云的服务器设置了白名单以及安全组等配置后，无法在家庭网络的三台主机中使用ssh命令或者第三方工具通过22端口进行连接。而在阿里云网页端的官方控制台可以远程连接。异地协助的朋友也可以在他的主机上直接使用ssh命令或者Xshell等第三方工具。 问题排查 首先是一如既往地检查阿里云服务器的安全组设置，请求客服协助，均没有问题； 在win10系统的主机上打开防火墙高级设置，设置22端口的出站规则； 使用命令netstat -ano|findstr 22查看端口，22端口和80、443等端口均没有发生占用情况； 使用手机开启移动4G热点，主机连接该热点后竟然能够成功ssh连接阿里云远程服务器！ 真正的问题所在经过问题排查的过程后，博主将目标锁定在运营商的端口规则上。 ISP的全称是Internet Service Provider，翻译为互联网服务提供商，即向广大用户综合提供互联网接入业务、信息业务、和增值业务的电信运营商。 为了了解我们的运营商屏蔽了哪些端口，我们使用站长工具中的端口扫描工具，或者相关脚本来扫描看看哪些端口可以代为使用。对博主主机扫描的结果是所有端口都被屏蔽，无法使用。。。 根据网络相关文章，这可能跟博主所用的主机并没有公网ip地址有关，以及运营商的屏蔽规则，导致正常无法使用端口。 最后，给你们介绍一下，博主家里使用的是： 123宽带类型：广电宽带业务：高清电视(IPTV)业务接入方式：光纤接入(FTTH) 80端口与Nginx与ApacheApache和Nginx都属于Web服务器（也称为WWW(WORLD WIDE WEB)服务器，主要功能是提供网上信息浏览服务），都实现了HTTP 1.1协议。我们在具体工程项目中选择哪个，都是根据应用场景来决定的，关于这两个服务器的更多异同我们将在之后进行学习探讨。 80端口是为HTTP超文本传输协议开放的端口卡相关的限制。Apache与nginx都会使用到该端口。比如博主在启动nginx时遇到的一个报错：“Address already in use…”，就说明该端口已经被其他程序所占用（大多数情况下是Apache，可能是很多软件不注意间被我们设置开机自动启动了）因此，要么将其中一个的端口进行修改，要么至启动一个（正常生产环境下的操作，无需两个都使用，功能有重复的地方） 我们使用systemctl stop httpd来结束apache服务，使用systemctl start nginx来启动nginx服务，反之亦然。 解决了nginx启动报错的问题后，我们得以部署成功，在浏览器上输入相关ip地址路由，可以成功访问到页面！","categories":[{"name":"网络","slug":"网络","permalink":"http://justskim.github.io/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://justskim.github.io/tags/%E7%BD%91%E7%BB%9C/"},{"name":"nginx","slug":"nginx","permalink":"http://justskim.github.io/tags/nginx/"},{"name":"apache","slug":"apache","permalink":"http://justskim.github.io/tags/apache/"}]},{"title":"localhost与127.0.0.1与0.0.0.0以及端口","slug":"localhost与127.0.0.1与0.0.0.0以及端口","date":"2022-02-21T17:43:42.599Z","updated":"2022-02-22T02:48:52.071Z","comments":true,"path":"2022/02/22/localhost与127.0.0.1与0.0.0.0以及端口/","link":"","permalink":"http://justskim.github.io/2022/02/22/localhost%E4%B8%8E127.0.0.1%E4%B8%8E0.0.0.0%E4%BB%A5%E5%8F%8A%E7%AB%AF%E5%8F%A3/","excerpt":"","text":"localhost与127.0.0.1与0.0.0.0以及端口起因博主在进行django框架的web项目练习时，遇到的一个问题。当博主按照所需的操作编写代码后，在网页链接栏输入http://localhost/mgr/index.html或者http://localhost/mgr/index.html#/时，都会显示404的错误提示界面，如下所示： 而只有在输入链接为127.0.0.1:4000/mgr/index.html#/时，才会出现正常界面： 与教程中唯一不同的步骤在于，博主的django应用，是使用命令python manage.py runserver 4000运行在4000端口上而不是80端口上。原因在于80端口被其他应用所占用。 如何查看端口是否被占用在win 10 系统上，打开控制台，输入命令netstat -ano可以查看所有端口的占用情况。若要查看某一个端口的占用情况，则使用诸如netstat -ano|findstr &quot;80&quot;的命令形式，注意要加双引号。查到占用该端口的进程的PID后，可以使用tasklist|find &quot;123&quot;命令查看进程，这里的123是进程PID。或者打开任务管理器，在“详细信息”一栏查看 80端口80端口是为HTTP超文本传输协议开放的端口，主要用于WWW万维网进行传输信息。其中的具体情况如下： 80端口作为http协议的默认端口，在输入网站的时候其实浏览器（非IE）已经帮忙输入协议了。所以这样一来，如果输入http://baidu.com，其实就等于访问http://baidu.com:80。因此我们访问localhost，默认是访问localhost:80 localhost与127.0.0.1的区别localhost也叫local ，正确的解释是：本地服务器 127.0.0.1在windows等系统的正确解释是：本机地址（本机服务器） 他们的解析通过本机的host文件，windows自动将localhost解析为127.0.0.1 localhost也叫local ，正确的解释是：本地服务器 127.0.0.1在windows等系统的正确解释是：本机地址（本机服务器） 他们的解析通过本机的host文件，windows自动将localhost解析为127.0.0.1 localhot（local）是不经网卡传输！这点很重要，它不受网络防火墙和网卡相关的的限制。 127.0.0.1是通过网卡传输，依赖网卡，并受到网络防火墙和网卡相关的限制。 一般设置程序时本地服务用localhost是最好的，localhost不会解析成ip，也不会占用网卡、网络资源。 有时候用localhost可以，但用127.0.0.1就不可以的情况就是在于此。 解决办法解决方法1：修改host文件用记事本打开C:&#x2F;WINDOWS&#x2F;system32&#x2F;drivers&#x2F;etc&#x2F;hosts文件，看是否有127.0.0.1 localhost 。如果没有则将其添加进去，再查看能否访问localhost。博主使用此方法，即可访问http://localhost:4000/mgr/index.html#/ 解决方法2：1、打开Internert信息管理查看IIS是否启动，且默认网站时候已经开启；2、打开http://127.0.0.1/ 看是否能访问IIS的默认网页，能访问则说明IIS已经成功安装到电脑上，可能是无法解析localhost；3、开始–命令（cmd）–ping localhost，看是否能ping通，从127.0.0.1上返回信息，如果成功则说明可以解析localhost；4、如果上一步不成功，则用记事本打开C:&#x2F;WINDOWS&#x2F;system32&#x2F;drivers&#x2F;etc&#x2F;hosts文件，看里面是否有包含：127.0.0.1 localhost ，如果没有则将其添加进去，再查看能否访问localhost。5、尝试将网站的主目录指向另一个目录或新建一个虚拟目录，并在该新目录创建一个新的网页文件，如index.html，然后将其加到默认网站的”文档”项中作为默认访问的网页，重新输入网址：http://localhost/，看否能访问。6、还是不行的话将IIS卸载掉，重新再安装一次。","categories":[{"name":"网络","slug":"网络","permalink":"http://justskim.github.io/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://justskim.github.io/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"Mysql安装的版本选择","slug":"Mysql安装的版本选择","date":"2022-02-12T10:30:47.490Z","updated":"2022-02-17T15:09:38.844Z","comments":true,"path":"2022/02/12/Mysql安装的版本选择/","link":"","permalink":"http://justskim.github.io/2022/02/12/Mysql%E5%AE%89%E8%A3%85%E7%9A%84%E7%89%88%E6%9C%AC%E9%80%89%E6%8B%A9/","excerpt":"","text":"Mysql安装的版本选择官网中的版本类别在mysql官方下载页面，可以看到有以下几个版本： MySQL Community Server 社区版本，由于开源免费因此是最常用的，但不提供官方技术支持。 MySQL Enterprise Edition 企业版本，需付费，可以试用30天。 MySQL Cluster 集群版，开源免费。可将几个MySQL Server封装成一个Server MySQL Cluster CGE 高级集群版，需付费。 MySQL Workbench（GUI TOOL）一款专为MySQL设计的ER&#x2F;数据库建模工具。它是著名的数据库设计工具DBDesigner4的继任者。MySQL Workbench又分为两个版本，分别是社区版（MySQL Workbench OSS）、商用版（MySQL Workbench SE）。 Linux中安装MySQL这里为了方便，我们使用MySQL Community Server版本来进行安装示例。 选择与Linux系统相配的安装版本注意，linux内核版本和linux系统版本是不同的概念！内核是系统的心脏，也是运行程序和管理设备的核心程序，而我们平时所说的Redhat，Ubuntu及Centos是不同的linux发行版 查看Linux内核版本命令 cat /proc/version 这个文件只有一行内容, 说明正在运行的内核版本 uname -a Linux uname（英文全拼：unix name）命令用于显示系统信息。uname 可显示电脑以及操作系统的相关信息，语法：uname [-amnrsv][--help][--version]；其中-a或–all 显示全部的信息。 查看Linux系统版本命令 使用命令lsb_release -a列出所有版本信息，如果提示未找到相关命令，则需要我们使用命令yum install -y redhat-lsb进行安装； cat /etc/redhat-release，这种方法只适合RedHat系的Linux； cat /etc/issue，/etc/issue、/etc/issue与 /etc/motd 作用一致，都是用于显示欢迎信息，可能包含Linux系统版本的信息。 查找到的结果为：CentOS Linux release 7.8.2003 我们在这里选择Linux genertic下x86_64的版本，复制相关链接，在远程服务器的Linux系统中使用wget进行下载安装。 下载得到的是一个tar压缩包，我们可以在MySQL官方提供的说明文档（这里以8.0版本为例）中 对该安装包使用命令tar -xvf解压： 我们使用的系统是Centos，因此有yum工具而没有apt，如果是ubuntu要使用apt进行安装，操作如相关教程博客： 1234apt install numactl#仅安装libaio库还不行，还要安装numactl库apt install libaio-dev 在安装完相关库之后，我们使用以下的命令： 1234567891011$&gt; groupadd mysql$&gt; useradd -r -g mysql -s /bin/false mysql$&gt; cd mysql$&gt; mkdir mysql-files$&gt; chown mysql:mysql mysql-files$&gt; chmod 750 mysql-files$&gt; bin/mysqld --initialize --user=mysql$&gt; bin/mysql_ssl_rsa_setup$&gt; bin/mysqld_safe --user=mysql &amp;# Next command is optional$&gt; cp support-files/mysql.server /etc/init.d/mysql.server 其中，如果赋相关目录MySQL用户权限的chown命令发生以下报错： 1chown: invalid user: mysql:mysql 我们需要再次通过添加执行用户名和组的方式解决： 12groupadd mysqluseradd -g mysql mysql 注意，初始化数据库时，如果提示mysqld not found错误，是由于 &#x2F;etc&#x2F;init.d&#x2F; 不存在 mysqld 这个命令","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://justskim.github.io/categories/Mysql/"},{"name":"安装","slug":"Mysql/安装","permalink":"http://justskim.github.io/categories/Mysql/%E5%AE%89%E8%A3%85/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://justskim.github.io/tags/mysql/"}]},{"title":"win10上的代理服务器设置与127.0.0.1","slug":"win10上的代理服务器设置与127.0.0.1","date":"2022-02-08T06:02:05.413Z","updated":"2022-02-08T07:13:50.206Z","comments":true,"path":"2022/02/08/win10上的代理服务器设置与127.0.0.1/","link":"","permalink":"http://justskim.github.io/2022/02/08/win10%E4%B8%8A%E7%9A%84%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE%E4%B8%8E127.0.0.1/","excerpt":"","text":"win10上的代理服务器设置与127.0.0.1代理服务器的定义代理服务器（Proxy Server）是介于浏览器和Web服务器之间的一台服务器，可被用于代理网络用户去取得网络信息。可以说，代理服务器是网络信息的中转站，是个人网络和Internet服务商之间的中间代理机构，负责转发合法的网络信息，对转发进行控制和登记，工作在OSI模型的对话层。当你通过代理服务器上网浏览时，浏览器不是直接到Web服务器去取回网页，而是向代理服务器发出请求，由代理服务器来取回浏览器所需要的信息，并传送给你的浏览器。 Win10系统提供系统级代理服务器设置，通过在Win10系统中设置代理服务器，系统中所有的软件都会通过我们设置的代理服务器访问网络，这样就不用一个一个软件设置代理服务器了，包括浏览器等应用，都会使用设定的系统代理服务器上网。 环回地址127.0.0.1127.0.0.1是回送地址主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，协议软件立即返回之，不进行任何网络传输。有时候当我们使用浏览器点击网页时，有时候会发现提示网页无法找到，建议我们检查代理服务器设置。而在win10系统的设置一栏，有一项“代理服务器”的设置，有时我们点开这里，会发现代理服务器被设置为127.0.0.1，原因不明，但将代理服务器关闭即可正常访问网络，检查host文件也没有发现异常。","categories":[{"name":"网络","slug":"网络","permalink":"http://justskim.github.io/categories/%E7%BD%91%E7%BB%9C/"},{"name":"服务器","slug":"网络/服务器","permalink":"http://justskim.github.io/categories/%E7%BD%91%E7%BB%9C/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://justskim.github.io/tags/%E7%BD%91%E7%BB%9C/"},{"name":"服务器","slug":"服务器","permalink":"http://justskim.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"在vmware虚拟机中进行网络连接","slug":"在vmware虚拟机中进行网络连接","date":"2021-11-16T07:16:40.924Z","updated":"2022-02-12T10:13:06.192Z","comments":true,"path":"2021/11/16/在vmware虚拟机中进行网络连接/","link":"","permalink":"http://justskim.github.io/2021/11/16/%E5%9C%A8vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5/","excerpt":"","text":"在vmware虚拟机中进行网络连接四种网络模式点击VMware Workstation的导航栏，在“虚拟机-&gt;设置-&gt;硬件-&gt;网络设配器”中，可看到网络连接模式的选择（不能在虚拟机挂起的时候进行更改），VMware的官方网站中说明了四种网络模式的区别： 设置 说明 使用桥接模式网络连接 为虚拟机配置桥接模式网络连接。使用桥接模式网络连接时，虚拟机将具有直接访问外部以太网网络的权限。虚拟机必须在外部网络中具有自己的 IP 地址。如果您的主机系统位于网络中，而且您拥有可用于虚拟机的单独 IP 地址（或者可以从 DHCP 服务器获得 IP 地址），请选择此设置。网络中的其他计算机将能够与该虚拟机直接通信。 使用网络地址转换 (NAT) 为虚拟机配置 NAT 连接。利用 NAT，虚拟机和主机系统将共享一个网络标识，此标识在网络以外不可见。如果您没有可用于虚拟机的单独 IP 地址，但又希望能够连接到 Internet，请选择 NAT。 使用仅主机模式网络连接 为虚拟机配置仅主机模式网络连接。仅主机模式网络连接使用对主机操作系统可见的虚拟网络适配器，在虚拟机和主机系统之间提供网络连接。使用仅主机模式网络连接时，虚拟机只能与主机系统以及仅主机模式网络中的其他虚拟机进行通信。要设置独立的虚拟网络，请选择仅主机模式网络连接。 不使用网络连接 不为虚拟机配置网络连接。 自定义（Windows 主机）或已命名的网络（Linux 主机） （仅限远程虚拟机）选择特定虚拟网络。从下拉菜单中选择一个自定义网络。尽管列表中有 VMnet0、VMnet1 和 VMnet8，但这些网络通常被用于桥接模式、仅主机模式和 NAT 模式网络。 对于使用校园网或者公司网络的用户，NAT是最简单的方式。 网络配置相关文件eth0 该文件一般位于路径“&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts”中 网络配置相关命令ifconfig 用于配置网卡的基本命令，注意不是ipconfig！ifconfig命令的英文全称是“network interfaces configuring”，即用于配置和显示Linux内核中网络接口的网络参数。用ifconfig命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。要想将上述的配置信息永远的存的电脑里，那就要修改网卡的配置文件了。 常用参数： add &lt;地址&gt; 设置网络设备IPv6的IP地址 del &lt;地址&gt; 删除网络设备IPv6的IP地址 down 关闭指定的网络设备 up 启动指定的网络设备 IP地址 指定网络设备的IP地址 一个与之相似的命令是windows系统下的ipconfig命令 ethtool 用于查询ethX网口基本设置、及设置网卡的参数 以上步骤尝试过后，依然无法解决联网问题如果在以上步骤尝试过后，依然无法解决联网问题，特别是最简单的NAT模式下，可以查看相关端口是否被杀毒软件禁止，以及服务是否成功启动。笔者在实际操作中遇到过这种情况，最后，根据这篇博客，将win10中的服务打开，手动启动或者重新启动VMware DHCP Service和VMware NAT Service两个服务即可。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://justskim.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://justskim.github.io/tags/linux/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://justskim.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://justskim.github.io/tags/ubuntu/"},{"name":"vmware","slug":"vmware","permalink":"http://justskim.github.io/tags/vmware/"}]},{"title":"python3中的运行命令与环境","slug":"python3中的运行命令与环境","date":"2021-11-08T18:35:42.058Z","updated":"2021-11-08T18:36:09.710Z","comments":true,"path":"2021/11/09/python3中的运行命令与环境/","link":"","permalink":"http://justskim.github.io/2021/11/09/python3%E4%B8%AD%E7%9A%84%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4%E4%B8%8E%E7%8E%AF%E5%A2%83/","excerpt":"","text":"python3中的运行命令与环境本机电脑仅安装python3，以下使用的均为python3环境配置 镜像是什么？镜像（Mirroring）是一种文件存储形式，是冗余的一种类型，一个磁盘上的数据在另一个磁盘上存在一个完全相同的副本即为镜像。 镜像源 就是把官方的源做一个镜像，你可以在这下载软件。 比如ubuntu官方源在国外，下载软件可能会很慢，这时候就需要换成国内的镜像源。 源 端口就是指本地端口 目的端口就是远程端口 一个数据包（pocket）被解封装成数据段（segment）后就会涉及到 连接上层协议的端口问题。 镜像网站（Mirror sites）又称之为镜像站点 anaconda环境命令行运行python程序，与idle中”Run module“的区别笔者在学习RLCard——一款卡牌游戏强化学习工具包的时候，发现了范例中的代码如下： 1234567891011121314151617181920212223242526272829import argparseimport rlcardfrom rlcard.agents import RandomAgentfrom rlcard.utils import set_seeddef run(args): # Make environment env = rlcard.make(args.env, config=&#123;&#x27;seed&#x27;: 42&#125;) num_episodes = 1 # Seed numpy, torch, random set_seed(42) # Set agents agent = RandomAgent(num_actions=env.num_actions) env.set_agents([agent for _ in range(env.num_players)]) for episode in range(num_episodes): # Generate data from the environment trajectories, player_wins = env.run(is_training=False) # Print out the trajectories print(&#x27;\\nEpisode &#123;&#125;&#x27;.format(episode)) print(trajectories)if __name__ == &#x27;__main__&#x27;: parser = argparse.ArgumentParser(&quot;Random example in RLCard&quot;) parser.add_argument(&#x27;--env&#x27;, type=str, default=&#x27;leduc-holdem&#x27;) args = parser.parse_args() run(args) 这段代码在idle中无法被“Run module”运行，却可以在命令行中运行 123456789101112131415161718192021222324252627#在idle中无法被“Run module”运行============== RESTART: E:/python练习/RLCard/examples/run_random.py ==============Traceback (most recent call last): File &quot;E:/python练习/RLCard/examples/run_random.py&quot;, line 4, in &lt;module&gt; from rlcard.agents import RandomAgent File &quot;E:\\python\\lib\\site-packages\\rlcard\\agents\\__init__.py&quot;, line 5, in &lt;module&gt; reqs = subprocess.check_output([sys.executable, &#x27;-m&#x27;, &#x27;pip&#x27;, &#x27;freeze&#x27;]) File &quot;E:\\python\\lib\\subprocess.py&quot;, line 424, in check_output return run(*popenargs, stdout=PIPE, timeout=timeout, check=True, File &quot;E:\\python\\lib\\subprocess.py&quot;, line 528, in run raise CalledProcessError(retcode, process.args,subprocess.CalledProcessError: Command &#x27;[&#x27;E:\\\\python\\\\pythonw.exe&#x27;, &#x27;-m&#x27;, &#x27;pip&#x27;, &#x27;freeze&#x27;]&#x27; returned non-zero exit status 120.#可以在命令行中运行$ python examples/run_random.pyWARNING: Ignoring invalid distribution -ip (e:\\python\\lib\\site-packages)WARNING: Ignoring invalid distribution -ip (e:\\python\\lib\\site-packages)Episode 0[[&#123;&#x27;legal_actions&#x27;: OrderedDict([(1, None), (2, None), (3, None)]), &#x27;obs&#x27;: array([0., 1., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]), &#x27;raw_obs&#x27;: &#123;&#x27;hand&#x27;: &#x27;HQ&#x27;, &#x27;public_card&#x27;: None, &#x27;all_chips&#x27;: [2, 1], &#x27;my_chips&#x27;: 2, &#x27;legal_actions&#x27;: [&#x27;raise&#x27;, &#x27;fold&#x27;, &#x27;check&#x27;], &#x27;current_player&#x27;: 0&#125;, &#x27;raw_legal_actions&#x27;: [&#x27;raise&#x27;, &#x27;fold&#x27;, &#x27;check&#x27;], &#x27;action_record&#x27;: [(1, &#x27;fold&#x27;)]&#125;], [&#123;&#x27;legal_actions&#x27;: OrderedDict([(0, None), (1, None), (2, None)]), &#x27;obs&#x27;: array([1., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]), &#x27;raw_obs&#x27;: &#123;&#x27;hand&#x27;: &#x27;HJ&#x27;, &#x27;public_card&#x27;: None, &#x27;all_chips&#x27;: [2, 1], &#x27;my_chips&#x27;: 1, &#x27;legal_actions&#x27;: [&#x27;call&#x27;, &#x27;raise&#x27;, &#x27;fold&#x27;], &#x27;current_player&#x27;: 1&#125;, &#x27;raw_legal_actions&#x27;: [&#x27;call&#x27;, &#x27;raise&#x27;, &#x27;fold&#x27;], &#x27;action_record&#x27;: [(1, &#x27;fold&#x27;)]&#125;, 2, &#123;&#x27;legal_actions&#x27;: OrderedDict([(1, None), (2, None), (3, None)]), &#x27;obs&#x27;: array([1., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]), &#x27;raw_obs&#x27;: &#123;&#x27;hand&#x27;: &#x27;HJ&#x27;, &#x27;public_card&#x27;: None, &#x27;all_chips&#x27;: [2, 1], &#x27;my_chips&#x27;: 1, &#x27;legal_actions&#x27;: [&#x27;raise&#x27;, &#x27;fold&#x27;, &#x27;check&#x27;], &#x27;current_player&#x27;: 0&#125;, &#x27;raw_legal_actions&#x27;: [&#x27;raise&#x27;, &#x27;fold&#x27;, &#x27;check&#x27;], &#x27;action_record&#x27;: [(1, &#x27;fold&#x27;)]&#125;]] 我们试着来比较这两个命令的差别： 这篇博客中介绍了sys模块的使用详情，我们只讲两个下面会使用到的函数， sys模块提供了一系列有关Python运行环境的变量和函数， sys.path返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值 sys.executable该属性是一个字符串，在正常情况下，其值是当前运行的 Python 解释器对应的可执行程序所在的绝对路径。 比如在 Windows 上使用 Anaconda 安装的 Python，该属性的值就是： 12&gt;&gt;&gt; sys.executable&#x27;E:\\\\Anaconda\\\\Anaconda\\\\python.exe&#x27; 打印结果，我们可以发现二者的绝对路径不一样，在Idle中，python解释器对应的可执行程序为pythonw.exe，而在命令行中则是python.exe python.exe与pythonw.exe Windows系统搭建好Python的环境后，进入Python的安装目录，大家会发现目录中有python.exe和pythonw.exe两个程序。 这两个程序的区别在于： 1234567891011a）、python.exe在运行程序的时候，会弹出一个黑色的控制台窗口（也叫命令行窗口、DOS/CMD窗口）； b）、pythonw.exe是无窗口的Python可执行程序，意思是在运行程序的时候，没有窗口，代码在后台执行 .py和.pyw文件的区别也来源于python.exe和pythonw.exe的区别： 安装视窗版 Python 时，扩展名为 .py 的文件被默认为用 python.exe 运行的文件，而 .pyw文件则被默认为用 pythonw.exe 运行。这里还要解释一个问题，如果.py文件直接用python.exe打开，文件被执行完成之后，视窗会立即关闭，如果想让视窗停留；给大家提供两个方法： ① 可以在程序中import time模块，加入超长睡眠语句，如time.sleep(1800)，如果你不手动关闭视窗，视窗将会停留30min； ② 可以调用sys和os模块，使用命令行语句pause 3、.pyw格式是被设计用来运行开发的纯图形界面程序的，纯图形界面程序的用户不需要看到控制台窗口。 在开发纯图形界面程序的时候，可以暂时把 .pyw 改成 .py ，运行时能调出控制台窗口，方便看到所有错误信息。 至于.pyc文件，是Python解释器运行程序的过程中产生的字节码文件（也就是中间文件）。 总之，我们尽可能地使用命令行来执行.py格式程序。","categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"},{"name":"Python3","slug":"Programming-languages-and-projects/Python3","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"}],"tags":[{"name":"python3","slug":"python3","permalink":"http://justskim.github.io/tags/python3/"},{"name":"anaconda","slug":"anaconda","permalink":"http://justskim.github.io/tags/anaconda/"}]},{"title":"python3中的生成器与迭代器","slug":"python3中的生成器与迭代器","date":"2021-11-03T01:55:18.115Z","updated":"2021-11-03T08:39:09.363Z","comments":true,"path":"2021/11/03/python3中的生成器与迭代器/","link":"","permalink":"http://justskim.github.io/2021/11/03/python3%E4%B8%AD%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/","excerpt":"","text":"python3中的生成器与迭代器生成器与迭代器在Python社区，生成器和迭代器被看作一种工具，生成器的本质就是迭代器。唯一的区别就是生成器是开发人员自己用Python代码构建的数据结构，而迭代器是Python内置提供或转化而来的。 迭代器迭代器是一种对象，该对象包含值的可计数数字。 迭代器是可迭代的对象，这意味着您可以遍历所有值。 从技术上讲，在 Python 中，迭代器是实现迭代器协议的对象，它包含方法__iter__()和 __next__()。要把对象&#x2F;类创建为迭代器，必须为对象实现 __iter__() 和 __next__() 方法。 正如您在 Python 类&#x2F;对象 一章中学到的，所有类都有名为 __init__() 的函数，它允许您在创建对象时进行一些初始化。 __iter__()方法的作用相似，您可以执行操作（初始化等），但必须始终返回迭代器对象本身。 __next__()方法也允许您执行操作，并且必须返回序列中的下一个项目。 可迭代对象（Iterable）列表、元组、字典和集合、字符串都是可迭代的对象。它们是可迭代的容器，您可以从中获取迭代器（Iterator）。 所有这些对象都有用于获取迭代器的 iter() 方法： 1234567891011121314151617181920212223242526&gt;&gt;&gt; mytuple = (&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;)myit = iter(mytuple)print(next(myit))print(next(myit))print(next(myit))&gt;&gt;&gt; mytuple = (&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;)&gt;&gt;&gt; myit=iter(mytuple)&gt;&gt;&gt; print(next(myit))apple&gt;&gt;&gt; print(next(myit))banana&gt;&gt;&gt; print(next(myit))cherry&gt;&gt;&gt; mytuple1=&quot;banana&quot;&gt;&gt;&gt; myit1=iter(mytuple1)&gt;&gt;&gt; print(next(myit))Traceback (most recent call last): File &quot;&lt;pyshell#54&gt;&quot;, line 1, in &lt;module&gt; print(next(myit))StopIteration #序列的所有项目都被迭代过，因此迭代（iteration）停止，报错&gt;&gt;&gt; print(next(myit1))b&gt;&gt;&gt; print(next(myit1))a 也可以使用 for 循环遍历可迭代对象 StopIteration 异常的使用StopIteration异常用于完成标识迭代，防止无限循环。 __next__()函数完成指定循环次数后，会触发该异常结束迭代。 12345678it = iter([1,2,3,4,5])while True: try: x = next(it) print(x) except StopIteration: break#如果不使用StopIteration，则会报错异常 将一个类当做迭代器使用把一个类作为一个迭代器使用需要在类中方法 __iter__()0与 __next__() 。 1234567891011121314151617class MyNumbers: def __iter__(self): self.a = 1 return self def __next__(self): x = self.a self.a += 1 return x myclass = MyNumbers()myiter = iter(myclass)print(next(myiter))#1print(next(myiter))#2print(next(myiter))#3print(next(myiter))#4print(next(myiter))#5 python3生成器在 Python 中，使用了 yield 的函数被称为生成器（generator）。 跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。 在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。 调用一个生成器函数，返回的是一个迭代器对象。 yield关键字我们先将yield看做return，执行下面的程序，看看结果如何？ 1234567891011121314&gt;&gt;&gt; def foo(): print(&quot;starting...&quot;) while True: res=yield 4 print(&quot;res:&quot;,res) &gt;&gt;&gt; g=foo()&gt;&gt;&gt; print(next(g))starting...4&gt;&gt;&gt; print(&quot;*&quot;*20)********************&gt;&gt;&gt; print(next(g))res: None4 原文章的博主对于执行顺序给出了以下解释： 1.程序开始执行以后，因为foo函数中有yield关键字，所以foo函数并不会真的执行，而是先得到一个生成器g(相当于一个对象) 2.直到调用next方法，foo函数正式开始执行，先执行foo函数中的print方法，然后进入while循环 3.程序遇到yield关键字，然后把yield想象成return，return了一个4之后，程序停止，并没有执行赋值给res操作，此时next(g)语句执行完成，所以输出的前两行（第一行“starting…”是while上面的print的结果，第二行“4”是return出的结果）是执行print(next(g))的结果，注意并没有执行yield一句下一行的print(“res:”,res)语句 4.程序执行print(“*“*20)，输出20个* 5.又开始执行下面的print(next(g))，不同的是，这一次从刚才那个next程序停止的地方开始执行的，也就是要从yield语句的下一行语句开始，执行res的赋值操作，这时候要注意，这个时候赋值操作的右边是没有值的（因为刚才那个是return出去了，并没有给赋值操作的左边传参数），所以这个时候res赋值是None,所以接着下面的输出就是res:None 6.程序会继续在while里执行，又一次碰到yield,这个时候同样return 出4，然后程序停止，print函数输出的4就是这次return出的4. 带yield的函数是一个生成器，可以不再看做一个函数了。这个生成器有一个next函数，相当于“下一步”生成哪个数，这一次的next开始的地方是接着上一次的next停止的地方执行的，所以调用next的时候，生成器并不会从foo函数的开始执行，只是接着上一步停止的地方开始，然后遇到yield后，return出要生成的数，此步就结束。 我们接着上面的代码，继续输出next(g)，每一次的next开始的地方都是上一次的next停止的地方： 123456&gt;&gt;&gt; print(next(g))res: None4&gt;&gt;&gt; print(next(g))res: None4 也就是说，除了第一次next函数可能会特殊（循环体外的代码部分执行原因），每次我们使用next函数，都是从上一个yield停止的地方，开始跑代码，跑到下一个yield语句，return了值， 停止。下面的例子更加直观一些： 12345678910111213141516171819202122232425262728&gt;&gt;&gt; def fo(n): print(&quot;fo start!&quot;) while True: #注意，因为下一次next函数执行在循环体中开始，因此要再接一轮while判断，而不会执行循环体外面的上一行print(&quot;fo start&quot;)语句 print(&quot;before yield, n = &quot;,n) n = n + 1 res = yield n #跑到这里结束 print(&quot;after yield, n = &quot;,n) #从这里开始&gt;&gt;&gt; x = fo(1)&gt;&gt;&gt; print(next(x))fo start!before yield, n = 12&gt;&gt;&gt; print(next(x))after yield, n = 2before yield, n = 23&gt;&gt;&gt; print(next(x))after yield, n = 3before yield, n = 34&gt;&gt;&gt; print(next(x))after yield, n = 4before yield, n = 45&gt;&gt;&gt; print(next(x))after yield, n = 5before yield, n = 56","categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"},{"name":"Python3","slug":"Programming-languages-and-projects/Python3","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"}],"tags":[{"name":"python3","slug":"python3","permalink":"http://justskim.github.io/tags/python3/"}]},{"title":"python3中的一些常见语法糖整理","slug":"python3中的一些常见语法糖","date":"2021-10-31T12:02:01.432Z","updated":"2021-11-08T18:11:54.922Z","comments":true,"path":"2021/10/31/python3中的一些常见语法糖/","link":"","permalink":"http://justskim.github.io/2021/10/31/python3%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E8%AF%AD%E6%B3%95%E7%B3%96/","excerpt":"","text":"python3中的一些常见语法糖整理输入输出的类型提示123class Solution: def addBinary(self, a: str, b: str) -&gt; str: return str 学过C语言的同学，都懂得，参数中a，b要求为str类型的输入参数 在定义函数时，在def那一行后面会加一个-&gt;。这个玩意儿有个专门的名词叫 type hint， 即类型提示。这里就是说返回的数据类型为str。 在Python中，str 表示字符串类 ，也可以是将变量强制转换为字符串的函数，写作str () 类型标注 int,long,float: 整型,长整形,浮点型 bool,str: 布尔型，字符串类型 List, Tuple, Dict, Set:列表，元组，字典, 集合 Iterable,Iterator:可迭代类型，迭代器类型 Generator：生成器类型 限定函数参数类型及输出1def foo(text:&#x27;str&#x27;,max:&#x27;int &gt; 0&#x27; = 100,min:&#x27;int &gt; 0&#x27;)-&gt;str: 在限定函数参数类型的同时还可以限定参数的范围以及默认值。 注意！在函数定义时，第一个带有默认值的参数之后的所有参数都必须有默认值，否则，运行时报错 函数定义时的和*在参数前面加上*号 ，意味着参数个数不止一个，而带一个星号*参数的函数传入的参数存储为一个元组（tuple），带两个*号则是表示字典（dict）。 *将参数按顺序一一赋值，而dict类型则是将字典的keys作为函数参数进行赋值。 **参数方式则要求输入必须是一个dict，而且变量名称要与函数定义的变量名称一致 1234567891011121314151617181920212223242526272829303132333435363738&gt;&gt;&gt; def func1(a, *b): print(a) print(b) print(type(b))&gt;&gt;&gt; def func2(a, **b): print(a) print(b) print(type(b))&gt;&gt;&gt; def func3(a, *b, **c): print(a) print(b) print(c)&gt;&gt;&gt; func1(1,2,3,4)1(2, 3, 4)&lt;class &#x27;tuple&#x27;&gt;&gt;&gt;&gt; func1(1111,(2,3))1111((2, 3),) #如果传入一个元组，该元组会被当成元组的第一个参数&lt;class &#x27;tuple&#x27;&gt;&gt;&gt;&gt; func2(1,2,3)Traceback (most recent call last): File &quot;&lt;pyshell#17&gt;&quot;, line 1, in &lt;module&gt; func2(1,2,3)TypeError: func2() takes 1 positional argument but 3 were given&gt;&gt;&gt; func2(1,x=1,y=2) #传入的字典参数必须有key和value1&#123;&#x27;x&#x27;: 1, &#x27;y&#x27;: 2&#125;&lt;class &#x27;dict&#x27;&gt;&gt;&gt;&gt; func2(111,&#123;x=22,y=44&#125;) #注意是传入的参数作为字典，不能传入dict类型的参数！SyntaxError: invalid syntax&gt;&gt;&gt; func3(1,2,3,4,x=5,y=6)1(2, 3, 4)&#123;&#x27;x&#x27;: 5, &#x27;y&#x27;: 6&#125; 在调用时，*主要是用来解压参数列表，对于set、tuple、list、dict(会取其values的值)类型的数据都适用 另外一个值得注意的就是参数的顺序，我们知道，最正规的写法就是将这三个参数按*号从少到多排列，那换一种写法呢？ 12345678910&gt;&gt;&gt; def func4(a,**b,*c):SyntaxError: invalid syntax #**参数方式在*参数方式之前，无效&gt;&gt;&gt; def func5(*b,a): #*参数方式在不带*的参数之前，可以定义，但注意输入！！ print(b,&#x27;\\n&#x27;,a)&gt;&gt;&gt; def func5(**b,a): #**参数方式在不带*参数方式之前，无效SyntaxError: invalid syntax&gt;&gt;&gt; def func5(**b,*c): #**参数方式在*参数方式之前，无效SyntaxError: invalid syntax&gt;&gt;&gt; def func5(*b,**c): #没有不带*的参数，*参数方式在**参数方式之前，有效 print(b,c) 但是要注意的是，如果带*的参数在不带*的参数之前，输入的时候要进行明确参数赋值： 1234567891011&gt;&gt;&gt; def func6(*b,a): print(b) print(&quot;a=&quot;,a)&gt;&gt;&gt; func6(1,2,3,4,5,&#x27;222&#x27;,333)Traceback (most recent call last): File &quot;&lt;pyshell#38&gt;&quot;, line 1, in &lt;module&gt; func6(1,2,3,4,5,&#x27;222&#x27;,333)TypeError: func6() missing 1 required keyword-only argument: &#x27;a&#x27;&gt;&gt;&gt; func6(1,2,3,4,5,&#x27;222&#x27;,a=333) #输入的时候要进行明确参数赋值(1, 2, 3, 4, 5, &#x27;222&#x27;)a= 333 函数参数中的selfPython类中规定，函数的第一个参数是实例对象本身，并且约定俗成，把其名字写为self。其作用相当于java中的this，表示当前类的对象，可以调用当前类中的属性和方法。 在菜鸟教程中，对于python类有如下介绍： 类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。 方法：类中定义的函数。 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。 数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。 局部变量：定义在方法中的变量，只作用于当前实例的类。 实例变量：在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。 实例化：创建一个类的实例，类的具体对象。 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。 class是面向对象的设计思想，instance（也即是 object，对象）是根据 class 创建的。在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self, 且为第一个参数，self 代表的是类的实例而不是类！self 代表的是类的实例，代表当前对象的地址，而 self.class 则指向类。self 不是 python 关键字，我们把他替换成合格的字符串形式参数也是可以正常执行的。 类中的__init__方法类有一个名为·__init__() 的特殊方法（构造方法），该方法在类实例化时会自动调用 123456class Complex: def __init__(self, realpart, imagpart): self.r = realpart self.i = imagpartx = Complex(3.0, -4.5)print(x.r, x.i) # 输出结果：3.0 -4.5 python 类的继承Python 同样支持类的继承，如果一种语言不支持继承，类就没有什么意义。 子类（派生类 DerivedClassName）会继承父类（基类 BaseClassName）的属性和方法。 BaseClassName（实例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用: 1234567891011121314151617181920212223242526272829#!/usr/bin/python3#类定义class people: #定义基本属性 name = &#x27;&#x27; age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age)) #单继承示例class student(people): grade = &#x27;&#x27; def __init__(self,n,a,w,g): #调用父类的构函 people.__init__(self,n,a,w) self.grade = g #覆写父类的方法 def speak(self): print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade))s = student(&#x27;ken&#x27;,10,60,3)s.speak()#执行结果：ken 说: 我 10 岁了，我在读 3 年级 python也支持多重继承 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#!/usr/bin/python3 #类定义class people: #定义基本属性 name = &#x27;&#x27; age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age)) #单继承示例class student(people): grade = &#x27;&#x27; def __init__(self,n,a,w,g): #调用父类的构函 people.__init__(self,n,a,w) self.grade = g #覆写父类的方法 def speak(self): print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade)) #另一个类，多重继承之前的准备class speaker(): topic = &#x27;&#x27; name = &#x27;&#x27; def __init__(self,n,t): self.name = n self.topic = t def speak(self): print(&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;%(self.name,self.topic)) #多重继承class sample(speaker,student): a =&#x27;&#x27; def __init__(self,n,a,w,g,t): student.__init__(self,n,a,w,g) speaker.__init__(self,n,t) test = sample(&quot;Tim&quot;,25,80,4,&quot;Python&quot;)test.speak() #方法名同，默认调用的是在括号中排前地父类的方法#执行结果：我叫 Tim，我是一个演说家，我演讲的主题是 Python 类的私有属性__private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs。 类的方法在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self，且必须为第一个参数，self 代表的是类的实例。 self 的名字并不是规定死的，也可以使用 this，但是最好还是按照约定使用 self。 类的私有方法__private_method：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。self.__private_methods。 lambda表达式（匿名函数）如果一个函数的函数体仅有 1 行，那么该函数就可以用 lambda 表达式来代替，下面两个函数在表达效果上是相等的： 123def name(arg1,...argn): return 表达式name = lambda [arg1 [,arg2,.....argn]]: 表达式 定义 lambda 表达式，必须使用 lambda 关键字，注意冒号前是参数，可以有多个，用逗号隔开，冒号右边的为表达式（只能为一个）。其实lambda返回值是一个函数的地址，也就是函数对象。 注意传入的参数必须用逗号隔开，下面这么定义是错误的： 12345&gt;&gt;&gt; add = lambda [x,y]:x+ySyntaxError: invalid syntax&gt;&gt;&gt; add = lambda x,y:x+y&gt;&gt;&gt; add(2,3)5 python中的5种下划线形式 单前导下划线：**_var** 单末尾下划线：var_ 双前导下划线：**__var** 双前导和末尾下划线：__var__ 单下划线：**_** 单前导下划线：**_var**，前置单下划线只有约定含义。它对于程序员而言是一种提示——Python社区约定好单下划线表达的是某种意思，其本身并不会影响程序的行为。 前置下划线的意思是提示其他程序员，以单下划线开头的变量或方法只在内部使用。PEP 8中定义了这个约定（PEP 8是最常用的Python代码风格指南。 详见PEP 8：“Style Guide for Python Code”。 不过，这个约定对Python解释器并没有特殊含义。与Java不同，Python在“私有”和“公共”变量之间并没有很强的区别。在变量名之前添加一个下划线更像是有人挂出了一个小小的下划线警告标志：“注意，这并不是这个类的公共接口。最好不要使用它。” 我们实例化一个类，并为其添加一个使用单前导下划线的属性： 123456789class Test: def __init__(self): self.foo = 11 self._bar = 23&gt;&gt;&gt; t = Test()&gt;&gt;&gt; t.foo11&gt;&gt;&gt; t._bar23 _bar前面的单下划线并没有阻止我们“进入”这个类访问变量的值。 这是因为Python中的前置单下划线只是一个公认的约定，至少在涉及变量名和方法名时是这样的。 使用单前导下划线需要注意的是，前置下划线会影响从模块中导入名称的方式，如果使用通配符*导入从这个模块中导入所有名称，Python不会导入带有前置单下划线的名称（除非模块中定义了__all__列表覆盖了这个行为： 123456789101112# 在my_module.py中这么定义：def external_func(): return 23def _internal_func(): return 42#在idle或另一个py文件中导入&gt;&gt;&gt; from my_module import *&gt;&gt;&gt; external_func()23&gt;&gt;&gt; _internal_func()NameError: &quot;name &#x27;_internal_func&#x27; is not defined&quot; 值得注意的是：要尽可能避免使用通配符*导入，因为这样就不清楚当前名称空间中存在哪些名称了。为了清楚起见，最好坚持使用常规导入方法。与通配符导入不同，常规导入不受前置单下划线命名约定的影响. 遵循PEP 8的建议不使用通配符导入，那么真正需要记住的只有下面这一条。以单下划线开头的名称只是Python命名中的约定，表示供内部使用。它通常对Python解释器没有特殊含义，仅仅作为对程序员的提示。 单末尾下划线：var_有时某个变量最合适的名称已被Python语言中的关键字占用。因此，诸如class或def的名称不能用作Python中的变量名。在这种情况下，可以追加一个下划线来绕过命名冲突。PEP 8中定义并解释了这个用一个单末尾下划线来避免与python关键字冲突的约定。 1234&gt;&gt;&gt; def func(name,class):SyntaxError: invalid syntax&gt;&gt;&gt; def func(name,class_): pass 上面介绍的单下划线（无论放在前边还是末尾），都只是约定的作用。 双前导下划线：**__var**上面介绍的单下划线（无论放在前边还是末尾），都只是约定的作用。 但使用以双下划线开头的Python类属性（变量和方法）就不一样了。 双下划线前缀会让Python解释器重写属性名称，以避免子类中的命名冲突。 这也称为名称改写（name mangling），即解释器会更改变量的名称，以便在稍后扩展这个类时避免命名冲突。 双前导和末尾下划线：__var__一些特殊的双前导和末尾下划线 __all__ 不像 Ruby 或者 Java，Python 没有语言原生的可见性控制，而是靠一套需要大家自觉遵守的”约定“下工作。比如下划线开头的应该对外部不可见。同样，__all__ 也是对于模块公开接口的一种约定，比起下划线，__all__ 提供了暴露接口用的”白名单“。一些不以下划线开头的变量（比如从其他地方 import 到当前模块的成员）可以同样被排除出去。 当我们向文件导入某个模块时，导入的是该模块中那些名称不以下划线（单下划线“_”或者双下划线“__”）开头的变量、函数和类。因此，如果我们不想模块文件中的某个成员被引入到其它文件中使用，有两种方法： 在其名称前添加单下划线。 借助模块提供的__all__ 变量，该变量的值是一个列表，存储的是当前模块中一些成员（变量、函数或者类）的名称。 通过在模块文件中设置__all__变量，当其它文件以“from 模块名 import *”的形式导入该模块时，该文件中只能使用__all__ 列表中指定的成员。__all__也是对于模块公开接口的一种约定，比起下划线，__all__提供了暴露接口用的“白名单”。 ———————————————— 版权声明：本文为CSDN博主「-徐徐图之-」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/zylooooooooong/article/details/115564782 __init__ 在创建类时，我们可以手动添加一个__init__()方法，该方法是一个特殊的类实例方法，称为构造方法（或构造函数）。 构造方法用于创建对象时使用，每当创建一个类的实例对象时，Python 解释器都会自动调用它。 __init__() 方法可以包含多个参数，但必须包含一个名为 self 的参数，且必须作为第一个参数。 即便不手动为类添加任何构造方法，Python 也会自动为类添加一个仅包含 self 参数的构造方法。 如果子类中不重写__init__，实例化子类时，就会调用父类中定义的__init__: 1234567891011121314151617class Father(object): def __init__(self, name): self.name=name print ( &quot;name: %s&quot; %( self.name) ) def getName(self): return &#x27;Father &#x27; + self.name class Son(Father): def getName(self): return &#x27;Son &#x27;+self.name if __name__==&#x27;__main__&#x27;: son=Son(&#x27;runoob&#x27;) print ( son.getName() )#输出结果name: runoobSon runoob 如果重写了**init** 时，实例化子类，就不会调用父类已经定义的 **init**，语法格式如下： 1234567891011121314151617181920class Father(object): def __init__(self, name): self.name=name print ( &quot;name: %s&quot; %( self.name) ) def getName(self): return &#x27;Father &#x27; + self.name class Son(Father): def __init__(self, name): print ( &quot;hi&quot; ) self.name = name def getName(self): return &#x27;Son &#x27;+self.name if __name__==&#x27;__main__&#x27;: son=Son(&#x27;runoob&#x27;) print ( son.getName() )#输出结果：hiSon runoob 若重写了__init__，还要继承父类的构造方法，可以使用super关键字。 1234567891011121314151617181920212223class Father(object): def __init__(self, name): self.name=name print ( &quot;name: %s&quot; %( self.name)) def getName(self): return &#x27;Father &#x27; + self.name class Son(Father): def __init__(self, name): super(Son, self).__init__(name) print (&quot;hi&quot;) self.name = name def getName(self): return &#x27;Son &#x27;+self.name if __name__==&#x27;__main__&#x27;: son=Son(&#x27;runoob&#x27;) print ( son.getName() ) #输出结果如下：name: runoobhiSon runoob 也可以直接调用父类的__init__类方法： 1234567891011&gt;&gt;&gt; dad = Father(&#x27;luo&#x27;)name: luo&gt;&gt;&gt; dad.__init__()Traceback (most recent call last): File &quot;&lt;pyshell#10&gt;&quot;, line 1, in &lt;module&gt; dad.__init__()TypeError: __init__() missing 1 required positional argument: &#x27;name&#x27;&gt;&gt;&gt; dad.__init__(&quot;WHALE&quot;)name: WHALE&gt;&gt;&gt; dad.name&#x27;WHALE&#x27; __name__ 一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用__name__属性来使该程序块仅在该模块自身运行时执行。 123456789101112131415#!/usr/bin/python3# Filename: using_name.pyif __name__ == &#x27;__main__&#x27;: print(&#x27;程序自身在运行&#x27;)else: print(&#x27;我来自另一模块&#x27;)#以下是程序运行结果$ python using_name.py #在模块自身运行时程序自身在运行$ python&gt;&gt;&gt; import using_name #在模块被引用时我来自另一模块&gt;&gt;&gt; 注意：每个模块都有一个__name__属性，当其值是__main__时，表明该模块自身在运行，否则是被引入。 单下划线：**_**有时候单个独立下划线是用作一个名字，来表示某个变量是临时的或无关紧要的。 例如，在下面的循环中，我们不需要访问正在运行的索引，我们可以使用”_”来表示它只是一个临时值： 12&gt;&gt;&gt; for _ in range(32):... print(&#x27;Hello, World.&#x27;) 你也可以在拆分(unpacking)表达式中将单个下划线用作”不关心的”变量，以忽略特定的值。 同样，这个含义只是”依照约定”，并不会在Python解释器中触发特殊的行为。 单个下划线仅仅是一个有效的变量名称，会有这个用途而已。 在下面的代码示例中，我将汽车元组拆分为单独的变量，但我只对颜色和里程值感兴趣。 但是，为了使拆分表达式成功运行，我需要将包含在元组中的所有值分配给变量。 在这种情况下，”_”作为占位符变量可以派上用场： 123456789&gt;&gt;&gt; car = (&#x27;red&#x27;, &#x27;auto&#x27;, 12, 3812.4)&gt;&gt;&gt; color, _, _, mileage = car&gt;&gt;&gt; color&#x27;red&#x27;&gt;&gt;&gt; mileage3812.4&gt;&gt;&gt; _12 除了用作临时变量之外，”_”是大多数Python REPL中的一个特殊变量，它表示由解释器评估的最近一个表达式的结果。 这样就很方便了，比如你可以在一个解释器会话中访问先前计算的结果，或者，你是在动态构建多个对象并与它们交互，无需事先给这些对象分配名字： 1234567891011121314&gt;&gt;&gt; 20 + 323&gt;&gt;&gt; _23&gt;&gt;&gt; print(_)23&gt;&gt;&gt; list()[]&gt;&gt;&gt; _.append(1)&gt;&gt;&gt; _.append(2)&gt;&gt;&gt; _.append(3)&gt;&gt;&gt; _[1, 2, 3] 对于上面五种类型的下划线，菜鸟教程的小结可以很好的帮助我们：","categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"},{"name":"Python3","slug":"Programming-languages-and-projects/Python3","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"}],"tags":[{"name":"python3","slug":"python3","permalink":"http://justskim.github.io/tags/python3/"}]},{"title":"linux的进程优先级与进程调度策略","slug":"linux的进程优先级与进程调度策略","date":"2021-10-23T12:38:09.488Z","updated":"2021-10-25T07:05:02.833Z","comments":true,"path":"2021/10/23/linux的进程优先级与进程调度策略/","link":"","permalink":"http://justskim.github.io/2021/10/23/linux%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%8E%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/","excerpt":"","text":"linux的进程优先级与进程调度策略linux中的进程调度策略FIFO，RR，OTHER 实时进程会抢占普通进程，FIFO会导致同优先级实时进程始终占用CPU，RR会保证同优先级实时进程按时间片轮流执行。 上面说的很通俗易懂，那么，两个同等优先级的FIFO实时进程，是不是谁先占据了cpu，另一个就只能等待它完成了让出CPU呢？ 其实不尽然，即使是在单核cpu的linux系统中，FIFO实时进程也会被调度。 具体可见博客： cnblogs.com&#x2F;tongye&#x2F;p&#x2F;9575602.html blog.csdn.net&#x2F;qq_37451250&#x2F;article&#x2F;details&#x2F;104807725 C语言中的进程优先级设置创建实时进程与普通进程略有区别——在创建普通进程的基础上，将调度类从CFS（completely fair完全公平调度类）转向RT类（实时调度类型，包括RR和FIFO） 常见的几个进程优先级设置与取得函数（位于头文件sched.h中）： sched_get_priority_max() 取得静态优先级的上限 sched_get_priority_min() 取得静态优先级的下限 sched_getparam()取得进程的调度参数 sched_setparam()设置进程的调度参数 sched_getscheduler()取得指定进程的调度类 sched_setscheduler()设置指定进程的调度类 int sched_getscheduler(pid_t pid, int policy, const struct sched_param *param) 第一个参数是进程号（0表示本进程），第二个参数为调度类（SCHED_RR为2、SCHED_FIFO为1、SCHED_OTHER为0，三个之一） ，第三个参数是一个struct sched_param 类型的调度参数——其sched_priority成员可以指定优先级。 sched_rr_get_interval()取得按RR算法调度的实时进程的时间片长度 sched_yield()进程主动让出处理器并将自己挂入等候调度队列的队尾 sched文件 C语言system函数 执行 dos(windows系统) 或 shell(Linux&#x2F;Unix系统) 命令，参数字符串command为命令名。另，在windows系统下参数字符串不区分大小写。 说明：在windows系统中，system函数直接在控制台调用一个command命令。在Linux&#x2F;Unix系统中，system函数会调用fork函数产生子进程，由子进程来执行command命令，命令执行完后随即返回原调用的进程。 函数返回值命令执行成功返回0，执行失败返回-1。 C语言sprintf函数 int sprintf( char *buffer, const char *format, [ argument] … )； 这个函数包含三个部分的参数： buffer：char型指针，指向将要写入的字符串的缓冲区。format：格式化字符串。即可选参数的想要输入的数据类型。[argument]…：可选参数，可以是任何类型的数据。 这个函数就是把第三部分的数据，按照第二部分格式化字符的格式，把第三部分的数据进行”格式化“，然后在把格式化后的数据类型，存储到字符串的缓存区间里去。 通过查看&#x2F; proc &#x2F;&lt; PID&gt; &#x2F; sched中的调度统计信息(scheduling stats in /proc/&lt;PID&gt;/sched),您可以获得如下输出（仅限进程运行着的时候） 为了在进程退出后依然能看到这些调度统计信息，我们可以使用以上代码将其存储至本目录的sched-pid文件中 &gt; nr_switches：上下文切换次数.&gt; nr_voluntary_switches：自愿切换的数量,即线程被阻塞,因此拾取另一个线程.&gt; nr_involuntary_switches：调度程序将线程踢出,因为有另一个饥饿的线程已准备好运行. C语言中的进程调度函数","categories":[{"name":"Linux","slug":"Linux","permalink":"http://justskim.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://justskim.github.io/tags/linux/"}]},{"title":"在vmware中“/mnt/hgfs”路径下共享文件夹的挂载","slug":"在vmware中“mnthgfs”路径下共享文件夹的挂载","date":"2021-10-23T12:13:05.314Z","updated":"2021-10-23T12:28:45.188Z","comments":true,"path":"2021/10/23/在vmware中“mnthgfs”路径下共享文件夹的挂载/","link":"","permalink":"http://justskim.github.io/2021/10/23/%E5%9C%A8vmware%E4%B8%AD%E2%80%9Cmnthgfs%E2%80%9D%E8%B7%AF%E5%BE%84%E4%B8%8B%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E6%8C%82%E8%BD%BD/","excerpt":"","text":"在vmware中“&#x2F;mnt&#x2F;hgfs”路径下共享文件夹的挂载在之前的博客中，我们已经讲过如何在vmware虚拟机中设置共享文件夹，mnt目录是挂接光驱、USB设备的目录，在其中进行文件操作需要有root权限。linux系统中一定会有&#x2F;mnt目录，但其下不一定有hgfs目录，在我们成功安装完VMWare tools后会出现hgfs文件夹，但一些情况下hgfs文件夹中可能不存在我们之前在虚拟机中设置的共享文件夹名称，下面是解决办法 &#x2F;mnt路径下有hgfs但却没有共享文件夹先进入到root权限下，使用命令vmware-hgfsclient来查看当前有哪些共享的目录，如果未能成功安装VMWare tools则该命令会导致报错。 然后使用命令mount -t vmhgfs .host:/你所设置的共享文件夹名称 /mnt/hgfs来挂载共享文件夹即可。 以上设置后每次重新开机都要重复设置一次共享文件夹，我们使用在文件/etc/fstab中进行修改来设置开机后自动挂载： 在文件/etc/fstab中添加以下一行：.host:/mnt/hgfs vmhgfs defaults 0 0","categories":[{"name":"Linux","slug":"Linux","permalink":"http://justskim.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://justskim.github.io/tags/linux/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://justskim.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://justskim.github.io/tags/ubuntu/"},{"name":"vmware","slug":"vmware","permalink":"http://justskim.github.io/tags/vmware/"}]},{"title":"linux的权限与隐藏权限","slug":"linux的权限与隐藏权限","date":"2021-09-27T12:26:36.587Z","updated":"2021-09-29T02:11:21.640Z","comments":true,"path":"2021/09/27/linux的权限与隐藏权限/","link":"","permalink":"http://justskim.github.io/2021/09/27/linux%E7%9A%84%E6%9D%83%E9%99%90%E4%B8%8E%E9%9A%90%E8%97%8F%E6%9D%83%E9%99%90/","excerpt":"","text":"linux的权限与隐藏权限linux的权限linux中的文件类型 linux一共有7种文件类型,分别如下: ​ -：普通文件 ​ d：目录文件 ​ l： 软链接（类似Windows的快捷方式） ​ (下面四种是特殊文件) ​ b：块设备文件（例如硬盘、光驱等） ​ p：管道文件 ​ c：字符设备文件（例如猫等串口设备） ​ s：套接口文件&#x2F;数据接口文件（例如启动一个MySql服务器时会产生一个mysql.sock文件） linux的隐藏权限除了文件的读写,执行权限外,linux还有一种隐藏权限,设置隐藏权限可以防止一些其他用户的误操作或者恶意操作,当我们配置了nginx的放跨站攻击或其他安全措施后,相应的会在项目的根目录下生成一个隐藏文件.user.ini,当删除整个项目时会阻止操作完成.我们使用ls命令并使用chmod chown等命令设置了文件权限后会发现还是无法删除.这就是因为这个文件有隐藏的权限。 linux系统的隐藏权限总共有以下十三种类型： A：即Atime，告诉系统不要修改对这个文件的最后访问时间； S：即Sync，一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘； a：即Append Only，系统只允许在这个文件之后追加数据，不允许任何进程覆盖或截断这个文件。如果目录具有这个属性，系统将只允许在这个目录下建立和修改文件，而不允许删除任何文件； b：不更新文件或目录的最后存取时间； c：将文件或目录压缩后存放； d：当dump程序执行时，该文件或目录不会被dump备份； D:检查压缩文件中的错误； i：即Immutable，系统不允许对这个文件进行任何的修改。如果目录具有这个属性，那么任何的进程只能修改目录之下的文件，不允许建立和删除文件； s：彻底删除文件，不可恢复，因为是从磁盘上删除，然后用0填充文件所在区域； u：当一个应用程序请求删除这个文件，系统会保留其数据块以便以后能够恢复删除这个文件，用来防止意外删除文件或目录； t:文件系统支持尾部合并（tail-merging）； X：可以直接访问压缩文件的内容 e: 表示文件以ext4 extents存储的，ext4上新建文件的默认属性，不可用chattr修改。 使用命令chattr +权限类型和chattr -权限类型可以为文件添加或删除隐藏权限 chattr命令提到文件权限的修改，必然绕不过这一命令，根据C语言中文网（这个网站怎么啥都有）： chattr 命令，专门用来修改文件或目录的隐藏属性，只有 root 用户可以使用。该命令的基本格式为： [root@localhost ~]# chattr [+-&#x3D;] [属性] 文件或目录名 下面是常用chattr命令来授予&#x2F;删除的一些属性： 属性选项 功能 i 如果对文件设置 i 属性，那么不允许对文件进行删除、改名，也不能添加和修改数据； 如果对目录设置 i 属性，那么只能修改目录下文件中的数据，但不允许建立和删除文件； a 如果对文件设置 a 属性，那么只能在文件中増加数据，但是不能删除和修改数据； 如果对目录设置 a 属性，那么只允许在目录中建立和修改文件，但是不允许删除文件； u 设置此属性的文件或目录，在删除时，其内容会被保存，以保证后期能够恢复，常用来防止意外删除文件或目录。 s 和 u 相反，删除文件或目录时，会被彻底删除（直接从硬盘上删除，然后用 0 填充所占用的区域），不可恢复。 b 不更新文件或目录的最后存取时间。 c 将文件或目录压缩后存放。 d 将文件或目录排除在倾倒操作之外 S 即时更新文件或目录","categories":[{"name":"Linux","slug":"Linux","permalink":"http://justskim.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://justskim.github.io/tags/linux/"}]},{"title":"在vmware中实现共享文件夹以及安装vmware-tools","slug":"在vmware中实现共享文件夹以及安装vmware-tools","date":"2021-09-27T11:27:13.351Z","updated":"2021-10-01T01:46:47.786Z","comments":true,"path":"2021/09/27/在vmware中实现共享文件夹以及安装vmware-tools/","link":"","permalink":"http://justskim.github.io/2021/09/27/%E5%9C%A8vmware%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85vmware-tools/","excerpt":"","text":"在vmware中实现共享文件夹以及安装vmware-tools原因：想要设置共享文件夹，而ubuntu16.04版本系统中，只有文件夹mnt，其中没有文件夹hgfs，而按照网上教程操作，需要重新安装vmware-tools才能使得该选项可以点击，然而虚拟机菜单栏中，“重新安装vmware-tool”的选项为灰色不可点击 首先使用命令su root跳转至超级用户权限， 然后，使用命令apt-get install open-vmware-tools安装， 注意，完成之后，在文件夹media下面会有以下的文件 我们如果在media文件夹中使用tar命令对 文件 进行解压缩，会发现出错，大量的报错语句： tar: vmware-tools-distrib: Cannot mkdir: Read only file system 然后我们使用命令su root输入密码进入超级用户权限，再次尝试解压缩，依然出错！ 原因在于linux系统对我们的贴心： 我们知道root用户是linux执行权限最高的管理者用户，他可以进行任何的权限操作；然而我们的操作系统同样也考虑过这样的弊端，就是当我们使用者并不了解文件属性和重要性时会给予我们使用者提示； 举个例子，当我们在linux下打开磁盘文件时，想要直接修改磁盘中的文件属性，一般会提示为只读文件，这时我们可以将其从磁盘中移动到本地目录下，这样就可以进行权限操作了； 实例如图显示，我的操作是试图对DVD中的文件进行权限修改，这是不被允许的； 如果我们在media文件夹目录下使用lsattr命令：可以发现： 注意，e是linux文件的隐藏权限类型！！ 在linux操作系统中，有这么几个特殊的文件夹： &#x2F;mnt：一般是挂在镜像和硬盘一类的目录；&#x2F;media:是挂在多媒体设备的目录，如默认情况下的光盘、优盘、硬盘等设备都挂在在此目录；&#x2F;misc即各种其它杂七杂八东西 otp 是第三方软件的存放目录selinux 是linux 下强制存取控制的实现 一般用来保护apachesrv 是存放系统提供服务站点的数据media 是存放即插即用 设备的 挂载点。 比如USB 设备 自动在这个目录下创建一个目录 因为你没有对 文件所对应的内容进行操作 所以他是空的 在How-To-Geek上对Linux系统的目录结构说明文档中，关于media文件夹有这样的解释： &#x2F;media — Removable MediaThe &#x2F;media directory contains subdirectories where removable media devices inserted into the computer are mounted. For example, when you insert a CD into your Linux system, a directory will automatically be created inside the &#x2F;media directory. You can access the contents of the CD inside this directory. 在我们使用apt-get下载了相关tar.gz格式的压缩文件后，这一篇博客介绍了之后的步骤： 当然，作者也遇到了media文件夹中不能解压缩的问题，给出了下面的解答步骤： 于是，我们使用命令cp VMwaretools.tar.gz /home/user/Desktop将其拷贝一份至桌面进行解压缩 tar -zxvf VMwareTools.tar.gz 然后跳转到解压后的文件夹 cd vmware-tools-distrib/ 执行命令sudo ./vmware-install.pl。 完成，成功解压缩。 然后我们重新启动虚拟机，可以看到，&#x2F;mnt文件夹下已经有了hgfs文件夹 在中文的一个方便网站上，我们可以搜索到上面几个重要命令的讲解： cp CoPy，功能为复制文件或目录，可以将多个文件复制到一个具体的文件名或一个已经存在的目录下，也可以同时复制多个文件到一个指定的目录中。 cp [参数] [文件] [路径] tar TARball，根据菜鸟教程中的描述： tar 是用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件。 必要参数如下： A 新增压缩文件到已存在的压缩 c 建立新的压缩文件 d 记录文件的差别 r 添加文件到已经压缩的文件 u 添加改变了和现有的文件到已经存在的压缩文件 x 从压缩的文件中提取文件 t 显示压缩文件的内容 z 支持gzip解压文件 j 支持bzip2解压文件 Z 支持compress解压文件 v 显示操作过程 l 文件系统边界设置 k 保留原有文件不覆盖 m 保留文件不被覆盖 W 确认压缩文件的正确性 cd Change Directory，切换目录 cd [参数] [目录名] 一些特殊的目录表示： “ ~ ”表示为用户目录的意思； “ . ”则是表示目前所在的目录； “ .. ”则表示当前目录位置的上一级目录。 常用参数 -P 如果切换的目标目录是一个符号链接，则直接切换到符号链接指向的目标目录 -L 如果切换的目标目录是一个符号链接，则直接切换到符号链接名所在的目录 – 仅使用”-“选项时，当前目录将被切换到环境变量”OLDPWD”对应值的目录 ~ 切换至当前用户目录 .. 切换至当前目录位置的上一级目录 sudo SuperUser DO sudo 是一种权限管理机制，管理员可以授权于一些普通用户去执行一些 root 执行的操作，而不需要知道 root 的密码。 sudo 允许一个已授权用户以超级用户或者其它用户的角色运行一个命令。当然，能做什么不能做什么都是通过安全策略来指定的。sudo 支持插件架构的安全策略，并能把输入输出写入日志。第三方可以开发并发布自己的安全策略和输入输出日志插件，并让它们无缝的和 sudo 一起工作。默认的安全策略记录在 &#x2F;etc&#x2F;sudoers 文件中。而安全策略可能需要用户通过密码来验证他们自己。也就是在用户执行 sudo 命令时要求用户输入自己账号的密码。如果验证失败，sudo 命令将会退出。 语法格式：sudo [参数] 常用参数： -v 因为 sudo 在第一次执行时或是在 N分钟内没有执行（N 预设为五）会问密码，这个参数是重新做一次确认，如果超过N分钟，也会问密码 -k 强迫使用者在下一次执行 sudo 时问密码（不论有没有超过 N 分钟） -b 将要执行的指令放在背景执行 -p prompt 可以更改问密码的提示语，其中 %u 会代换为使用者的帐号名称，%h 会显示主机名称 -s 执行环境变数中的SHELL 所指定的shell ，或是 &#x2F;etc&#x2F;passwd 里所指定的 shell command 要以系统管理者身份（或以 -u 更改为其他人）执行的指令 例如我们要切换到root用户，需要使用命令sudo su 一个小插曲——如何在ubuntu中启用中英文输入法按照这一篇教程安装搜狗输入法的linux版本，并进行相关配置。 当我们在linux桌面系统的终端或编辑器中启用输入的时候，只要记得右上角linux图标点击切换输入法即可。 当我们在Linux系统启用搜狗输入法时，记得用”shift”键切换中英文即可，对于大写的启用键与windows系统中一致。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://justskim.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://justskim.github.io/tags/linux/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://justskim.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://justskim.github.io/tags/ubuntu/"},{"name":"vmware","slug":"vmware","permalink":"http://justskim.github.io/tags/vmware/"}]},{"title":"在linux系统创建父子进程及相关操作","slug":"在linux系统创建父子进程及相关操作","date":"2021-09-26T02:16:56.153Z","updated":"2021-10-01T01:46:43.533Z","comments":true,"path":"2021/09/26/在linux系统创建父子进程及相关操作/","link":"","permalink":"http://justskim.github.io/2021/09/26/%E5%9C%A8linux%E7%B3%BB%E7%BB%9F%E5%88%9B%E5%BB%BA%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/","excerpt":"","text":"在linux系统创建父子进程及相关操作fork函数fork这一词，在英文中有两个意思： n. 叉(挖掘用的园艺工具); 餐叉; (道路、河流等的)分岔处; 岔路; v. 分岔出分支，走岔路中的一条。 fork函数是基本上只在Linux环境中会使用到的C语言函数，在使用时需要调用unistd.h这个头文件，我们在Linux环境下举例讲解C语言的fork()函数用法： 一个进程，包括代码、数据和分配给进程的资源。fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。 一个进程调用fork（）函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。 由fork函数创建的新进程被称为子进程。fork函数被调用一次，但是返回两次。父进程返回的值是新进程的进程ID，而子进程返回的值是0。 fork函数返回值的三种情况 返回子进程标识符，即PID给父进程（在父进程中，fork返回新创建子进程的进程ID） 因为一个进程的子进程可能有多个，并且没有一个函数可以获得一个进程的所有子进程ID。 返回0给子进程（在子进程中，fork返回值为0） 一个进程只会有一个父进程，所以子进程总是可以调用getpid以获得当前进程Id以及调用getppid获得父进程Id. 出现错误，返回负值 当前进程数已经达到系统规定的上限，这时errno的值被设置为EAGAIN 系统内存不足，这时errno的值被设置为ENOMEM 创建新进程成功后，系统中出现两个基本完全相同的进程，这两个进程执行没有固定的先后顺序，哪个进程先执行要看系统的进程调度策略 更加形象的解释： “ 其实就相当于链表，进程形成了链表，父进程的fork函数返回的值指向子进程的进程id, 因为子进程没有子进程，所以其fork函数返回的值为0 . 调用fork之后，数据、堆、栈有两份，代码仍然为一份但是这个代码段成为两个进程的共享代码段都从fork函数中返回。当父子进程有一个想要修改数据或者堆栈时，两个进程真正分裂。 注意！子进程代码是从fork处开始执行的， 为什么不是从#include处开始复制代码的？这是因为fork是把 进程当前的情况拷贝一份 ，执行fork时，进程已经执行完了int count&#x3D;0;fork只拷贝下一个要执行的代码到新的进程。 fork函数被调用一次，返回两次，详解来自这篇博客的例子： 123456789101112131415161718192021#include &lt;unistd.h&gt; //引入pid_t类型的头文件#include &lt;stdio.h&gt; int main () &#123; pid_t fpid; //fpid表示fork函数返回的值 int count=0; fpid=fork(); if (fpid &lt; 0) printf(&quot;error in fork!&quot;); //fork函数返回的第一种情况，为负数，错误处理 else if (fpid == 0) &#123; //fork函数返回的第二种情况，在子进程中返回0 printf(&quot;i am the child process, my process id is %d/n&quot;,getpid()); count++; &#125; else &#123; //fork函数返回的第三种情况，在父进程中，fork返回新创建子进程的进程ID printf(&quot;i am the parent process, my process id is %d/n&quot;,getpid()); //这里因为已经在父进程中了，getpid()函数返回的是当前进程（elseif语句中进程的父进程）的进程ID count++; &#125; printf(&quot;统计结果是: %d/n&quot;,count); return 0;&#125; 编译后运行的结果： 1234i am the child process, my process id is 5574统计结果是: 1i am the parent process, my process id is 5573统计结果是: 1 借用一张图解释一下为什么同一个if else语句会执行两次，并且count的值为1而不是2： 上面的代码都是位于语句fpid=fork()之后，进程1的变量为count=0，fpid！=0（父进程）。进程2的变量为count=0，fpid=0（子进程），这两个进程的变量都是独立的，存在不同的地址中，不是共用的，这点要注意。可以说，我们就是通过fpid来识别和操作父子进程的。 如果疑惑为什么不是从#include处开始复制代码的，这是因为fork是把进程当前的情况拷贝一份，执行fork时，进程已经执行完了int count=0;，正如我们上面所说的，子进程代码是从fork处开始执行的，fork只拷贝下一个要执行的代码到新的进程。 所以，其实执行的是两个if…else语句，输出的两个count也不是同一个。 12345678910111213141516171819202122232425#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main(void)&#123; int i=0; printf(&quot;i son/pa ppid pid fpid/n&quot;);//打印表头 for(i=0;i&lt;2;i++)&#123; pid_t fpid=fork(); if(fpid==0) printf(&quot;%d child %4d %4d %4d/n&quot;,i,getppid(),getpid(),fpid); else printf(&quot;%d parent %4d %4d %4d/n&quot;,i,getppid(),getpid(),fpid); &#125; return 0;&#125;/*运行结果： i son/pa ppid pid fpid 0 parent 2043 3224 3225 这里是最开始的那个父进程id3224，它的ppid2043我们不用管 0 child 3224 3225 0 子进程3225的ppid是父进程的pid 1 parent 2043 3224 3226 仍然是父进程id3224，又用fork创建了一个子进程3226 1 parent 3224 3225 3227 在这里fork返回了子进程3225创建的孙子进程3227 1 child 1 3227 0 1 child 1 3226 0*/ 从上面，我们可以看到，每次都是先执行父进程中的语句，再执行子进程中拷贝的代码语句，正如博主所说： 第一步：在父进程中，指令执行到for循环中，i&#x3D;0，接着执行fork，fork执行完后，系统中出现两个进程，分别是p3224和p3225（后面我都用pxxxx表示进程id为xxxx的进程）。可以看到父进程p3224的父进程是p2043，子进程p3225的父进程正好是p3224。我们用一个链表来表示这个关系： p2043-&gt;p3224-&gt;p3225 第一次fork后，p3224（父进程）的变量为i&#x3D;0，fpid&#x3D;3225（fork函数在父进程中返向子进程id） p3225（子进程）的变量为i&#x3D;0，fpid&#x3D;0（fork函数在子进程中返回0），打印出结果： 0 parent 2043 3224 3225 0 child 3224 3225 0 第二步：假设父进程p3224先执行，当进入下一个循环时，i&#x3D;1，接着执行fork，系统中又新增一个进程p3226，对于此时的父进程，p2043-&gt;p3224（当前进程）-&gt;p3226（被创建的子进程）。 对于子进程p3225，执行完第一次循环后，i&#x3D;1，接着执行fork，系统中新增一个进程p3227，对于此进程，p3224-&gt;p3225（当前进程）-&gt;p3227（被创建的子进程）。从输出可以看到p3225原来是p3224的子进程，现在变成p3227的父进程。父子是相对的，这个大家应该容易理解。只要当前进程执行了fork，该进程就变成了父进程了，就打印出了parent。 所以打印出结果是： 1 parent 2043 3224 3226 1 parent 3224 3225 3227 第三步：第二步创建了两个进程p3226，p3227，这两个进程执行完printf函数后就结束了，因为这两个进程无法进入第三次循环，无法fork，该执行return 0;了，其他进程也是如此。 以下是p3226，p3227打印出的结果： 1 child 1 3227 0 1 child 1 3226 0 细心的读者可能注意到p3226，p3227的父进程难道不该是p3224和p3225吗，怎么会是1呢？这里得讲到进程的创建和死亡的过程，在p3224和p3225执行完第二个循环后，main函数就该退出了，也即进程该死亡了，因为它已经做完所有事情了。p3224和p3225死亡后，p3226，p3227就没有父进程了，这在操作系统是不被允许的，所以p3226，p3227的父进程就被置为p1了，p1是永远不会死亡的，至于为什么，这里先不介绍。 最后，用博主的这段打印祖孙三代关系的代码： 1234567891011121314151617181920212223242526#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main(void)&#123; int i=0; for(i=0;i&lt;3;i++)&#123; pid_t fpid=fork(); if(fpid==0) printf(&quot;son/n&quot;); else printf(&quot;father/n&quot;); &#125; return 0;&#125;/* for i=0 1 2 father father father son son father son son father father son son father son*/ pid_t类型pid_t类型是Linux下的进程号类型，在Linux环境编程中用于定义进程ID，需要引入头文件&lt;sys/types.h&gt;，否则会报错：error:&#39;pid_t&#39; was not declared in this scope。 使用fork函数时，为什么使用pid_t而不用int: pid_t是一个typedef定义类型，sys&#x2F;types.h中的定义:typedef short pid_t; &#x2F;* used for process ids *&#x2F; pid_t就是一个short类型变量，实际表示的是内核中的进程表的索引 可以看到，头文件里也不过是个typedef而已.使用pid_t而不使用int只是为了可移植性好一些.因为在不同的平台上有可能这么定义：typedef int pid_t也有可能：typedef long pid_t 但是，在和fork函数配合使用时，由于进程很多时，fork函数返回的pid_t类型的子进程id，可能长度超过了int类型，需要用long int类型来存储，这时候就使用pid_t来存储子进程PID比较便于使用和移植。 PID PPID PGID与SID详见博客，在Linux中，进程都拥有以下的ID Process ID(PID，也称之为进程标识)Linux中标识进程的一个数字，它的值是不确定的，是由系统分配的（但是有一个例外，启动阶段,kernel运行的第一个进程是init，它的PID是1，是所有进程的最原始的父进程），每个进程都有唯一PID，当进程退出运行之后，PID就会回收，可能之后创建的进程会分配这个PID Parent Process ID(PPID)字面意思，父进程的PID Process Group ID(PGID)PGID就是进程所属的Group的Leader的PID，如果PGID&#x3D;PID，那么该进程是Group Leader Session ID(SID)和PGID非常相似，SID就是进程所属的Session Leader的PID，如果SID&#x3D;&#x3D;PID，那么该进程是session leader Session和Group都是管理多个进程的方式，同一个Group的进程属于同一个Session，一个Session里可以包含多个Group 注意，父进程也有ppid（爸爸的爸爸叫爷爷(～￣▽￣)～ ），ppid为1的进程被称之为僵尸进程，这是因为linux下有3个特殊的进程，idle进程(PID = 0), init进程(PID = 1)和kthreadd(PID = 2)。 在terminal中使用默认的ps命令输出的信息值包括和当前终端会话相关的进程信息，自然看不到id很短的进程： 我们可以使用命令ps --help获取帮助，然后使用命令ps -A或ps -e来获取全部进程（all process）![查看全部进程](E:\\JS练习\\blog\\Myblog\\source\\images\\ps -A命令.png) getpid和getppid函数，与fork函数产生的pidgetpid返回当前进程标识（也就是PID），getppid返回当前进程的父进程标识，使用这两个函数需要引入头文件&lt;unistd.h&gt;。 每个进程都有一个独特（互不相同）的进程标识符（process ID），可以通过getpid()函数获得，还有一个记录父进程pid的变量，可以通过getppid()函数获得变量的值。 这两个函数在调用中都不能返回错误，注意，返回值的pid_t类型 能够放进 int类型中去，返回值被转为long 整型输出。 ！！注意，我们常用到命令pid_t pid = fork()产生的pid根据所处分支是在子进程还是在父进程而具有不同的值，同时要注意，这个pid的值，是getpid()返回的进程id刚创建的子进程id（没有则为0），从祖宗关系上，是getppid()返回的id所属的进程的孙子进程的id，例如下面这一段代码： 123456789101112131415161718int main()&#123; int fencha(int i,int num); fencha(0,10);&#125;int fencha(int i,int num)&#123; int pid = fork; if(pid&lt;0)printf(&quot;ERROR\\n&quot;); else if(pid==0)&#123; sleep(1); if(i&lt;num) fencha(i+1,num); &#125; else&#123; printf(&quot;现在在父进程中&quot;); printf(&quot;由fork函数产生的pid是 %d,&quot;,pid) printf(&quot;用getpid函数获取的值为%d，用getppid函数获取的值为%d\\n&quot;,getpid(),getppid()); &#125;&#125; 我们看到代码结果如下，这是一个十层的子进程递归创建，祖宗总共十代： 1 注意，在上面的代码中，我们使用了sleep()函数，这是为了确保在子进程代码运行的过程中，父进程不会执行完所有代码而被内核释放掉所有资源，如果我们不使用sleep函数，如下面的代码，会导致孤儿进程（没有父进程的进程，那么照顾他的重任就落到了init进程身上）的产生。 想想看，为什么我们的代码已经执行完毕，但是id为6666的进程依然可以在ps命令中被查询到，tty为一个问号?说明该进程不是通过tty&#x2F;console启动，自然与终端terminal无关。 孤儿进程与僵尸进程这篇博客中提到了一个区别： 孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。 僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。 值得注意的是，照顾孤儿进程的进程id在不同版本的Linux系统中是不一样的，笔者所用的ubuntu16.04版本中由id为6666的进程负责收养孤儿进程。 虽然孤儿进程并没有危害，任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。这是每个 子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。 如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://justskim.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://justskim.github.io/tags/linux/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://justskim.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://justskim.github.io/tags/ubuntu/"},{"name":"c语言","slug":"c语言","permalink":"http://justskim.github.io/tags/c%E8%AF%AD%E8%A8%80/"},{"name":"进程","slug":"进程","permalink":"http://justskim.github.io/tags/%E8%BF%9B%E7%A8%8B/"}]},{"title":"在linux系统中编写并执行C语言程序","slug":"在linux系统中编写并执行C语言程序","date":"2021-09-24T12:07:36.765Z","updated":"2021-09-27T02:26:49.095Z","comments":true,"path":"2021/09/24/在linux系统中编写并执行C语言程序/","link":"","permalink":"http://justskim.github.io/2021/09/24/%E5%9C%A8linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%BC%96%E5%86%99%E5%B9%B6%E6%89%A7%E8%A1%8CC%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"在linux系统中编写并执行C语言程序1. 按照教程使用Vmware创建虚拟机值得注意的两点是，vmware15的激活码无法适用于vmware16的虚拟机，ubuntu的iso映像文件可以在官方网站中下载，使用最新（20版本）的即可。版本名称中带有desktop字段的意味着自带图形界面系统。 2. linux系统下的C语言编译执行我们按照教程的步骤配置编译程序环境： 找到命令行窗口输入：（1）、sudo apt-get install gcc（2）、sudo apt-get install build-essential &#x2F;&#x2F;编写c所用到的库（3）、gedit [文件名].c &#x2F;&#x2F;创建一个c文件，并且会自动打开，即可开始编写（4）、gcc [文件名].c -o [自定义程序名] &#x2F;&#x2F;创建可执行文件（5）、.&#x2F; [自定义程序名] &#x2F;&#x2F;即可运行 然后写了第一个简单的程序： 12345#include &lt;stdio.h&gt;int main()&#123; printf(&quot;hello world\\n&quot;); return 0;&#125; 执行，报错： 12345user@ubuntu:~$ cd Desktop#因为是在桌面上直接创建的cpp程序，因此要从home/user文件夹中跳到子文件夹Desktop中user@ubuntu:~/Desktop$ ./hello.cppbash: ./hello.cpp: Permission denied 根据博客的讲解： 出现这个问题的原因是由于权限不够。解决办法就是改变可执行文件的权限。 对于单个的可执行文件使用命令：chmod 777 file-name若需要将一个目录下的所有可执行文件的权限都升级，可使用命令：chmod -R 777 directory-name 其中：-R 是指级联应用到目录里的所有子目录和文件777 是所有用户都拥有最高权限 如果我们不对cpp文件创建可执行文件，而是直接运行cpp文件，会导致报错如下： 123user@ubuntu:~/Desktop$ ./hello.cpp./hello.cpp: line 2: syntax error near unexpected token `(&#x27;./hello.cpp: line 2: `int main()&#123;&#x27; 只有执行gcc编译命令后，再执行相关可执行文件，才可正确输出： 123user@ubuntu:~/Desktop$ gcc hello.cpp -o hellouser@ubuntu:~/Desktop$ ./hellohello world 除此之外，我们还可以在ubuntu的页面上看到一个hello可执行文件： 可以看到，文件的类型其实就是executable，简称exe可执行文件。 3. GCC编译在配置好的windows系统中，C程序执行步骤如下所示： 打开一个文本编辑器，添加上述代码。 保存文件为 hello.c。 打开命令提示符，进入到保存文件所在的目录。 键入 gcc hello.c，输入回车，编译代码。 如果代码中没有错误，命令提示符会跳到下一行，并生成 a.out 可执行文件。 现在，键入 a.out 来执行程序。 您可以看到屏幕上显示 *”Hello World”*。 123$ gcc hello.c$ ./a.outHello, World! 在C语言中，一个源程序如果不编译是绝对无法运行的。一个源程序必须经过编译生成后缀为.obj目标程序，然后连接生成后缀为.exe的可执行文件，方能运行。如果编译没有问题，只能说明没有语法错误，但可能会存在一些逻辑错误导致程序不能运行。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://justskim.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://justskim.github.io/tags/linux/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://justskim.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://justskim.github.io/tags/ubuntu/"},{"name":"c语言","slug":"c语言","permalink":"http://justskim.github.io/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"几个常用的vue名词详解","slug":"几个常用的vue名词详解","date":"2021-09-19T02:25:01.014Z","updated":"2021-09-19T12:19:51.412Z","comments":true,"path":"2021/09/19/几个常用的vue名词详解/","link":"","permalink":"http://justskim.github.io/2021/09/19/%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84vue%E5%90%8D%E8%AF%8D%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"几个常用的vue名词详解vue是什么？没有比官网更好的解释了： Vue (读音 &#x2F;vjuː&#x2F;，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 官方文档中还提供提供了vue2与其他几个常见框架的对比。 相比传统的html、css、javascript使用vue的优势在于我们不必手动操作DOM，而是可以直接将js变量放到html页面当中，数据会自动绑定。开发者只需将重点放到对数据的处理上即可，代码也更加精简。当页面元素很多的时候，使用vue组件（如v-for列表渲染），可以让我们不必再一味复制粘贴html标签。 但是，以上操作只是将html和js组合在一起，并解决了html的复用问题，但css样式依然需要复制粘贴。为了解决这个问题，我们要使用单文件的vue组件，将html，css，javascript代码放到同一个.vue文件中。然后，使用webpack这一构建工具将代码进行分离，并分别与其他同类型的代码打包到一起。在基础阶段不必熟知webpack的具体原理，只需会用即可。 使用webpack打包有以下几个好处： 将许多碎小文件打包成一个整体，减少单页面内的衍生请求次数，提高网站效率。 将ES6的高级语法进行转换编译，以兼容老版本的浏览器。 将代码打包的同时进行混淆，提高代码的安全性。 webpack模板webpack官方文档对此有解释： 本质上，webpack 是一个现代 JavaScript 应用程序的*静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)*，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 这篇简书文章中也有提到： Webpack是一个模块化打包工具，专注于构建模块化项目，在Webpack眼里一切文件都是模块，通过Loader转换翻译文件，通过Plugin注入钩子，最后输出由多个模块组合成的文件。 之所以一切文件皆模块，如：JavaScript、CSS、SCSS以及图片等资源，在Webpack眼中都是模块，因为这样可以更好的理清描述各个模块之间的依赖关系，方便Webpack对模块进行打包组合，输出浏览器使用的静态资源。 目前，大部分的教程和大型项目都推荐使用webpack对vue进行打包。 为什么要使用vue-cli?Vue 提供了一个官方的 CLI，为单页面应用 (SPA) 快速搭建繁杂的脚手架。它为现代前端工作流提供了开箱即用的构建设置。只需要几分钟的时间就可以运行起来并带有热重载、保存时 lint 校验，以及生产环境可用的构建版本。更多详情可查阅 vue cli官方文档对vue-cli的定义： Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统，提供： 通过 @vue/cli 实现的交互式的项目脚手架。 通过 @vue/cli + @vue/cli-service-global 实现的零配置原型开发。 一个运行时依赖 ( 1@vue/cli-service )，该依赖： 可升级； 基于 webpack 构建，并带有合理的默认配置； 可以通过项目内的配置文件进行配置； 可以通过插件进行扩展。 一个丰富的官方插件集合，集成了前端生态中最好的工具。 一套完全图形化的创建和管理 Vue.js 项目的用户界面。 Vue CLI 致力于将 Vue 生态中的工具基础标准化。它确保了各种构建工具能够基于智能的默认配置即可平稳衔接，这样你可以专注在撰写应用上，而不必花好几天去纠结配置的问题。与此同时，它也为每个工具提供了调整配置的灵活性，无需 eject。 这篇掘金文章中，讲到了使用命令vue init webpack myproject来创建项目时候的信息填写与选择： Project name (baoge)： —–项目名称，直接回车，按照括号中默认名字（注意这里的名字不能有大写字母，否则会报错：Sorry, name can no longer contain capital letters） Project description (A Vue.js project)： —-项目描述，也可直接点击回车，使用默认名字 Author ()： —-作者 接下来是用户可以进行选择的项： Runtime + Compiler: recommended for most users 运行加编译，既然已经说了推荐，就选它了Runtime-only: about 6KB lighter min+gzip, but templates (or any Vue-specificHTML) are ONLY allowed in .vue files - render functions are required elsewhere 仅运行时，已经有推荐了就选择第一个了 Install vue-router? (Y&#x2F;n) 是否安装vue-router，这是官方的路由，大多数情况下都使用，这里就输入“y”后回车即可。 Use ESLint to lint your code? (Y&#x2F;n) 是否使用ESLint管理代码，ESLint是个代码风格管理工具，是用来统一代码风格的，一般项目中都会使用。接下来也是选择题Pick an ESLint preset (Use arrow keys) 选择一个ESLint预设，编写vue项目时的代码风格，直接y回车 Setup unit tests with Karma + Mocha? (Y&#x2F;n) 是否安装单元测试，选择安装y回车 Setup e2e tests with Nightwatch(Y&#x2F;n)? 是否安装e2e测试 ，选择安装y回车 不使用vue-cli的情况下搭建vue项目首先，我们在DOS窗口中使用npm init来初始化一个项目。 在node开发中使用npm init会生成一个pakeage.json文件，这个文件主要是用来记录这个项目的详细信息的，它会将我们在项目开发中所要用到的包，以及项目的详细信息等记录在这个项目中。方便在以后的版本迭代和项目移植的时候会更加的方便。也是防止在后期的项目维护中误删除了一个包导致的项目不能够正常运行。使用npm init初始化项目还有一个好处就是在进行项目传递的时候不需要将项目依赖包一起发送给对方，对方在接受到你的项目之后再执行npm install就可以将项目依赖全部下载到项目里。话不多说我们就直接开始进行操作。 执行该命令后，DOS窗口中询问选项的含义如下所示： 123456789package name: 你的项目名字叫啥version: 版本号description: 对项目的描述entry point: 项目的入口文件（一般你要用那个js文件作为node服务，就填写那个文件，旧的版本默认为app.js，在14.15.5版本的node中默认为index.js）test command: 项目启动的时候要用什么命令来执行脚本文件git repository: 如果你要将项目上传到git中的话，那么就需要填写git的仓库地址keywords： 项目关键字author: 作者的名字license: 发行项目需要的证书，默认为ISC npmjs的官方网站上有对这几个名词的解释，中文方面的翻译欠缺。 对于任何项目，Entry point是执行开始的文件。它取决于正在使用的技术的项目配置和运行时环境。 示例：对于node.js项目，使用app.js初始化应用程序并将所有内容粘合在一起。 在我们生成的package.json中，也有一个名为main的属性，官方解释： The main field is a module ID that is the primary entry point to your program. 对于属性keywords的解释： Put keywords in it. It’s an array of strings. This helps people discover your package as it’s listed in npm search. 想省事的话，可以使用命令npm init -y来代替，该命令会采用所有默认的配置。 项目会生成一个package.json文件，代码如下： 12345678910111213&#123; &quot;name&quot;: &quot;vue_test&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;&#125;","categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"},{"name":"JavaScript","slug":"Programming-languages-and-projects/JavaScript","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/JavaScript/"},{"name":"Vue","slug":"Programming-languages-and-projects/JavaScript/Vue","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/JavaScript/Vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://justskim.github.io/tags/vue/"},{"name":"vue-cli","slug":"vue-cli","permalink":"http://justskim.github.io/tags/vue-cli/"},{"name":"webpack","slug":"webpack","permalink":"http://justskim.github.io/tags/webpack/"},{"name":"store","slug":"store","permalink":"http://justskim.github.io/tags/store/"},{"name":"router","slug":"router","permalink":"http://justskim.github.io/tags/router/"}]},{"title":"创建vue项目的两个命令：vue create myproject与vue init webpack 详解","slug":"创建vue项目的两个命令：vue-create-myproject与vue-init-webpack-详解","date":"2021-09-19T02:11:56.099Z","updated":"2021-09-22T03:01:21.593Z","comments":true,"path":"2021/09/19/创建vue项目的两个命令：vue-create-myproject与vue-init-webpack-详解/","link":"","permalink":"http://justskim.github.io/2021/09/19/%E5%88%9B%E5%BB%BAvue%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%91%BD%E4%BB%A4%EF%BC%9Avue-create-myproject%E4%B8%8Evue-init-webpack-%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"创建vue项目的两个命令：vue create myproject与vue init webpack 详解两个不同方法的来源vue create 是vue-cli3.x（包括现在最新的vue-cli4.x）的初始化方式，目前模板是固定的，模板选项可自由配置，创建出来的是vue-cli3的项目，与cue-cli2项目结构不同，配置方法不同，具体配置方法参考官方文档网页链接。 vue init 则是vue-cli2.x的初始化方式，可以使用github上面的一些模板来初始化项目，webpack是官方推荐的标准模板名。vue-cli2.x项目向3.x迁移只需要把static目录复制到public目录下，老项目的src目录覆盖3.x的src目录(如果修改了配置，可以查看文档，用cli3的方法进行配置) vue init webpack 详解简书文章中对DOS窗口中各个选择题的解释： Project name (my-project): #项目名称，如果不需要就直接回车。注：此处项目名不能使用大写。 Project description (A Vue.js project): #项目描述，如果不需要就直接回车。 Author (xxx)：#项目作者，默认计算机用户名 vue build (Use arrow keys) &gt; Runtime + Compiler:recommended for most users #译：运行+编译：被推荐为大多数用户的默认选择 &gt; Runtime-only:about 6KB lighter min+gzip,but templates (or any Vue-specific HTML) are ONLY allowed in .vue files-render functions are required elsewhere #译：只运行大约6KB比较轻量的压缩文件，但只允许模板（或任何VUE特定HTML，VUE文件需要在其他地方呈现函数。翻译不精准，意思大概是选择该构建方式对文件大小有要求 install vue-router? #安装vue的路由插件，需要就选y，否则就n [建议Y] Use ESLint to lint your code? #是否使用ESLint检测你的代码？[ESLint 是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。建议选择 ‘N’ 因为选择 ‘Y’ 在做调试项目时,控制台会有很多 黄色警告 提示格式不规范,但其实并不影响项目] Setup unit tests? #是否安装单元测试(国内其实为了追求开发速度这一块很少安装，但后续添加麻烦) Setup e2e tests with Nightwatch(Y&#x2F;n)? #是否安装E2E测试框架NightWatch（E2E，也就是End To End，就是所谓的“用户真实场景” [建议N] Should we run ‘npm install’ for you after the project has been created? #项目创建后是否要为你运行“npm install”?这里选择包管理工具 [建议yes,use npm] yes,use npm #使用npm yes,use yarn #使用yarn no,I will handle that myself #自己操作 Run time complier和Run time only的区别 二者区别主要在main.js文件上：Run time complier中注册了App在使用，而在Run time only中，直接是一个render函数 12345678import Vue from &#x27;vue&#x27;import App from &#x27;./App&#x27;Vue.config.productionTip = falsenew Vue(&#123; el:&#x27;#app&#x27;, components:&#123; App &#125;, template:&#x27;&lt;App/&gt;&#x27;&#125;) Run time only 1234567import Vue from &#x27;vue&#x27;import App from &#x27;./App&#x27;Vue.config.productionTip = falsenew Vue(&#123; el:&#x27;#app&#x27;, render: h =&gt; h(App)&#125;) 二者区别的原因在于运行原理 在run time comliper中，将template传进给Vue时，会将template保存在Vue实例中的potions中，然后解析成ast 结构（ast是abstrct syntax trees英文的简称，译为抽象语法树）进而，将ast 编译成render函数；render函数又会将对应的tempalet转换成虚拟的dom节点元素，这些虚拟的节点元素就会构成一课虚拟dom树，最后再转化成真实的dom元素，也是就UI。 这就是run time comliper 的原理，总结起来就是：template –&gt; ast –&gt; render –&gt;virtual dom –&gt; UI。 run time only 中没有template 而只有函数，所以它的原理就是比 run time compiler 少了template –&gt; ast 的步骤。直接从render函数开始，转换成虚拟的dom最后变成真实的UI。 全部选择y的情况文件目录结构： 123456789101112131415161718192021222324252627282930313233343536project| README.md| .editorconfig| .eslintignore| .eslintrc.js| .gitignore| .postcssrc.js| .babelrc| package.json| package-lock.json| index.html└---node_modules└---config| |---dev.env.js| |---index.js| |---prod.env.js└---build| |---build.js| |---check-versions.js| |---logo.png| |---utils.js| |---vue-loader.conf.js| |---webpack.base.conf.js| |---webpack.dev.conf.js| |---webpack.prod.conf.js└---static| |---.gitkeep└---src |---App.vue |---main.js └---router | |---index.js └---components | |---HelloWorld.vue └---assets |---logo.png 简易说明一下其中几个文件和文件夹的说明： 123456789node_modules：安装的依赖代码库.babelrc：babel相关配置（babel的作用在于将es6语法转换成浏览器支持的es5语法）.editorconfig：编辑器的配置，可以在此修改代码、缩进等.eslintrc.js：eslint的配置文件.gitignore：git忽略里面设定的这些文件的提交src：项目源码static：存放静态资源index.html：入口html文件package.json：项目的配置文件，用于描述该项目，包括初始化时的设置、环境、依赖包、版本等信息 .eslintignore文件： 当 ESLint 运行时，在确定哪些文件要检测之前，它会在当前工作目录中查找一个 .eslintignore 文件。如果发现了这个文件，当遍历目录时，将会应用这些偏好设置。一次只有一个 .eslintignore 文件会被使用，所以，不是当前工作目录下的 .eslintignore 文件将不会被用到。 static文件夹中的.gitkeep文件： git无法追踪一个空文件夹,当用户需要追踪(track)一个空文件夹的时候,按照惯例,大家会把一个称为.gitkeep的文件放在这些文件夹里 build文件夹build文件夹中的文件对 webpack 开发和打包进行相关设置，包括入口文件、输出文件、使用的模块等。build.js构建环境下的配置:loading动画、删除创建目标文件夹、webpack编译、输出信息： 123456789101112131415161718192021222324252627282930313233343536373839404142&#x27;use strict&#x27;require(&#x27;./check-versions&#x27;)() //请求同级目录下的check-versions.js文件，进行node和npm的版本检查process.env.NODE_ENV = &#x27;production&#x27; //设置环境变量为生产环境const ora = require(&#x27;ora&#x27;) //主要用来实现node.js命令行环境的loading效果,和显示各种状态的图标等const rm = require(&#x27;rimraf&#x27;)const path = require(&#x27;path&#x27;)const chalk = require(&#x27;chalk&#x27;)const webpack = require(&#x27;webpack&#x27;)const config = require(&#x27;../config&#x27;)const webpackConfig = require(&#x27;./webpack.prod.conf&#x27;)const spinner = ora(&#x27;building for production...&#x27;)spinner.start() //启动Loading动画//删除dist/static文件夹rm(path.join(config.build.assetsRoot, config.build.assetsSubDirectory), err =&gt; &#123; if (err) throw err webpack(webpackConfig, (err, stats) =&gt; &#123; spinner.stop() //结束Loading动画 if (err) throw err process.stdout.write(stats.toString(&#123; //标准输出流，类似于console.log colors: true, //增加控制台颜色开关 modules: false, //是否增加内置模块信息 children: false, // If you are using ts-loader, setting this to true will make TypeScript errors show up during build. chunks: false, //是否允许较少的输出 chunkModules: false//是否在编译过程中持续打印 &#125;) + &#x27;\\n\\n&#x27;) //编译出错的信息 if (stats.hasErrors()) &#123; console.log(chalk.red(&#x27; Build failed with errors.\\n&#x27;)) process.exit(1) &#125; //编译成功的信息 console.log(chalk.cyan(&#x27; Build complete.\\n&#x27;)) console.log(chalk.yellow( &#x27; Tip: built files are meant to be served over an HTTP server.\\n&#x27; + &#x27; Opening index.html over file:// won\\&#x27;t work.\\n&#x27; )) &#125;)&#125;) check-versions.js文件负责node和npm的版本检查 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&#x27;use strict&#x27;const chalk = require(&#x27;chalk&#x27;)const semver = require(&#x27;semver&#x27;)const packageConfig = require(&#x27;../package.json&#x27;)const shell = require(&#x27;shelljs&#x27;)/*脚本跨域通过child_process模块新建子进程，从而执行unix系统命令将cmd参数传递的值转换成前后没有空格的字符串，即版本号*/function exec (cmd) &#123; return require(&#x27;child_process&#x27;).execSync(cmd).toString().trim()&#125;//声明常量数组，数组内容为有关node相关信息的对象const versionRequirements = [ &#123; name: &#x27;node&#x27;,//对象名称 currentVersion: semver.clean(process.version), //使用semver插件，将版本信息转换成规定格式 versionRequirement: packageConfig.engines.node //规定package.json中engines选项的node版本信息 &#125;]if (shell.which(&#x27;npm&#x27;)) &#123; //linux指令 versionRequirements.push(&#123; name: &#x27;npm&#x27;, currentVersion: exec(&#x27;npm --version&#x27;), versionRequirement: packageConfig.engines.npm &#125;)&#125;module.exports = function () &#123; const warnings = [] for (let i = 0; i &lt; versionRequirements.length; i++) &#123; const mod = versionRequirements[i] if (!semver.satisfies(mod.currentVersion, mod.versionRequirement)) &#123; warnings.push(mod.name + &#x27;: &#x27; + chalk.red(mod.currentVersion) + &#x27; should be &#x27; + chalk.green(mod.versionRequirement) //若版本号用红色标识，则要求改用绿色标识 ) &#125; &#125;//为真则打印提示用户升级新版本 if (warnings.length) &#123; console.log(&#x27;&#x27;) console.log(chalk.yellow(&#x27;To use this template, you must update following to modules:&#x27;)) console.log() for (let i = 0; i &lt; warnings.length; i++) &#123; const warning = warnings[i] console.log(&#x27; &#x27; + warning) &#125; console.log() process.exit(1) &#125;&#125; util.js文件配置静态资源路径，生成cssLoaders用于加载.vue文件中的样式，生成styleLoaders用于加载不在.vue文件中的单独存在的样式文件（被引入的css文件） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&#x27;use strict&#x27;const path = require(&#x27;path&#x27;)const config = require(&#x27;../config&#x27;) //！引入的是config文件夹下的index.js文件const ExtractTextPlugin = require(&#x27;extract-text-webpack-plugin&#x27;)//该插件抽离css样式const packageConfig = require(&#x27;../package.json&#x27;)exports.assetsPath = function (_path) &#123; const assetsSubDirectory = process.env.NODE_ENV === &#x27;production&#x27; ? config.build.assetsSubDirectory : config.dev.assetsSubDirectory return path.posix.join(assetsSubDirectory, _path)&#125;exports.cssLoaders = function (options) &#123; options = options || &#123;&#125; const cssLoader = &#123; loader: &#x27;css-loader&#x27;, options: &#123; sourceMap: options.sourceMap &#125; &#125; const postcssLoader = &#123; loader: &#x27;postcss-loader&#x27;, options: &#123; sourceMap: options.sourceMap &#125; &#125; // generate loader string to be used with extract text plugin function generateLoaders (loader, loaderOptions) &#123; const loaders = options.usePostCSS ? [cssLoader, postcssLoader] : [cssLoader] if (loader) &#123; loaders.push(&#123; loader: loader + &#x27;-loader&#x27;, options: Object.assign(&#123;&#125;, loaderOptions, &#123; sourceMap: options.sourceMap &#125;) &#125;) &#125; // Extract CSS when that option is specified // (which is the case during production build) if (options.extract) &#123; return ExtractTextPlugin.extract(&#123; use: loaders, fallback: &#x27;vue-style-loader&#x27; &#125;) &#125; else &#123; return [&#x27;vue-style-loader&#x27;].concat(loaders) &#125; &#125; // https://vue-loader.vuejs.org/en/configurations/extract-css.html return &#123; css: generateLoaders(), postcss: generateLoaders(), less: generateLoaders(&#x27;less&#x27;), sass: generateLoaders(&#x27;sass&#x27;, &#123; indentedSyntax: true &#125;), scss: generateLoaders(&#x27;sass&#x27;), stylus: generateLoaders(&#x27;stylus&#x27;), styl: generateLoaders(&#x27;stylus&#x27;) &#125;&#125;// Generate loaders for standalone style files (outside of .vue)exports.styleLoaders = function (options) &#123; const output = [] const loaders = exports.cssLoaders(options) for (const extension in loaders) &#123; const loader = loaders[extension] output.push(&#123; test: new RegExp(&#x27;\\\\.&#x27; + extension + &#x27;$&#x27;), use: loader &#125;) &#125; return output&#125;exports.createNotifierCallback = () =&gt; &#123; const notifier = require(&#x27;node-notifier&#x27;) return (severity, errors) =&gt; &#123; if (severity !== &#x27;error&#x27;) return const error = errors[0] const filename = error.file &amp;&amp; error.file.split(&#x27;!&#x27;).pop() notifier.notify(&#123; title: packageConfig.name, message: severity + &#x27;: &#x27; + error.name, subtitle: filename || &#x27;&#x27;, icon: path.join(__dirname, &#x27;logo.png&#x27;) &#125;) &#125;&#125; vue-loader.config.js 123456789101112131415161718192021222324&#x27;use strict&#x27;const utils = require(&#x27;./utils&#x27;)const config = require(&#x27;../config&#x27;)const isProduction = process.env.NODE_ENV === &#x27;production&#x27;//判断是否为生产环境//根据环境来获取相应的productionSourceMap或者cssSourceMapconst sourceMapEnabled = isProduction ? config.build.productionSourceMap : config.dev.cssSourceMapmodule.exports = &#123; loaders: utils.cssLoaders(&#123; sourceMap: sourceMapEnabled,//是否开始sourceMap用来调试 extract: isProduction //是否单独提取抽离CSS &#125;), cssSourceMap: sourceMapEnabled,//纪录压缩的代码，用来找到源码位置 cacheBusting: config.dev.cacheBusting,//是否缓存破坏 //在模块编译的过程中，将某些属性转换并调用 transformToRequire: &#123; video: [&#x27;src&#x27;, &#x27;poster&#x27;], source: &#x27;src&#x27;, img: &#x27;src&#x27;, image: &#x27;xlink:href&#x27; &#125;&#125; webpack.base.conf.js文件基本的webpack配置 配置webpack编译入口 配置webpack输出路径和命名规则 配置模块resolve规则 配置不同类型模块的处理规则 webpack.dev.conf.js文件开发环境配置 在base.conf基础进一步完善 将hot-reload相关的代码添加到entry chunks 使用styleLoaders 配置Source Maps 配置webpack插件 webpack.prod.conf.js文件生产环境配置 在base.conf基础进一步完善 合并基础webpack配置 使用styleLoaders 配置webpack输出 配置webpack插件 gzip模式下的webpack插件配置 webpack-bundle分析 config文件夹 config文件夹下有三个文件&#96;&#96;dev.env.js、index.js、prod.env.js&#96;。 prod.env.js： 123456&#x27;use strict&#x27;module.exports = &#123; NODE_ENV: &#x27;&quot;production&quot;&#x27;&#125;//内容非常简单，仅仅是导出了一个对象，里面写明了执行环境是“production（生产环境）”；//注意，严格模式是es5的保留字，但不推荐在es6语法下使用！ dev.env.js： 12345678&#x27;use strict&#x27;const merge = require(&#x27;webpack-merge&#x27;)const prodEnv = require(&#x27;./prod.env&#x27;)module.exports = merge(prodEnv, &#123; NODE_ENV: &#x27;&quot;development&quot;&#x27;&#125;)//在“dev.env.js”中，先引入了webpack-merge这个模块。这个模块的作用是来合并两个配置文件对象并生成一个新的配置文件，有点儿类似于es6的object.assign(); index.js： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&#x27;use strict&#x27;// Template version: 1.3.1// see http://vuejs-templates.github.io/webpack for documentation.const path = require(&#x27;path&#x27;)module.exports = &#123; dev: &#123; // Paths assetsSubDirectory: &#x27;static&#x27;, //静态资源文件夹，默认“static” assetsPublicPath: &#x27;/&#x27;, //发布路径 proxyTable: &#123;&#125;, //设置代理API，常用于解决跨域问题 // Various Dev Server settings host: &#x27;localhost&#x27;, // can be overwritten by process.env.HOST port: 8080, // can be overwritten by process.env.PORT, if port is in use, a free one will be determined autoOpenBrowser: false, //是否自动打开浏览器 errorOverlay: true, //查询错误 notifyOnErrors: true, //通知错误 poll: false, // https://webpack.js.org/configuration/dev-server/#devserver-watchoptions- //poll是跟devserver相关的一个配置，webpack为我们提供的devserver是可以监控文件改动的，但在有些情况下却不能工作，我们可以设置一个轮询（poll）来解决 // Use Eslint Loader? // If true, your code will be linted during bundling and // linting errors and warnings will be shown in the console. useEslint: true, // If true, eslint errors and warnings will also be shown in the error overlay // in the browser. showEslintErrorsInOverlay: false, //上面这两个是跟eslint相关的属性 /** * Source Maps */ devtool: &#x27;cheap-module-eval-source-map&#x27;, /* webpack提供的用来方便调试的配置，它有四种模式， 详见https://webpack.js.org/configuration/devtool/#development */ // If you have problems debugging vue-files in devtools, // set this to false - it *may* help // https://vue-loader.vuejs.org/en/options.html#cachebusting cacheBusting: true, //一个配合devtool的配置，当给文件名插入新的hash导致清楚缓存时是否生成souce maps，默认在开发环境下为true cssSourceMap: true //是否开启cssSourceMap &#125;, build: &#123; // Template for index.html index: path.resolve(__dirname, &#x27;../dist/index.html&#x27;), //编译后index.html的路径 //Node.js 中,__dirname总是指向被执行 js 文件的绝对路径,比如你在/d1/d2/myscript.js文件中写了__dirname, 它的值就是/d1/d2 // Paths assetsRoot: path.resolve(__dirname, &#x27;../dist&#x27;),//打包后的文件根路径 assetsSubDirectory: &#x27;static&#x27;, assetsPublicPath: &#x27;/&#x27;, /** * Source Maps */ productionSourceMap: true, // https://webpack.js.org/configuration/devtool/#production devtool: &#x27;#source-map&#x27;, // Gzip off by default as many popular static hosts such as // Surge or Netlify already gzip all static assets for you. // Before setting to `true`, make sure to: // npm install --save-dev compression-webpack-plugin productionGzip: false, productionGzipExtensions: [&#x27;js&#x27;, &#x27;css&#x27;], // Run the build command with an extra argument to // View the bundle analyzer report after build finishes: // `npm run build --report` // Set to `true` or `false` to always turn it on or off bundleAnalyzerReport: process.env.npm_config_report &#125;&#125; package.json中的情况： 参照这一篇CSDN博客为各个属性名添加了注释 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&#123; &quot;name&quot;: &quot;helloworld&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;A Vue.js project&quot;, &quot;author&quot;: &quot;your name&lt;your email&gt;&quot;, &quot;private&quot;: true, &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;, &quot;start&quot;: &quot;npm run dev&quot;, &quot;lint&quot;: &quot;eslint --ext .js,.vue src&quot;, &quot;build&quot;: &quot;node build/build.js&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;vue&quot;: &quot;^2.5.2&quot;, //该属性介绍了vue的版本 &quot;vue-router&quot;: &quot;^3.0.1&quot; //该属性介绍了vue-router的版本 &#125;, &quot;devDependencies&quot;: &#123; &quot;autoprefixer&quot;: &quot;^7.1.2&quot;, &quot;babel-core&quot;: &quot;^6.22.1&quot;, &quot;babel-eslint&quot;: &quot;^8.2.1&quot;, &quot;babel-helper-vue-jsx-merge-props&quot;: &quot;^2.0.3&quot;, &quot;babel-loader&quot;: &quot;^7.1.1&quot;, &quot;babel-plugin-syntax-jsx&quot;: &quot;^6.18.0&quot;, &quot;babel-plugin-transform-runtime&quot;: &quot;^6.22.0&quot;, &quot;babel-plugin-transform-vue-jsx&quot;: &quot;^3.5.0&quot;, &quot;babel-preset-env&quot;: &quot;^1.3.2&quot;, &quot;babel-preset-stage-2&quot;: &quot;^6.22.0&quot;, &quot;chalk&quot;: &quot;^2.0.1&quot;, &quot;copy-webpack-plugin&quot;: &quot;^4.0.1&quot;, &quot;css-loader&quot;: &quot;^0.28.0&quot;, &quot;eslint&quot;: &quot;^4.15.0&quot;, &quot;eslint-config-airbnb-base&quot;: &quot;^11.3.0&quot;, &quot;eslint-friendly-formatter&quot;: &quot;^3.0.0&quot;, &quot;eslint-import-resolver-webpack&quot;: &quot;^0.8.3&quot;, &quot;eslint-loader&quot;: &quot;^1.7.1&quot;, &quot;eslint-plugin-import&quot;: &quot;^2.7.0&quot;, &quot;eslint-plugin-vue&quot;: &quot;^4.0.0&quot;, &quot;extract-text-webpack-plugin&quot;: &quot;^3.0.0&quot;, &quot;file-loader&quot;: &quot;^1.1.4&quot;, &quot;friendly-errors-webpack-plugin&quot;: &quot;^1.6.1&quot;, &quot;html-webpack-plugin&quot;: &quot;^2.30.1&quot;, &quot;node-notifier&quot;: &quot;^5.1.2&quot;, &quot;optimize-css-assets-webpack-plugin&quot;: &quot;^3.2.0&quot;, &quot;ora&quot;: &quot;^1.2.0&quot;, &quot;portfinder&quot;: &quot;^1.0.13&quot;, &quot;postcss-import&quot;: &quot;^11.0.0&quot;, &quot;postcss-loader&quot;: &quot;^2.0.8&quot;, &quot;postcss-url&quot;: &quot;^7.2.1&quot;, &quot;rimraf&quot;: &quot;^2.6.0&quot;, &quot;semver&quot;: &quot;^5.3.0&quot;, &quot;shelljs&quot;: &quot;^0.7.6&quot;, &quot;uglifyjs-webpack-plugin&quot;: &quot;^1.1.1&quot;, &quot;url-loader&quot;: &quot;^0.5.8&quot;, &quot;vue-loader&quot;: &quot;^13.3.0&quot;, &quot;vue-style-loader&quot;: &quot;^3.0.1&quot;, &quot;vue-template-compiler&quot;: &quot;^2.5.2&quot;, &quot;webpack&quot;: &quot;^3.6.0&quot;, &quot;webpack-bundle-analyzer&quot;: &quot;^2.9.0&quot;, &quot;webpack-dev-server&quot;: &quot;^2.9.1&quot;, &quot;webpack-merge&quot;: &quot;^4.1.0&quot; &#125;, &quot;engines&quot;: &#123; //引擎相关的内容 &quot;node&quot;: &quot;&gt;= 6.0.0&quot;, //node版本要求 &quot;npm&quot;: &quot;&gt;= 3.0.0&quot; //npm版本要求 &#125;, &quot;browserslist&quot;: [ //配置浏览器的信息查询范围，这些信息将给Autoprefixer babel-env-preset eslint-plugin-compat这些组件来使用 &quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, //每种浏览器的最近两个版本 &quot;not ie &lt;= 8&quot; //IE8及之前的旧版本不查询 ]&#125; 这里面的很多字段我们之前已经提到过，下面介绍几个重要的名词。 dependencies和devDependencies使用npm install安装模块，有以下四个常用命令： 1234npm install moduleName # 安装模块到项目目录下npm install -g moduleName # -g 的意思是将模块安装到全局，具体安装到磁盘哪个位置，要看 npm config prefix 的位置。npm install -save moduleName # -save 的意思是将模块安装到项目目录下，并在package文件的dependencies节点写入依赖。npm install -save-dev moduleName # -save-dev 的意思是将模块安装到项目目录下，并在package文件的devDependencies节点写入依赖。 简单的来说，安装在dependencies中的库是在生产环境中使用的，而安装在devDependencies中的库是在开发环境中使用的（记住develop有发展的意思）。 例如：webpack，gulp等打包工具，这些都是我们开发阶段使用的，代码提交线上时，不需要这些工具，所以我们将它放入devDependencies即可，但是像jquery这类插件库，是我们生产环境所使用的，所以如要放入dependencies，如果未将jquery安装到dependencies，那么项目就可能报错，无法运行，所以类似这种项目必须依赖的插件库，我们则必须打入dependencies中，这下子都明白了吧。链接：https://www.jianshu.com/p/afb171cac890 我们可以在上面的package.json文件中看到，devDependencies中有一个模块autoprefixer，简书文章中对此解释： Autoprefixer是一个后处理程序，不象Sass以及Stylus之类的预处理器。它适用于普通的CSS，可以实现css3代码自动补全。也可以轻松跟Sass，LESS及Stylus集成，在CSS编译前或编译后运行。 Autoprefixer 同样会清理过期的前缀 12345#清理前的CSS样式a &#123; -webkit-border-radius : 5px; border-radius : 5px&#125; 12345&gt;#清理后的CSS样式a &#123; border-radius : 5px&#125; private属性 If you set &quot;private&quot;: true in your package.json, then npm will refuse to publish it. This is a way to prevent accidental publication of private repositories. If you would like to ensure that a given package is only ever published to a specific registry (for example, an internal registry), then use the publishConfig dictionary described below to override the registry config param at publish-time. 在项目的package.json文件中，直接将该属性设置为true即可。 package-lock.json文件 安装之后锁定包的版本，手动更改package.json文件安装将不会更新包，想要更新只能使用 npm install &#x78;&#x78;&#120;&#64;&#49;&#x2e;&#48;&#x2e;&#x30; –save 这种方式来进行版本更新package-lock.json 文件才可以 加快了npm install 的速度，因为 package-lock.json 文件中已经记录了整个 node_modules 文件夹的树状结构，甚至连模块的下载地址都记录了，如果删除了nodel_modules模块，再重新安装的时候只需要直接下载文件即可 如果我们全部选择’n’，就形成了更简单的文件目录结构12345678910111213141516171819202122232425262728293031323334project| README.md| .editorconfig| .gitignore| .postcssrc.js| .babelrc| package.json| package-lock.json| index.html└---node_modules└---config| |---dev.env.js| |---index.js| |---prod.env.js└---build| |---build.js| |---check-versions.js| |---logo.png| |---utils.js| |---vue-loader.conf.js| |---webpack.base.conf.js| |---webpack.dev.conf.js| |---webpack.prod.conf.js└---static| |---.gitkeep└---src |---App.vue |---main.js └---router | |---index.js └---components | |---HelloWorld.vue └---assets |---logo.png vue create 详解我们使用版本为4.5.13的vue-cli脚手架，选定vue3版本模板创建一个项目，项目文件目录结构如下 1234567891011121314151617project| README.md| .gitignore| babel.config.js| package.json| package-lock.json└---node_modules└---public| |---favicon.ico| |---index.html└---src |---App.vue |---main.js └---components | |---HelloWorld.vue └---assets |---logo.png 可以看到，使用vue-cli3之后版本脚手架的命令来创建的项目文件目录结构变得简单了许多。 babel.config.js 我们前面已经说过，babel是一个编译器，主要作用是将es5之后的语法转换成浏览器支持的es5语法。该文件存在于vue3.0根目录中，详见https://babeljs.io/docs/en/config-files#project-wide-configuration 12345module.exports = &#123; presets: [ &#x27;@vue/cli-plugin-babel/preset&#x27; ]&#125; 我们看一下新版脚手架创建的package.json文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; &quot;name&quot;: &quot;vue_create&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;private&quot;: true, &quot;scripts&quot;: &#123; &quot;serve&quot;: &quot;vue-cli-service serve&quot;, &quot;build&quot;: &quot;vue-cli-service build&quot;, &quot;lint&quot;: &quot;vue-cli-service lint&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;core-js&quot;: &quot;^3.6.5&quot;, &quot;vue&quot;: &quot;^3.0.0&quot; //vue版本 &#125;, &quot;devDependencies&quot;: &#123; //脚手架部分插件的版本 &quot;@vue/cli-plugin-babel&quot;: &quot;~4.5.0&quot;, &quot;@vue/cli-plugin-eslint&quot;: &quot;~4.5.0&quot;, &quot;@vue/cli-service&quot;: &quot;~4.5.0&quot;, &quot;@vue/compiler-sfc&quot;: &quot;^3.0.0&quot;, &quot;babel-eslint&quot;: &quot;^10.1.0&quot;, &quot;eslint&quot;: &quot;^6.7.2&quot;, &quot;eslint-plugin-vue&quot;: &quot;^7.0.0&quot; &#125;, &quot;eslintConfig&quot;: &#123; &quot;root&quot;: true, &quot;env&quot;: &#123; &quot;node&quot;: true &#125;, &quot;extends&quot;: [ &quot;plugin:vue/vue3-essential&quot;, &quot;eslint:recommended&quot; ], &quot;parserOptions&quot;: &#123; &quot;parser&quot;: &quot;babel-eslint&quot; &#125;, &quot;rules&quot;: &#123;&#125; &#125;, &quot;browserslist&quot;: [ &quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;not dead&quot; ]&#125;","categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"},{"name":"JavaScript","slug":"Programming-languages-and-projects/JavaScript","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/JavaScript/"},{"name":"Vue","slug":"Programming-languages-and-projects/JavaScript/Vue","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/JavaScript/Vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://justskim.github.io/tags/vue/"},{"name":"vue-cli","slug":"vue-cli","permalink":"http://justskim.github.io/tags/vue-cli/"}]},{"title":"对于github.io的访问","slug":"对于github.io的访问","date":"2021-09-16T09:51:57.773Z","updated":"2021-09-16T09:58:47.971Z","comments":true,"path":"2021/09/16/对于github.io的访问/","link":"","permalink":"http://justskim.github.io/2021/09/16/%E5%AF%B9%E4%BA%8Egithub.io%E7%9A%84%E8%AE%BF%E9%97%AE/","excerpt":"","text":"对于github.io的访问 当我们写完一篇博客，想要到自己的github.io界面看一看效果时，在谷歌浏览器中可能会遇到下面的情况： 产生的原因可能是这一篇博客讲到的证书问题，我们后续再进行探究。 对于这个问题，网上有很多千篇一律的解决方案，这里就不一一赘述了，我们这里介绍一下这篇博客分享的一个小技巧： 在当前页面用键盘输入 thisisunsafe，注意这一个字符串没有空格，而且并不是在地址栏输入，直接敲键盘即可（页面中不会显示输入内容），页面即会自动刷新进入网页。 但实际上，使用这一个方法是有缺陷的，其原理和不足可以见码农家园对该绕过chrome证书&#x2F;HSTS错误的讲解，我们后续会再探究。 如果输入之后，github.io博客页面的报错信息发生变化，变成： …无法访问此网站…github.io 请求遭到拒绝 … 未获授权 … 产生的原因和解决方案见这一篇博客中的说法： 因为github.com是外网，我们连接的时候IP地址需要转接地址，一层一层转接下来，就出现了上面的情况。","categories":[{"name":"Git","slug":"Git","permalink":"http://justskim.github.io/categories/Git/"},{"name":"Github","slug":"Git/Github","permalink":"http://justskim.github.io/categories/Git/Github/"}],"tags":[{"name":"安全证书","slug":"安全证书","permalink":"http://justskim.github.io/tags/%E5%AE%89%E5%85%A8%E8%AF%81%E4%B9%A6/"}]},{"title":"scipy版本的一些废弃方法及解决方案","slug":"scipy版本的一些废弃方法及解决方案","date":"2021-09-16T02:40:00.811Z","updated":"2021-09-16T09:30:55.280Z","comments":true,"path":"2021/09/16/scipy版本的一些废弃方法及解决方案/","link":"","permalink":"http://justskim.github.io/2021/09/16/scipy%E7%89%88%E6%9C%AC%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BA%9F%E5%BC%83%E6%96%B9%E6%B3%95%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"","text":"scipy版本的一些废弃方法及解决方案在之前我们为了解决scipy版本的问题，在python的cp37环境中下载了scipy的1.2.0版本。 今天，跟着numpy官方文档中的scipy章节敲代码时，发现了scipy版本废弃方法的相关bug。 文档中的示例代码如下： 12345678910111213141516171819from scipy.misc import imread, imsave, imresize# Read an JPEG image into a numpy arrayimg = imread(&#x27;assets/cat.jpg&#x27;)print(img.dtype, img.shape) # Prints &quot;uint8 (400, 248, 3)&quot;# We can tint the image by scaling each of the color channels# by a different scalar constant. The image has shape (400, 248, 3);# we multiply it by the array [1, 0.95, 0.9] of shape (3,);# numpy broadcasting means that this leaves the red channel unchanged,# and multiplies the green and blue channels by 0.95 and 0.9# respectively.img_tinted = img * [1, 0.95, 0.9]# Resize the tinted image to be 300 by 300 pixels.img_tinted = imresize(img_tinted, (300, 300))# Write the tinted image back to diskimsave(&#x27;assets/cat_tinted.jpg&#x27;, img_tinted) 运行后，会产生以下几个报错： 123456789101112PS E:\\python练习\\Numpy练习&gt; &amp; C:/Users/Ryan/Anaconda3/python.exe e:/python练习/Numpy练习/python中的Scipy.py e:/python练习/Numpy练习/python中的Scipy.py:13: DeprecationWarning: `imread` is deprecated! `imread` is deprecated in SciPy 1.0.0, and will be removed in 1.2.0. Use ``imageio.imread`` instead. img = imread(&#x27;assets/cat.jpg&#x27;)uint8 (400, 248, 3) `imresize` is deprecated in SciPy 1.0.0, and will be removed in 1.3.0. Use Pillow instead: ``numpy.array(Image.fromarray(arr).resize())``. img_tinted = imresize(img_tinted, (300, 300))e:/python练习/Numpy练习/python中的Scipy.py:28: DeprecationWarning: `imsave` is deprecated! `imsave` is deprecated in SciPy 1.0.0, and will be removed in 1.2.0. Use ``imageio.imwrite`` instead. 大概意思就是，scipy.misc模块中的imsave，imresize，imread这几个方法在scipy包的1.0版本中就已被弃用（deprecated）。为了实现该方法的功能，我们可以用报错信息中提示的几个方法来代替。 1. 从PIL包中引入Image模块，来取代imresize方法：stackoverflow上的这一个问题给出了 scipy.misc.imresize 的官方文档方面对此方法弃用的解释： imresize is deprecated! imresize is deprecated in SciPy 1.0.0, and will be removed in 1.3.0. Use Pillow instead: numpy.array(Image.fromarray(arr).resize()). Resize an image. This function is only available if Python Imaging Library (PIL) is installed. Warning This function uses bytescale under the hood to rescale images to use the full (0, 255) range if mode is one of None, &#39;L&#39;, &#39;P&#39;, &#39;l&#39;. It will also cast data for 2-D images to uint32 for mode=None (which is the default). Parameters: arr : ndarrayThe array of image to be resized.size : int, float or tupleint - Percentage of current size.float - Fraction of current size.tuple - Size of the output image (height, width).interp : str, optionalInterpolation to use for re-sizing (‘nearest’, ‘lanczos’, ‘bilinear’, ‘bicubic’ or ‘cubic’).mode : str, optionalThe PIL image mode (‘P’, ‘L’, etc.) to convert arr before resizing. If mode=None (the default), 2-D images will be treated like mode=&#39;L&#39;, i.e. casting to long integer. For 3-D and 4-D arrays, mode will be set to &#39;RGB&#39; and &#39;RGBA&#39; respectively. Returns: imresize : ndarrayThe resized array of image. 2. 从imageio包中使用相关方法替代imsave和imreadimageio的官方文档中，就有代替scipy.misc的相关说明： Transitioning from Scipy’s imreadScipy is deprecating their image I&#x2F;O functionality. This document is intended to help people coming from Scipy to adapt to Imageio’s imread function. We recommend reading the user api and checkout some examples to get a feel of imageio. Imageio makes use of variety of plugins to support reading images (and volumes&#x2F;movies) from many different formats. Fortunately, Pillow is the main plugin for common images, which is the same library as used by Scipy’s imread. Note that Imageio automatically selects a plugin based on the image to read (unless a format is explicitly specified), but uses Pillow where possible. In short terms: For images previously read by Scipy’s imread, imageio should generally use Pillow as well, and imageio provides the same functionality as Scipy in these cases. But keep in mind: Instead of mode, use the pilmode keyword argument. Instead of flatten, use the as_gray keyword argument. The documentation for the above arguments is not on imread, but on the docs of the individual formats, e.g. PNG. Imageio’s functions all return numpy arrays, albeit as a subclass (so that meta data can be attached). 我们使用imageio.imread和imageio.write分别代替scipy.misc中的imread和imsave两个方法，成功解决问题。 3. PIL包的作用廖雪峰的官方网站中关于pillow这一个常用第三方模块的介绍是： PIL：Python Imaging Library，已经是Python平台事实上的图像处理标准库了。PIL功能非常强大，但API却非常简单易用。 由于PIL仅支持到Python 2.7，加上年久失修，于是一群志愿者在PIL的基础上创建了兼容的版本，名字叫Pillow，支持最新Python 3.x，又加入了许多新特性，因此，我们可以直接安装使用Pillow。 若已经安装anaconda，则无需使用pip安装Pillow包了。 对于这一个库的学习，在以后我们会继续探讨 改正后，我们的代码如下： 123456789101112131415161718192021222324252627282930313233# -*- coding: UTF-8 –*-# 上面这一行是python头文件的声明# 缺省情况下程序需要用ascii码书写，但如果其中写中文的话，python解释器会报错import imageiofrom PIL import Imageimport numpy &#x27;&#x27;&#x27;直接使用pip安装misc会报错 ImportError:cannot import name &#x27;imread&#x27; from &#x27;scipy.misc&#x27;原因在于包的版本问题，新版本的scipy.misc没有这一个方法为了对照文档，我们卸载并重新安装：pip3 install scipy==1.2.0但是依然无法解决问题，发现是我们下错版本了，要用1.0的才行，不过我们不会管这个问题了，因为我们使用imageio和PIL来作为解决方案，详见我的个人博客&#x27;&#x27;&#x27;# Read an JPEG image into a numpy arrayimg = imageio.imread(&#x27;assets/cat.jpg&#x27;)print(img.dtype, img.shape) # Prints &quot;uint8 (400, 248, 3)&quot;# We can tint the image by scaling each of the color channels# by a different scalar constant. The image has shape (400, 248, 3);# we multiply it by the array [1, 0.95, 0.9] of shape (3,);# numpy broadcasting means that this leaves the red channel unchanged,# and multiplies the green and blue channels by 0.95 and 0.9# respectively.img_tinted = img * [1, 0.95, 0.9]# Resize the tinted image to be 300 by 300 pixels.img_tinted = numpy.array(Image.fromarray(img).resize((300,300)))#成功将图片保存# Write the tinted image back to diskimageio.imwrite(&#x27;assets/cat_tinted.jpg&#x27;, img_tinted) 成功运行！","categories":[{"name":"Data analysis","slug":"Data-analysis","permalink":"http://justskim.github.io/categories/Data-analysis/"}],"tags":[{"name":"数据分析","slug":"数据分析","permalink":"http://justskim.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"python","slug":"python","permalink":"http://justskim.github.io/tags/python/"},{"name":"debug","slug":"debug","permalink":"http://justskim.github.io/tags/debug/"},{"name":"package","slug":"package","permalink":"http://justskim.github.io/tags/package/"},{"name":"scipy","slug":"scipy","permalink":"http://justskim.github.io/tags/scipy/"}]},{"title":"python旧版本的安装与debug ———— 以scipy1.2.0为例","slug":"python旧版本的安装与debug-————-以scipy1.2.0为例","date":"2021-09-15T13:25:23.482Z","updated":"2021-09-16T02:49:20.725Z","comments":true,"path":"2021/09/15/python旧版本的安装与debug-————-以scipy1.2.0为例/","link":"","permalink":"http://justskim.github.io/2021/09/15/python%E6%97%A7%E7%89%88%E6%9C%AC%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8Edebug-%E2%80%94%E2%80%94%E2%80%94%E2%80%94-%E4%BB%A5scipy1.2.0%E4%B8%BA%E4%BE%8B/","excerpt":"","text":"python旧版本的安装与debug ———— 以scipy1.2.0为例在对照numpy中文文档进行学习时，使用pip安装对应的包，启动以下示例代码中的py文件： 12345678910111213141516171819import numpy as npfrom scipy.misc import imread, imresizeimport matplotlib.pyplot as pltimg = imread(&#x27;assets/cat.jpg&#x27;) #这里的是一张自定义的资源图片文件img_tinted = img * [1, 0.95, 0.9]# Show the original imageplt.subplot(1, 2, 1)plt.imshow(img)# Show the tinted imageplt.subplot(1, 2, 2)# A slight gotcha with imshow is that it might give strange results# if presented with data that is not uint8. To work around this, we# explicitly cast the image to uint8 before displaying it.plt.imshow(np.uint8(img_tinted))plt.show() 产生报错如下：AttributeError: &#39;module&#39; object has no attribute &#39;imread&#39; 经过查询相关博客，发现导致该报错的原因在于，从1.3版本开始，imread等几个经典方法已经从scipy包的misc模块中移除。那么，既然找到问题，我们就要寻求解决的方法，目前发现了以下三个： 安装imageio库https://blog.csdn.net/sky_9900/article/details/98171702 安装pillow库https://www.dovov.com/scipy-miscimread.html 使用1.2版本的scipy包，当我们遇到其他类似情况时，也可以寻求使用旧版本的包 容易掉坑的点第一个，就是python的编辑器版本，我下的时候没有注意，直接下的最新的版本3.9 结果，当我直接在cmd中使用命令pip install scipy==1.2.0时，直接弹出一大堆报错： 12ERROR: Command errored out with exit status 1:... #（下面还有很多行，但与解决问题无关紧要） 接着，我尝试着从pypi.org中下载旧版本的whl文件去进行安装，这一次给出的报错信息明显让我意识到了编辑器版本的不匹配： 123456E:\\&gt;pip install scipy-1.2.0-cp37-cp37m-win_amd64.whlWARNING: Ignoring invalid distribution -ip (e:\\python\\lib\\site-packages)WARNING: Ignoring invalid distribution -ip (e:\\python\\lib\\site-packages)ERROR: scipy-1.2.0-cp37-cp37m-win_amd64.whl is not a supported wheel on this platform.WARNING: Ignoring invalid distribution -ip (e:\\python\\lib\\site-packages)WARNING: Ignoring invalid distribution -ip (e:\\python\\lib\\site-packages) （事实证明，pypi.org比很多包的官网有用，含有的包版本也更多，比如scipy官网） 从pypi.org上查找到的scipy1.2版本适用的编辑器最高版本为cp37，所幸我电脑上之前用conda安装了对应版本的python，不必经过配置，在vs code中点击左下角，切换python编辑器环境为3.7。![Switch](&#x2F;images&#x2F;在vs code左下角切换环境.png)然后我们启动代码，成功跑通！ 附：几种python包指定版本的安装方式 pip 安装 whl文件下载安装 tar.gz文件下载安装 conda下载安装conda 下载安装whl文件conda 下载安装tar.gz文件附：几个常用的python包下载网站 https://pypi.org/ https://www.lfd.uci.edu/~gohlke/pythonlibs/","categories":[{"name":"Data analysis","slug":"Data-analysis","permalink":"http://justskim.github.io/categories/Data-analysis/"}],"tags":[{"name":"数据分析","slug":"数据分析","permalink":"http://justskim.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"python","slug":"python","permalink":"http://justskim.github.io/tags/python/"},{"name":"debug","slug":"debug","permalink":"http://justskim.github.io/tags/debug/"},{"name":"package","slug":"package","permalink":"http://justskim.github.io/tags/package/"},{"name":"scipy","slug":"scipy","permalink":"http://justskim.github.io/tags/scipy/"}]},{"title":"网站搜索纪录的删除","slug":"网站搜索纪录的删除","date":"2021-09-06T14:56:21.062Z","updated":"2021-09-06T14:56:21.063Z","comments":true,"path":"2021/09/06/网站搜索纪录的删除/","link":"","permalink":"http://justskim.github.io/2021/09/06/%E7%BD%91%E7%AB%99%E6%90%9C%E7%B4%A2%E7%BA%AA%E5%BD%95%E7%9A%84%E5%88%A0%E9%99%A4/","excerpt":"","text":"网站搜索纪录的删除在一些网站的搜索框中，可能会出现你之前并没有搜索的词条，如： 即使在浏览器中清空浏览历史和cookies都无效。 解决方法：鼠标移至该词条上方选中，同时按住“delete”+“shift”键即可删除。 出现这种情况的原因暂且不明，推测与浏览器的自动保存信息有关，留待以后探究。","categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"},{"name":"JavaScript","slug":"Programming-languages-and-projects/JavaScript","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/JavaScript/"},{"name":"web","slug":"Programming-languages-and-projects/JavaScript/web","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/JavaScript/web/"}],"tags":[{"name":"browser","slug":"browser","permalink":"http://justskim.github.io/tags/browser/"},{"name":"web","slug":"web","permalink":"http://justskim.github.io/tags/web/"}]},{"title":"typora与hexo博客中的图片插入","slug":"typora与hexo博客中的图片插入","date":"2021-09-06T10:25:20.704Z","updated":"2022-03-13T13:54:41.414Z","comments":true,"path":"2021/09/06/typora与hexo博客中的图片插入/","link":"","permalink":"http://justskim.github.io/2021/09/06/typora%E4%B8%8Ehexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%8F%92%E5%85%A5/","excerpt":"","text":"typora与hexo博客中的图片插入Markdown文档^1中给出的图片插入方式 要添加图像，请添加感叹号（!），然后在括号中添加替代文本，并在括号中添加图像资源的路径或URL。您可以选择在括号中的URL之后添加标题。 链接图像——点击该图像后可以跳转到相关链接要向图像添加链接，请将图像的Markdown括在方括号中，然后在括号中添加链接。 Typora编辑器中的图片插入方式如果使用传统的在markdown文档中图片插入的方式，实际上文档中保存的只是一个指向该图片的本地地址。当我们要在typora文档中永久保存一张图片，并且实现实时预览的功能，可以采用这一篇博客^2所讲到的方法： 将图片转化为base64格式并在typora里插入的方法：1、例如，在src里输入这段编码；2、通过常见的![][src]，src里是编码，可以看到这里是中括号[]，而不是括号。 另外，因为编码比较长，且图片可能较多，所以有的时候我们可以通过把src换成图片编号，然后在文档最后将图片编号指向编码。示例： 工具网站很多，比如一个在线的：http://tool.chinaz.com/tools/imgtobase。github上一键转换：https://github.com/hujingnb/markdownImage/tree/master Hexo博客文章中的图片插入方式Hexo的官方文档^3中给出了两种博客文章的插入方法： 资源文件夹资源（Asset）代表 source 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。比方说，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 source/images 文件夹中。然后通过类似于 ![](/images/image.jpg) 的方法访问它们。对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，Hexo也提供了更组织化的方式来管理资源。这个稍微有些复杂但是管理资源非常方便的功能可以通过将 config.yml 文件中的 post_asset_folder 选项设为 true 来打开。1_config.ymlpost_asset_folder: true 当资源文件管理功能打开后，Hexo将会在你每一次通过 hexo new [layout] &lt;title&gt; 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。 相对路径引用的标签插件通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。123&gt;&#123;% asset_path slug %&#125;&gt;&#123;% asset_img slug [title] %&#125;&gt;&#123;% asset_link slug [title] %&#125; 比如说：当你打开文章资源文件夹功能后，你把一个 example.jpg 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 ![](example.jpg) ，它将 不会 出现在首页上。（但是它会在文章中按你期待的方式工作）正确的引用图片方式是使用下列的标签插件而不是 markdown ： 1&gt;&#123;% asset_img example.jpg This is an example image %&#125; 通过这种方式，图片将会同时出现在文章和主页以及归档页中。 第二种方法用起来稍微麻烦，这里根据博客——hexo+typora 插入图片的简便解决方案[^4]介绍第三种方法： 使用最简单的方式在 source 目录下创建images目录，然后图片都保存在这里。 关键是要在typora上做以下设置： 在md文件头部的配置项中，添加 typora-root-url: ../ ，格式如下 1234title: hexo+typora 插入图片 date: 2019-06-08 10:37:22 tags: typora-root-url: ../ 这样引用的图片都以上一级目录即 source作为根目录了，此时插入的图片时，只要点击“复制图片到…”并选择一次文件夹，以后每次都会自动保存在 source&#x2F;image目录下，并且本地的显示和服务器上的根目录完全一致，使用体验还是很方便的。 在具体使用中，可以使用以下两种方法添加图片链接： ![描述](图片文件路径，如/images/cat.jpg，注意无引号) &lt;img src=&quot;图片文件路径，如/images/cat.jpg&quot;&gt; 经过验证，这个方法是十分方便可靠的，感谢博主，推荐使用。 很多个markdown中文官方网站 https://markdown.com.cn/basic-syntax/images.html https://markdown-zh.readthedocs.io/en/latest/blockelements/ http://markdown.p2hp.com/basic-syntax/ http://www.markdown.cn/#images References[^4]: 博客——hexo+typora 插入图片的简便解决方案","categories":[{"name":"MarkDown","slug":"MarkDown","permalink":"http://justskim.github.io/categories/MarkDown/"},{"name":"typora的特殊使用","slug":"MarkDown/typora的特殊使用","permalink":"http://justskim.github.io/categories/MarkDown/typora%E7%9A%84%E7%89%B9%E6%AE%8A%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://justskim.github.io/tags/markdown/"},{"name":"typora","slug":"typora","permalink":"http://justskim.github.io/tags/typora/"},{"name":"hexo","slug":"hexo","permalink":"http://justskim.github.io/tags/hexo/"}]},{"title":"MYSQL字段属性","slug":"MYSQL字段属性","date":"2021-09-05T07:24:32.452Z","updated":"2021-09-08T09:59:49.338Z","comments":true,"path":"2021/09/05/MYSQL字段属性/","link":"","permalink":"http://justskim.github.io/2021/09/05/MYSQL%E5%AD%97%E6%AE%B5%E5%B1%9E%E6%80%A7/","excerpt":"","text":"MYSQL字段属性参考博客“MySql中的列属性”^1： MySql中，真正约束字段的是数据类型，但是数据类型的约束太单一，因此我们需要有一些额外的约束，来更加保证数据的合法性。 MySql中的常用列属性有：null、not null、default、primary key、auto_increment、comment。下面以博主所用当前最新的Mysql版本2021-9-1 mysql Ver 8.0.26 for Win64 on x86_64 (MySQL Community Server - GPL)为例介绍几个列属性值： 1. 主键 primary key主键（primary key）有以下几个作用： 能唯一标识记录的字段，可以作为主键。 一个表最多只能有一个主键。 主键具有唯一性，因此又称唯一键需要特别注意的是： 主键字段的值不能为null; 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。使用主键：声明字段时，用 primary key 标识。 添加主键有以下四种方式： 创建表的时候，在字段后加上 primary key。 123456#语法： 字段名 数据类型 primary key #例子：添加一个名叫【my_primark_key1】的表，为其添加id字段和name字段，且将id字段设置成主键。create table if not exists my_primary_key1( id int primary key, name varchar(10) not null)charset utf8; 注意，使用这种主键定义方式的话，只能给一个字段添加primary key，如果为多个字段添加这一标识，如1234create table ttt_test( id int primary key, name varchar(30) primary key)charset utf8; 就会导致以下的报错：1ERROR 1068 (42000): Multiple primary key defined 插入数据：insert into my_primary_key values(1001,&#39;张三&#39;);如果我们再次插入一条主键相同的数据，如: insert into my_primary_key values(1001,&#39;张大&#39;);就会产生报错： Duplicate entry &#39;1001&#39; for key &#39;PRIMARY&#39;报错的原因是主键值不能相同。 复合主键。在创建表的时候，在所有的字段之后，使用primay key(主键字段列表)来创建主键(可以有多个字段作为主键)来创建复合主键。 1234567#语法：primary key(字段1，字段2......)**#例子：创建一张【my_primark_key2】的表，为其添加number字段(int类型)和classname 字段(varchar类型)，将这个字段添加成复合主键。** create table if not exists my_primary_key2( number int not null, classname varchar(20) not null, primary key(number,classname))charset utf8; 插入数据：插入数据只有两个字段(number,name)共同重复时才会插入失败，如果只有1个字段重复，而另一个字段不重复，那么就被允许插入。 123insert into my_primary_key2(number,classname) values(1001,&#x27;高一(2)班&#x27;); #插入成功 insert into my_primary_key2(number,classname) values(1001,&#x27;高一(3)班&#x27;); #也成功插入，因为插入的值中有1个字段的值与表中的值不一样。 向表中的字段追加主键（该方法也适合于修改字段的其他属性值&#x2F;增加其他标识）。 12345678#语法：alter table 表名字 字段名 数据类型 primary key(新建一个字段，添加主键，如果字段已经存在要用修改的方式）;#例子：新建一个名叫【my_primary_key3】的表，为其加入id字段和name字段。create table if not exists my_primary_key3( id int, name varchar(10) not null)charset utf8;#修改 my_primary_key3表中的id字段为主键。alter table my_primary_key2 modify id int primary key comment &#x27;编号&#x27;; 通过add primary key(字段名) 进行添加。语法：alter table 表名字 add primary key(要添加主键的字段名);例子：添加id为主键。alter table userinfo add primary key(id);主键约束。 主键对应的字段中的数据不允许重复，一旦重复，操作失败。主键没有办法更新，只能先删除主键，然后再添加主键。 12345#语法：alter table 表名字 drop primary key#例子：修改【my_primary_key3】表中已存在的主键，为name字段设置主键。alter table my_primary_key3 drop primary key3; -- 先删除。#为name 字段添加主键(以修改的形式)。alter table my_primary_key3 modify name varchar(10) primary key; 2. unique 唯一索引（唯一约束） 使得某字段的值也不能重复。一张表往往有很多字段需要具有唯一性，数据不能重复，这个时候用唯一键(unique)就体现出其优势了，可以解决表中多个字段需要唯一性约束的问题，唯一键的本质与主键的性质差不多，唯一键默认的允许字段为空， 而且可以多个字段为空(空字段不参与唯一性比较)。 添加唯一键。语法：字段名 数据类型 unique&#x2F;unique key有3种方式添加唯一键。 在字段后面添加唯一键。例子：新建一张【my_unique】的表，为其添加一个name字段，并设置成唯一键。 1234567create table if not exists my_unique( name varchar(10) not null unique)charset utf8;#插入数据：insert into my_unique(&#x27;李四&#x27;); #再次插入一个名叫李四的就会报错。 在所有的字段之后添加 unique key(字段列表)，复合唯一键。例子：添加一张【my_unique】的表，为其添加number字段(int类型)和name字段(varchar类型)，然后将两个设置成复合唯一键。 123456789create table if not exists my_unique2(number int not null,name varchar(20) not null,unique key(number,name))charset utf8;#插入数据。 insert into my_unique2 values(10001,&#x27;张三&#x27;); # 有效数据insert into my_unique2 values(10001,&#x27;李四&#x27;); # 有效数据(符合唯一键是两个字段值要相同)insert into my_unique2 values(10001,&#x27;张三&#x27;); # 无效数据(复合主键重复了) 追加唯一键。 1234567#语法：alter table 表名字 add unque key(字段名);#例子：新建一张【my_unique3】的表，添加一个字段name(carchar类型)。create table if not exists my_unique3( name varchar(30) not null)charset utf8;#向my_unique3表中追加唯一键。alter table my_unique3 add unique key(name); 更新唯一键的方法：先删除，后新增。 删除唯一键：语法：alter table 表名字 drop index 索引名字(唯一键默认的使用字段名作为索引名字) 3. 空属性 null 约束空属性有2个值，分别是 null(空，默认的) 和 not null(不为空)，mysql数据库默认字段都是为null的，但是在实际开发过程中，尽可能保证所有的数据都不应该为null，空数据没有意义，空数据没有办法参加运算注意！null不是数据类型，是列的一个属性。 123456 # 语法：字段名 数据类型 not null create table if not exists my_notnull( name varchar(10) not null )charset utf8;#此时表示将第一个字段的值设为null, 取决于该字段是否允许为nullinsert into tab values (null, &#x27;val&#x27;); 4. default 默认值属性 当前字段的默认值，用default表示，某一种数据会经常的出现某个具体值，可以在一开始指定好，在需要真实数据的时候，用户可以选择性地使用默认值。 123456789#语法：字段名 数据类型 default 默认值#例子：添加一个【my_default】表，为其添加name字段，age字段，并未age字段指定默认值为18。 create table if not exists my_default( name varchar(10) not null comment &#x27;姓名&#x27;, age tinyint unsigned not null default 18 comment &#x27;年龄&#x27;)charset utf8;#插入数据：如果要使用默认值，在给表插入数据的时候，不给字段赋值即可。insert into my_default(name) values(&#x27;张三&#x27;); 5. auto_increment 自动增长约束注意拼写方式为auto_increment，有下划线连接当对应的字段不给值，或者给null的时候会自动地被系统触发，系统会从当前字段中已有的最大值再进行+1，得到一个新的不同的字段，通常和主键搭配。 自动增长必须为索引（主键或unique） 只能存在一个字段为自增长auto_increment。默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或alter table tbl auto_increment = x;自增长的特点 ： 任何一个字段做自增长前提 自身是一个索引(key一栏有值)。 自增长字段通常是整形。 一个表中只能有1个自增长。12345#例子：添加一张【my_auto_increment】的表，为其添加id字段和name字段，其中id字段设置成主键和自增长。create table if not exists my_auto_increment( id int primary key auto_increment, name varchar(10) not null)charset utf8; 插入值： 12insert into my_auto_Increment values(null,&#x27;张三&#x27;); #有效insert into my_auto_Increment(name) values(&#x27;李四&#x27;); #有效 自增长如果对应的字段输入了值，那么自增长失效，但是**下一次还是能够正确的自增长(从最大值+1)**。1234567891011121314151617181920212223242526mysql&gt; select * from my_auto_increment;+----+--------+| id | name |+----+--------+| 1 | Mary || 3 | Tom || 5 | Cook || 6 | Lowson |+----+--------+4 rows in set (0.00 sec)mysql&gt; insert my_auto_increment values(null,&quot;Taylo&quot;);Query OK, 1 row affected (0.01 sec)mysql&gt; select * from my_auto_increment;+----+--------+| id | name |+----+--------+| 1 | Mary || 3 | Tom || 5 | Cook || 6 | Lowson || 7 | Taylo |+----+--------+5 rows in set (0.00 sec)#可以看到，新插入的id为7而不是4,5,6 修改自增长：自增长如果是涉及到字段改变，必须先删除自增长，后增加，一张表中只能有1个自增长。修改当前已存在自增长的值，！特别注意：修改只能比当前已有的自增长的最大值大，不能小(小则不生效)！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#插入数据mysql&gt; insert my_auto_increment values(null,&quot;Chechil&quot;);Query OK, 1 row affected (0.01 sec)mysql&gt; select * from my_auto_increment;+----+---------+| id | name |+----+---------+| 1 | Mary || 3 | Tom || 6 | Lowson || 7 | Taylo || 13 | Cook || 14 | Brazil || 15 | Chechil |+----+---------+7 rows in set (0.00 sec)#修改某个数据的自增长属性值，由14改为20mysql&gt; update my_auto_increment set id = 15 where name=&#x27;Chechil&#x27;;Query OK, 0 rows affected (0.00 sec)Rows matched: 1 Changed: 0 Warnings: 0mysql&gt; select * from my_auto_increment;+----+---------+| id | name |+----+---------+| 1 | Mary || 3 | Tom || 6 | Lowson || 7 | Taylo || 13 | Cook || 14 | Brazil || 20 | Chechil |+----+---------+7 rows in set (0.00 sec)#再次插入数据mysql&gt; insert my_auto_increment values(null,&quot;Agent&quot;);Query OK, 1 row affected (0.01 sec)mysql&gt; select * from my_auto_increment;+----+---------+| id | name |+----+---------+| 1 | Mary || 3 | Tom || 6 | Lowson || 7 | Taylo || 13 | Cook || 14 | Brazil || 20 | Chechil || 21 | Agent |+----+---------+8 rows in set (0.00 sec)#注意！！！插入的数据从最大值+1开始，前面的全部跳过不管！！ 删除自增增长。自增长是字段的一个属性，可以通过modify属性来修改(字段没有自增长)。语法：alter table 表名字 modify 字段名 数据类型例子：将【my_auto_Increment】表中 id字段的自增长去掉。alter table my_auto_increment modify id int; 自增长为什么从1开始（注意不像其他编程语言从0开始）？又为什么每次都是自增1呢？所有系统的表现(如字符集、校对集)都是由系统的内部变量进行控制的。查看自增长对应的变量的语法：show variables like ‘auto_increment%’; 可以修改变量实现不同的效果。如果对整个数据修改(而不是但张表)，这种方式是修改时会话级(当前客户端，当此连接有效，关闭失效)。修改成一次自增为5:set auto_increment_increment = 5; 1234567891011121314151617181920212223242526272829303132333435363738mysql&gt; set my_auto_increment = 5;ERROR 1193 (HY000): Unknown system variable &#x27;my_auto_increment&#x27;mysql&gt; set auto_increment = 5;ERROR 1193 (HY000): Unknown system variable &#x27;auto_increment&#x27;mysql&gt; show variables like &#x27;auto_increment%&#x27;;+--------------------------+-------+| Variable_name | Value |+--------------------------+-------+| auto_increment_increment | 1 || auto_increment_offset | 1 |+--------------------------+-------+2 rows in set, 1 warning (0.01 sec)#自增长的两个相关配置：auto_increment_offset和auto_increment_increment#auto_increment_offset表示自增长字段从那个数开始，他的取值范围是1 .. 65535#auto_increment_increment表示自增长字段每次递增的量，其默认值是1，取值范围是1 .. 65535mysql&gt; set auto_increment_increment = 5;Query OK, 0 rows affected (0.01 sec)mysql&gt; insert my_auto_increment value(null,&quot;Panda&quot;);Query OK, 1 row affected (0.01 sec)mysql&gt; select * from my_auto_increment;+----+---------+| id | name |+----+---------+| 1 | Mary || 3 | Tom || 6 | Lowson || 7 | Taylo || 13 | Cook || 14 | Brazil || 20 | Chechil || 21 | Agent || 26 | Panda |+----+---------+9 rows in set (0.00 sec)#可以看到，从21到26一次增加了5 6. comment 注释（列描述）列描述(注释)：comment，实际没有什么含义，是专门用来描述字段的，会根据创建语句保存，用来给程序员(或者数据库管理员)来进行了解的。主要用于查看创建表的语法上进行查看。 12345#语法：字段名 数据类型 comment ‘说明文字’#例子：创建一张【my_comment 】的表，为其添加一个name字段，并为其添加说明。 create table if not exists my_comment( name varchar(10) comment &#x27;姓名字段&#x27;)charset utf8; 7. foreign key 外键约束CSDN博主「Mr.路痴」的这一篇原创文章[^2]中提到了外键约束的一些特点： 父表和子表必须使用相同的存储引擎，而且禁止使用临时表。数据表的存储引擎只能为InnoDB。外键列和参照列必须具有相似的数据类型，也就是可以相互转换类型的列，比如 int 和 tinyint 可以，而 int 和 char 则不可以数字类型的长度以及是否有符号（是否unsigned）必须相同字符类型的长度则可以不同。外键列和参照列必须创建索引。如果外键列不存在索引，MySQl将自动创建。外键的名字不能重复 C语言中文网对于mysql外键约束的这一篇博客[^3]讲的很好： MySQL 外键约束（FOREIGN KEY）是表的一个特殊字段，经常与主键约束一起使用。对于两个具有关联关系的表而言，相关联字段中主键所在的表就是主表（父表），外键所在的表就是从表（子表）。 外键用来建立主表与从表的关联关系，为两个表的数据建立连接，约束两个表中数据的一致性和完整性。比如，一个水果摊，只有苹果、桃子、李子、西瓜等 4 种水果，那么，你来到水果摊要买水果就只能选择苹果、桃子、李子和西瓜，其它的水果都是不能购买的。 主表删除某条记录时，从表中与之对应的记录也必须有相应的改变。一个表可以有一个或多个外键，外键可以为空值，若不为空值，则每一个外键的值必须等于主表中主键的某个值。 定义外键时，需要遵守下列规则： 主表必须已经存在于数据库中，或者是当前正在创建的表。如果是后一种情况，则主表与从表是同一个表，这样的表称为自参照表，这种结构称为自参照完整性。 必须为主表定义主键。 主键不能包含空值，但允许在外键中出现空值。也就是说，只要外键的每个非空值出现在指定的主键中，这个外键的内容就是正确的。 在主表的表名后面指定列名或列名的组合。这个列或列的组合必须是主表的主键或候选键。 外键中列的数目必须和主表的主键中列的数目相同。 外键中列的数据类型必须和主表主键中对应列的数据类型相同。 在创建表时设置外键约束在 CREATE TABLE 语句中，通过 FOREIGN KEY 关键字来指定外键，具体的语法格式如下： [CONSTRAINT &lt;外键名&gt;] FOREIGN KEY 字段名 [，字段名2，…]REFERENCES &lt;主表名&gt; 主键列1 [，主键列2，…] 例 1为了展现表与表之间的外键关系，本例在 test_db 数据库中创建一个部门表 tb_dept1，表结构如下表所示。 字段名称 数据类型 备注 id INT(11) 部门编号 name VARCHAR(22) 部门名称 location VARCHAR(22) 部门位置 创建 tb_dept1 的 SQL 语句和运行结果如下所示。 1234567mysql&gt; CREATE TABLE tb_dept1 -&gt; ( -&gt; id INT(11) PRIMARY KEY, -&gt; name VARCHAR(22) NOT NULL, -&gt; location VARCHAR(50) -&gt; );Query OK, 0 rows affected (0.37 sec) 创建数据表 tb_emp6，并在表 tb_emp6 上创建外键约束，让它的键 deptId 作为外键关联到表 tb_dept1 的主键 id，SQL 语句和运行结果如下所示。 123456789101112131415161718192021mysql&gt; CREATE TABLE tb_emp6 -&gt; ( -&gt; id INT(11) PRIMARY KEY, -&gt; name VARCHAR(25), -&gt; deptId INT(11), -&gt; salary FLOAT, -&gt; CONSTRAINT fk_emp_dept1 -&gt; FOREIGN KEY(deptId) REFERENCES tb_dept1(id) -&gt; );Query OK, 0 rows affected (0.37 sec)mysql&gt; DESC tb_emp6;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(25) | YES | | NULL | || deptId | int(11) | YES | MUL | NULL | || salary | float | YES | | NULL | |+--------+-------------+------+-----+---------+-------+4 rows in set (1.33 sec) 以上语句执行成功之后，在表 tb_emp6 上添加了名称为 fk_emp_dept1 的外键约束，外键名称为 deptId，其依赖于表 tb_dept1 的主键 id。 注意：从表的外键关联的必须是主表的主键，且主键和外键的数据类型必须一致。例如，两者都是 INT 类型，或者都是 CHAR 类型。如果不满足这样的要求，在创建从表时，就会出现“ERROR 1005(HY000): Can’t create table”错误。 在修改表时添加外键约束外键约束也可以在修改表时添加，但是添加外键约束的前提是：从表中外键列中的数据必须与主表中主键列中的数据一致或者是没有数据。 在修改数据表时添加外键约束的语法格式如下： ALTER TABLE &lt;数据表名&gt; ADD CONSTRAINT &lt;外键名&gt;FOREIGN KEY(&lt;列名&gt;) REFERENCES &lt;主表名&gt; (&lt;列名&gt;); 例 2修改数据表 tb_emp2，将字段 deptId 设置为外键，与数据表 tb_dept1 的主键 id 进行关联，SQL 语句和运行结果如下所示。 1234567891011121314151617181920mysql&gt; ALTER TABLE tb_emp2 -&gt; ADD CONSTRAINT fk_tb_dept1 -&gt; FOREIGN KEY(deptId) -&gt; REFERENCES tb_dept1(id);Query OK, 0 rows affected (1.38 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; SHOW CREATE TABLE tb_emp2\\G*************************** 1. row *************************** Table: tb_emp2Create Table: CREATE TABLE `tb_emp2` ( `id` int(11) NOT NULL, `name` varchar(30) DEFAULT NULL, `deptId` int(11) DEFAULT NULL, `salary` float DEFAULT NULL, PRIMARY KEY (`id`), KEY `fk_tb_dept1` (`deptId`), CONSTRAINT `fk_tb_dept1` FOREIGN KEY (`deptId`) REFERENCES `tb_dept1` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=gb23121 row in set (0.12 sec) 注意：在为已经创建好的数据表添加外键约束时，要确保添加外键约束的列的值全部来源于主键列，并且外键列不能为空。 删除外键约束当一个表中不需要外键约束时，就需要从表中将其删除。外键一旦删除，就会解除主表和从表间的关联关系。 删除外键约束的语法格式如下所示： ALTER TABLE &lt;表名&gt; DROP FOREIGN KEY &lt;外键约束名&gt;; 例 3删除数据表 tb_emp2 中的外键约束 fk_tb_dept1，SQL 语句和运行结果如下所示。 1234567891011121314151617mysql&gt; ALTER TABLE tb_emp2 -&gt; DROP FOREIGN KEY fk_tb_dept1;Query OK, 0 rows affected (0.19 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; SHOW CREATE TABLE tb_emp2\\G*************************** 1. row *************************** Table: tb_emp2Create Table: CREATE TABLE `tb_emp2` ( `id` int(11) NOT NULL, `name` varchar(30) DEFAULT NULL, `deptId` int(11) DEFAULT NULL, `salary` float DEFAULT NULL, PRIMARY KEY (`id`), KEY `fk_tb_dept1` (`deptId`)) ENGINE=InnoDB DEFAULT CHARSET=gb23121 row in set (0.00 sec) 可以看到，tb_emp2 中已经不存在 FOREIGN KEY，原有的名称为 fk_emp_dept 的外键约束删除成功。 Mysql workbench中的其他列属性 根据这一篇博客《MySQL Workbench 中各个列属性的含义》： PK: 主键 (Primary Key) NN: 非空 (Not Null) UQ: 唯一索引 (Unique Index) BIN: 二进制 (Binary) 将数据储存为二进制字符串 UN: 无符号的 (Unsigned) ZF: 零填充的 (Zero Fill) 如：INT (5) 的列中，12 会被填充为 00012 AI: 自增长的 (Auto Increment) G: 生成出来的 (Generated) 如：根据公式从其它列中生成的数据 之前我们已经讲过了里面的很多属性，下面重点介绍四个：unsigned、binary、generated和unique inex。 unsiged属性UNSIGNED属性将数字类型无符号化，与C、C++这些程序语言中的unsigned含义相同。例如，INT的类型范围是-2 147 483 648 ～ 2 147 483 647， INT UNSIGNED的范围类型就是0 ～ 4 294 967 295。 在MYSQL中整型范围： 类型 大小 范围（有符号） 范围（无符号） 用途 TINYINT 1 字节 (-128，127) (0，255) 小整数值 SMALLINT 2 字节 (-32 768，32 767) (0，65 535) 大整数值 MEDIUMINT 3 字节 (-8 388 608，8 388 607) (0，16 777 215) 大整数值 INT或INTEGER 4 字节 (-2 147 483 648，2 147 483 647) (0，4 294 967 295) 大整数值 binary属性binary属性只用于char和varchar值。当为列指定了该属性时，将以区分大小写的方式排序。与之相反，忽略binary属性时，将使用不区分大小写的方式排序 generated column属性Generated Column是MySQL5.7引入的新特性，博客MySQL 5.7新特性之Generated Column中对此有详细解释： 所谓Cenerated Column，就是数据库中这一列由其他列计算而得，我们以官方参考手册中的例子予以说明。 例如，知道直角三角形的两条直角边，要求斜边的长度。很明显，斜边的长度可以通过两条直角边计算而得，那么，这时候就可以在数据库中只存放直角边，斜边使用Generated Column，如下所示： 1234567CREATE TABLE triangle ( sidea DOUBLE,#直角边a sideb DOUBLE,#直角边b sidec DOUBLE AS (SQRT(sidea * sidea + sideb * sideb)) #根据公式求出斜边c);INSERT INTO triangle (sidea, sideb) VALUES(1,1),(3,4),(6,8); 查询结果： 123456789101112131415mysql&gt; SELECT * FROM triangle;+-------+-------+--------------------+| sidea | sideb | sidec |+-------+-------+--------------------+| 1 | 1 | 1.4142135623730951 || 3 | 4 | 5 || 6 | 8 | 10 |+-------+-------+--------------------+ 这个例子就足以说明Generated Columns是什么，以及怎么使用用了。 Mysql中key、primary key、unique key、index之间的区别以下引用自简书发布者陈琰AC的博客 一、Key1.1 key 是数据库的物理结构，它包含两层意义和作用 一是约束：偏重于约束和规范数据库的结构完整性 二是索引：辅助查询用的 key包括primary key, unique key, foreign key 等。 1.2 primary key 有两个作用，一是约束作用（constraint），用来规范一个存储主键和唯一性，但同时也在此key上建立了一个主键索引 primary key 约束：唯一标识数据库表中的每条记录 主键必须包含唯一的值； 主键列不能包含 NULL 值； 每个表都应该有一个主键，并且每个表只能有一个主键。（primary key 拥有自动定义的 unique 约束） 1.3 unique key 也有两个作用，一是约束作用（constraint），规范数据的唯一性，但同时也在这个key上建立了一个唯一索引 unique 约束：唯一标识数据库表中的每条记录。 unique 和 primary key 约束均为列或列集合提供了唯一性的保证。-每个表可以有多个 unique 约束，但是每个表只能有一个primary key 约束. 1.4 foreign key也有两个作用，一是约束作用（constraint），规范数据的引用完整性，但同时也在这个key上建立了一个index 可见，MySQL的key是同时具有constraint和index的意义，这点和其他数据库表现的可能有区别（至少在oracle上建立外键，不会自动建立index）。 1.5 因此创建key也有如下几种方式：（1）在字段级以key方式建立， 如 create table t (id int not null primary key);（2）在表级以constraint方式建立，如create table t(id int, CONSTRAINT pk_t_id PRIMARY key (id));（3）在表级以key方式建立，如create table t(id int, primary key (id)); 其它key创建类似，但不管那种方式，既建立了constraint，又建立了index，只不过index使用的就是这个constraint或key。 二、Indexindex是数据库的物理结构，它只是辅助查询的，它创建时会在另外的表空间（mysql中的innodb表空间）以一个类似目录的结构存储。索引要分类的话，分为前缀索引、全文本索引等。因此，索引只是索引，它不会去约束索引的字段的行为（那是key要做的事情）。我们说索引分类，分为： 主键索引（必须指定为“PRIMARY KEY”，没有PRIMARY Index） 唯一索引（unique index，一般写成unique key） 普通索引(index，只有这一种才是纯粹的index) 三、Index 与Key 的区别Key即键值，是关系模型理论中的一部份，比如有主键（Primary Key)，外键（Foreign Key）等，用于数据完整性检否与唯一性约束等。而Index则处于实现层面，比如可以对表的任意列建立索引，那么当建立索引的列处于SQL语句中的Where条件中时，就可以得到快速的数据定位，从而快速检索。至于Unique Index，则只是属于Index中的一种而已，建立了Unique Index表示此列数据不可重复。在设计表的时候，Key只是处于模型层面的，而当需要进行查询优化，则对相关列建立索引即可。另外，在MySQL中，对于一个Primary Key的列，MySQL已经自动对其建立了Unique Index，无需重复再在上面建立索引了。 四、UNIQUE KEY和PRIMARY KEY有什么区别 Primary key的1个或多个列必须为NOT NULL，如果列为NULL，在增加PRIMARY KEY时，列自动更改为NOT NULL。而UNIQUE KEY 对列没有此要求。 一个表只能有一个PRIMARY KEY，但可以有多个UNIQUE KEY 主键和唯一键约束是通过参考索引实施的，如果插入的值均为NULL，则根据索引的原理，全NULL值不被记录在索引上，所以插入全NULL值时，可以有重复的，而其他的则不能插入重复值。 References[^2]: MySQl 外键约束（FOREIGN KEY）[^3]: C语言中文网对于mysql外键约束的这一篇博客讲的很好","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://justskim.github.io/categories/Mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://justskim.github.io/tags/mysql/"},{"name":"数据存储","slug":"数据存储","permalink":"http://justskim.github.io/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"}]},{"title":"MYSQL数据类型","slug":"MYSQL数据类型","date":"2021-09-05T06:24:59.886Z","updated":"2021-09-06T02:01:31.733Z","comments":true,"path":"2021/09/05/MYSQL数据类型/","link":"","permalink":"http://justskim.github.io/2021/09/05/MYSQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"MYSQL数据类型菜鸟教程[^1]中给出了几款主流数据库软件的数据类型 这一篇中我们着重讲MySQL 数据类型在 MySQL 中，有三种主要的类型：Text（文本）、Number（数字）和 Date&#x2F;Time（日期&#x2F;时间）类型。 Text 类型： 数据类型 描述 CHAR(size) 保存固定长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的长度。最多 255 个字符。 VARCHAR(size) 保存可变长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的最大长度。最多 255 个字符。注释：如果值的长度大于 255，则被转换为 TEXT 类型。 TINYTEXT 存放最大长度为 255 个字符的字符串。 TEXT 存放最大长度为 65,535 个字符的字符串。 BLOB 用于 BLOBs（Binary Large OBjects）。存放最多 65,535 字节的数据。 MEDIUMTEXT 存放最大长度为 16,777,215 个字符的字符串。 MEDIUMBLOB 用于 BLOBs（Binary Large OBjects）。存放最多 16,777,215 字节的数据。 LONGTEXT 存放最大长度为 4,294,967,295 个字符的字符串。 LONGBLOB 用于 BLOBs (Binary Large OBjects)。存放最多 4,294,967,295 字节的数据。 ENUM(x,y,z,etc.) 允许您输入可能值的列表。可以在 ENUM 列表中列出最大 65535 个值。如果列表中不存在插入的值，则插入空值。注释：这些值是按照您输入的顺序排序的。可以按照此格式输入可能的值： ENUM(‘X’,’Y’,’Z’) SET 与 ENUM 类似，不同的是，SET 最多只能包含 64 个列表项且 SET 可存储一个以上的选择。 Number 类型： 数据类型 描述 TINYINT(size) 带符号-128到127 ，无符号0到255。 SMALLINT(size) 带符号范围-32768到32767，无符号0到65535, size 默认为 6。 MEDIUMINT(size) 带符号范围-8388608到8388607，无符号的范围是0到16777215。 size 默认为9 INT(size) 带符号范围-2147483648到2147483647，无符号的范围是0到4294967295。 size 默认为 11 BIGINT(size) 带符号的范围是-9223372036854775808到9223372036854775807，无符号的范围是0到18446744073709551615。size 默认为 20 FLOAT(size,d) 带有浮动小数点的小数字。在 size 参数中规定显示最大位数。在 d 参数中规定小数点右侧的最大位数。 DOUBLE(size,d) 带有浮动小数点的大数字。在 size 参数中规显示定最大位数。在 d 参数中规定小数点右侧的最大位数。 DECIMAL(size,d) 作为字符串存储的 DOUBLE 类型，允许固定的小数点。在 size 参数中规定显示最大位数。在 d 参数中规定小数点右侧的最大位数。 注意：以上的 size 代表的并不是存储在数据库中的具体的长度，如 int(4) 并不是只能存储4个长度的数字。 实际上int(size)所占多少存储空间并无任何关系。int(3)、int(4)、int(8) 在磁盘上都是占用 4 btyes 的存储空间。就是在显示给用户的方式有点不同外，int(M) 跟 int 数据类型是相同的。 例如： 1、int的值为10 （指定zerofill） 12int（9）显示结果为000000010int（3）显示结果为010 就是显示的长度不一样而已 都是占用四个字节的空间 Date 类型： 数据类型 描述 DATE() 日期。格式：YYYY-MM-DD注释：支持的范围是从 ‘1000-01-01’ 到 ‘9999-12-31’ DATETIME() *日期和时间的组合。格式：YYYY-MM-DD HH:MM:SS注释：支持的范围是从 ‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’ TIMESTAMP() *时间戳。TIMESTAMP 值使用 Unix 纪元(‘1970-01-01 00:00:00’ UTC) 至今的秒数来存储。格式：YYYY-MM-DD HH:MM:SS注释：支持的范围是从 ‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-09 03:14:07’ UTC TIME() 时间。格式：HH:MM:SS注释：支持的范围是从 ‘-838:59:59’ 到 ‘838:59:59’ YEAR() 2 位或 4 位格式的年。注释：4 位格式所允许的值：1901 到 2155。2 位格式所允许的值：70 到 69，表示从 1970 到 2069。 *即便 DATETIME 和 TIMESTAMP 返回相同的格式，它们的工作方式很不同。在 INSERT 或 UPDATE 查询中，TIMESTAMP 自动把自身设置为当前的日期和时间。TIMESTAMP 也接受不同的格式，比如 YYYYMMDDHHMMSS、YYMMDDHHMMSS、YYYYMMDD 或 YYMMDD。 MySQL支持所有标准SQL数值数据类型。 这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。 关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。 BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。 作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。 类型 大小 范围（有符号） 范围（无符号） 用途 TINYINT 1 byte (-128，127) (0，255) 小整数值 SMALLINT 2 bytes (-32 768，32 767) (0，65 535) 大整数值 MEDIUMINT 3 bytes (-8 388 608，8 388 607) (0，16 777 215) 大整数值 INT或INTEGER 4 bytes (-2 147 483 648，2 147 483 647) (0，4 294 967 295) 大整数值 BIGINT 8 bytes (-9,223,372,036,854,775,808，9 223 372 036 854 775 807) (0，18 446 744 073 709 551 615) 极大整数值 FLOAT 4 bytes (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) 0，(1.175 494 351 E-38，3.402 823 466 E+38) 单精度 浮点数值 DOUBLE 8 bytes (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 双精度 浮点数值 DECIMAL 对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2 依赖于M和D的值 依赖于M和D的值 小数值 日期和时间类型表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。 每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。 TIMESTAMP类型有专有的自动更新特性，将在后面描述。 类型 大小 ( bytes) 范围 格式 用途 DATE 3 1000-01-01&#x2F;9999-12-31 YYYY-MM-DD 日期值 TIME 3 ‘-838:59:59’&#x2F;‘838:59:59’ HH:MM:SS 时间值或持续时间 YEAR 1 1901&#x2F;2155 YYYY 年份值 DATETIME 8 1000-01-01 00:00:00&#x2F;9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 混合日期和时间值 TIMESTAMP 4 1970-01-01 00:00:00&#x2F;2038结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07 YYYYMMDD HHMMSS 混合日期和时间值，时间戳 字符串类型字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。 类型 大小 用途 CHAR 0-255 bytes 定长字符串 VARCHAR 0-65535 bytes 变长字符串 TINYBLOB 0-255 bytes 不超过 255 个字符的二进制字符串 TINYTEXT 0-255 bytes 短文本字符串 BLOB 0-65 535 bytes 二进制形式的长文本数据 TEXT 0-65 535 bytes 长文本数据 MEDIUMBLOB 0-16 777 215 bytes 二进制形式的中等长度文本数据 MEDIUMTEXT 0-16 777 215 bytes 中等长度文本数据 LONGBLOB 0-4 294 967 295 bytes 二进制形式的极大文本数据 LONGTEXT 0-4 294 967 295 bytes 极大文本数据 注意：char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。 CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。 BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。 BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。 有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。 Microsoft Access 数据类型 数据类型 描述 存储 Text 用于文本或文本与数字的组合。最多 255 个字符。 Memo Memo 用于更大数量的文本。最多存储 65,536 个字符。注释：无法对 memo 字段进行排序。不过它们是可搜索的。 Byte 允许 0 到 255 的数字。 1 字节 Integer 允许介于 -32,768 与 32,767 之间的全部数字。 2 字节 Long 允许介于 -2,147,483,648 与 2,147,483,647 之间的全部数字。 4 字节 Single 单精度浮点。处理大多数小数。 4 字节 Double 双精度浮点。处理大多数小数。 8 字节 Currency 用于货币。支持 15 位的元，外加 4 位小数。提示：您可以选择使用哪个国家的货币。 8 字节 AutoNumber AutoNumber 字段自动为每条记录分配数字，通常从 1 开始。 4 字节 Date&#x2F;Time 用于日期和时间 8 字节 Yes&#x2F;No 逻辑字段，可以显示为 Yes&#x2F;No、True&#x2F;False 或 On&#x2F;Off。在代码中，使用常量 True 和 False （等价于 1 和 0）。注释：Yes&#x2F;No 字段中不允许 Null 值 1 比特 Ole Object 可以存储图片、音频、视频或其他 BLOBs（Binary Large OBjects）。 最多 1GB Hyperlink 包含指向其他文件的链接，包括网页。 Lookup Wizard 允许您创建一个可从下拉列表中进行选择的选项列表。 4 字节 SQL Server 数据类型String 类型： 数据类型 描述 存储 char(n) 固定长度的字符串。最多 8,000 个字符。 Defined width varchar(n) 可变长度的字符串。最多 8,000 个字符。 2 bytes + number of chars varchar(max) 可变长度的字符串。最多 1,073,741,824 个字符。 2 bytes + number of chars text 可变长度的字符串。最多 2GB 文本数据。 4 bytes + number of chars nchar 固定长度的 Unicode 字符串。最多 4,000 个字符。 Defined width x 2 nvarchar 可变长度的 Unicode 字符串。最多 4,000 个字符。 nvarchar(max) 可变长度的 Unicode 字符串。最多 536,870,912 个字符。 ntext 可变长度的 Unicode 字符串。最多 2GB 文本数据。 bit 允许 0、1 或 NULL binary(n) 固定长度的二进制字符串。最多 8,000 字节。 varbinary 可变长度的二进制字符串。最多 8,000 字节。 varbinary(max) 可变长度的二进制字符串。最多 2GB。 image 可变长度的二进制字符串。最多 2GB。 Number 类型： 数据类型 描述 存储 tinyint 允许从 0 到 255 的所有数字。 1 字节 smallint 允许介于 -32,768 与 32,767 的所有数字。 2 字节 int 允许介于 -2,147,483,648 与 2,147,483,647 的所有数字。 4 字节 bigint 允许介于 -9,223,372,036,854,775,808 与 9,223,372,036,854,775,807 之间的所有数字。 8 字节 decimal(p,s) 固定精度和比例的数字。允许从 -10^38 +1 到 10^38 -1 之间的数字。p 参数指示可以存储的最大位数（小数点左侧和右侧）。p 必须是 1 到 38 之间的值。默认是 18。s 参数指示小数点右侧存储的最大位数。s 必须是 0 到 p 之间的值。默认是 0。 5-17 字节 numeric(p,s) 固定精度和比例的数字。允许从 -10^38 +1 到 10^38 -1 之间的数字。p 参数指示可以存储的最大位数（小数点左侧和右侧）。p 必须是 1 到 38 之间的值。默认是 18。s 参数指示小数点右侧存储的最大位数。s 必须是 0 到 p 之间的值。默认是 0。 5-17 字节 smallmoney 介于 -214,748.3648 与 214,748.3647 之间的货币数据。 4 字节 money 介于 -922,337,203,685,477.5808 与 922,337,203,685,477.5807 之间的货币数据。 8 字节 float(n) 从 -1.79E + 308 到 1.79E + 308 的浮动精度数字数据。n 参数指示该字段保存 4 字节还是 8 字节。float(24) 保存 4 字节，而 float(53) 保存 8 字节。n 的默认值是 53。 4 或 8 字节 real 从 -3.40E + 38 到 3.40E + 38 的浮动精度数字数据。 4 字节 Date 类型： 数据类型 描述 存储 datetime 从 1753 年 1 月 1 日 到 9999 年 12 月 31 日，精度为 3.33 毫秒。 8 字节 datetime2 从 1753 年 1 月 1 日 到 9999 年 12 月 31 日，精度为 100 纳秒。 6-8 字节 smalldatetime 从 1900 年 1 月 1 日 到 2079 年 6 月 6 日，精度为 1 分钟。 4 字节 date 仅存储日期。从 0001 年 1 月 1 日 到 9999 年 12 月 31 日。 3 bytes time 仅存储时间。精度为 100 纳秒。 3-5 字节 datetimeoffset 与 datetime2 相同，外加时区偏移。 8-10 字节 timestamp 存储唯一的数字，每当创建或修改某行时，该数字会更新。timestamp 值基于内部时钟，不对应真实时间。每个表只能有一个 timestamp 变量。 其他数据类型： 数据类型 描述 sql_variant 存储最多 8,000 字节不同数据类型的数据，除了 text、ntext 以及 timestamp。 uniqueidentifier 存储全局唯一标识符 (GUID)。 xml 存储 XML 格式化数据。最多 2GB。 cursor 存储对用于数据库操作的指针的引用。 table 存储结果集，供稍后处理。 References[^1]: 菜鸟教程——SQL 用于各种数据库的数据类型","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://justskim.github.io/categories/Mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://justskim.github.io/tags/mysql/"},{"name":"数据存储","slug":"数据存储","permalink":"http://justskim.github.io/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"}]},{"title":"express框架下使用ejs模板","slug":"express框架下使用ejs模板","date":"2021-09-03T10:14:57.108Z","updated":"2021-09-03T10:17:20.834Z","comments":true,"path":"2021/09/03/express框架下使用ejs模板/","link":"","permalink":"http://justskim.github.io/2021/09/03/express%E6%A1%86%E6%9E%B6%E4%B8%8B%E4%BD%BF%E7%94%A8ejs%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"express框架下使用ejs模板ejs模板ejs官方文档^1中，对于其的描述为： EJS 是一套简单的模板语言，帮你利用普通的 JavaScript 代码生成 HTML 页面。EJS 没有如何组织内容的教条；也没有再造一套迭代和控制流语法；有的只是普通的 JavaScript 代码而已。 利用 NPM 安装 EJS 很简单。 1$ npm install ejs References","categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"},{"name":"JavaScript","slug":"Programming-languages-and-projects/JavaScript","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/JavaScript/"},{"name":"Nodejs","slug":"Programming-languages-and-projects/JavaScript/Nodejs","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/JavaScript/Nodejs/"}],"tags":[{"name":"ejs","slug":"ejs","permalink":"http://justskim.github.io/tags/ejs/"},{"name":"express","slug":"express","permalink":"http://justskim.github.io/tags/express/"},{"name":"nodejs","slug":"nodejs","permalink":"http://justskim.github.io/tags/nodejs/"}]},{"title":"Git第一次与远程仓库关联并push时的报错","slug":"Git第一次与远程仓库关联并push时的报错","date":"2021-09-02T23:32:48.083Z","updated":"2021-09-02T23:51:18.357Z","comments":true,"path":"2021/09/03/Git第一次与远程仓库关联并push时的报错/","link":"","permalink":"http://justskim.github.io/2021/09/03/Git%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%85%B3%E8%81%94%E5%B9%B6push%E6%97%B6%E7%9A%84%E6%8A%A5%E9%94%99/","excerpt":"","text":"Git第一次与远程仓库关联并push时的报错关于该debug的过程描述当我们在github建立一个远程仓库时，github会给予我们相应的quick start提示： …or create a new repository on the command line1234567echo &quot;# ejs_express_demo&quot; &gt;&gt; README.mdgit initgit add README.mdgit commit -m &quot;first commit&quot;git branch -M maingit remote add origin https://github.com/JustSkim/ejs_express_demo.gitgit push -u origin main …or push an existing repository from the command line123git remote add origin https://github.com/JustSkim/ejs_express_demo.gitgit branch -M maingit push -u origin main …or import code from another repositoryYou can initialize this repository with code from a Subversion, Mercurial, or TFS project.Import code $ git initInitialized empty Git repository in E:&#x2F;JS练习&#x2F;ejs_demo&#x2F;.git&#x2F; 首先，创建一个 Git 仓库 User@TAPTOP-N6POI72B MNIWG19 &#x2F;e&#x2F;JS练习&#x2F;ejs_demo (master)$ git commit -m “no useful file first commit”On branch masterInitial commitUntracked files: .gitignore package.json nothing added to commit but untracked files present 然后，提交暂存区到本地仓库。事实上，我们第一次使用在该文件夹中使用该git commit命令出现了差错：**Untracked files … nothing added to commit but untracked files present **一般而言，第一次执行提交暂存区到本地仓库的操作，如果使用git commit -m &quot;description&quot; 而不是git commit -a -m &quot;description&quot;，是不会出现该错误的[^1]。 对于我们这种情况，出现该差错的原因在于：在我们每次使用 git commit 命令之前，使用 git add 跟踪一个文件，并且将其纳入暂存区。git add使用文件或者目录作为参数，如果参数是目录，那么会递归地跟踪该目录下左右文件（为”.”，则跟踪目录下所有未被.gitignore排除的文件）[^2]。 User@TAPTOP-N6POI72B MNIWG19 &#x2F;e&#x2F;JS练习&#x2F;ejs_demo (master)$git remote add origin &#x67;&#x69;&#x74;&#x40;&#103;&#x69;&#x74;&#x68;&#x75;&#x62;&#46;&#99;&#111;&#x6d;:JustSkim&#x2F;ejs_express_demo.git 添加名为origind 远程版本库： User@TAPTOP-N6POI72B MNIWG19 &#x2F;e&#x2F;JS练习&#x2F;ejs_demo (master)$ git push -u origin mainerror: src refspec main does not match any.error: failed to push some refs to ‘&#x67;&#105;&#x74;&#x40;&#103;&#105;&#116;&#x68;&#117;&#98;&#46;&#x63;&#x6f;&#x6d;:JustSkim&#x2F;ejs_express_demo.git’ 这里push失败，我们尝试改为https的连接方式（事实证明这对于解决问题是起不到帮助的）（但是当网络环境差导致多次Push失败时，建议更改连接方式） User@TAPTOP-N6POI72B MNIWG19 &#x2F;e&#x2F;JS练习&#x2F;ejs_demo (master)$ git remote set-url origin https://github.com/JustSkim/ejs_express_demo.git User@TAPTOP-N6POI72B MNIWG19 &#x2F;e&#x2F;JS练习&#x2F;ejs_demo (master)$ git push -u origin mastererror: src refspec master does not match any.error: failed to push some refs to ‘https://github.com/JustSkim/ejs_express_demo.git&#39; User@TAPTOP-N6POI72B MNIWG19 &#x2F;e&#x2F;JS练习&#x2F;ejs_demo (master)$ git branch -a 由于之前的错误，存在未被跟踪的文件导致提交失败，因此在这里，无论使用命令“git branch”还是”git branch -a“，都没有列出任何分支 User@TAPTOP-N6POI72B MNIWG19 &#x2F;e&#x2F;JS练习&#x2F;ejs_demo (master)$ git add .warning: LF will be replaced by CRLF in package.json.The file will have its original line endings in your working directory. User@TAPTOP-N6POI72B MNIWG19 &#x2F;e&#x2F;JS练习&#x2F;ejs_demo (master)$ git logfatal: your current branch ‘master’ does not have any commits yet 我们重新跟踪文件这里日志提示我们 ”该master分支下至今没有任何提交“ User@TAPTOP-N6POI72B MNIWG19 &#x2F;e&#x2F;JS练习&#x2F;ejs_demo (master)$ git commit -m “no file”[master (root-commit) 7bbefea] no filewarning: LF will be replaced by CRLF in package.json.The file will have its original line endings in your working directory.2 files changed, 16 insertions(+)create mode 100644 .gitignorecreate mode 100644 package.json 好了，这一次我们提交成功了 User@TAPTOP-N6POI72B MNIWG19 &#x2F;e&#x2F;JS练习&#x2F;ejs_demo (master)$ git branch*master 可以看到master分支存在 User@TAPTOP-N5PIO$ git push origin masterCounting objects: 4, done.Delta compression using up to 16 threads.Compressing objects: 100% (3&#x2F;3), done.Writing objects: 100% (4&#x2F;4), 445 bytes | 0 bytes&#x2F;s, done.Total 4 (delta 0), reused 0 (delta 0)To https://github.com/JustSkim/ejs_express_demo.git [new branch] master -&gt; master 代码成功推送到远程仓库 References[^1]: git commit -a -m “提交报错”[^2]: git提交报错nothing added to commit but untracked files present","categories":[{"name":"Git","slug":"Git","permalink":"http://justskim.github.io/categories/Git/"},{"name":"Git报错处理","slug":"Git/Git报错处理","permalink":"http://justskim.github.io/categories/Git/Git%E6%8A%A5%E9%94%99%E5%A4%84%E7%90%86/"}],"tags":[{"name":"git","slug":"git","permalink":"http://justskim.github.io/tags/git/"}]},{"title":"new Promise构造函数详解","slug":"new-Promise构造函数详解","date":"2021-08-31T07:27:48.096Z","updated":"2021-09-03T10:14:47.314Z","comments":true,"path":"2021/08/31/new-Promise构造函数详解/","link":"","permalink":"http://justskim.github.io/2021/08/31/new-Promise%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"new Promise构造函数详解Promise 对象是 JavaScript 的异步操作解决方案，为异步操作提供统一接口[^1]。它起到代理作用（proxy），充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口。Promise 可以让异步操作写起来，就像在写同步操作的流程（链式操作），而不必一层层地嵌套回调函数。 Promise是一个对象，也是一个构造函数，在ES6中，加入了Promise，其设计思想是：所有异步任务都返回一个 Promise 实例。而每个Promise 实例又都有一个then方法，用来指定下一步的回调函数。如果不使用Promise，我们往往要使用很多层回调的写法，下面做一个对比： 12345678910111213141516// 传统写法step1(function (value1) &#123; step2(value1, function(value2) &#123; step3(value2, function(value3) &#123; step4(value3, function(value4) &#123; // ... &#125;); &#125;); &#125;);&#125;);// Promise 的写法(new Promise(step1)) .then(step2) .then(step3) .then(step4); Promise的构造函数接收一个参数，是函数，并且传入两个参数：resolve，reject，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。按照标准来讲，resolve是将Promise的状态置为fullfiled，reject是将Promise的状态置为rejected。注意，Promise对象通过自身的状态来控制异步操作！ 根据mdn官方网站上的讲解： 一个 Promise 对象代表一个在这个 promise 被创建出来时不一定已知的值。它让您能够把异步操作最终的成功返回值或者失败原因和相应的处理程序关联起来。 这样使得异步方法可以像同步方法那样返回值：异步方法并不会立即返回最终的值，而是会返回一个 promise，以便在未来某个时候把值交给使用者。一个 Promise 必然处于以下几种状态之一： 待定（pending）: 初始状态，既没有被兑现，也没有被拒绝。 已兑现（fulfilled）: 意味着操作成功完成。 已拒绝（rejected）: 意味着操作失败。 其中，状态fulfilled和rejected合在一起称为resolved（已定型），这三种的状态的变化途径只有两种： 从“未完成”到“成功”——异步操作成功，Promise 实例传回一个值（value），状态变为fulfilled。 从“未完成”到“失败”——异步操作失败，Promise 实例抛出一个错误（error），状态变为rejected。 注意！一个Promise对象的状态发生一次变化，就凝固了，不会再有新的状态变化！这也是 Promise 这个名字的由来，它的英语意思是“承诺”，一旦承诺成效，就不得再改变了。这也意味着，Promise 实例的状态变化只可能发生一次。 当两个途径之一发生时，我们用 promise 的 then 方法排列起来的相关处理程序就会被调用。如果 promise 在一个相应的处理程序被绑定时就已经被兑现或被拒绝了，那么这个处理程序就会被调用，因此在完成异步操作和绑定处理方法之间不会存在竞争状态。 构造一个Promise实例12345678var promise = new Promise(function (resolve, reject) &#123; // ... if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; /* 异步操作失败 */ reject(new Error()); &#125;&#125;); resolve函数的作用是，将Promise实例的状态从“未完成”变为“成功”（即从pending变为fulfilled），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去。reject函数的作用是，将Promise实例的状态从“未完成”变为“失败”（即从pending变为rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 Reference[^1]: Promise 对象","categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"},{"name":"JavaScript","slug":"Programming-languages-and-projects/JavaScript","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/JavaScript/"},{"name":"Nodejs","slug":"Programming-languages-and-projects/JavaScript/Nodejs","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/JavaScript/Nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://justskim.github.io/tags/nodejs/"},{"name":"http","slug":"http","permalink":"http://justskim.github.io/tags/http/"}]},{"title":"nodejs中http相关方法","slug":"nodejs中http相关方法","date":"2021-08-31T06:25:35.662Z","updated":"2021-08-31T07:54:54.543Z","comments":true,"path":"2021/08/31/nodejs中http相关方法/","link":"","permalink":"http://justskim.github.io/2021/08/31/nodejs%E4%B8%ADhttp%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95/","excerpt":"","text":"nodejs中http相关方法response相关http.response.end原文链接https://www.jb51.net/article/58468.htm http.response.end结束响应，告诉客户端所有消息已经发送。当所有要返回的内容发送完毕时，该函数必须被调用一次。如果不调用该函数，客户端将永远处于等待状态。语法：response.end([data], [encoding])接收参数：data ： end()执行完毕后要输出的字符，如果指定了 data 的值，那就意味着在执行完 response.end() 之后，会接着执行一条 response.write(data , encoding);encoding： 对应data的字符编码 http.response.write原文链接：https://www.jianshu.com/p/ab0889a387e6response.write(chunk, [encoding])参数：chunk 是一个buffer 或 字符串，表示发送的内容encoding 如果chunk是字符串，就需要指定encoding来说明它的编码方式，默认utf-8该函数用于向请求的客户端发送响应内容。在 response.end() 之前，response.write() 可以被执行多次。 1234app.get(&#x27;/to&#x27;,(req,resp)=&gt;&#123; resp.write(&quot;JQK&quot;); resp.end(&quot;abc&quot;);&#125;) 后续的response.end(data)并不会覆盖之前response.write(data)的值","categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"},{"name":"JavaScript","slug":"Programming-languages-and-projects/JavaScript","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/JavaScript/"},{"name":"Nodejs","slug":"Programming-languages-and-projects/JavaScript/Nodejs","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/JavaScript/Nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://justskim.github.io/tags/nodejs/"},{"name":"http","slug":"http","permalink":"http://justskim.github.io/tags/http/"}]},{"title":"PYQT5绘图","slug":"PYQT5绘图","date":"2021-08-30T21:32:57.313Z","updated":"2021-08-30T21:33:03.986Z","comments":true,"path":"2021/08/31/PYQT5绘图/","link":"","permalink":"http://justskim.github.io/2021/08/31/PYQT5%E7%BB%98%E5%9B%BE/","excerpt":"","text":"PYQT5绘图绘图文本涂鸦12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：文本涂鸦ZetCode PyQt5 tutorial In this example, we draw text in Russian Cylliric.Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom PyQt5.QtWidgets import QWidget, QApplicationfrom PyQt5.QtGui import QPainter, QColor, QFontfrom PyQt5.QtCore import Qtclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.text = &quot;Лев Николаевич Толстой\\nАнна Каренина&quot; #写了一些文本上下居中对齐的俄罗斯Cylliric语言的文字 self.setGeometry(300, 300, 500, 500) self.setWindowTitle(&#x27;Drawing text&#x27;) self.show() def paintEvent(self, event): #在绘画事件内完成绘画动作 qp = QPainter() &#x27;&#x27;&#x27; QPainter是低级的绘画类。所有的绘画动作都在这个类的begin()和end()方法之间完成，绘画动作都封装在drawText()内部了。 &#x27;&#x27;&#x27; qp.begin(self) self.drawText(event, qp) qp.end() def drawText(self, event, qp): qp.setPen(QColor(168, 34, 3)) qp.setFont(QFont(&#x27;Decorative&#x27;, 10)) &#x27;&#x27;&#x27; 为文字绘画定义了笔和字体。 &#x27;&#x27;&#x27; qp.drawText(event.rect(), Qt.AlignCenter, self.text) #drawText()方法在窗口里绘制文本，rect()方法返回要更新的矩形区域if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_())","categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"},{"name":"Python3","slug":"Programming-languages-and-projects/Python3","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"},{"name":"PYQT5","slug":"Programming-languages-and-projects/Python3/PYQT5","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/PYQT5/"}],"tags":[{"name":"python3","slug":"python3","permalink":"http://justskim.github.io/tags/python3/"},{"name":"gui","slug":"gui","permalink":"http://justskim.github.io/tags/gui/"}]},{"title":"PYQT5拖拽","slug":"PYQT5拖拽","date":"2021-08-30T21:31:39.560Z","updated":"2021-08-30T21:31:57.703Z","comments":true,"path":"2021/08/31/PYQT5拖拽/","link":"","permalink":"http://justskim.github.io/2021/08/31/PYQT5%E6%8B%96%E6%8B%BD/","excerpt":"","text":"PYQT5拖拽简单的拖放1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：拖放ZetCode PyQt5 tutorialThis is a simple drag anddrop example. Author: Jan BodnarWebsite: zetcode.comLast edited: August 2017&quot;&quot;&quot;from PyQt5.QtWidgets import (QPushButton, QWidget, QLineEdit, QApplication)import sysclass Button(QPushButton): #用QPushButton上构造一个按钮实例 def __init__(self, title, parent): super().__init__(title, parent) self.setAcceptDrops(True) &#x27;&#x27;&#x27; 激活组件的拖拽事件 &#x27;&#x27;&#x27; def dragEnterEvent(self, e): &#x27;&#x27;&#x27; 重构了dragEnterEvent()方法。设定好接受拖拽的数据类型（plain text） &#x27;&#x27;&#x27; if e.mimeData().hasFormat(&#x27;text/plain&#x27;): e.accept() else: e.ignore() def dropEvent(self, e): #重构dropEvent()方法，更改按钮接受鼠标的释放事件的默认行为。 self.setText(e.mimeData().text()) class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): edit = QLineEdit(&#x27;line-edit&#x27;, self) &#x27;&#x27;&#x27; QLineEdit默认支持拖拽操作，所以我们只要调用setDragEnabled()方法使用就行了。 &#x27;&#x27;&#x27; edit.setDragEnabled(True) edit.move(30, 65) button = Button(&quot;Button&quot;, self) button.move(190, 65) self.setWindowTitle(&#x27;Simple drag and drop&#x27;) self.setGeometry(300, 300, 300, 150)if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() ex.show() app.exec_() 拖放按钮组件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：拖放按钮组件 注意是右键拖拽！！！ZetCode PyQt5 tutorialIn this program, we can press on a button with a left mouseclick or drag and drop the button with the right mouse click. Author: Jan BodnarWebsite: zetcode.comLast edited: August 2017例子中，窗口上有一个QPushButton组件。左键点击按钮，控制台就会输出press。右键可以点击然后拖动按钮。&quot;&quot;&quot;from PyQt5.QtWidgets import QPushButton, QWidget, QApplicationfrom PyQt5.QtCore import Qt, QMimeDatafrom PyQt5.QtGui import QDragimport sysclass Button(QPushButton): def __init__(self, title, parent): super().__init__(title, parent) &#x27;&#x27;&#x27; 从QPushButton继承一个Button类，然后重构QPushButton的两个方法: mouseMoveEvent()和mousePressEvent(). mouseMoveEvent()是拖拽开始的事件。 mousePressEvent()是鼠标给予压力的事件，分鼠标左键、右键、滚轮、前进键、后退键（不包含dpi键） &#x27;&#x27;&#x27; def mouseMoveEvent(self, e): #这里只劫持按钮的右键事件（Qt.RightButton），左键的操作还是默认行为 if e.buttons() != Qt.RightButton: return mimeData = QMimeData() drag = QDrag(self) &#x27;&#x27;&#x27; 创建一个QDrag对象，用来传输MIME-based数据。 &#x27;&#x27;&#x27; drag.setMimeData(mimeData) drag.setHotSpot(e.pos() - self.rect().topLeft()) dropAction = drag.exec_(Qt.MoveAction) def mousePressEvent(self, e): super().mousePressEvent(e) if e.button() == Qt.LeftButton: print(&#x27;press&#x27;) print(e.button()) &#x27;&#x27;&#x27; 左键点击按钮，会在控制台输出“press”。注意，我们在父级上也调用了mousePressEvent()方法， 不然的话，我们是看不到按钮按下的效果的。 mousePressEvent()是鼠标给予压力的事件，各个键有对应的int值（e.button()） 分鼠标左键（Qt.leftButton = 1）、右键（2）、滚轮（4）、前进键（16）、后退键（8） （不包含dpi键） &#x27;&#x27;&#x27;class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setAcceptDrops(True) self.button = Button(&#x27;Button&#x27;, self) self.button.move(100, 65) self.setWindowTitle(&#x27;Click or Move&#x27;) self.setGeometry(300, 300, 280, 150) def dragEnterEvent(self, e): e.accept() def dropEvent(self, e): position = e.pos() self.button.move(position) &#x27;&#x27;&#x27; 在dropEvent()方法里，我们定义了按钮按下后和释放后的行为，获得鼠标移动的位置，然后把按钮放到这个地方 &#x27;&#x27;&#x27; e.setDropAction(Qt.MoveAction) &#x27;&#x27;&#x27; 指定放下的动作类型为moveAction &#x27;&#x27;&#x27;if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() ex.show() app.exec_()","categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"},{"name":"Python3","slug":"Programming-languages-and-projects/Python3","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"},{"name":"PYQT5","slug":"Programming-languages-and-projects/Python3/PYQT5","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/PYQT5/"}],"tags":[{"name":"python3","slug":"python3","permalink":"http://justskim.github.io/tags/python3/"},{"name":"gui","slug":"gui","permalink":"http://justskim.github.io/tags/gui/"}]},{"title":"PYQT5控件","slug":"PYQT5控件","date":"2021-08-30T21:26:04.103Z","updated":"2021-11-03T01:53:59.969Z","comments":true,"path":"2021/08/31/PYQT5控件/","link":"","permalink":"http://justskim.github.io/2021/08/31/PYQT5%E6%8E%A7%E4%BB%B6/","excerpt":"","text":"PYQT5控件QCheckBox12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;ZetCode PyQt5 tutorial In this example, a QCheckBox widgetis used to toggle the title of a window.Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;from PyQt5.QtWidgets import QWidget, QCheckBox, QApplicationfrom PyQt5.QtCore import Qtimport sysclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): cb = QCheckBox(&#x27;Show title&#x27;, self) #QCheckBox的构造器，QCheckBox组件有两个状态：开和关 &#x27;&#x27;&#x27; QCheckBox构造一个三态复选框 名称 值 含义 Qt.Checked 2 组件没有被选中（默认） Qt.PartiallyChecked 1 组件被半选中 Qt.Unchecked 0 组件被选中 &#x27;&#x27;&#x27; cb.move(20, 20) print(&#x27;cb.toggle = &#x27;,cb.toggle()) &#x27;&#x27;&#x27; 检查单选框的状态。默认情况下，窗口没有标题，单选框未选中 PySide2.QtWidgets.QAbstractButton.toggled(checked)¶ Parameters checked – bool &#x27;&#x27;&#x27; cb.stateChanged.connect(self.changeTitle) &#x27;&#x27;&#x27; PySide2.QtWidgets.QCheckBox.stateChanged(arg__1)¶ Parameters arg__1 – int &#x27;&#x27;&#x27; self.setGeometry(300, 300, 250, 150) self.setWindowTitle(&#x27;QCheckBox&#x27;) self.show() def changeTitle(self, state): #根据状态实现窗口标题切换的功能 print(&quot;state = &quot;,state) &#x27;&#x27;&#x27; Qt.Checked为int类型，值为2，代表组件没有被选中 &#x27;&#x27;&#x27; if state == Qt.Checked: self.setWindowTitle(&#x27;QCheckBox&#x27;) else: self.setWindowTitle(&#x27; &#x27;)if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 切换按钮123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：切换按钮ZetCode PyQt5 tutorial In this example, we create three toggle buttons.They will control the background color of a QFrame. Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;from PyQt5.QtWidgets import (QWidget, QPushButton, QFrame, QApplication)from PyQt5.QtGui import QColorimport sysclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.col = QColor(0, 0, 0) redb = QPushButton(&#x27;Red&#x27;, self) redb.setCheckable(True) redb.move(10, 10) redb.clicked[bool].connect(self.setColor) greenb = QPushButton(&#x27;Green&#x27;, self) greenb.setCheckable(True) greenb.move(10, 60) greenb.clicked[bool].connect(self.setColor) blueb = QPushButton(&#x27;Blue&#x27;, self) blueb.setCheckable(True) blueb.move(10, 110) blueb.clicked[bool].connect(self.setColor) #每一种颜色都与这一个设置色彩（RGB三项分别）的函数点击关联 self.square = QFrame(self) &#x27;&#x27;&#x27; 容器中的Frame为一个矩形的框架对象，对应类QFrame， QFrame类是PyQt中带框架部件的所有类的基类，如菜单、进度条、Label标签 &#x27;&#x27;&#x27; self.square.setGeometry(150, 20, 100, 100) self.square.setStyleSheet(&quot;QWidget &#123; background-color: %s &#125;&quot; % self.col.name()) self.setGeometry(300, 300, 280, 170) self.setWindowTitle(&#x27;Toggle button&#x27;) self.show() def setColor(self, pressed): source = self.sender() if pressed: val = 255 else: val = 0 if source.text() == &quot;Red&quot;: self.col.setRed(val) #将RGB模式中红色值调为val=255 elif source.text() == &quot;Green&quot;: self.col.setGreen(val) else: self.col.setBlue(val) self.square.setStyleSheet(&quot;QFrame &#123; background-color: %s &#125;&quot; % self.col.name()) &#x27;&#x27;&#x27; 使用样式表（就是CSS的SS）改变背景色 此处self.square是一个QFrame类 PySide2.QtWidgets.QWidget.setStyleSheet(styleSheet)¶ Parameters： styleSheet – str This property holds the widget’s style sheet. The style sheet contains a textual description of customizations to the widget’s style, as described in the Qt Style Sheets document. 该函数可以设置样式（包括颜色、字体、边框等，类比于html中style属性） &#x27;&#x27;&#x27;if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 滑块12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：滑块ZetCode PyQt5 tutorial This example shows a QSlider widget.Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;from PyQt5.QtWidgets import (QWidget, QSlider, QLabel, QApplication)from PyQt5.QtCore import Qtfrom PyQt5.QtGui import QPixmapimport sysclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): sld = QSlider(Qt.Horizontal, self) &#x27;&#x27;&#x27; 创建一个水平的QSlider QSlider控件提供一个垂直或者水平的滑动条，滑动条是一个用于控制有界值典型的控件， 它允许用户沿水平或者垂直方向在某一范围内移动滑块，并将滑块所在的位置转换为一个合法范围内的整数值， 有时候这中方式比输入数字或者使用SpinBox（计数器·）更加自然，在槽函数中对滑块所在位置的处理相当于从整数之间的最小值和最高值进行取值 原文链接：https://blog.csdn.net/jia666666/article/details/81534588 &#x27;&#x27;&#x27; sld.setFocusPolicy(Qt.NoFocus) &#x27;&#x27;&#x27; setFocusPolicy(Policy) 设置焦点获取策略 Qt.TabFocus() 通过Tab键获取焦点 Qt.ClickFocus() 通过被单击获取焦点 Qt.StrongFocus() 可以通过上面两种方式获取焦点 Qt.NoFocus() 不能通过上面两种方式获取焦点 &#x27;&#x27;&#x27; sld.setGeometry(30, 40, 100, 300) &#x27;&#x27;&#x27; setGeometry()有两个作用： 把窗口放到屏幕上；设置窗口大小。 四个参数分别代表屏幕坐标的x、y和窗口大小的宽、高。 这个方法是resize()和move()的合体。 &#x27;&#x27;&#x27; sld.valueChanged[int].connect(self.changeValue) self.label = QLabel(self) self.label.setPixmap(QPixmap(&#x27;mute.png&#x27;)) &#x27;&#x27;&#x27; 创建一个QLabel组件并给它设置一个静音图标(作为图标的默认设置) PySide2.QtWidgets.QLabel.setPixmap(arg__1)¶ Parameters arg__1 – PySide2.QtGui.QPixmap This property holds the label’s pixmap.. Previously, Qt provided a version of pixmap() which returned the pixmap by-pointer. That version is now deprecated. To maintain compatibility with old code, you can explicitly differentiate between the by-pointer function and the by-value function: QPixmap类用于绘图设备的图像显示，它可以作为一个QPainterDevice对象，也可以加载到一个控件中，通常是标签或者按钮，用于在标签或按钮上显示图像 QPixmap可以读取的图像文件类型有BMP，GIF，JPG等 &#x27;&#x27;&#x27; self.label.setGeometry(160, 40, 1000, 800) self.setGeometry(100, 100, 2000, 1600) self.setWindowTitle(&#x27;QSlider&#x27;) self.show() def changeValue(self, value): if value == 0: self.label.setPixmap(QPixmap(&#x27;mute.png&#x27;)) elif value &gt; 0 and value &lt;= 30: self.label.setPixmap(QPixmap(&#x27;min.png&#x27;)) elif value &gt; 30 and value &lt; 80: self.label.setPixmap(QPixmap(&#x27;med.png&#x27;)) else: self.label.setPixmap(QPixmap(&#x27;max.png&#x27;))if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 进度条123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：进度条ZetCode PyQt5 tutorial This example shows a QProgressBar widget.Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;from PyQt5.QtWidgets import (QWidget, QProgressBar, QPushButton, QApplication)from PyQt5.QtCore import QBasicTimerimport sysclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.pbar = QProgressBar(self) #新建一个QProgressBar构造器。 self.pbar.setGeometry(30, 40, 200, 25) self.btn = QPushButton(&#x27;Start&#x27;, self) self.btn.move(40, 80) self.btn.clicked.connect(self.doAction)#点击绑定一个用来控制开始和停止的方法 self.timer = QBasicTimer() &#x27;&#x27;&#x27; 用时间控制进度条。 QBasicTimer类为对象提供计时器事件。这是Qt内部使用的一个快速，轻量级和低级别的类。 注意这个定时器是一个重复的定时器，除非调用stop()函数，否则它将发送后续的定时器事件。 当定时器超时时，它将向QObject子类发送一个timer事件。 &#x27;&#x27;&#x27; self.step = 0 self.setGeometry(300, 300, 280, 170) self.setWindowTitle(&#x27;QProgressBar&#x27;) self.show() def timerEvent(self, e): &#x27;&#x27;&#x27; 每个QObject和又它继承而来的对象都有一个timerEvent()事件处理函数。 为了触发事件，我们重载（≠重写）了这个方法。 &#x27;&#x27;&#x27; if self.step &gt;= 100: self.timer.stop() &#x27;&#x27;&#x27; PySide2.QtCore.QBasicTimer.stop()¶ No parameters. Stops the timer. &#x27;&#x27;&#x27; self.btn.setText(&#x27;Finished&#x27;) #改变按钮控件的text值 return self.step = self.step + 1 self.pbar.setValue(self.step)#设置值 def doAction(self): if self.timer.isActive(): self.timer.stop() self.btn.setText(&#x27;Start&#x27;) else: self.timer.start(100, self) &#x27;&#x27;&#x27; 调用start()方法加载时间事件，这个方法有两个参数：过期时间（单位：毫秒）和事件接收者 start(int, QObject) &#x27;&#x27;&#x27; self.btn.setText(&#x27;Stop&#x27;)#按钮文字改为“Stop”if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 日历1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：日历ZetCode PyQt5 tutorial This example shows a QCalendarWidget widget.Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;from PyQt5.QtWidgets import (QWidget, QCalendarWidget, QLabel, QApplication, QVBoxLayout)from PyQt5.QtCore import QDateimport sysclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): vbox = QVBoxLayout(self) &#x27;&#x27;&#x27; QHBoxLayout和QVBoxLayout类继承自QBoxLayout，采用QBOXLayout类可以在水平和垂直方向上排列控件， 本案例采用QHBoxLayout类，按照从左到右的顺序来添加控件， 详见博客https://blog.csdn.net/jia666666/article/details/81699900 &#x27;&#x27;&#x27; cal = QCalendarWidget(self) &#x27;&#x27;&#x27; 创建一个QCalendarWidge &#x27;&#x27;&#x27; cal.setGridVisible(False) #setGridVisible(bool)方法可以设置是否在日历上显示网格 cal.clicked[QDate].connect(self.showDate) &#x27;&#x27;&#x27; 选择一个日期时，QDate的点击信号就触发了，把这个信号和我们自己定义的showDate()方法关联起来 &#x27;&#x27;&#x27; vbox.addWidget(cal) self.lbl = QLabel(self) date = cal.selectedDate() &#x27;&#x27;&#x27; selectedDate()方法获取日历控件选中的日期(格式为一个QDate日期对象) PySide2.QtWidgets.QCalendarWidget.selectedDate()¶ Return type PySide2.QtCore.QDate This property holds the currently selected date.. The selected date must be within the date range specified by the minimumDate and maximumDate properties. By default, the selected date is the current date. &#x27;&#x27;&#x27; self.lbl.setText(date.toString())#将该日期对象转换为字符串 vbox.addWidget(self.lbl) self.setLayout(vbox) self.setGeometry(300, 300, 350, 300) self.setWindowTitle(&#x27;Calendar&#x27;) self.show() def showDate(self, date): self.lbl.setText(date.toString())if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 图片123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：图片处理ZetCode PyQt5 tutorial In this example, we dispay an imageon the window. Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;from PyQt5.QtWidgets import (QWidget, QHBoxLayout, QLabel, QApplication)from PyQt5.QtGui import QPixmapimport sysclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): hbox = QHBoxLayout(self) pixmap = QPixmap(&quot;exit.png&quot;) #创建一个QPixmap对象，接收一个文件作为参数。 &#x27;&#x27;&#x27; QPixmap类用于绘图设备的图像显示，它可以作为一个QPainterDevice对象，也可以加载到一个控件中，通常是标签或者按钮，用于在标签或按钮上显示图像QPixmap可以读取的图像文件类型有BMP，GIF，JPG等 &#x27;&#x27;&#x27; lbl = QLabel(self) lbl.setPixmap(pixmap) &#x27;&#x27;&#x27; 把QPixmap实例放到QLabel组件里。 注意，组件大小 必须大于等于 QPixmap这个控件大小（也即图片大小） PySide2.QtWidgets.QLabel.setPixmap(arg__1)¶ Parameters arg__1 – PySide2.QtGui.QPixmap This property holds the label’s pixmap.. Previously, Qt provided a version of pixmap() which returned the pixmap by-pointer. That version is now deprecated. To maintain compatibility with old code, you can explicitly differentiate between the by-pointer function and the by-value function: &#x27;&#x27;&#x27; hbox.addWidget(lbl) self.setLayout(hbox) self.move(300, 200) self.setWindowTitle(&#x27;Red Rock&#x27;) self.show() if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 行编辑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：行编辑让标签的文本与输入文本相同ZetCode PyQt5 tutorial This example shows text which is entered in a QLineEditin a QLabel widget.Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017例子中展示了一个编辑组件和一个标签，我们在输入框里键入的文本，会立即在标签里显示出来&quot;&quot;&quot;import sysfrom PyQt5.QtWidgets import (QWidget, QLabel, QLineEdit, QApplication)class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.lbl = QLabel(self) qle = QLineEdit(self) #创建一个QLineEdit对象。 qle.move(60, 100) self.lbl.move(60, 40) qle.textChanged[str].connect(self.onChanged) &#x27;&#x27;&#x27; 输入框的值有变化时调用我们自己创建的一个方法。 QLineEdit类中的常用信号textChanged：当修改文本内容时，这个信号就会发射 &#x27;&#x27;&#x27; self.setGeometry(300, 300, 280, 170) self.setWindowTitle(&#x27;QLineEdit&#x27;) self.show() def onChanged(self, text): #把文本框里的值赋值给了标签组件，然后调用adjustSize()方法让标签自适应文本内容 self.lbl.setText(text) #改变标签的文本 self.lbl.adjustSize() #adjustSize() 根据内容自适应大小if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) QSplitter1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：splitter 分束器————窗口分隔ZetCode PyQt5 tutorial This example showshow to use QSplitter widget.Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017QSplitter组件能让用户通过 拖拽分割线 的方式改变子窗口大小的组件。本例中我们展示用两个分割线隔开的三个QFrame组件。&quot;&quot;&quot;import sysfrom PyQt5.QtCore import Qtfrom PyQt5.QtWidgets import (QWidget, QHBoxLayout, QFrame, QSplitter, QApplication)class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): hbox = QHBoxLayout(self) topleft = QFrame(self) topleft.setFrameShape(QFrame.StyledPanel) &#x27;&#x27;&#x27; 为了更清楚的看到分割线，我们使用了设置好的子窗口样式。 QFrame的相关值与表现形式可见 http://allstack.net/wordpress/post-918.html 注意这里是 StyledPanel 而不是style! &#x27;&#x27;&#x27; topright = QFrame(self) topright.setFrameShape(QFrame.StyledPanel) bottom = QFrame(self) bottom.setFrameShape(QFrame.StyledPanel) splitter1 = QSplitter(Qt.Horizontal) splitter1.addWidget(topleft) splitter1.addWidget(topright) &#x27;&#x27;&#x27; 创建一个QSplitter组件，并在里面添加了两个框架 &#x27;&#x27;&#x27; splitter2 = QSplitter(Qt.Vertical) splitter2.addWidget(splitter1) &#x27;&#x27;&#x27; 在分割线里面再进行分割 &#x27;&#x27;&#x27; splitter2.addWidget(bottom) hbox.addWidget(splitter2) self.setLayout(hbox) self.setGeometry(300, 300, 300, 200) self.setWindowTitle(&#x27;QSplitter&#x27;) self.show() def onChanged(self, text): self.lbl.setText(text) self.lbl.adjustSize() if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 下拉选框12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：组合下拉框ZetCode PyQt5 tutorial This example shows how to use a QComboBox widget.Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;&#x27;&#x27;&#x27;QComboBox组件能让用户在 多个选择项 中 选择 一个combo 意为 组合的意思combobox: 组合框；下拉列表框&#x27;&#x27;&#x27;from PyQt5.QtWidgets import (QWidget, QLabel, QComboBox, QApplication)import sysclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.lbl = QLabel(&quot;Ubuntu&quot;, self) combo = QComboBox(self) combo.addItem(&quot;Ubuntu&quot;) #添加选项 combo.addItem(&quot;Mandriva&quot;) combo.addItem(&quot;Fedora&quot;) combo.addItem(&quot;Arch&quot;) combo.addItem(&quot;Gentoo&quot;) combo.addItems([&quot;CentOS&quot;,&quot;Alibaba linux&quot;]) &#x27;&#x27;&#x27; addItem() 添加一个下拉选项 addItems() 从列表中添加下拉选项 Clear() 删除下拉选项集合中的所有选项 count() 返回下拉选项集合中的数目 currentText() 返回选中选项的文本 itemText(i) 获取索引为i的item的选项文本 currentIndex() 返回选中项的索引 setItemText(int index,text) 改变序列号为index的文本 原文链接：https://blog.csdn.net/jia666666/article/details/81534260 &#x27;&#x27;&#x27; combo.move(50, 50) self.lbl.move(50, 150) combo.activated[str].connect(self.onActivated) self.setGeometry(300, 300, 300, 200) self.setWindowTitle(&#x27;QComboBox&#x27;) self.show() def onActivated(self, text): self.lbl.setText(text) self.lbl.adjustSize() if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_())","categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"},{"name":"Python3","slug":"Programming-languages-and-projects/Python3","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"},{"name":"PYQT5","slug":"Programming-languages-and-projects/Python3/PYQT5","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/PYQT5/"}],"tags":[{"name":"python3","slug":"python3","permalink":"http://justskim.github.io/tags/python3/"},{"name":"gui","slug":"gui","permalink":"http://justskim.github.io/tags/gui/"}]},{"title":"PYQT5对话框","slug":"PYQT5对话框","date":"2021-08-30T21:14:50.018Z","updated":"2021-08-30T21:14:50.022Z","comments":true,"path":"2021/08/31/PYQT5对话框/","link":"","permalink":"http://justskim.github.io/2021/08/31/PYQT5%E5%AF%B9%E8%AF%9D%E6%A1%86/","excerpt":"","text":"PYQT5对话框输入文字123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：输入文字ZetCode PyQt5 tutorial In this example, we receive data froma QInputDialog dialog. Aauthor: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;from PyQt5.QtWidgets import (QWidget, QPushButton, QLineEdit, QInputDialog, QApplication)import sysclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.btn = QPushButton(&#x27;Dialog&#x27;, self) self.btn.move(20, 20) self.btn.clicked.connect(self.showDialog) self.le = QLineEdit(self) self.le.move(130, 22) self.setGeometry(300, 300, 290, 150) self.setWindowTitle(&#x27;Input dialog&#x27;) self.show() def showDialog(self): print(&quot;the type of return is : &quot;,type(QInputDialog.getText(self, &#x27;Input Dialog&#x27;, &#x27;Enter your name:&#x27;))) text, ok = QInputDialog.getText(self, &#x27;Input Dialog&#x27;, &#x27;Enter your name:&#x27;) &#x27;&#x27;&#x27; 显示一个输入框的代码。第一个参数是输入框的标题，第二个参数是输入框的占位符。 对话框返回输入内容和一个布尔值，如果点击的是OK按钮，布尔值就返回True python的解构语法（逗号在左，与封装语法相反） 把线性结构(列表，元组，字符串，bytes，baitarry)的元素解开，并顺序的赋给其他变量； 左边接纳的变量数要和右边解开的元素个数一致； static PySide2.QtWidgets.QInputDialog.getText(parent, title, label[, echo=QLineEdit.Normal[, text=&quot;&quot;[, flags=Qt.WindowFlags()[, inputMethodHints=Qt.ImhNone]]]])¶ Parameters parent – PySide2.QtWidgets.QWidget title – str label – str echo – EchoMode text – str flags – WindowFlags inputMethodHints – InputMethodHints Return type：(str,bool)(QString, bool ok) QInputDialog.getText (QWidget parent, QString title, QString label, QLineEdit.EchoMode mode = QLineEdit.Normal, QString text = &#x27;&#x27;, Qt.WindowFlags flags = 0) &#x27;&#x27;&#x27; if ok: self.le.setText(str(text))if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 选取颜色123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：选择颜色ZetCode PyQt5 tutorial In this example, we select a color valuefrom the QColorDialog and change the backgroundcolor of a QFrame widget. Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;from PyQt5.QtWidgets import (QWidget, QPushButton, QFrame, QColorDialog, QApplication)from PyQt5.QtGui import QColorimport sysclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): col = QColor(222, 222, 0) &#x27;&#x27;&#x27; 这里通过rgb三项来设置默认的背景颜色为黄色，下面可以使用QColorDialog改变背景颜色 &#x27;&#x27;&#x27; self.btn = QPushButton(&#x27;Dialog&#x27;, self) self.btn.move(20, 20) self.btn.clicked.connect(self.showDialog) #点击事件绑定函数 self.frm = QFrame(self) &#x27;&#x27;&#x27; 容器中的Frame为一个矩形的框架对象，对应类QFrame， QFrame类是PyQt中带框架部件的所有类的基类，如菜单、进度条、Label标签 &#x27;&#x27;&#x27; self.frm.setStyleSheet(&quot;QWidget &#123; background-color: %s &#125;&quot; % col.name()) self.frm.setGeometry(130, 22, 100, 100) self.setGeometry(300, 300, 250, 180) self.setWindowTitle(&#x27;Color dialog&#x27;) self.show() def showDialog(self): col = QColorDialog.getColor() &#x27;&#x27;&#x27; 弹出一个QColorDialog对话框 Pops up a modal color dialog with the given window title (or “Select Color” if none is specified), lets the user choose a color, and returns that color. The color is initially set to initial . The dialog is a child of parent . It returns an invalid (see isValid() ) color if the user cancels the dialog. The options argument allows you to customize the dialog. 调出一个调色板窗口，用户选定颜色后，该函数会用name ()方法返回颜色值 Return type: PySide2.QtGui.QColor 返回一个class类型 &#x27;&#x27;&#x27; for item in dir(col): print(&#x27;-- &#x27;,item,&#x27; --&#x27;) #打印该class中的属性、方法名称 if col.isValid(): #PySide2.QtGui.QColor.isValid()¶ Returns true if the color is valid; otherwise returns false . print(&quot;RGB: &quot;,col.name()) #Returns the name of the color in the format “#RRGGBB”; i.e. a “#” character followed by three two-digit hexadecimal numbers. self.frm.setStyleSheet(&quot;QWidget &#123; background-color: %s &#125;&quot; % col.name())if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 选择字体12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：选择字体ZetCode PyQt5 tutorial In this example, we select a font nameand change the font of a label. Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QPushButton, QSizePolicy, QLabel, QFontDialog, QApplication)import sysclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): vbox = QVBoxLayout() &#x27;&#x27;&#x27; QHBoxLayout和QVBoxLayout类继承自QBoxLayout，采用QBOXLayout类可以在水平和垂直方向上排列控件， 本案例采用QHBoxLayout类，按照从左到右的顺序来添加控件， 详见博客https://blog.csdn.net/jia666666/article/details/81699900 &#x27;&#x27;&#x27; btn = QPushButton(&#x27;Dialog&#x27;, self) btn.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed) btn.move(20, 20) vbox.addWidget(btn) btn.clicked.connect(self.showDialog) self.lbl = QLabel(&#x27;Knowledge only matters&#x27;, self) self.lbl.move(130, 20) vbox.addWidget(self.lbl) self.setLayout(vbox) self.setGeometry(300, 300, 250, 180) self.setWindowTitle(&#x27;Font dialog&#x27;) self.show() def showDialog(self): font, ok = QFontDialog.getFont() &#x27;&#x27;&#x27; 创建了一个有一个按钮和一个标签的QFontDialog的对话框，我们可以使用这个功能修改字体样式. getFont()方法返回一个字体名称和状态信息。状态信息有OK和其他两种。 static PySide2.QtWidgets.QFontDialog.getFont([parent=None])¶ Parameters parent – PySide2.QtWidgets.QWidget Return type PyTuple &#x27;&#x27;&#x27; if ok: #如果点击OK，标签的字体就会随之更改 self.lbl.setFont(font)if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 选择文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：文件保存ZetCode PyQt5 tutorial In this example, we select a file with aQFileDialog and display its contentsin a QTextEdit.Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;from PyQt5.QtWidgets import (QMainWindow, QTextEdit, QAction, QFileDialog, QApplication)from PyQt5.QtGui import QIconimport sysclass Example(QMainWindow): &#x27;&#x27;&#x27; 设置了一个文本编辑框，文本编辑框是基于QMainWindow组件的。 本例中有一个菜单栏，一个置中的文本编辑框，一个状态栏。点击菜单栏选项会弹出一个QtGui.QFileDialog对话框， 在这个对话框里，你能选择文件，然后文件的内容就会显示在文本编辑框里。 &#x27;&#x27;&#x27; def __init__(self): super().__init__() self.initUI() def initUI(self): self.textEdit = QTextEdit() self.setCentralWidget(self.textEdit) self.statusBar() openFile = QAction(QIcon(&#x27;open.png&#x27;), &#x27;Open&#x27;, self) openFile.setShortcut(&#x27;Ctrl+O&#x27;) openFile.setStatusTip(&#x27;Open new File&#x27;) openFile.triggered.connect(self.showDialog) menubar = self.menuBar() fileMenu = menubar.addMenu(&#x27;&amp;File&#x27;) fileMenu.addAction(openFile) self.setGeometry(300, 300, 350, 300) self.setWindowTitle(&#x27;File dialog&#x27;) self.show() def showDialog(self): fname = QFileDialog.getOpenFileName(self, &#x27;Open file&#x27;, &#x27;/home&#x27;) &#x27;&#x27;&#x27; 弹出QFileDialog窗口。getOpenFileName()方法的第一个参数是说明文字， 第二个参数是默认打开的文件夹路径。默认情况下显示所有类型的文件。 &#x27;&#x27;&#x27; if fname[0]: f = open(fname[0], &#x27;r&#x27;) with f: data = f.read() self.textEdit.setText(data) &#x27;&#x27;&#x27; 读取选中的文件，并显示在文本编辑框内 注意只能读取二进制文件，如txt，html等 （但是打开HTML文件时，是渲染后的结果） 打开pdf,png格式图片时候，会报错如下： UnicodeDecodeError: &#x27;gbk&#x27; codec can&#x27;t decode byte 0x89 in position 24: illegal multibyte sequence &#x27;&#x27;&#x27; if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_())","categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"},{"name":"Python3","slug":"Programming-languages-and-projects/Python3","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"},{"name":"PYQT5","slug":"Programming-languages-and-projects/Python3/PYQT5","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/PYQT5/"}],"tags":[{"name":"python3","slug":"python3","permalink":"http://justskim.github.io/tags/python3/"},{"name":"gui","slug":"gui","permalink":"http://justskim.github.io/tags/gui/"}]},{"title":"PYQT5事件与信号","slug":"PYQT5事件与信号","date":"2021-08-30T21:07:47.378Z","updated":"2021-08-30T21:08:00.898Z","comments":true,"path":"2021/08/31/PYQT5事件与信号/","link":"","permalink":"http://justskim.github.io/2021/08/31/PYQT5%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BF%A1%E5%8F%B7/","excerpt":"","text":"PYQT5事件与信号事件根据发布在gitbook网站上的中文博客^1讲解： signals and slots 被其他人翻译成信号和槽机制，(⊙o⊙)…我这里还是不翻译好了。所有的应用都是事件驱动的。事件大部分都是由用户的行为产生的，当然也有其他的事件产生方式，比如网络的连接，窗口管理器或者定时器等。调用应用的exec_()方法时，应用会进入主循环，主循环会监听和分发事件。在事件模型中，有三个角色：事件源事件事件目标事件源就是发生了状态改变的对象。事件是这个对象状态改变的内容。事件目标是事件想作用的目标。事件源绑定事件处理函数，然后作用于事件目标身上。PyQt5处理事件方面有个signal and slot机制。Signals and slots用于对象间的通讯。事件触发的时候，发生一个signal，slot是用来被Python调用的。 信号(signal)与槽(slot)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子： 信号、槽ZetCode PyQt5 tutorial In this example, we connect a signalof a QSlider to a slot of a QLCDNumber. Author: Jan BodnarWebsite: zetcode.com Last edited: January 2017&quot;&quot;&quot;import sysfrom PyQt5.QtCore import Qtfrom PyQt5.QtWidgets import (QWidget, QLCDNumber, QSlider, QVBoxLayout, QApplication)class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): lcd = QLCDNumber(self) sld = QSlider(Qt.Horizontal, self) vbox = QVBoxLayout() vbox.addWidget(lcd) vbox.addWidget(sld) self.setLayout(vbox) sld.valueChanged.connect(lcd.display) #把滑块的变化和数字的变化绑定在一起 self.setGeometry(300, 300, 250, 150) self.setWindowTitle(&#x27;Signal and slot&#x27;) self.show()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 重构事件处理器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：重构事件处理器（用自己的覆盖库自带的）ZetCode PyQt5 tutorial In this example, we reimplement an event handler. Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom PyQt5.QtCore import Qtfrom PyQt5.QtWidgets import QWidget, QApplicationclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setGeometry(300, 300, 250, 150) self.setWindowTitle(&#x27;Event handler&#x27;) self.show() def keyPressEvent(self, e): &#x27;&#x27;&#x27; 替换了事件处理器函数keyPressEvent()，按下esc键会退出程序 &#x27;&#x27;&#x27; if e.key() == Qt.Key_Escape: self.close()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 事件对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：事件对象ZetCode PyQt5 tutorial In this example, we display the x and y coordinates of a mouse pointer in a label widget.Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom PyQt5.QtCore import Qtfrom PyQt5.QtWidgets import QWidget, QApplication, QGridLayout, QLabelclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): grid = QGridLayout() grid.setSpacing(10) x = 0 y = 0 self.text = &quot;x: &#123;0&#125;, y: &#123;1&#125;&quot;.format(x, y) #在一个组件里显示鼠标的X和Y坐标。 self.label = QLabel(&#x27;self.text&#x27;, self) &#x27;&#x27;&#x27; PySide2.QtWidgets.QLabel(text[, parent=None[, f=Qt.WindowFlags()]]) QLabel用于显示文本或图像。没有提供用户交互功能 Constructs a label that displays the text. The parent and widget flag f , arguments are passed to the QFrame constructor. 构建一个显示文本的标签，参数中父级和控件标志f会被传递给QFrame构造函数 &#x27;&#x27;&#x27; grid.addWidget(self.label, 0, 0, Qt.AlignTop) self.setMouseTracking(True) #事件追踪默认没有开启，当开启后才会追踪鼠标的点击事件 self.setLayout(grid) self.setGeometry(300, 300, 350, 200) self.setWindowTitle(&#x27;Event object&#x27;) self.show() def mouseMoveEvent(self, e): &#x27;&#x27;&#x27; 官方文档中的解释仅一句：Override this to handle mouse move events. 覆盖此操作以处理鼠标移动事件 这里的参数e为事件对象。里面有我们触发事件（鼠标移动）的事件对象。 下面的x()和y()方法可以得到鼠标在窗口中此刻的x和y坐标点，然后拼成字符串输出到QLabel组件里 &#x27;&#x27;&#x27; x = e.x() y = e.y() text = &quot;x: &#123;0&#125;, y: &#123;1&#125;&quot;.format(x, y) self.label.setText(text) &#x27;&#x27;&#x27; 注意qtcy中以很多个setText函数，这里是：PySide2.QtWidgets.QLabel.setText(arg__1) Parameters: arg__1 – str &#x27;&#x27;&#x27;if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 事件发送123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：事件发送ZetCode PyQt5 tutorial In this example, we determine the event senderobject.Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom PyQt5.QtWidgets import QMainWindow, QPushButton, QApplicationclass Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): btn1 = QPushButton(&quot;Button 1&quot;, self) btn1.move(30, 50) btn2 = QPushButton(&quot;Button 2&quot;, self) btn2.move(150, 50) btn1.clicked.connect(self.buttonClicked) btn2.clicked.connect(self.buttonClicked) self.statusBar() self.setGeometry(300, 300, 290, 150) self.setWindowTitle(&#x27;Event sender&#x27;) self.show() def buttonClicked(self): sender = self.sender() &#x27;&#x27;&#x27;Returns a pointer to the object that sent the signal, if called in a slot activated by a signal; otherwise(否则) it returns None . The pointer is valid only during the execution(执行) of the slot that calls this function from this object’s thread context.The pointer returned by this function becomes invalid if the sender(发送人) is destroyed, or if the slot is disconnected from the sender’s signal.sender()在QT里的原型是QObject::sender(),也就是对象，实例化的对象可以发送信号，返回发送信号的对象的指针，返回类型为QObject * &#x27;&#x27;&#x27; self.statusBar().showMessage(sender.text() + &#x27; was pressed&#x27;) &#x27;&#x27;&#x27; Returns the object that emitted the signal. 该函数没有参数，返回发送信号的那一个对象 用调用sender()方法的方式决定了事件源。状态栏显示了被点击的按钮. &#x27;&#x27;&#x27;if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 信号发送123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：信号发送ZetCode PyQt5 tutorial In this example, we show how to emit（发射，发送） a custom signal. Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom PyQt5.QtCore import pyqtSignal, QObjectfrom PyQt5.QtWidgets import QMainWindow, QApplicationclass Communicate(QObject): #创建了一个叫closeApp的信号，这个信号会在鼠标按下的时候触发，事件与QMainWindow绑定。 closeApp = pyqtSignal() class Example(QMainWindow): &#x27;&#x27;&#x27; class PySide2.QtWidgets.QMainWindow([parent=None[, flags=Qt.WindowFlags()]])¶ param parent PySide2.QtWidgets.QWidget param flags WindowFlags Constructs a QMainWindow with the given parent and the specified widget flags . QMainWindow sets the Window flag itself, and will hence always be created as a top-level widget. &#x27;&#x27;&#x27; def __init__(self): super().__init__() self.initUI() def initUI(self): self.c = Communicate() &#x27;&#x27;&#x27; Communicate类创建了一个pyqtSignal()属性的信号。 &#x27;&#x27;&#x27; self.c.closeApp.connect(self.close) &#x27;&#x27;&#x27; PySide2.QtGui.QWindow.close()¶ Return type bool 功能只有一个Close the window. &#x27;&#x27;&#x27; self.setGeometry(300, 300, 290, 150) self.setWindowTitle(&#x27;Emit signal&#x27;) self.show() def mousePressEvent(self, event): event.gg = &#x27;gg&#x27; print(&quot;event: &quot;,event.__dict__) #打印对象的全部属性 self.c.closeApp.emit()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) Reference","categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"},{"name":"Python3","slug":"Programming-languages-and-projects/Python3","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"},{"name":"PYQT5","slug":"Programming-languages-and-projects/Python3/PYQT5","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/PYQT5/"}],"tags":[{"name":"python3","slug":"python3","permalink":"http://justskim.github.io/tags/python3/"},{"name":"gui","slug":"gui","permalink":"http://justskim.github.io/tags/gui/"}]},{"title":"PYQT5布局管理","slug":"PYQT5布局管理","date":"2021-08-30T20:58:59.264Z","updated":"2021-08-30T20:58:59.264Z","comments":true,"path":"2021/08/31/PYQT5布局管理/","link":"","permalink":"http://justskim.github.io/2021/08/31/PYQT5%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86/","excerpt":"","text":"PYQT5布局管理绝对定位123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：绝对定位ZetCode PyQt5 tutorial This example shows three labels on a windowusing absolute positioning. Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom PyQt5.QtWidgets import QWidget, QLabel, QApplicationclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): &#x27;&#x27;&#x27; QLabel小部件提供文本或图像显示，没有交互功能！ &#x27;&#x27;&#x27; lbl1 = QLabel(text=&#x27;Zetcode&#x27;, parent=self) lbl1.move(15, 10) #使用move方法定位元素(也就是这个label部件) lbl2 = QLabel(&#x27;tutorials&#x27;, self) lbl2.move(35, 40) lbl3 = QLabel(&#x27;for programmers&#x27;, self) lbl3.move(55, 70) self.setGeometry(400, 400, 500, 250) &#x27;&#x27;&#x27; setGeometry()有两个作用： 把窗口放到屏幕上；设置窗口大小。 四个参数分别代表屏幕坐标的x、y和窗口大小的宽、高。 这个方法是resize()和move()的合体。 &#x27;&#x27;&#x27; self.setWindowTitle(&#x27;Absolute&#x27;) #为窗口添加了一个在标题栏展示的标题 self.show()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 盒布局123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：盒布局ZetCode PyQt5 tutorial In this example, we position two pushbuttons in the bottom-right corner of the window. Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom PyQt5.QtWidgets import (QWidget, QPushButton, QHBoxLayout, QVBoxLayout, QApplication)class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): okButton = QPushButton(&quot;OK&quot;) #创建一个继承自QPushButton的按钮(自然就是一个控件)。第一个参数text参数是想要显示的按钮名称，第二个参数parent是按钮的父级组件 cancelButton = QPushButton(&quot;Cancel&quot;) &#x27;&#x27;&#x27; 下面十行代码创建一个水平布局，并增加弹性空间和两个按钮。 addStretch函数的作用就是平分布局，它所带的参数就是所占的比例，这里为1占据了全部 &#x27;&#x27;&#x27; hbox = QHBoxLayout() &#x27;&#x27;&#x27; QHBoxLayout和QVBoxLayout类继承自QBoxLayout，采用QBOXLayout类可以在水平和垂直方向上排列控件， 本案例采用QHBoxLayout类，按照从左到右的顺序来添加控件， 详见博客https://blog.csdn.net/jia666666/article/details/81699900 &#x27;&#x27;&#x27; hbox.addStretch(1) hbox.addWidget(okButton) &#x27;&#x27;&#x27; PySide2.QtWidgets.QGridLayout.addWidget(arg__1, row, column, rowSpan, columnSpan[, alignment=Qt.Alignment()]) row:行位置 column：列位置 rowSpan：跨行数、行跨距（一般用于QTextEdit()文本输入组件） columnSpan：列跨距 alignment；对齐方式 if rowSpan and/or columnSpan is -1, then the widget will extend to the bottom and/or right edge, respectively. 如果这两项设置为-1，该小组件会分别沿两个方向延伸到底部/右边缘 这里增加了一个按钮 addwidget()方法用于向布局中添加控件（这里是按钮okButton） &#x27;&#x27;&#x27; hbox.addWidget(cancelButton) vbox = QVBoxLayout() vbox.addStretch(1) vbox.addLayout(hbox) &#x27;&#x27;&#x27; 为了布局需要，我们把这个水平布局放到了一个垂直布局盒里面。弹性元素会把水平布局挤到窗口的下边。 &#x27;&#x27;&#x27; self.setLayout(vbox) self.setGeometry(300, 300, 300, 150) self.setWindowTitle(&#x27;Buttons&#x27;) self.show()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 栅格布局123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：栅格化布局ZetCode PyQt5 tutorial In this example, we create a skeletonof a calculator using a QGridLayout.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015&quot;&quot;&quot;import sysfrom PyQt5.QtWidgets import (QWidget, QGridLayout, QPushButton, QApplication)class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): grid = QGridLayout(self) &#x27;&#x27;&#x27; QGridLayout（网格布局）是将窗口分割成行和列的网格来进行排列， 通常可以使用函数addWidget（）将被管理的控件（Widget）添加到窗口中，或者使用addLayout（）函数将布局（layout）添加到窗口中， 也可以通过addWIdget（）函数对所添加的控件设置行数与列数的跨越，最后实现网格占据多个窗格。 QGridLayout类中有以下三个常用方法： addWidget(QWidget Widget,int row,int col,int alignment=0) 给网格布局添加部件，设置指定的行和列，起始位置的默认值为（0,0） addWidget(QWidget widget,int fromRow,int fromColulmn,int rowSpan,int columnSpan,Qt.Alignment alignment=0) setSpacing(int spacing) 所添加的的控件跨越很多行或者列的时候，使用这个函数 setSpacing(int spacing) 设置软件在水平和垂直方向的间隔 详见https://blog.csdn.net/jia666666/article/details/81701176 &#x27;&#x27;&#x27; self.setLayout(grid) #创建一个QGridLayout实例，并把它放到程序窗口里 &#x27;&#x27;&#x27; 有些控件或者布局有addLayout和addWidget的函数,但是有些就没有, 比如QWidget这个控件就没有addLayout和addWidget这个函数,取而代之的是一个setLayout函数, 在addLayout函数中,我们可以多次使用addLayout来依次添加布局,addWidget亦是如此, 但是setlayout只能set一次 官方文档中对此的解释： Sets the layout manager for this widget to layout . If there already is a layout manager installed on this widget, QWidget won’t let you install another. You must first delete the existing layout manager (returned by layout() ) before you can call with the new layout. If layout is the layout manager on a different widget, will reparent the layout and make it the layout manager for this widget. 翻译过来就是： 为此小组件设置布局管理器以布局。 若您已经在此窗口小部件上安装了一个布局管理器，则QWidget这个控件不会允许您安装另一个布局管理器，除非删除现有的布局管理器（在使用新布局调用之前删除PlayOut（））。 如果布局是在不同的另一个窗口小部件上的布局管理器，那么将重新定义布局并使其成为此小部件的布局管理器。 &#x27;&#x27;&#x27; names = [&#x27;Cls&#x27;, &#x27;Bck&#x27;, &#x27;&#x27;, &#x27;Close&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;/&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;*&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;-&#x27;, &#x27;0&#x27;, &#x27;.&#x27;, &#x27;=&#x27;, &#x27;+&#x27;] #定义一个列表，存储将要使用的按钮的名称 positions = [(i,j) for i in range(5) for j in range(4)] #生成位置坐标，五行(i)四列(j) for position, name in zip(positions, names): #依次创建按钮位置列表 if name == &#x27;&#x27;: continue #为空的话，原本控件的位置会空出来，不会被后面的挤占 button = QPushButton(name) &#x27;&#x27;&#x27; www.zetcode.com的解释 QPushButton is a widget which executes an action when a user clicks on it. A QPushButton can display text and icons. &#x27;&#x27;&#x27; grid.addWidget(button, *position) &#x27;&#x27;&#x27; QGridLayout::addWidget ( QWidget * widget, int row, int column, Qt::Alignment alignment = 0 ) python中，*参数收集所有未匹配的位置参数组成一个tuple对象（元组），局部变量args指向此tuple对象 &#x27;&#x27;&#x27; self.move(300, 150) self.setWindowTitle(&#x27;Calculator&#x27;) self.show()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 制作提交反馈信息的布局123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：能反馈信息的布局ZetCode PyQt5 tutorial In this example, we create a more complicated window layout usingthe QGridLayout manager. Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom PyQt5.QtWidgets import (QWidget, QLabel, QLineEdit, QTextEdit, QGridLayout, QApplication)class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): title = QLabel(&#x27;Title&#x27;) author = QLabel(&#x27;Author&#x27;) review = QLabel(&#x27;Review&#x27;) titleEdit = QLineEdit() authorEdit = QLineEdit() reviewEdit = QTextEdit() &#x27;&#x27;&#x27; 用QGridLayout模块制作两个行编辑窗口和一个文本编辑窗口 &#x27;&#x27;&#x27; grid = QGridLayout() #一个QGridLayout类 #QGridLayout(parent)，在构建新网格布局时必须将其插入父布局，没有则为self。 grid.setSpacing(10) #各个控件之间的间距（包括上下左右）设置为10px &#x27;&#x27;&#x27; 在组件的排列中，行列均从0开始， 行缺失则后面的填上位置，所以从0或1开始无所谓， 但网格化布局中，列必须从0而不是1开始，也不能缺失 &#x27;&#x27;&#x27; grid.addWidget(title, 0, 0) #将该组件添加至第0行第0列 grid.addWidget(titleEdit, 0, 1) #将该组件添加至第0行第1列 grid.addWidget(author, 1, 0) grid.addWidget(authorEdit, 1, 1) grid.addWidget(review, 2, 0) grid.addWidget(reviewEdit, 2, 1, 5, 1) &#x27;&#x27;&#x27; PySide2.QtWidgets.QGridLayout.addWidget(arg__1, row, column, rowSpan, columnSpan[, alignment=Qt.Alignment()]) row:行位置 column：列位置 rowSpan：跨行数、行跨距（一般用于QTextEdit()文本输入组件） columnSpan：列跨距 alignment；对齐方式 这里文本编辑窗口跨5行，仍然只占一列 &#x27;&#x27;&#x27; self.setLayout(grid) #设置布局管理器，一个QWidget控件中只能设置一个 self.setGeometry(300, 300, 350, 300) self.setWindowTitle(&#x27;Review&#x27;) self.show()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_())","categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"},{"name":"Python3","slug":"Programming-languages-and-projects/Python3","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"},{"name":"PYQT5","slug":"Programming-languages-and-projects/Python3/PYQT5","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/PYQT5/"}],"tags":[{"name":"python3","slug":"python3","permalink":"http://justskim.github.io/tags/python3/"},{"name":"gui","slug":"gui","permalink":"http://justskim.github.io/tags/gui/"}]},{"title":"Pyqt5中的窗口与工具栏","slug":"Pyqt5中的窗口与工具栏","date":"2021-08-30T20:45:49.898Z","updated":"2021-08-30T20:55:29.290Z","comments":true,"path":"2021/08/31/Pyqt5中的窗口与工具栏/","link":"","permalink":"http://justskim.github.io/2021/08/31/Pyqt5%E4%B8%AD%E7%9A%84%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%B7%A5%E5%85%B7%E6%A0%8F/","excerpt":"","text":"Pyqt5中的窗口与工具栏主窗口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：主窗口ZetCode PyQt5 tutorial This program creates a skeleton ofa classic GUI application with a menubar,toolbar, statusbar, and a central widget. Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom PyQt5.QtWidgets import QMainWindow, QTextEdit, QAction, QApplicationfrom PyQt5.QtGui import QIconclass Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): textEdit = QTextEdit() self.setCentralWidget(textEdit) &#x27;&#x27;&#x27; 创建了一个文本编辑区域，并把它放在QMainWindow的中间区域，这个组件会占满所有剩余的区域。 &#x27;&#x27;&#x27; exitAct = QAction(QIcon(&#x27;exit24.png&#x27;), &#x27;Exit&#x27;, self) #当鼠标移至工具栏中的该图标时，会显示这里的文字‘Exit’ exitAct.setShortcut(&#x27;Ctrl+Q&#x27;) #设置该动作的相关快捷键 exitAct.setStatusTip(&#x27;Exit application&#x27;) exitAct.triggered.connect(self.close) self.statusBar() #创建一个状态栏 menubar = self.menuBar() #创建一个菜单栏 fileMenu = menubar.addMenu(&#x27;&amp;File&#x27;) #这里的符号&#x27;&amp;&#x27;不会在菜单栏选项中显示出来 fileMenu.addAction(exitAct) toolbar = self.addToolBar(&#x27;Exit&#x27;) #addToolBar()创建工具栏 toolbar.addAction(exitAct) #工具栏添加一个选项 self.setGeometry(300, 300, 350, 250) self.setWindowTitle(&#x27;Main window&#x27;) self.show()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 状态栏1234567891011121314151617181920212223242526272829303132333435363738394041424344#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例1：状态栏ZetCode PyQt5 tutorial This program creates a statusbar.Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom PyQt5.QtWidgets import QMainWindow, QApplication#状态栏由QMainWindow创建class Example(QMainWindow): def __init__(self): #super() 函数是用于调用父类(超类)的一个方法。super ().__init__ ()，就是继承父类的init方法 super().__init__() self.initUI() def initUI(self): self.statusBar().showMessage(&#x27;Ready&#x27;) &#x27;&#x27;&#x27; 调用QtGui.QMainWindow类的statusBar()方法，创建状态栏。 第一次调用会创建一个状态栏，而再次调用会返回一个状态栏对象。showMessage()方法在状态栏上显示一条信息。 &#x27;&#x27;&#x27; self.setGeometry(300, 300, 250, 150) self.setWindowTitle(&#x27;Statusbar&#x27;) self.show()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 菜单栏12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例2：菜单栏ZetCode PyQt5 tutorial This program creates a menubar. Themenubar has one menu with an exit action.Author: Jan BodnarWebsite: zetcode.com Last edited: January 2017&quot;&quot;&quot;import sysfrom PyQt5.QtWidgets import QMainWindow, QAction, qApp, QApplicationfrom PyQt5.QtGui import QIconclass Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): exitAct = QAction(QIcon(&#x27;exit.png&#x27;), &#x27;&amp;Exit&#x27;, self) exitAct.setShortcut(&#x27;Ctrl+Q&#x27;) exitAct.setStatusTip(&#x27;Exit application&#x27;) &#x27;&#x27;&#x27; QAction是菜单栏、工具栏或者快捷键的动作的组合。 上面三行中，前两行创建了一个图标、一个exit的标签和一个快捷键组合，都执行了一个动作； 第三行，创建了一个状态栏，当鼠标悬停在菜单栏的时候，能显示当前状态。 &#x27;&#x27;&#x27; exitAct.triggered.connect(qApp.quit) #当执行这个指定的动作时，就触发了一个事件。这个事件跟QApplication的quit()行为相关联，所以这个动作就能终止这个应用。 self.statusBar() menubar = self.menuBar() #创建一个菜单栏（位于顶部固定位置） &#x27;&#x27;&#x27; QMenu和QMenuBar是Qt中的菜单类(也就是右键菜单)和菜单栏类，其中，菜单QMenu挂载在菜单栏QMenuBar上 &#x27;&#x27;&#x27; fileMenu = menubar.addMenu(&#x27;&amp;File&#x27;) fileMenu.addAction(exitAct) &#x27;&#x27;&#x27; menuBar()创建菜单栏。这里创建了一个菜单栏，并用addMenu()在上面添加了一个file菜单， 用addAction()关联了点击退出应用的事件/动作（也就是可直接进行的选项而非子级菜单）。 &#x27;&#x27;&#x27; self.setGeometry(300, 300, 300, 200) self.setWindowTitle(&#x27;Simple menu&#x27;) self.show()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 子菜单1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例3：子菜单ZetCode PyQt5 tutorial This program creates a submenu.Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom PyQt5.QtGui import QIconfrom PyQt5.QtWidgets import QMainWindow, QAction, QMenu, QApplicationclass Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setWindowIcon(QIcon(&#x27;icon.png&#x27;)) #设置图标 menubar = self.menuBar() #菜单栏上一个没有子级菜单的纯粹选项（动作） GoAction = menubar.addAction(&quot;GOOOOOOOOoo&quot;) &#x27;&#x27;&#x27; 主菜单栏第一项为File，其下添加两个动作（addAction(impAct)）New和Save， 添加两个子级菜单(addMenu(impMenu))Import和Import2 &#x27;&#x27;&#x27; fileMenu = menubar.addMenu(&#x27;File&#x27;) impMenu = QMenu(&#x27;Import&#x27;, self) #定义一个子菜单 Import impAct = QAction(&#x27;Import mail&#x27;, self) #在子菜单Import下的子级菜单 Import mail impMenu.addAction(impAct) #用addAction()关联事件————悬浮在Import时会出现Import mail。 impMenu2 = QMenu(&#x27;Import2&#x27;, self) impAct2 = QAction(&#x27;Import mail2&#x27;, self) impMenu2.addAction(impAct2) newAct = QAction(&#x27;New一个&#x27;, self) save = QAction(&#x27;Save保存文件&#x27;,self) fileMenu.addAction(newAct)#添加了菜单下的一个动作（也就是可直接进行的选项而非子级菜单） fileMenu.addAction(save) #添加了动作“Save保存文件”，注意顺序在new之后 fileMenu.addMenu(impMenu)#添加了子菜单，注意函数addMenu是和添加主菜单一样的 fileMenu.addMenu(impMenu2) #定义菜单栏的选项edit editMenu = menubar.addMenu(&quot;Edit&quot;) impMenu_edit = QMenu(&quot;write in Chinese&quot;,self) editMenu.addMenu(impMenu_edit) impAct_edit = QAction(&quot;give up&quot;,self) editMenu.addAction(impAct_edit) self.setGeometry(300, 300, 300, 200) self.setWindowTitle(&#x27;Submenu&#x27;) self.show()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 勾选菜单1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例4：勾选菜单ZetCode PyQt5 tutorial This program creates a optional menu.Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom typing import ValuesViewfrom PyQt5.QtWidgets import QMainWindow, QAction, QApplicationclass Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): self.statusbar = self.statusBar() self.statusbar.showMessage(&#x27;Ready&#x27;) #状态栏显示 menubar = self.menuBar() #本例创建了一个行为菜单。这个行为／动作能切换状态栏显示或者隐藏。 viewMenu = menubar.addMenu(&#x27;View&#x27;) viewStatAct = QAction(text=&#x27;View statusbar&#x27;, parent=self, checkable=True) #checkable选项为True，意味着所创建的这一个 动作（父级菜单的子项） 能被选中 viewStatAct.setStatusTip(&#x27;View statusbar&#x27;) viewStatAct.setChecked(True) #设置该动作的默认状态为选中状态 viewStatAct.triggered.connect(self.toggleMenu)#绑定动作激活时的事件 viewMenu.addAction(viewStatAct) self.setGeometry(300, 300, 300, 200) self.setWindowTitle(&#x27;Check menu&#x27;) self.show() def toggleMenu(self, state): #根据是否打钩来决定是否显示底部的状态栏 if state: self.statusbar.show() else: self.statusbar.hide()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 右键菜单12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例5：右键菜单ZetCode PyQt5 tutorial This program creates a context menu.context有内容、上下文的意思，context menu意为右键菜单（上下文菜单）Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom PyQt5.QtWidgets import QMainWindow, qApp, QMenu, QApplicationclass Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setGeometry(300, 300, 300, 200) self.setWindowTitle(&#x27;Context menu&#x27;) self.show() &#x27;&#x27;&#x27; 利用右键菜单事件 QWidget::contextMenuEvent() 来处理右键事件，所以需要重写此函数 &#x27;&#x27;&#x27; def contextMenuEvent(self, event): &#x27;&#x27;&#x27; The QMenu class provides a menu widget for use in menu bars, context menus, and other popup menus &#x27;&#x27;&#x27; cmenu = QMenu(&#x27;这里的文字不会显示，有无均可&#x27;,self) #使用QMenu创建一个上下文菜单，即右键菜单 newAct = cmenu.addAction(&quot;New&quot;) #添加了一名为“New”的动作 opnAct = cmenu.addAction(&quot;Open&quot;) quitAct = cmenu.addAction(&quot;Quit&quot;) action = cmenu.exec_(self.mapToGlobal(event.pos())) &#x27;&#x27;&#x27; 使用exec_()方法显示菜单。从鼠标右键事件对象中获得当前坐标。mapToGlobal()方法把当前组件的相对坐标转换为窗口（window）的绝对坐标。 &#x27;&#x27;&#x27; &#x27;&#x27;&#x27; 如果点击右键菜单中的Quit动作，则退出 右键菜单里触发了事件，也就触发了退出事件，执行关闭菜单行为 &#x27;&#x27;&#x27; if action == quitAct: qApp.quit() else: print(&quot;现在执行的动作不是quitAct&quot;)if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 工具栏123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：工具栏ZetCode PyQt5 tutorial This program creates a toolbar.The toolbar has one action, whichterminates the application, if triggered.Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom PyQt5.QtWidgets import QMainWindow, QAction, qApp, QApplicationfrom PyQt5.QtGui import QIconclass Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): exitAct = QAction(icon=QIcon(&#x27;exit24.png&#x27;), text=&#x27;Exittttt&#x27;, parent=self) exitAct.setShortcut(&#x27;Ctrl+Q&#x27;) exitAct.triggered.connect(qApp.quit) #行为被触发的时候，会调用QtGui.QMainWindow的quit方法退出应用 self.toolbar = self.addToolBar(&#x27;Exit&#x27;)#addToolBar()创建工具栏 #‘Exit’不会显示在工具栏中，当鼠标移至该图标时，会显示文字‘Exittttt’而非‘Exit’ self.toolbar.addAction(exitAct) #将动作添加到工具栏 self.setGeometry(300, 300, 300, 200) self.setWindowTitle(&#x27;Toolbar&#x27;) self.show()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 主窗口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例子：主窗口ZetCode PyQt5 tutorial This program creates a skeleton ofa classic GUI application with a menubar,toolbar, statusbar, and a central widget. Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom PyQt5.QtWidgets import QMainWindow, QTextEdit, QAction, QApplicationfrom PyQt5.QtGui import QIconclass Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): textEdit = QTextEdit() self.setCentralWidget(textEdit) &#x27;&#x27;&#x27; 创建了一个文本编辑区域，并把它放在QMainWindow的中间区域，这个组件会占满所有剩余的区域。 &#x27;&#x27;&#x27; exitAct = QAction(QIcon(&#x27;exit24.png&#x27;), &#x27;Exit&#x27;, self) #当鼠标移至工具栏中的该图标时，会显示这里的文字‘Exit’ exitAct.setShortcut(&#x27;Ctrl+Q&#x27;) #设置该动作的相关快捷键 exitAct.setStatusTip(&#x27;Exit application&#x27;) exitAct.triggered.connect(self.close) self.statusBar() #创建一个状态栏 menubar = self.menuBar() #创建一个菜单栏 fileMenu = menubar.addMenu(&#x27;&amp;File&#x27;) #这里的符号&#x27;&amp;&#x27;不会在菜单栏选项中显示出来 fileMenu.addAction(exitAct) toolbar = self.addToolBar(&#x27;Exit&#x27;) #addToolBar()创建工具栏 toolbar.addAction(exitAct) #工具栏添加一个选项 self.setGeometry(300, 300, 350, 250) self.setWindowTitle(&#x27;Main window&#x27;) self.show()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_())","categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"},{"name":"Python3","slug":"Programming-languages-and-projects/Python3","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"},{"name":"PYQT5","slug":"Programming-languages-and-projects/Python3/PYQT5","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/PYQT5/"}],"tags":[{"name":"python3","slug":"python3","permalink":"http://justskim.github.io/tags/python3/"},{"name":"gui","slug":"gui","permalink":"http://justskim.github.io/tags/gui/"}]},{"title":"Pyqt5中的常用模块与组件","slug":"应用窗口初始化","date":"2021-08-29T14:29:42.426Z","updated":"2021-08-30T20:48:02.559Z","comments":true,"path":"2021/08/29/应用窗口初始化/","link":"","permalink":"http://justskim.github.io/2021/08/29/%E5%BA%94%E7%94%A8%E7%AA%97%E5%8F%A3%E5%88%9D%E5%A7%8B%E5%8C%96/","excerpt":"","text":"应用窗口初始化QApplication与QWidgetQWidget控件是一个用户界面的基本控件，它提供了基本的应用构造器。默认情况下，构造器是没有父级的，没有父级的构造器被称为窗口（window）。 窗口类型简介^1QMainWindow、QWidget、QDialog用于创建窗口，可以直接使用，也可以派生使用，这3个基类从名字上看分别是 “微件”、”对话框”、”主窗口。QMainWindow窗口包含菜单栏、工具栏、状态栏、标题栏等，是最常见的窗口形式。QDialog是对话框窗口的基类，主要用于执行短期任务，或与用户进行交互，可以是模态或非模态的。QDialog对话框没有菜单栏、工具栏、状态栏等。QWidget是Qt图形组件的基类，可以作为顶层窗口，也可以嵌入到其它组件中。 在创建Qt Gui Application时，总会让你选择在QWidget,QMainWindow和QDialog中选择一个Base Class。 这三个类具体有什么区别呢？在Qt的手册和网上找了一些资料。 先看官方的手册中的介绍： QWidget Class ReferenceThe QWidget class is the base class of all user interface objects.Inherits: QObject and QPaintDevice.Inherited by: ……, QDialog, ……,QMainWindow, …… QDialog Class ReferenceThe QDialog class is the base class of dialog windows.Inherits: QWidget. QMainWindow Class ReferenceThe QMainWindow class provides a main application window.Inherits: QWidget. 可以看到QMainWindow和QDialog都是继承自QWidget。再看看下面那段从网上转过来的介绍，大概就能了解三者之间的区别了。 QWidget类是所有用户界面对象的基类。 窗口部件是用户界面的一个原子：它从窗口系统接收鼠标、键盘和其它事件，并且在屏幕上绘制自己的表现。每一个窗口部件都是矩形，并且它们按Z轴顺序排列的。一个窗口部件可以被它的父窗口部件或者它前面的窗口部件盖住一部分。 QMainWindow 类提供一个有菜单条、锚接窗口（例如工具条）和一个状态条的主应用程序窗口。主窗口通常用在提供一个大的中央窗口部件（例如文本编辑或者绘制画布）以及周围菜单、工具条和一个状态条。QMainWindow常常被继承，因为这使得封装中央部件、菜单和工具条以及窗口状态变得更容易。继承使创建当用户点击菜单项或者工具条按钮时被调用的槽成为可能。你也可以使用Qt设计器来创建主窗口。 QDialog类是对话框窗口的基类。对话框窗口是主要用于短期任务以及和用户进行简要通讯的顶级窗口。QDialog可以是模式的也可以是非模式的。QDialog支持扩展性并且可以提供返回值。它们可以有默认按钮。QDialog也可以有一个QSizeGrip在它的右下角，使用setSizeGripEnabled()。 QDialog 是最普通的顶级窗口。不被嵌入到一个父窗口部件的窗口部件被叫做顶级窗口部件。通常情况下，顶级窗口部件是有框架和标题栏的窗口（尽管如果使用了一定的窗口部件标记，创建顶级窗口部件时也可能没有这些装饰。）在Qt中，QMainWindow和和不同的QDialog的子类是最普通的顶级窗口。 综上，如果是顶级对话框，那就基于QDialog创建，如果是主窗体，那就基于QMainWindow，如果不确定，或者有可能作为顶级窗体，或有可能嵌入到其他窗体中，则基于QWidget创建。当然了，实际中，你还可以基于任何其他部件类来派生。看实际需求了，比如QFrame、QStackedWidget等等。 根据官方对QApplication的解释：PyQt5.QtGui .QGuiApplication继承自QCoreApplication，由PyQt5.QtWidgets .QApplication继承。QApplication管理GUI程序的控制流和主要设置。QApplication包含窗口系统和其他来源处理过和发送过的主事件循环。它也处理应用程序的初始化和收尾工作，并提供对话管理。QApplication可以对系统和应用的大部分设置项进行设置。对于用Qt写的任何一个GUI应用，不管这个应用有没有窗口或多少个窗口，有且只有一QApplication对象。sys.argv是一组命令行参数的列表。Python可以在shell里运行，这个参数提供对脚本控制的功能每一个PyQt5项目都需要创建一个 QApplication 对象。 sys.argv 则提供了命令行的一些参数，这样 Python 脚本就能从 Shell 运行，这是我们控制脚本开始运行的方式。 至于为什么需要sys.argv，可以看stackoverflow上的这一个回答：This calls the constructor of the C++ class QApplication.It uses sys.argv (argc and argv in C++) to initialize the QT application.There are a bunch of arguments that you can pass to QT, like styles, debugging stuff and so on.以及官方文档：https://doc.qt.io/qt-5/qapplication.html#QApplication Hello World实例以下是一个来自技术网站zetcode的实例代码 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;ZetCode PyQt5 tutorial In this example, we create a simplewindow in PyQt5.author: Jan Bodnarwebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom PyQt5.QtWidgets import QApplication, QWidgetif __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) w = QWidget() w.resize(250, 150) w.move(300, 300) w.setWindowTitle(&#x27;Simple&#x27;) w.show() #QWidget类中的show()方法能让窗口在桌面上显示出来。注意窗口是在内存里创建，之后才能在显示器里显示出来 sys.exit(app.exec_()) &#x27;&#x27;&#x27; 调用exit()方法或直接销毁窗口时，主循环就会结束。sys.exit()方法能确保主循环安全退出。外部环境会收到窗口如何结束的信息。 这里的方法exec_()之所以有个下划线，是因为exec是一个Python的关键字。 &#x27;&#x27;&#x27; 几个名词之间的区分根据技术网站zetcode^2提供的相关英文文档，内容如下： Here we provide the necessary imports. The basic widgets are located in PyQt5.QtWidgets module. 1234app = QApplication(sys.argv) ```Every PyQt5 application must create an application object. The `sys.argv` parameter is a list of arguments from a command line. Python scripts can be run from the shell. It is a way how we can control the startup of our scripts. w &#x3D; QWidget()&#96;&#96;&#96; The QWidget widget is the base class of all user interface objects in PyQt5. We provide the default constructor for QWidget. The default constructor has no parent. A widget with no parent is called a window. 带图标的窗口12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例2 带图标的窗口ZetCode PyQt5 tutorial This example shows an iconin the titlebar of the window.Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom PyQt5.QtWidgets import QApplication, QWidgetfrom PyQt5.QtGui import QIconclass Example(QWidget): def __init__(self): super().__init__() self.initUI() #使用initUI()方法创建一个GUI(图形用户界面 Graphical User Interface)。 def initUI(self): self.setGeometry(300, 300, 300, 220) self.setWindowTitle(&#x27;Icon&#x27;) self.setWindowIcon(QIcon(&#x27;icon.png&#x27;)) &#x27;&#x27;&#x27; 三个方法都继承自QWidget类。 setGeometry()有两个作用： 把窗口放到屏幕上并且设置窗口大小。参数分别代表屏幕坐标的x、y和窗口大小的宽、高。 也就是说这个方法是resize()和move()的合体。 setWindowTitle(&#x27;Icon&#x27;)为窗口添加了一个在标题栏展示文字&#x27;Icon&#x27;的标题 最后一个方法是添加了图标。先创建一个QIcon对象，然后接受一个路径作为参数显示图标。 &#x27;&#x27;&#x27; self.show() #让控件在桌面上显示出来。控件在内存里创建，之后才能在显示器上显示出来。if __name__ == &#x27;__main__&#x27;: MyApplication = QApplication(sys.argv) #创建应用对象，名称无所谓，后续操作相同即可 ex = Example() sys.exit(MyApplication.exec_()) #销毁主控件 提示框1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;# 例3 提示框ZetCode PyQt5 tutorial This example shows a tooltip on a window and a button.Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom PyQt5.QtWidgets import (QWidget, QToolTip, QPushButton, QApplication) #引用相关模块from PyQt5.QtGui import QFont class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): #为应用创建了一个提示框，10px的SansSerif字体 QToolTip.setFont(QFont(&#x27;SansSerif&#x27;, 10)) #QToolTip.setFont(QFont(&#x27;SansSerif&#x27;, 10,QFont.Bold,italic=True)) #函数QFont具体使用见 https://doc.qt.io/qtforpython/PySide6/QtGui/QFont.html #参数：字体类型，大小（px），粗细，斜体... btn = QPushButton(text=&#x27;Button&#x27;,parent=self) &#x27;&#x27;&#x27; 创建一个继承自QPushButton的按钮。第一个参数text参数是想要显示的按钮名称， 第二个参数parent是按钮的父级组件，这个例子中，self所指的父级组件，就是我们创建的继承自Qwidget的Example类。 应用中的组件都是一层一层（继承而来的？）的，在这个层里，大部分的组件都有自己的父级， 没有父级的组件（parent=None,没有parent的QWidget类），是顶级的窗口，即被认为是最上层的窗体（通常是MainWindow）。 &#x27;&#x27;&#x27; #创建一个按钮，当鼠标悬浮于按钮时，提示&#x27;This is a QPushButton widget&#x27; btn.setToolTip(&#x27;This is a &lt;b&gt;QPushButton&lt;/b&gt; widget&#x27;) #调用setTooltip()创建提示框可以使用富文本格式的内容 #当鼠标悬浮于窗口中时，提示&#x27;This is a QWidget widget&#x27; self.setToolTip(&#x27;This is a &lt;b&gt;QWidget&lt;/b&gt; widget&#x27;) btn.resize(btn.sizeHint())#sizeHint()会自动给定一个合适的尺寸 btn.move(50, 50) self.setGeometry(300, 300, 300, 200) #setGeometry()把窗口放到屏幕上并且设置窗口大小，4个参数分别代表屏幕坐标的x、y和窗口大小的宽、高。 self.setWindowTitle(&#x27;Tooltips&#x27;) #设置标题 self.show()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 关闭窗口12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例4：关闭窗口ZetCode PyQt5 tutorial This program creates a quitbutton. When we press the button,the application terminates. Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom PyQt5.QtWidgets import QWidget, QPushButton, QApplicationfrom PyQt5.QtCore import QCoreApplication#程序需要QtCore对象class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): qbtn = QPushButton(text=&#x27;Quit&#x27;, parent=self) #创建一个继承自QPushButton的按钮。第一个参数text参数是想要显示的按钮名称，第二个参数parent是按钮的父级组件 #创建了一个点击之后就退出窗口的按钮。 qbtn.clicked.connect(QCoreApplication.instance().quit) &#x27;&#x27;&#x27; 事件传递系统在PyQt5内建的single（信号）和slot（槽）机制里面。 点击按钮之后，信号会被捕捉并给出既定的反应。 QCoreApplication包含了事件的主循环，它能添加和删除所有的事件，instance()创建了一个它的实例。 QCoreApplication是在QApplication里创建的。 点击事件和能终止进程并退出应用的quit函数绑定在了一起。 在发送者和接受者之间建立了通讯，发送者就是按钮，接受者就是应用对象。 QpushButton常用的三种响应有pressed，released和clicked 在Qt中，控件中的clicked（）信号和clicked（bool）信号是两个不同的信号，区别在于： 映射槽函数时，clicked（）信号映射到的槽函数是不带参的，clicked（bool）信号映射到的槽函数是带参数的。 &#x27;&#x27;&#x27; qbtn.resize(qbtn.sizeHint()) qbtn.move(50, 50) self.setGeometry(300, 300, 250, 150) self.setWindowTitle(&#x27;Quit button&#x27;) self.show()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 消息盒子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例5 消息盒子ZetCode PyQt5 tutorial This program shows a confirmation message box when we click on the closebutton of the application window. Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom PyQt5.QtWidgets import QWidget, QMessageBox, QApplicationclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setGeometry(300, 300, 250, 150) self.setWindowTitle(&#x27;Message box&#x27;) self.show() &#x27;&#x27;&#x27; QWidget在程序窗口关闭时会触发 closeEvent() 事件 因此我们这里药重写窗口方法closeEvent,添加关闭窗口触发的事件 &#x27;&#x27;&#x27; def closeEvent(self, event): reply = QMessageBox.question(self, &#x27;Message&#x27;, &quot;Are you sure to quit?&quot;, QMessageBox.Yes | QMessageBox.No, QMessageBox.No) &#x27;&#x27;&#x27; 创建了一个消息框，上面有俩按钮：Yes和No.第一个字符串显示在消息框的标题栏，第二个字符串显示在对话框，第三个参数是消息框的俩按钮，最后一个参数是默认按钮，这个按钮是默认选中的。返回值在变量reply里。 &#x27;&#x27;&#x27; if reply == QMessageBox.Yes: event.accept() else: event.ignore() &#x27;&#x27;&#x27; 关闭QWidget，就会产生一个QCloseEvent，并且把它传入到closeEvent函数的event参数中。 改变控件的默认行为，就是替换掉默认的事件处理。 &#x27;&#x27;&#x27; if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 窗口居中1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot;例6：窗口居中ZetCode PyQt5 tutorial This program centers a window on the screen. Author: Jan BodnarWebsite: zetcode.com Last edited: August 2017&quot;&quot;&quot;import sysfrom PyQt5.QtWidgets import QWidget, QDesktopWidget, QApplicationclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.resize(250, 150) self.center() self.setWindowTitle(&#x27;Center&#x27;) self.show() def center(self): qr = self.frameGeometry() #这一句获得主窗口所在的框架，其中QtGui.QDesktopWidget提供了用户的桌面信息，包括屏幕的大小。 cp = QDesktopWidget().availableGeometry().center() #获取显示器的分辨率，然后得到屏幕中间点的位置。 qr.moveCenter(cp) #通过move函数把主窗口的左上角移动到其框架的左上角，实现窗口居中 self.move(qr.topLeft())if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) References","categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"},{"name":"Python3","slug":"Programming-languages-and-projects/Python3","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"},{"name":"PYQT5","slug":"Programming-languages-and-projects/Python3/PYQT5","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/PYQT5/"}],"tags":[{"name":"python3","slug":"python3","permalink":"http://justskim.github.io/tags/python3/"},{"name":"gui","slug":"gui","permalink":"http://justskim.github.io/tags/gui/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-08-29T14:29:42.425Z","updated":"2022-03-31T10:34:37.305Z","comments":true,"path":"2021/08/29/hello-world/","link":"","permalink":"http://justskim.github.io/2021/08/29/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Diary","slug":"Diary","permalink":"http://justskim.github.io/categories/Diary/"},{"name":"life","slug":"Diary/life","permalink":"http://justskim.github.io/categories/Diary/life/"}],"tags":[{"name":"life","slug":"life","permalink":"http://justskim.github.io/tags/life/"}]},{"title":"Your first md","slug":"first","date":"2021-08-29T14:29:42.424Z","updated":"2021-08-29T14:29:42.424Z","comments":true,"path":"2021/08/29/first/","link":"","permalink":"http://justskim.github.io/2021/08/29/first/","excerpt":"","text":"light single page blog application theme, using Vue, Vuex, ElementUI and so on. 第一个使用的主题是一款基于Vue, Vuex 和 ElementUI 构建的轻量单页博客主题 Live DemoDemo | 在线演示 Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"typora中的锚点与引用","slug":"Reference","date":"2021-08-29T14:29:42.424Z","updated":"2021-09-02T23:48:45.283Z","comments":true,"path":"2021/08/29/Reference/","link":"","permalink":"http://justskim.github.io/2021/08/29/Reference/","excerpt":"","text":"在markdown编辑器Typora中使用锚点与引用点击链接，打开网页，跳转相关url在之前写博客的时候，一直被引用参考文献的问题所困扰，Markdown官方语法教程相关页面中给对于引用和链接跳转出了以下的方法， 引用类型链接引用样式链接是一种特殊的链接，它使URL在Markdown中更易于显示和阅读。参考样式链接分为两部分：与文本保持内联的部分以及存储在文件中其他位置的部分，以使文本易于阅读。 # 链接的第一部分格式引用类型的链接的第一部分使用两组括号进行格式设置。第一组方括号包围应显示为链接的文本。第二组括号显示了一个标签，该标签用于指向您存储在文档其他位置的链接。 尽管不是必需的，可以在第一组和第二组括号之间包含一个空格。第二组括号中的标签不区分大小写，可以包含字母，数字，空格或标点符号。 以下示例格式对于链接的第一部分效果相同： [hobbit-hole][1] [hobbit-hole] [1] # 链接的第二部分格式引用类型链接的第二部分使用以下属性设置格式： 放在括号中的标签，其后紧跟一个冒号和至少一个空格（例如[label]:）。 链接的URL，可以选择将其括在尖括号中。 链接的可选标题，可以将其括在双引号，单引号或括号中。 以下示例格式对于链接的第二部分效果相同： [1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle [1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle &quot;Hobbit lifestyles&quot; [1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle &#39;Hobbit lifestyles&#39; [1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle (Hobbit lifestyles) [1]: &lt;https://en.wikipedia.org/wiki/Hobbit#Lifestyle&gt; &quot;Hobbit lifestyles&quot; [1]: &lt;https://en.wikipedia.org/wiki/Hobbit#Lifestyle&gt; &#39;Hobbit lifestyles&#39; [1]: &lt;https://en.wikipedia.org/wiki/Hobbit#Lifestyle&gt; (Hobbit lifestyles) 可以将链接的第二部分放在Markdown文档中的任何位置。有些人将它们放在出现的段落之后，有些人则将它们放在文档的末尾（例如尾注或脚注）。 此处被“ctrl+鼠标左键”点击后，调用浏览器跳转至百度首页 点击此处不能实现跳转 References注意参考文献reference是可数名词 这种方式适合于带有链接的参考文献，如果想在点击链接后，跳转至markdown文件末尾的脚注中（再进一步决定是否跳转脚注指向的参考文献中的url链接），我们需要采用下面的办法。 实现页内跳转页内跳转：从一篇文章的一个地方（锚点）跳到该篇文章的另一个地方（页内链接） 一些网上资料中，介绍这样一种markdown文档中实现页面内部跳转的方式： 先定义要跳转的锚点——这一部分放在我们的正文中 &lt;span id=&quot;your_anchor&quot;&gt;在别处点击后，您要跳转到此锚点处&lt;/span&gt; 然后是定义链接（点击后跳转到对应的锚点）——这一部分通常放在末尾作为参考文献[锚点]（#your_anchor） 但实际上，在markdown编辑器typora中，这个方式存在缺陷，具体原因为：需要使用a标签而不能为其他标签，诸如span，div等，比如下面的例子： a标签中的文本，“ctrl+左键”可以跳转到锚点 在这一个链接中，a标签被嵌套于一个div标签中，也可以跳转到与上面链接一样关联的锚点。同时我们通过设置a标签的style属性来去除此链接的下划线 这一个span标签中的链接就没办法跳转了 Typora官方文档的此页面中给出了a标签在这种情况下的使用方法： HTML &lt;a&gt; tagYou could also use raw HTML to add links, for example 12345&lt;a href=&quot;http://www.google.com&quot; target=&quot;__blank&quot;&gt;Link to Google&lt;/a&gt;&lt;a name=&quot;anchor&quot;&gt;&lt;/a&gt; Anchor&lt;a href=&quot;#anchor&quot;&gt;Link to Anchor&lt;/a&gt; For link towards a website, we suggest you DO NOT ommit URL protocols like https:// or http://, or it may be interpreted as relative link by Typora or other Markdown egines, or after export&#x2F;publish. 这里是我们预先定义的锚点 注意，以上这几种方式只能实现单向跳转。如果想要实现word编辑论文中，参考文献式的双向跳转，需要参照markdown官方教程中的脚注语法^1： 脚注使您可以添加注释和参考，而不会使文档正文混乱。当您创建脚注时，带有脚注的上标数字会出现在您添加脚注参考的位置。读者可以单击链接（在typora编辑器中为”ctrl+左键”）以跳至页面底部的脚注内容。 要创建脚注参考，请在方括号（[^1]）内添加插入符号和标识符。标识符可以是数字或单词，但不能包含空格或制表符。标识符仅将脚注参考与脚注本身相关联-在输出中，脚注按顺序编号。 在括号内使用另一个插入符号和数字添加脚注，并用冒号和文本（[^1]: My footnote.）。您不必在文档末尾添加脚注。您可以将它们放在除列表，块引号和表之类的其他元素之外的任何位置。 1234567891011Here&#x27;s a simple footnote,[^1] and here&#x27;s a longer one.[^bignote][^1]: This is the first footnote.[^bignote]: Here&#x27;s one with multiple paragraphs and code. Indent paragraphs to include them in the footnote. `&#123; my code &#125;` Add as many paragraphs as you like. 呈现的输出如下所示： Here’s a simple footnote,^1 and here’s a longer one.[^bignote] ^1: This is the first footnote.[^bignote]: Here’s one with multiple paragraphs and code. 注意，这里末尾的参考文献中，编号为1的脚注之所以有两个箭头指向链接，是因为我们在本篇博客中使用了两个同名为“1”的链接，我们可以从这里看出，脚注具有顺序性。 一个值得注意的点 编写作为锚点的位于末尾的参考文献时，如果要附上url链接，格式写作如下形式： 1[^anchor]: [文章标题](url) 其中，不仅第二个方括号和冒号之间要空一格，由于**[文本](url)**是markdown的一种链接语法，为了让参考文献也拥有向url跳转的箭头功能，需要在(url)后空一格，箭头才能显现，否则就无法实现双向的跳转。 Reference","categories":[{"name":"MarkDown","slug":"MarkDown","permalink":"http://justskim.github.io/categories/MarkDown/"},{"name":"typora的特殊使用","slug":"MarkDown/typora的特殊使用","permalink":"http://justskim.github.io/categories/MarkDown/typora%E7%9A%84%E7%89%B9%E6%AE%8A%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://justskim.github.io/tags/markdown/"},{"name":"typora","slug":"typora","permalink":"http://justskim.github.io/tags/typora/"}]},{"title":"PYQT5介绍","slug":"PYQT5介绍","date":"2021-08-29T14:29:42.423Z","updated":"2021-08-29T14:29:42.423Z","comments":true,"path":"2021/08/29/PYQT5介绍/","link":"","permalink":"http://justskim.github.io/2021/08/29/PYQT5%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"PYQT5介绍PyQt5 是Digia的一套Qt5应用框架与python的结合，同时支持2.x和3.x。Qt库由Riverbank Computing开发，是最强大的GUI库之一 ，官方网站：https://riverbankcomputing.com/PyQt5是由一系列Python模块组成。超过620个类，6000函数和方法。能在诸如Unix、Windows和Mac OS等主流操作系统上运行。PyQt5有两种证书，GPL和商业证书。 PYQT和QTPyQt的介绍，以及其与Qt的不同，可见官网此页 Qt是一组c++库和开发工具，包括图形用户界面，网络，线程，正则表达式，SQL数据库，SVG, OpenGL, XML，用户和应用程序设置，定位和定位服务，短程通信(NFC和蓝牙)，web浏览，3D动画，图表、3D数据可视化以及与应用商店的交互。PyQt5作为一组Python模块实现了超过1000个这样的类。 PyQt5是一组来自Qt公司的用于Qt应用程序框架v5的Python绑定，由PyQt5本身和许多与Qt的附加库相对应的附加组件组成。每一个都提供了一个源代码发行版(sdist)和用于Windows、Linux和macOS的二进制轮。PyQt5支持Windows、Linux、UNIX、Android、macOS和iOS平台，需要Python v3.5或更高版本。(PyQt5还应该使用遗留的configure.py构建脚本在Python v2.7和Python v3的早期版本上构建，但这是不支持的。) PYQT的类别Pyqt的类别分为以下几个模块： QtCore:包含了核心的非GUI功能。此模块用于处理时间、文件和目录、各种数据类型、流、URL、MIME类型、线程或进程。 QtGui包含类窗口系统集成、事件处理、二维图形、基本成像、字体和文本。 QtWidgets模块包含创造经典桌面风格的用户界面提供了一套UI元素的类。 QtMultimedia包含的类来处理多媒体内容和API来访问相机和收音机的功能。 Qtbluetooth模块包含类的扫描设备和连接并与他们互动。描述模块包含了网络编程的类。这些类便于TCP和IP和UDP客户端和服务器的编码，使网络编程更容易和更便携。 Qtpositioning包含类的利用各种可能的来源，确定位置，包括卫星、Wi-Fi、或一个文本文件。 Enginio模块实现了客户端库访问Qt云服务托管的应用程序运行时。 Qtwebsockets模块包含实现WebSocket协议类。 QtWebKit包含一个基于Webkit2图书馆Web浏览器实现类。 QtWebkitwidgets包含的类的基础webkit1一用于qtwidgets应用Web浏览器的实现。 QtXml包含与XML文件的类。这个模块为SAX和DOM API提供了实现。 QtSvg模块提供了显示SVG文件内容的类。可伸缩矢量图形（SVG）是一种描述二维图形和图形应用的语言。 QtSql模块提供操作数据库的类。 QtTest包含的功能，使pyqt5应用程序的单元测试 Pyqt5与Pyside2这里有一篇英文文章讲述了这两个package之间的区别。简单地说，Pyqt的使用历史比较长，目前中文方面的资料也比较多，Pyside是后续由原先参与Pyqt项目的公司推出的，二者在使用协议方面由不同。在文档方面，Pyqt5与Pyside2大部分函数的构造都相同，详情可见以下网址：PyQt5官方文档Pyside2官方文档 安装与配置12345pip install pyqt5#使用pip下载该packagepip install pyqt5-tools#由于Qt Designer已经在Python3.5版本从PyQt5转移到了tools，因此我们还需要安装pyqt5-tools 验证是否成功安装qt designer是PyQt程序UI界面的实现工具，使用Qt Designer可以拖拽、点击完成GUI界面设计，并且设计完成的.ui程序可以转换成.py文件供python程序调用。Qt Designer的设计符合MVC的架构，其实现了视图和逻辑的分离，从而实现了开发的便捷。Qt Designer中的操作方式十分灵活，其通过拖拽的方式放置控件可以随时查看控件效果。Qt Designer生成的.ui文件（实质上是XML格式的文件）也可以通过pyuic5工具转换成.py文件。 同时按下win+s键，在cornata 中输入designer，可以定位到qt designer程序的地址，成功启动该程序，则说明PyQt5已经被安装。 另一种方法：在控制台中输入pyuic5，若返回信息为：Error: one input ui-file must be specified，说明 PyQt5已经被成功安装。","categories":[{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"},{"name":"Python3","slug":"Programming-languages-and-projects/Python3","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"},{"name":"PYQT5","slug":"Programming-languages-and-projects/Python3/PYQT5","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/PYQT5/"}],"tags":[{"name":"python3","slug":"python3","permalink":"http://justskim.github.io/tags/python3/"},{"name":"gui","slug":"gui","permalink":"http://justskim.github.io/tags/gui/"}]}],"categories":[{"name":"Linux","slug":"Linux","permalink":"http://justskim.github.io/categories/Linux/"},{"name":"Java","slug":"Java","permalink":"http://justskim.github.io/categories/Java/"},{"name":"Maven","slug":"Java/Maven","permalink":"http://justskim.github.io/categories/Java/Maven/"},{"name":"机器学习","slug":"机器学习","permalink":"http://justskim.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Servlet","slug":"Java/Servlet","permalink":"http://justskim.github.io/categories/Java/Servlet/"},{"name":"Diary","slug":"Diary","permalink":"http://justskim.github.io/categories/Diary/"},{"name":"Latex","slug":"Latex","permalink":"http://justskim.github.io/categories/Latex/"},{"name":"Programming languages and projects","slug":"Programming-languages-and-projects","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/"},{"name":"知识图谱","slug":"知识图谱","permalink":"http://justskim.github.io/categories/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"},{"name":"Python3","slug":"Programming-languages-and-projects/Python3","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/"},{"name":"Eclipse","slug":"Java/Eclipse","permalink":"http://justskim.github.io/categories/Java/Eclipse/"},{"name":"Windows","slug":"Windows","permalink":"http://justskim.github.io/categories/Windows/"},{"name":"服务器","slug":"服务器","permalink":"http://justskim.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Tomcat","slug":"服务器/Tomcat","permalink":"http://justskim.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Tomcat/"},{"name":"网络","slug":"网络","permalink":"http://justskim.github.io/categories/%E7%BD%91%E7%BB%9C/"},{"name":"Mysql","slug":"Mysql","permalink":"http://justskim.github.io/categories/Mysql/"},{"name":"安装","slug":"Mysql/安装","permalink":"http://justskim.github.io/categories/Mysql/%E5%AE%89%E8%A3%85/"},{"name":"服务器","slug":"网络/服务器","permalink":"http://justskim.github.io/categories/%E7%BD%91%E7%BB%9C/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"JavaScript","slug":"Programming-languages-and-projects/JavaScript","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/JavaScript/"},{"name":"Vue","slug":"Programming-languages-and-projects/JavaScript/Vue","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/JavaScript/Vue/"},{"name":"Git","slug":"Git","permalink":"http://justskim.github.io/categories/Git/"},{"name":"Github","slug":"Git/Github","permalink":"http://justskim.github.io/categories/Git/Github/"},{"name":"Data analysis","slug":"Data-analysis","permalink":"http://justskim.github.io/categories/Data-analysis/"},{"name":"web","slug":"Programming-languages-and-projects/JavaScript/web","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/JavaScript/web/"},{"name":"MarkDown","slug":"MarkDown","permalink":"http://justskim.github.io/categories/MarkDown/"},{"name":"typora的特殊使用","slug":"MarkDown/typora的特殊使用","permalink":"http://justskim.github.io/categories/MarkDown/typora%E7%9A%84%E7%89%B9%E6%AE%8A%E4%BD%BF%E7%94%A8/"},{"name":"Nodejs","slug":"Programming-languages-and-projects/JavaScript/Nodejs","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/JavaScript/Nodejs/"},{"name":"Git报错处理","slug":"Git/Git报错处理","permalink":"http://justskim.github.io/categories/Git/Git%E6%8A%A5%E9%94%99%E5%A4%84%E7%90%86/"},{"name":"PYQT5","slug":"Programming-languages-and-projects/Python3/PYQT5","permalink":"http://justskim.github.io/categories/Programming-languages-and-projects/Python3/PYQT5/"},{"name":"life","slug":"Diary/life","permalink":"http://justskim.github.io/categories/Diary/life/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://justskim.github.io/tags/linux/"},{"name":"java","slug":"java","permalink":"http://justskim.github.io/tags/java/"},{"name":"tomcat","slug":"tomcat","permalink":"http://justskim.github.io/tags/tomcat/"},{"name":"servlet","slug":"servlet","permalink":"http://justskim.github.io/tags/servlet/"},{"name":"maven","slug":"maven","permalink":"http://justskim.github.io/tags/maven/"},{"name":"IDEA","slug":"IDEA","permalink":"http://justskim.github.io/tags/IDEA/"},{"name":"python","slug":"python","permalink":"http://justskim.github.io/tags/python/"},{"name":"machine learning","slug":"machine-learning","permalink":"http://justskim.github.io/tags/machine-learning/"},{"name":"服务器","slug":"服务器","permalink":"http://justskim.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"life","slug":"life","permalink":"http://justskim.github.io/tags/life/"},{"name":"latex","slug":"latex","permalink":"http://justskim.github.io/tags/latex/"},{"name":"javascript","slug":"javascript","permalink":"http://justskim.github.io/tags/javascript/"},{"name":"知识图谱","slug":"知识图谱","permalink":"http://justskim.github.io/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"},{"name":"visual studio code","slug":"visual-studio-code","permalink":"http://justskim.github.io/tags/visual-studio-code/"},{"name":"eclipse","slug":"eclipse","permalink":"http://justskim.github.io/tags/eclipse/"},{"name":"windows","slug":"windows","permalink":"http://justskim.github.io/tags/windows/"},{"name":"网络","slug":"网络","permalink":"http://justskim.github.io/tags/%E7%BD%91%E7%BB%9C/"},{"name":"nginx","slug":"nginx","permalink":"http://justskim.github.io/tags/nginx/"},{"name":"apache","slug":"apache","permalink":"http://justskim.github.io/tags/apache/"},{"name":"mysql","slug":"mysql","permalink":"http://justskim.github.io/tags/mysql/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://justskim.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://justskim.github.io/tags/ubuntu/"},{"name":"vmware","slug":"vmware","permalink":"http://justskim.github.io/tags/vmware/"},{"name":"python3","slug":"python3","permalink":"http://justskim.github.io/tags/python3/"},{"name":"anaconda","slug":"anaconda","permalink":"http://justskim.github.io/tags/anaconda/"},{"name":"c语言","slug":"c语言","permalink":"http://justskim.github.io/tags/c%E8%AF%AD%E8%A8%80/"},{"name":"进程","slug":"进程","permalink":"http://justskim.github.io/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"vue","slug":"vue","permalink":"http://justskim.github.io/tags/vue/"},{"name":"vue-cli","slug":"vue-cli","permalink":"http://justskim.github.io/tags/vue-cli/"},{"name":"webpack","slug":"webpack","permalink":"http://justskim.github.io/tags/webpack/"},{"name":"store","slug":"store","permalink":"http://justskim.github.io/tags/store/"},{"name":"router","slug":"router","permalink":"http://justskim.github.io/tags/router/"},{"name":"安全证书","slug":"安全证书","permalink":"http://justskim.github.io/tags/%E5%AE%89%E5%85%A8%E8%AF%81%E4%B9%A6/"},{"name":"数据分析","slug":"数据分析","permalink":"http://justskim.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"debug","slug":"debug","permalink":"http://justskim.github.io/tags/debug/"},{"name":"package","slug":"package","permalink":"http://justskim.github.io/tags/package/"},{"name":"scipy","slug":"scipy","permalink":"http://justskim.github.io/tags/scipy/"},{"name":"browser","slug":"browser","permalink":"http://justskim.github.io/tags/browser/"},{"name":"web","slug":"web","permalink":"http://justskim.github.io/tags/web/"},{"name":"markdown","slug":"markdown","permalink":"http://justskim.github.io/tags/markdown/"},{"name":"typora","slug":"typora","permalink":"http://justskim.github.io/tags/typora/"},{"name":"hexo","slug":"hexo","permalink":"http://justskim.github.io/tags/hexo/"},{"name":"数据存储","slug":"数据存储","permalink":"http://justskim.github.io/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"},{"name":"ejs","slug":"ejs","permalink":"http://justskim.github.io/tags/ejs/"},{"name":"express","slug":"express","permalink":"http://justskim.github.io/tags/express/"},{"name":"nodejs","slug":"nodejs","permalink":"http://justskim.github.io/tags/nodejs/"},{"name":"git","slug":"git","permalink":"http://justskim.github.io/tags/git/"},{"name":"http","slug":"http","permalink":"http://justskim.github.io/tags/http/"},{"name":"gui","slug":"gui","permalink":"http://justskim.github.io/tags/gui/"}]}