<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://justskim.github.io.git/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="JustSkim">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://JustSkim.github.io.git"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-win10上的代理服务器设置与127.0.0.1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/02/08/win10%E4%B8%8A%E7%9A%84%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE%E4%B8%8E127.0.0.1/" class="article-date">
  <time class="dt-published" datetime="2022-02-08T06:02:05.413Z" itemprop="datePublished">2022-02-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/02/08/win10%E4%B8%8A%E7%9A%84%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE%E4%B8%8E127.0.0.1/">win10上的代理服务器设置与127.0.0.1</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="win10上的代理服务器设置与127-0-0-1"><a href="#win10上的代理服务器设置与127-0-0-1" class="headerlink" title="win10上的代理服务器设置与127.0.0.1"></a>win10上的代理服务器设置与127.0.0.1</h1><h2 id="代理服务器的定义"><a href="#代理服务器的定义" class="headerlink" title="代理服务器的定义"></a>代理服务器的定义</h2><p>代理服务器（Proxy Server）是介于浏览器和Web服务器之间的一台服务器，可被用于代理网络用户去取得网络信息。可以说，代理服务器是网络信息的中转站，是个人网络和Internet服务商之间的中间代理机构，负责转发合法的网络信息，对转发进行控制和登记，工作在OSI模型的对话层。当你通过代理服务器上网浏览时，浏览器不是直接到Web服务器去取回网页，而是向代理服务器发出请求，由代理服务器来取回浏览器所需要的信息，并传送给你的浏览器。 </p>
<p>Win10系统提供<strong>系统级代理服务器设置，通过在Win10系统中设置代理服务器</strong>，系统中所有的软件都会通过我们设置的代理服务器访问网络，这样就不用一个一个软件设置代理服务器了，包括浏览器等应用，都会使用设定的系统代理服务器上网。</p>
<h2 id="环回地址127-0-0-1"><a href="#环回地址127-0-0-1" class="headerlink" title="环回地址127.0.0.1"></a>环回地址127.0.0.1</h2><p>127.0.0.1是回送地址主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，协议软件立即返回之，不进行任何网络传输。有时候当我们使用浏览器点击网页时，有时候会发现提示网页无法找到，建议我们检查代理服务器设置。而在win10系统的设置一栏，有一项“代理服务器”的设置，有时我们点开这里，会发现代理服务器被设置为127.0.0.1，原因不明，但将代理服务器关闭即可正常访问网络，检查host文件也没有发现异常。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://justskim.github.io.git/2022/02/08/win10%E4%B8%8A%E7%9A%84%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE%E4%B8%8E127.0.0.1/" data-id="ckzds3a8e0000d8ud2gt94hvm" data-title="win10上的代理服务器设置与127.0.0.1" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ubuntu/" rel="tag">ubuntu</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vmware/" rel="tag">vmware</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag">虚拟机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-在vmware虚拟机中进行网络连接" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/11/16/%E5%9C%A8vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5/" class="article-date">
  <time class="dt-published" datetime="2021-11-16T07:16:40.924Z" itemprop="datePublished">2021-11-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/11/16/%E5%9C%A8vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5/">在vmware虚拟机中进行网络连接</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="在vmware虚拟机中进行网络连接"><a href="#在vmware虚拟机中进行网络连接" class="headerlink" title="在vmware虚拟机中进行网络连接"></a>在<code>vmware</code>虚拟机中进行网络连接</h1><h2 id="四种网络模式"><a href="#四种网络模式" class="headerlink" title="四种网络模式"></a>四种网络模式</h2><p>点击<code>VMware Workstation</code>的导航栏，在“虚拟机-&gt;设置-&gt;硬件-&gt;网络设配器”中，可看到网络连接模式的选择（不能在虚拟机挂起的时候进行更改），<a target="_blank" rel="noopener" href="https://docs.vmware.com/cn/VMware-Workstation-Pro/14.0/com.vmware.ws.using.doc/GUID-3B504F2F-7A0B-415F-AE01-62363A95D052.html">VMware的官方网站</a>中说明了四种网络模式的区别：</p>
<table>
<thead>
<tr>
<th align="left">设置</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>使用桥接模式网络连接</strong></td>
<td align="left">为虚拟机配置桥接模式网络连接。使用桥接模式网络连接时，虚拟机将具有直接访问外部以太网网络的权限。虚拟机必须在外部网络中具有自己的 IP 地址。如果您的主机系统位于网络中，而且您拥有可用于虚拟机的单独 IP 地址（或者可以从 DHCP 服务器获得 IP 地址），请选择此设置。网络中的其他计算机将能够与该虚拟机直接通信。</td>
</tr>
<tr>
<td align="left"><strong>使用网络地址转换 (NAT)</strong></td>
<td align="left">为虚拟机配置 NAT 连接。利用 NAT，虚拟机和主机系统将共享一个网络标识，此标识在网络以外不可见。如果您没有可用于虚拟机的单独 IP 地址，但又希望能够连接到 Internet，请选择 NAT。</td>
</tr>
<tr>
<td align="left"><strong>使用仅主机模式网络连接</strong></td>
<td align="left">为虚拟机配置仅主机模式网络连接。仅主机模式网络连接使用对主机操作系统可见的虚拟网络适配器，在虚拟机和主机系统之间提供网络连接。使用仅主机模式网络连接时，虚拟机只能与主机系统以及仅主机模式网络中的其他虚拟机进行通信。要设置独立的虚拟网络，请选择仅主机模式网络连接。</td>
</tr>
<tr>
<td align="left"><strong>不使用网络连接</strong></td>
<td align="left">不为虚拟机配置网络连接。</td>
</tr>
<tr>
<td align="left"><strong>自定义</strong>（Windows 主机）或<strong>已命名的网络</strong>（Linux 主机）</td>
<td align="left">（仅限远程虚拟机）选择特定虚拟网络。从下拉菜单中选择一个自定义网络。尽管列表中有 <code>VMnet0</code>、<code>VMnet1 </code>和 <code>VMnet8</code>，但这些网络通常被用于桥接模式、仅主机模式和 NAT 模式网络。</td>
</tr>
</tbody></table>
<p>对于使用校园网或者公司网络的用户，NAT是最简单的方式。</p>
<h2 id="网络配置相关文件"><a href="#网络配置相关文件" class="headerlink" title="网络配置相关文件"></a>网络配置相关文件</h2><p><strong>eth0</strong></p>
<p>该文件一般位于路径“/etc/sysconfig/network-scripts”中</p>
<h2 id="网络配置相关命令"><a href="#网络配置相关命令" class="headerlink" title="网络配置相关命令"></a>网络配置相关命令</h2><p><strong><code>ifconfig</code></strong></p>
<p><strong>用于配置网卡的基本命令</strong>，注意不是<code>ipconfig</code>！<code>ifconfig</code>命令的英文全称是“network interfaces configuring”，即用于配置和显示Linux内核中网络接口的网络参数。用<code>ifconfig</code>命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。要想将上述的配置信息永远的存的电脑里，那就要修改网卡的配置文件了。</p>
<p><strong>常用参数：</strong></p>
<table>
<thead>
<tr>
<th>add &lt;地址&gt;</th>
<th>设置网络设备IPv6的IP地址</th>
</tr>
</thead>
<tbody><tr>
<td><code>del</code> &lt;地址&gt;</td>
<td>删除网络设备IPv6的IP地址</td>
</tr>
<tr>
<td>down</td>
<td>关闭指定的网络设备</td>
</tr>
<tr>
<td>up</td>
<td>启动指定的网络设备</td>
</tr>
<tr>
<td>IP地址</td>
<td>指定网络设备的IP地址</td>
</tr>
</tbody></table>
<p>一个与之相似的命令是windows系统下的<code>ipconfig</code>命令</p>
<p><strong>ethtool</strong></p>
<p>用于查询ethX网口基本设置、及设置网卡的参数</p>
<h2 id="以上步骤尝试过后，依然无法解决联网问题"><a href="#以上步骤尝试过后，依然无法解决联网问题" class="headerlink" title="以上步骤尝试过后，依然无法解决联网问题"></a>以上步骤尝试过后，依然无法解决联网问题</h2><p>如果在以上步骤尝试过后，依然无法解决联网问题，特别是最简单的NAT模式下，可以查看相关端口是否被杀毒软件禁止，以及服务是否成功启动。笔者在实际操作中遇到过这种情况，最后，根据<a target="_blank" rel="noopener" href="https://www.cnblogs.com/hi3254014978/p/12668471.html">这篇博客</a>，将win10中的服务打开，手动启动或者重新启动<code>VMware DHCP Service</code>和<code>VMware NAT Service</code>两个服务即可。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://justskim.github.io.git/2021/11/16/%E5%9C%A8vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5/" data-id="ckzcw3wz3000croudhakaanjn" data-title="在vmware虚拟机中进行网络连接" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ubuntu/" rel="tag">ubuntu</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vmware/" rel="tag">vmware</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag">虚拟机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-python3中的运行命令与环境" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/11/09/python3%E4%B8%AD%E7%9A%84%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4%E4%B8%8E%E7%8E%AF%E5%A2%83/" class="article-date">
  <time class="dt-published" datetime="2021-11-08T18:35:42.058Z" itemprop="datePublished">2021-11-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Programming-languages-and-projects/">Programming languages and projects</a>►<a class="article-category-link" href="/categories/Programming-languages-and-projects/Python3/">Python3</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/11/09/python3%E4%B8%AD%E7%9A%84%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4%E4%B8%8E%E7%8E%AF%E5%A2%83/">python3中的运行命令与环境</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="python3中的运行命令与环境"><a href="#python3中的运行命令与环境" class="headerlink" title="python3中的运行命令与环境"></a>python3中的运行命令与环境</h1><p>本机电脑仅安装python3，以下使用的均为python3环境配置</p>
<h2 id="镜像是什么？"><a href="#镜像是什么？" class="headerlink" title="镜像是什么？"></a>镜像是什么？</h2><p>镜像（Mirroring）是一种文件存储形式，是冗余的一种类型，一个磁盘上的数据在另一个磁盘上存在一个完全相同的副本即为镜像。</p>
<p>镜像源 就是把官<strong>方的源做一个镜像，你</strong>可以在这下载软件。 比如ubuntu官方源在国外，下载软件可能会很慢，这时候就需要换成国内的镜像源。 源 端口就是指本地端口 目的端口就是远程端口 一个数据包（pocket）被解封装成数据段（segment）后就会涉及到 连接上层协议的端口问题。</p>
<p>镜像网站（Mirror sites）又称之为镜像站点</p>
<h2 id="anaconda环境"><a href="#anaconda环境" class="headerlink" title="anaconda环境"></a>anaconda环境</h2><h2 id="命令行运行python程序，与idle中”Run-module“的区别"><a href="#命令行运行python程序，与idle中”Run-module“的区别" class="headerlink" title="命令行运行python程序，与idle中”Run module“的区别"></a>命令行运行python程序，与idle中”Run module“的区别</h2><p>笔者在学习<a target="_blank" rel="noopener" href="https://gitee.com/daochenzha/rlcard?_from=gitee_search#/daochenzha/rlcard/blob/master/docs/toy-examples.md#playing-with-random-agents">RLCard——一款卡牌游戏强化学习工具包</a>的时候，发现了<a target="_blank" rel="noopener" href="https://gitee.com/daochenzha/rlcard/blob/master/docs/toy-examples.md#playing-with-random-agents">范例</a>中的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> rlcard</span><br><span class="line"><span class="keyword">from</span> rlcard.agents <span class="keyword">import</span> RandomAgent</span><br><span class="line"><span class="keyword">from</span> rlcard.utils <span class="keyword">import</span> set_seed</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">args</span>):</span></span><br><span class="line">    <span class="comment"># Make environment</span></span><br><span class="line">    env = rlcard.make(args.env, config=&#123;<span class="string">&#x27;seed&#x27;</span>: <span class="number">42</span>&#125;)</span><br><span class="line">    num_episodes = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Seed numpy, torch, random</span></span><br><span class="line">    set_seed(<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set agents</span></span><br><span class="line">    agent = RandomAgent(num_actions=env.num_actions)</span><br><span class="line">    env.set_agents([agent <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(env.num_players)])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> episode <span class="keyword">in</span> <span class="built_in">range</span>(num_episodes):</span><br><span class="line">        <span class="comment"># Generate data from the environment</span></span><br><span class="line">        trajectories, player_wins = env.run(is_training=<span class="literal">False</span>)</span><br><span class="line">        <span class="comment"># Print out the trajectories</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\nEpisode &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(episode))</span><br><span class="line">        <span class="built_in">print</span>(trajectories)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    parser = argparse.ArgumentParser(<span class="string">&quot;Random example in RLCard&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--env&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;leduc-holdem&#x27;</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    run(args)</span><br></pre></td></tr></table></figure>

<p>这段代码在idle中无法被“Run module”运行，却可以在命令行中运行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在idle中无法被“Run module”运行</span></span><br><span class="line">============== RESTART: E:/python练习/RLCard/examples/run_random.py ==============</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;E:/python练习/RLCard/examples/run_random.py&quot;</span>, line <span class="number">4</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">from</span> rlcard.agents <span class="keyword">import</span> RandomAgent</span><br><span class="line">  File <span class="string">&quot;E:\python\lib\site-packages\rlcard\agents\__init__.py&quot;</span>, line <span class="number">5</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    reqs = subprocess.check_output([sys.executable, <span class="string">&#x27;-m&#x27;</span>, <span class="string">&#x27;pip&#x27;</span>, <span class="string">&#x27;freeze&#x27;</span>])</span><br><span class="line">  File <span class="string">&quot;E:\python\lib\subprocess.py&quot;</span>, line <span class="number">424</span>, <span class="keyword">in</span> check_output</span><br><span class="line">    <span class="keyword">return</span> run(*popenargs, stdout=PIPE, timeout=timeout, check=<span class="literal">True</span>,</span><br><span class="line">  File <span class="string">&quot;E:\python\lib\subprocess.py&quot;</span>, line <span class="number">528</span>, <span class="keyword">in</span> run</span><br><span class="line">    <span class="keyword">raise</span> CalledProcessError(retcode, process.args,</span><br><span class="line">subprocess.CalledProcessError: Command <span class="string">&#x27;[&#x27;</span>E:\\python\\pythonw.exe<span class="string">&#x27;, &#x27;</span>-m<span class="string">&#x27;, &#x27;</span>pip<span class="string">&#x27;, &#x27;</span>freeze<span class="string">&#x27;]&#x27;</span> returned non-zero exit status <span class="number">120.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#可以在命令行中运行</span></span><br><span class="line">$ python examples/run_random.py</span><br><span class="line">WARNING: Ignoring invalid distribution -ip (e:\python\lib\site-packages)</span><br><span class="line">WARNING: Ignoring invalid distribution -ip (e:\python\lib\site-packages)</span><br><span class="line"></span><br><span class="line">Episode <span class="number">0</span></span><br><span class="line">[[&#123;<span class="string">&#x27;legal_actions&#x27;</span>: OrderedDict([(<span class="number">1</span>, <span class="literal">None</span>), (<span class="number">2</span>, <span class="literal">None</span>), (<span class="number">3</span>, <span class="literal">None</span>)]), <span class="string">&#x27;obs&#x27;</span>: array([<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>,</span><br><span class="line">       <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>,</span><br><span class="line">       <span class="number">0.</span>, <span class="number">0.</span>]), <span class="string">&#x27;raw_obs&#x27;</span>: &#123;<span class="string">&#x27;hand&#x27;</span>: <span class="string">&#x27;HQ&#x27;</span>, <span class="string">&#x27;public_card&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;all_chips&#x27;</span>: [<span class="number">2</span>, <span class="number">1</span>], <span class="string">&#x27;my_chips&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;legal_actions&#x27;</span>: [<span class="string">&#x27;raise&#x27;</span>, <span class="string">&#x27;fold&#x27;</span>, <span class="string">&#x27;check&#x27;</span>], <span class="string">&#x27;current_player&#x27;</span>: <span class="number">0</span>&#125;, <span class="string">&#x27;raw_legal_actions&#x27;</span>: [<span class="string">&#x27;raise&#x27;</span>, <span class="string">&#x27;fold&#x27;</span>, <span class="string">&#x27;check&#x27;</span>], <span class="string">&#x27;action_record&#x27;</span>: [(<span class="number">1</span>, <span class="string">&#x27;fold&#x27;</span>)]&#125;], [&#123;<span class="string">&#x27;legal_actions&#x27;</span>: OrderedDict([(<span class="number">0</span>, <span class="literal">None</span>), (<span class="number">1</span>, <span class="literal">None</span>), (<span class="number">2</span>, <span class="literal">None</span>)]), <span class="string">&#x27;obs&#x27;</span>: array([<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>,</span><br><span class="line">       <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>,</span><br><span class="line">       <span class="number">0.</span>, <span class="number">0.</span>]), <span class="string">&#x27;raw_obs&#x27;</span>: &#123;<span class="string">&#x27;hand&#x27;</span>: <span class="string">&#x27;HJ&#x27;</span>, <span class="string">&#x27;public_card&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;all_chips&#x27;</span>: [<span class="number">2</span>, <span class="number">1</span>], <span class="string">&#x27;my_chips&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;legal_actions&#x27;</span>: [<span class="string">&#x27;call&#x27;</span>, <span class="string">&#x27;raise&#x27;</span>, <span class="string">&#x27;fold&#x27;</span>], <span class="string">&#x27;current_player&#x27;</span>: <span class="number">1</span>&#125;, <span class="string">&#x27;raw_legal_actions&#x27;</span>: [<span class="string">&#x27;call&#x27;</span>, <span class="string">&#x27;raise&#x27;</span>, <span class="string">&#x27;fold&#x27;</span>], <span class="string">&#x27;action_record&#x27;</span>: [(<span class="number">1</span>, <span class="string">&#x27;fold&#x27;</span>)]&#125;, <span class="number">2</span>, &#123;<span class="string">&#x27;legal_actions&#x27;</span>: OrderedDict([(<span class="number">1</span>, <span class="literal">None</span>), (<span class="number">2</span>, <span class="literal">None</span>), (<span class="number">3</span>, <span class="literal">None</span>)]), <span class="string">&#x27;obs&#x27;</span>: array([<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>,</span><br><span class="line">       <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>,</span><br><span class="line">       <span class="number">0.</span>, <span class="number">0.</span>]), <span class="string">&#x27;raw_obs&#x27;</span>: &#123;<span class="string">&#x27;hand&#x27;</span>: <span class="string">&#x27;HJ&#x27;</span>, <span class="string">&#x27;public_card&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;all_chips&#x27;</span>: [<span class="number">2</span>, <span class="number">1</span>], <span class="string">&#x27;my_chips&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;legal_actions&#x27;</span>: [<span class="string">&#x27;raise&#x27;</span>, <span class="string">&#x27;fold&#x27;</span>, <span class="string">&#x27;check&#x27;</span>], <span class="string">&#x27;current_player&#x27;</span>: <span class="number">0</span>&#125;, <span class="string">&#x27;raw_legal_actions&#x27;</span>: [<span class="string">&#x27;raise&#x27;</span>, <span class="string">&#x27;fold&#x27;</span>, <span class="string">&#x27;check&#x27;</span>], <span class="string">&#x27;action_record&#x27;</span>: [(<span class="number">1</span>, <span class="string">&#x27;fold&#x27;</span>)]&#125;]]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们试着来比较这两个命令的差别：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/150835014">这篇博客中介绍了sys模块的使用详情</a>，我们只讲两个下面会使用到的函数，</p>
<p><em>sys模块</em>提供了一系列有关<em>Python</em>运行环境的变量和函数，</p>
<p>sys.path<br>返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值</p>
<h3 id="sys-executable"><a href="#sys-executable" class="headerlink" title="sys.executable"></a><strong>sys.executable</strong></h3><p>该属性是一个字符串，在正常情况下，其值是当前运行的 Python 解释器对应的可执行程序所在的绝对路径。</p>
<p>比如在 Windows 上使用 Anaconda 安装的 Python，该属性的值就是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.executable</span><br><span class="line"><span class="string">&#x27;E:\\Anaconda\\Anaconda\\python.exe&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="E:\JS练习\blog\Myblog\source\images\两个命令差别.png"></p>
<p>打印结果，我们可以发现二者的绝对路径不一样，在Idle中，python解释器对应的可执行程序为pythonw.exe，而在命令行中则是python.exe</p>
<p><strong>python.exe与pythonw.exe</strong></p>
<p>Windows系统搭建好Python的环境后，进入Python的安装目录，大家会发现目录中有python.exe和pythonw.exe两个程序。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/302384158">这两个程序的区别在于</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a）、python.exe在运行程序的时候，会弹出一个黑色的控制台窗口（也叫命令行窗口、DOS/CMD窗口）；</span><br><span class="line">   b）、pythonw.exe是无窗口的Python可执行程序，意思是在运行程序的时候，没有窗口，代码在后台执行</span><br><span class="line">   .py和.pyw文件的区别也来源于python.exe和pythonw.exe的区别：</span><br><span class="line">   安装视窗版 Python 时，扩展名为 .py 的文件被默认为用 python.exe 运行的文件，而 .pyw文件则被默认为用 pythonw.exe 运行。</span><br><span class="line">这里还要解释一个问题，如果.py文件直接用python.exe打开，文件被执行完成之后，视窗会立即关闭，如果想让视窗停留；给大家提供两个方法：		</span><br><span class="line">① 可以在程序中import time模块，加入超长睡眠语句，如time.sleep(1800)，如果你不手动关闭视窗，视窗将会停留30min；		</span><br><span class="line">② 可以调用sys和os模块，使用命令行语句pause</span><br><span class="line"></span><br><span class="line">  3、.pyw格式是被设计用来运行开发的纯图形界面程序的，纯图形界面程序的用户不需要看到控制台窗口。</span><br><span class="line">    在开发纯图形界面程序的时候，可以暂时把 .pyw 改成 .py ，运行时能调出控制台窗口，方便看到所有错误信息。</span><br><span class="line">    至于.pyc文件，是Python解释器运行程序的过程中产生的字节码文件（也就是中间文件）。</span><br></pre></td></tr></table></figure>

<p>总之，我们尽可能地使用命令行来执行.py格式程序。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://justskim.github.io.git/2021/11/09/python3%E4%B8%AD%E7%9A%84%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4%E4%B8%8E%E7%8E%AF%E5%A2%83/" data-id="ckzcw3wys0006roud8yvl1kyi" data-title="python3中的运行命令与环境" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/anaconda/" rel="tag">anaconda</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python3/" rel="tag">python3</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-python3中的生成器与迭代器" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/11/03/python3%E4%B8%AD%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/" class="article-date">
  <time class="dt-published" datetime="2021-11-03T01:55:18.115Z" itemprop="datePublished">2021-11-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Programming-languages-and-projects/">Programming languages and projects</a>►<a class="article-category-link" href="/categories/Programming-languages-and-projects/Python3/">Python3</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/11/03/python3%E4%B8%AD%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/">python3中的生成器与迭代器</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="python3中的生成器与迭代器"><a href="#python3中的生成器与迭代器" class="headerlink" title="python3中的生成器与迭代器"></a>python3中的生成器与迭代器</h1><h2 id="生成器与迭代器"><a href="#生成器与迭代器" class="headerlink" title="生成器与迭代器"></a>生成器与迭代器</h2><p>在Python社区，生成器和迭代器被看作一种工具，生成器的本质就是迭代器。唯一的区别就是生成器是开发人员自己用Python代码构建的数据结构，而迭代器是Python内置提供或转化而来的。</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器是一种对象，该对象包含值的可计数数字。</p>
<p>迭代器是可迭代的对象，这意味着您可以遍历所有值。</p>
<p>从技术上讲，在 Python 中，迭代器是实现迭代器协议的对象，它包含方法<code>__iter__()</code>和 <code>__next__()</code>。<br>要把对象/类创建为迭代器，必须为对象实现<code> __iter__()</code> 和 <code>__next__()</code> 方法。</p>
<p>正如您在 Python 类/对象 一章中学到的，所有类都有名为 <code>__init__()</code> 的函数，它允许您在创建对象时进行一些初始化。</p>
<p><code>__iter__()</code>方法的作用相似，您可以执行操作（初始化等），但必须始终返回迭代器对象本身。</p>
<p><code>__next__()</code>方法也允许您执行操作，并且必须返回序列中的下一个项目。</p>
<h3 id="可迭代对象（Iterable）"><a href="#可迭代对象（Iterable）" class="headerlink" title="可迭代对象（Iterable）"></a>可迭代对象（Iterable）</h3><p>列表、元组、字典和集合、字符串都是可迭代的对象。它们是可迭代的容器，您可以从中获取迭代器（Iterator）。</p>
<p>所有这些对象都有用于获取迭代器的 iter() 方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mytuple = (<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>)</span><br><span class="line">myit = <span class="built_in">iter</span>(mytuple)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myit))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myit))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myit))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mytuple = (<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myit=<span class="built_in">iter</span>(mytuple)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(myit))</span><br><span class="line">apple</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(myit))</span><br><span class="line">banana</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(myit))</span><br><span class="line">cherry</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mytuple1=<span class="string">&quot;banana&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myit1=<span class="built_in">iter</span>(mytuple1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(myit))</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#54&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(myit))</span><br><span class="line">StopIteration				<span class="comment">#序列的所有项目都被迭代过，因此迭代（iteration）停止，报错</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(myit1))</span><br><span class="line">b</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(myit1))</span><br><span class="line">a</span><br></pre></td></tr></table></figure>

<p>也可以使用 for 循环遍历可迭代对象</p>
<h3 id="StopIteration-异常的使用"><a href="#StopIteration-异常的使用" class="headerlink" title="StopIteration 异常的使用"></a><code>StopIteration</code> 异常的使用</h3><p><code>StopIteration</code>异常用于完成标识迭代，防止无限循环。</p>
<p><code>__next__()</code>函数完成指定循环次数后，会触发该异常结束迭代。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">it = <span class="built_in">iter</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        x = <span class="built_in">next</span>(it)</span><br><span class="line">        <span class="built_in">print</span>(x)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment">#如果不使用StopIteration，则会报错异常</span></span><br></pre></td></tr></table></figure>





<h3 id="将一个类当做迭代器使用"><a href="#将一个类当做迭代器使用" class="headerlink" title="将一个类当做迭代器使用"></a>将一个类当做迭代器使用</h3><p>把一个类作为一个迭代器使用需要在类中方法 <code>__iter__()0</code>与 <code>__next__()</code> 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNumbers</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">    x = self.a</span><br><span class="line">    self.a += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"> </span><br><span class="line">myclass = MyNumbers()</span><br><span class="line">myiter = <span class="built_in">iter</span>(myclass)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))<span class="comment">#1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))<span class="comment">#2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))<span class="comment">#3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))<span class="comment">#4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))<span class="comment">#5</span></span><br></pre></td></tr></table></figure>

<h2 id="python3生成器"><a href="#python3生成器" class="headerlink" title="python3生成器"></a><code>python3</code>生成器</h2><p>在 Python 中，使用了 yield 的函数被称为<strong>生成器（generator）</strong>。</p>
<p>跟普通函数不同的是，<strong>生成器</strong>是一个<strong>返回迭代器的函数</strong>，<strong>只能用于迭代操作</strong>，更简单点理解生成器就是一个迭代器。</p>
<p>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。</p>
<p>调用一个生成器函数，返回的是一个迭代器对象。</p>
<h3 id="yield关键字"><a href="#yield关键字" class="headerlink" title="yield关键字"></a>yield关键字</h3><p>我们先将yield看做return，执行下面的程序，看看结果如何？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;starting...&quot;</span>)</span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">		res=<span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;res:&quot;</span>,res)	</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g=foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br><span class="line">starting...</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line">********************</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br><span class="line">res: <span class="literal">None</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/mieleizhi0522/article/details/82142856">原文章</a>的博主对于执行顺序给出了以下解释：</p>
<blockquote>
<p>1.程序开始执行以后，因为<code>foo</code>函数中有yield关键字，所以<code>foo</code>函数并不会真的执行，而是先得到一个生成器g(相当于一个对象)</p>
<p>2.直到调用next方法，<code>foo</code>函数正式开始执行，先执行<code>foo</code>函数中的print方法，然后进入while循环</p>
<p>3.程序遇到yield关键字，然后把yield想象成return，return了一个4之后，程序停止，并没有执行赋值给res操作，此时next(g)语句执行完成，所以输出的前两行（第一行“starting…”是while上面的print的结果，第二行“4”是return出的结果）是执行print(next(g))的结果，<strong>注意并没有执行yield一句下一行的print(“res:”,res)语句</strong></p>
<p>4.程序执行print(“<code>*</code>“*20)，输出20个<code>*</code></p>
<p>5.又开始执行下面的<code>print(next(g))</code>，不同的是，这一次<strong>从刚才那个next程序停止的地方开始执行的</strong>，也就是要<strong>从yield语句的下一行语句开始</strong>，执行res的赋值操作，这时候要注意，这个时候赋值操作的右边是没有值的（因为刚才那个是return出去了，并没有给赋值操作的左边传参数），所以这个时候res赋值是None,所以接着下面的输出就是<code>res:None</code></p>
<p>6.程序会继续在while里执行，又一次碰到yield,这个时候同样return 出4，然后程序停止，print函数输出的4就是这次return出的4.</p>
</blockquote>
<p>带yield的函数是一个生成器，可以不再看做一个函数了。这个生成器有一个next函数，相当于“下一步”生成哪个数，<strong>这一次的next开始的地方是接着上一次的next停止的地方执行的</strong>，所以调用next的时候，生成器并不会从<code>foo</code>函数的开始执行，只是接着上一步停止的地方开始，然后遇到yield后，return出要生成的数，此步就结束。</p>
<p>我们接着上面的代码，继续输出next(g)，每一次的next开始的地方都是上一次的next停止的地方：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br><span class="line">res: <span class="literal">None</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(g))</span><br><span class="line">res: <span class="literal">None</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>也就是说，除了第一次next函数可能会特殊（循环体外的代码部分执行原因），<strong>每次我们使用next函数，都是从上一个yield停止的地方，开始跑代码，跑到下一个yield语句，return了值， 停止</strong>。下面的例子更加直观一些：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fo</span>(<span class="params">n</span>):</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;fo start!&quot;</span>)</span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:							<span class="comment">#注意，因为下一次next函数执行在循环体中开始，因此要再接一轮while判断，而不会执行循环体外面的上一行print(&quot;fo start&quot;)语句</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;before yield, n = &quot;</span>,n)</span><br><span class="line">		n = n + <span class="number">1</span></span><br><span class="line">		res = <span class="keyword">yield</span> n					<span class="comment">#跑到这里结束</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;after yield, n = &quot;</span>,n)	<span class="comment">#从这里开始</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = fo(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(x))</span><br><span class="line">fo start!</span><br><span class="line">before <span class="keyword">yield</span>, n =  <span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(x))</span><br><span class="line">after <span class="keyword">yield</span>, n =  <span class="number">2</span></span><br><span class="line">before <span class="keyword">yield</span>, n =  <span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(x))</span><br><span class="line">after <span class="keyword">yield</span>, n =  <span class="number">3</span></span><br><span class="line">before <span class="keyword">yield</span>, n =  <span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(x))</span><br><span class="line">after <span class="keyword">yield</span>, n =  <span class="number">4</span></span><br><span class="line">before <span class="keyword">yield</span>, n =  <span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">next</span>(x))</span><br><span class="line">after <span class="keyword">yield</span>, n =  <span class="number">5</span></span><br><span class="line">before <span class="keyword">yield</span>, n =  <span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="https://justskim.github.io.git/2021/11/03/python3%E4%B8%AD%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/" data-id="ckzcw3wz10008roudfpqlgcwx" data-title="python3中的生成器与迭代器" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python3/" rel="tag">python3</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-python3中的一些常见语法糖" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/10/31/python3%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E8%AF%AD%E6%B3%95%E7%B3%96/" class="article-date">
  <time class="dt-published" datetime="2021-10-31T12:02:01.432Z" itemprop="datePublished">2021-10-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Programming-languages-and-projects/">Programming languages and projects</a>►<a class="article-category-link" href="/categories/Programming-languages-and-projects/Python3/">Python3</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/10/31/python3%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E8%AF%AD%E6%B3%95%E7%B3%96/">python3中的一些常见语法糖整理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="python3中的一些常见语法糖整理"><a href="#python3中的一些常见语法糖整理" class="headerlink" title="python3中的一些常见语法糖整理"></a>python3中的一些常见语法糖整理</h1><h2 id="输入输出的类型提示"><a href="#输入输出的类型提示" class="headerlink" title="输入输出的类型提示"></a>输入输出的类型提示</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addBinary</span>(<span class="params">self, a: <span class="built_in">str</span>, b: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span></span><br></pre></td></tr></table></figure>

<p>学过C语言的同学，都懂得，参数中a，b要求为str类型的输入参数</p>
<p>在定义函数时，在def那一行后面会加一个-&gt;。这个玩意儿有个专门的名词叫 <strong>type hint， 即类型提示</strong>。这里就是说返回的数据类型为<code>str</code>。</p>
<p>在Python中，<code>str</code> 表示字符串类 ，也可以是将变量强制转换为字符串的函数，写作<code>str ()</code> </p>
<p><strong>类型标注</strong></p>
<ul>
<li><code>int</code>,<code>long</code>,<code>float</code>: 整型,长整形,浮点型</li>
<li><code>bool</code>,<code>str</code>: 布尔型，字符串类型</li>
<li><code>List</code>, <code>Tuple</code>, <code>Dict</code>, <code>Set</code>:列表，元组，字典, 集合</li>
<li><code>Iterable</code>,<code>Iterator</code>:可迭代类型，迭代器类型</li>
<li><code>Generator</code>：生成器类型</li>
</ul>
<h2 id="限定函数参数类型及输出"><a href="#限定函数参数类型及输出" class="headerlink" title="限定函数参数类型及输出"></a>限定函数参数类型及输出</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">text:<span class="string">&#x27;str&#x27;</span>,<span class="built_in">max</span>:<span class="string">&#x27;int &gt; 0&#x27;</span> = <span class="number">100</span>,<span class="built_in">min</span>:<span class="string">&#x27;int &gt; 0&#x27;</span></span>)-&gt;<span class="built_in">str</span>:</span></span><br></pre></td></tr></table></figure>

<p>在限定函数参数类型的同时还可以限定参数的范围以及默认值。</p>
<p>注意！在函数定义时，第一个带有默认值的参数之后的所有参数都必须有默认值，否则，运行时报错</p>
<h2 id="函数定义时的和"><a href="#函数定义时的和" class="headerlink" title="函数定义时的和*"></a>函数定义时的<em>和</em>*</h2><p>在参数前面加上<code>*</code>号 ，意味着参数个数不止一个，而带一个星号<code>*</code>参数的函数传入的参数存储为一个元组（tuple），带两个<code>*</code>号则是表示字典（dict）。</p>
<p>*将参数按顺序一一赋值，而dict类型则是将字典的keys作为函数参数进行赋值。</p>
<p>**参数方式则要求输入必须是一个dict，而且变量名称要与函数定义的变量名称一致</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func1</span>(<span class="params">a, *b</span>):</span></span><br><span class="line">	  <span class="built_in">print</span>(a)</span><br><span class="line">	  <span class="built_in">print</span>(b)</span><br><span class="line">	  <span class="built_in">print</span>(<span class="built_in">type</span>(b))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func2</span>(<span class="params">a, **b</span>):</span></span><br><span class="line">	  <span class="built_in">print</span>(a)</span><br><span class="line">	  <span class="built_in">print</span>(b)</span><br><span class="line">	  <span class="built_in">print</span>(<span class="built_in">type</span>(b))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func3</span>(<span class="params">a, *b, **c</span>):</span></span><br><span class="line">	  <span class="built_in">print</span>(a)</span><br><span class="line">	  <span class="built_in">print</span>(b)</span><br><span class="line">	  <span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func1(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">tuple</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">func1</span>(<span class="params"><span class="number">1111</span>,(<span class="params"><span class="number">2</span>,<span class="number">3</span></span>)</span>)</span></span><br><span class="line"><span class="class">1111</span></span><br><span class="line"><span class="class">(<span class="params">(<span class="params"><span class="number">2</span>, <span class="number">3</span></span>),</span>)					#如果传入一个元组，该元组会被当成元组的第一个参数</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;<span class="title">tuple</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">func2</span>(<span class="params"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">Traceback</span> (<span class="params">most recent call last</span>):</span></span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#17&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    func2(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">TypeError: func2() takes <span class="number">1</span> positional argument but <span class="number">3</span> were given</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func2(<span class="number">1</span>,x=<span class="number">1</span>,y=<span class="number">2</span>)    	<span class="comment">#传入的字典参数必须有key和value</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">&#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">dict</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">func2</span>(<span class="params"><span class="number">111</span>,&#123;x=<span class="number">22</span>,y=<span class="number">44</span>&#125;</span>)	#注意是传入的参数作为字典，不能传入<span class="title">dict</span>类型的参数！</span></span><br><span class="line"><span class="class"><span class="title">SyntaxError</span>:</span> invalid syntax</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func3(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,x=<span class="number">5</span>,y=<span class="number">6</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure>

<p>在调用时，*主要是用来解压参数列表，对于set、tuple、list、dict(会取其values的值)类型的数据都适用</p>
<p>另外一个值得注意的就是参数的顺序，我们知道，最正规的写法就是将这三个参数按<code>*</code>号从少到多排列，那换一种写法呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func4</span>(<span class="params">a,**b,*c</span>):</span></span><br><span class="line">SyntaxError: invalid syntax			<span class="comment">#**参数方式在*参数方式之前，无效</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func5</span>(<span class="params">*b,a</span>):</span>				<span class="comment">#*参数方式在不带*的参数之前，可以定义，但注意输入！！</span></span><br><span class="line">	<span class="built_in">print</span>(b,<span class="string">&#x27;\n&#x27;</span>,a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func5</span>(<span class="params">**b,a</span>):</span>				<span class="comment">#**参数方式在不带*参数方式之前，无效</span></span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func5</span>(<span class="params">**b,*c</span>):</span>				<span class="comment">#**参数方式在*参数方式之前，无效</span></span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func5</span>(<span class="params">*b,**c</span>):</span>				<span class="comment">#没有不带*的参数，*参数方式在**参数方式之前，有效</span></span><br><span class="line">	<span class="built_in">print</span>(b,c)</span><br></pre></td></tr></table></figure>

<p>但是要注意的是，如果带<code>*</code>的参数在不带<code>*</code>的参数之前，输入的时候要进行明确参数赋值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func6</span>(<span class="params">*b,a</span>):</span></span><br><span class="line">	<span class="built_in">print</span>(b)</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;a=&quot;</span>,a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func6(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="string">&#x27;222&#x27;</span>,<span class="number">333</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#38&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    func6(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="string">&#x27;222&#x27;</span>,<span class="number">333</span>)</span><br><span class="line">TypeError: func6() missing <span class="number">1</span> required keyword-only argument: <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func6(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="string">&#x27;222&#x27;</span>,a=<span class="number">333</span>)		<span class="comment">#输入的时候要进行明确参数赋值</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="string">&#x27;222&#x27;</span>)</span><br><span class="line">a= <span class="number">333</span></span><br></pre></td></tr></table></figure>





<h2 id="函数参数中的self"><a href="#函数参数中的self" class="headerlink" title="函数参数中的self"></a>函数参数中的self</h2><p>Python类中规定，函数的第一个参数是实例对象本身，并且约定俗成，把其名字写为self。其作用相当于java中的this，表示当前类的对象，可以调用当前类中的属性和方法。</p>
<p>在<a target="_blank" rel="noopener" href="https://www.runoob.com/python3/python3-class.html">菜鸟教程</a>中，对于python类有如下介绍：</p>
<blockquote>
<ul>
<li><strong>类(Class):</strong> 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</li>
<li><strong>方法：</strong>类中定义的函数。</li>
<li><strong>类变量：</strong>类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</li>
<li><strong>数据成员：</strong>类变量或者实例变量用于处理类及其实例对象的相关的数据。</li>
<li><strong>方法重写：</strong>如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</li>
<li><strong>局部变量：</strong>定义在方法中的变量，只作用于当前实例的类。</li>
<li><strong>实例变量：</strong>在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。</li>
<li><strong>继承：</strong>即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。</li>
<li><strong>实例化：</strong>创建一个类的实例，类的具体对象。</li>
<li><strong>对象：</strong>通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</li>
</ul>
</blockquote>
<p>class是面向对象的设计思想，instance（也即是 object，对象）是根据 class 创建的。<br>在类的内部，使用 <strong>def</strong> 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self, 且为第一个参数，self 代表的是类的实例而不是类！<br>self 代表的是类的实例，代表当前对象的地址，而 <code>self.class </code>则指向类。<br>self 不是 python 关键字，我们把他替换成合格的字符串形式参数也是可以正常执行的。</p>
<h2 id="类中的-init-方法"><a href="#类中的-init-方法" class="headerlink" title="类中的__init__方法"></a>类中的<code>__init__</code>方法</h2><p>类有一个名为·<code>__init__()</code> 的特殊方法（<strong>构造方法</strong>），该方法在类实例化时会自动调用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, realpart, imagpart</span>):</span></span><br><span class="line">        self.r = realpart</span><br><span class="line">        self.i = imagpart</span><br><span class="line">x = Complex(<span class="number">3.0</span>, -<span class="number">4.5</span>)</span><br><span class="line"><span class="built_in">print</span>(x.r, x.i)   <span class="comment"># 输出结果：3.0 -4.5</span></span><br></pre></td></tr></table></figure>



<h2 id="python-类的继承"><a href="#python-类的继承" class="headerlink" title="python 类的继承"></a>python 类的继承</h2><p>Python 同样支持类的继承，<strong>如果一种语言不支持继承，类就没有什么意义</strong>。</p>
<p>子类（派生类 DerivedClassName）会继承父类（基类 BaseClassName）的属性和方法。</p>
<p><code>BaseClassName</code>（实例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment">#类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>:</span></span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义私有属性,私有属性在类外部无法直接进行访问</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n,a,w</span>):</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s 说: 我 %d 岁。&quot;</span> %(self.name,self.age))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#单继承示例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span>(<span class="params">people</span>):</span></span><br><span class="line">    grade = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n,a,w,g</span>):</span></span><br><span class="line">        <span class="comment">#调用父类的构函</span></span><br><span class="line">        people.__init__(self,n,a,w)</span><br><span class="line">        self.grade = g</span><br><span class="line">    <span class="comment">#覆写父类的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;</span>%(self.name,self.age,self.grade))</span><br><span class="line">s = student(<span class="string">&#x27;ken&#x27;</span>,<span class="number">10</span>,<span class="number">60</span>,<span class="number">3</span>)</span><br><span class="line">s.speak()</span><br><span class="line"><span class="comment">#执行结果：ken 说: 我 10 岁了，我在读 3 年级</span></span><br></pre></td></tr></table></figure>

<p>python也支持多重继承</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>:</span></span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义私有属性,私有属性在类外部无法直接进行访问</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n,a,w</span>):</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s 说: 我 %d 岁。&quot;</span> %(self.name,self.age))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#单继承示例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span>(<span class="params">people</span>):</span></span><br><span class="line">    grade = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n,a,w,g</span>):</span></span><br><span class="line">        <span class="comment">#调用父类的构函</span></span><br><span class="line">        people.__init__(self,n,a,w)</span><br><span class="line">        self.grade = g</span><br><span class="line">    <span class="comment">#覆写父类的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;</span>%(self.name,self.age,self.grade))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#另一个类，多重继承之前的准备</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">speaker</span>():</span></span><br><span class="line">    topic = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n,t</span>):</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.topic = t</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;</span>%(self.name,self.topic))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#多重继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sample</span>(<span class="params">speaker,student</span>):</span></span><br><span class="line">    a =<span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n,a,w,g,t</span>):</span></span><br><span class="line">        student.__init__(self,n,a,w,g)</span><br><span class="line">        speaker.__init__(self,n,t)</span><br><span class="line"> </span><br><span class="line">test = sample(<span class="string">&quot;Tim&quot;</span>,<span class="number">25</span>,<span class="number">80</span>,<span class="number">4</span>,<span class="string">&quot;Python&quot;</span>)</span><br><span class="line">test.speak()   <span class="comment">#方法名同，默认调用的是在括号中排前地父类的方法</span></span><br><span class="line"><span class="comment">#执行结果：我叫 Tim，我是一个演说家，我演讲的主题是 Python</span></span><br></pre></td></tr></table></figure>

<h3 id="类的私有属性"><a href="#类的私有属性" class="headerlink" title="类的私有属性"></a>类的私有属性</h3><p><strong>__private_attrs</strong>：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 <strong>self.__private_attrs</strong>。</p>
<h3 id="类的方法"><a href="#类的方法" class="headerlink" title="类的方法"></a>类的方法</h3><p>在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 <strong>self</strong>，且<strong>必须</strong>为<strong>第一个</strong>参数，<strong>self</strong> 代表的是类的实例。</p>
<p><strong>self</strong> 的名字并不是规定死的，也可以使用 <strong>this</strong>，但是最好还是按照约定使用 <strong>self</strong>。</p>
<h3 id="类的私有方法"><a href="#类的私有方法" class="headerlink" title="类的私有方法"></a>类的私有方法</h3><p><strong>__private_method</strong>：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。<strong>self.__private_methods</strong>。</p>
<h2 id="lambda表达式（匿名函数）"><a href="#lambda表达式（匿名函数）" class="headerlink" title="lambda表达式（匿名函数）"></a>lambda表达式（匿名函数）</h2><p>如果一个函数的函数体<strong>仅有 1 行</strong>，那么该函数就可以用 lambda 表达式来代替，下面两个函数在表达效果上是相等的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">arg1,...argn</span>):</span></span><br><span class="line">    <span class="keyword">return</span> 表达式</span><br><span class="line">name = <span class="keyword">lambda</span>  [arg1 [,arg2,.....argn]]: 表达式</span><br></pre></td></tr></table></figure>

<p>定义 lambda 表达式，必须使用 lambda 关键字，注意冒号前是<strong>参数</strong>，可以有<strong>多个</strong>，用<strong>逗号隔开</strong>，冒号右边的为表达式（只能为一个）。其实lambda返回值是一个函数的地址，也就是函数对象。</p>
<p>注意传入的参数必须用逗号隔开，下面这么定义是错误的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>add = <span class="keyword">lambda</span> [x,y]:x+y</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add = <span class="keyword">lambda</span> x,y:x+y</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>





<h2 id="python中的5种下划线形式"><a href="#python中的5种下划线形式" class="headerlink" title="python中的5种下划线形式"></a>python中的5种下划线形式</h2><ul>
<li>单前导下划线：**_var**</li>
<li>单末尾下划线：<strong>var_</strong></li>
<li>双前导下划线：**__var**</li>
<li>双前导和末尾下划线：<code>__var__</code></li>
<li>单下划线：**_**</li>
</ul>
<h3 id="单前导下划线：-var"><a href="#单前导下划线：-var" class="headerlink" title="单前导下划线：**_var**"></a>单前导下划线：**_var**</h3><p>，前置单下划线只有约定含义。它对于程序员而言是一种提示——Python社区约定好单下划线表达的是某种意思，其本身并不会影响程序的行为。</p>
<p>前置下划线的意思是<strong>提示</strong>其他程序员，以单下划线开头的变量或方法只在内部使用。PEP 8中定义了这个约定（PEP 8是最常用的Python代码风格指南。</p>
<p>详见PEP 8：“Style Guide for Python Code”。</p>
<p>不过，这个约定对Python解释器并没有特殊含义。与Java不同，Python在“私有”和“公共”变量之间并没有很强的区别。在变量名之前添加一个下划线更像是有人挂出了一个小小的下划线警告标志：“<strong>注意，这并不是这个类的公共接口。最好不要使用它</strong>。”</p>
<p>我们实例化一个类，并为其添加一个使用单前导下划线的属性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.foo = <span class="number">11</span></span><br><span class="line">        self._bar = <span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = Test()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.foo</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t._bar</span><br><span class="line"><span class="number">23</span></span><br></pre></td></tr></table></figure>

<p><code>_bar</code>前面的单下划线并没有阻止我们“进入”这个类访问变量的值。</p>
<p>这是因为Python中的前置单下划线只是一个公认的约定，至少在涉及变量名和方法名时是这样的。</p>
<p><strong>使用单前导下划线需要注意的是</strong>，前置下划线会影响从模块中导入名称的方式，如果使用<strong>通配符<code>*</code>导入</strong>从这个模块中导入所有名称，Python<strong>不会</strong>导入带有前置单下划线的名称（除非模块中定义了<code>__all__</code>列表覆盖了这个行为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在my_module.py中这么定义：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">external_func</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">23</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_internal_func</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在idle或另一个py文件中导入</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> my_module <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>external_func()</span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_internal_func()</span><br><span class="line">NameError: <span class="string">&quot;name &#x27;_internal_func&#x27; is not defined&quot;</span></span><br></pre></td></tr></table></figure>

<p>值得注意的是：要<strong>尽可能避免使用通配符<code>*</code>导入</strong>，因为这样就不清楚当前名称空间中存在哪些名称了。为了清楚起见，最好坚持使用常规导入方法。与通配符导入不同，常规导入不受前置单下划线命名约定的影响.</p>
<p>遵循PEP 8的建议不使用通配符导入，那么真正需要记住的只有下面这一条。<br>以单下划线开头的名称只是Python命名中的约定，表示供内部使用。它通常对Python解释器没有特殊含义，仅仅作为对程序员的提示。</p>
<h3 id="单末尾下划线：var"><a href="#单末尾下划线：var" class="headerlink" title="单末尾下划线：var_"></a>单末尾下划线：<strong>var_</strong></h3><p>有时某个变量最合适的名称已被Python语言中的关键字占用。因此，诸如<code>class</code>或<code>def</code>的名称不能用作Python中的变量名。在这种情况下，可以追加一个下划线来绕过命名冲突。PEP 8中定义并解释了这个用一个单末尾下划线来避免与python关键字冲突的约定。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">name,<span class="keyword">class</span></span>):</span></span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">name,class_</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>上面介绍的单下划线（无论放在前边还是末尾），都只是约定的作用。</p>
<h3 id="双前导下划线：-var"><a href="#双前导下划线：-var" class="headerlink" title="双前导下划线：**__var**"></a>双前导下划线：**__var**</h3><p>上面介绍的单下划线（无论放在前边还是末尾），都只是约定的作用。</p>
<p>但使用以双下划线开头的Python类属性（变量和方法）就不一样了。</p>
<p>双下划线前缀会让Python解释器重写属性名称，以避免子类中的命名冲突。</p>
<p>这也称为<strong>名称改写</strong>（name mangling），即解释器会更改变量的名称，以便在稍后扩展这个类时避免命名冲突。</p>
<h3 id="双前导和末尾下划线：-var"><a href="#双前导和末尾下划线：-var" class="headerlink" title="双前导和末尾下划线：__var__"></a>双前导和末尾下划线：<code>__var__</code></h3><p><strong>一些特殊的双前导和末尾下划线</strong></p>
<ol>
<li><p><code>__all__</code></p>
<p>不像 Ruby 或者 Java，Python 没有语言原生的可见性控制，而是靠一套需要大家自觉遵守的”约定“下工作。比如下划线开头的应该对外部不可见。同样，<code>__all__</code> 也是对于模块公开接口的一种约定，比起下划线，<code>__all__</code> 提供了暴露接口用的”白名单“。一些不以下划线开头的变量（比如从其他地方 <code>import</code> 到当前模块的成员）可以同样被排除出去。</p>
<p>当我们向文件导入某个模块时，导入的是该模块中那些<strong>名称不以下划线（单下划线“_”或者双下划线“__”）开头</strong>的变量、函数和类。因此，如果我们不想模块文件中的某个成员被引入到其它文件中使用，有两种方法：</p>
<ol>
<li>在其名称前添加单下划线。</li>
<li>借助模块提供的__all__ 变量，该变量的值是一个列表，存储的是当前模块中一些成员（变量、函数或者类）的名称。</li>
</ol>
<p>通过在模块文件中设置__all__变量，当其它文件以“from 模块名 import *”的形式导入该模块时，该文件中只能使用__all__ 列表中指定的成员。__all__也是对于模块公开接口的一种约定，比起下划线，__all__提供了暴露接口用的“白名单”。</p>
<pre><code>   ————————————————
  版权声明：本文为CSDN博主「-徐徐图之-」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
  原文链接：https://blog.csdn.net/zylooooooooong/article/details/115564782
</code></pre>
</li>
<li><p><code>__init__</code></p>
<p>在创建类时，我们可以手动添加一个<code>__init__()</code>方法，该方法是一个特殊的类实例方法，称为构造方法（或构造函数）。</p>
<p>构造方法用于创建对象时使用，每当创建一个类的实例对象时，<a target="_blank" rel="noopener" href="http://c.biancheng.net/python/">Python</a> 解释器都会自动调用它。</p>
<p><code>__init__() </code>方法可以包含多个参数，但必须包含一个名为 self 的参数，且必须作为第一个参数。</p>
<p>即便不手动为类添加任何构造方法，Python 也会自动为类添加一个仅包含 self 参数的构造方法。</p>
<p>如果子类中不重写<code>__init__</code>，实例化子类时，就会调用父类中定义的<code>__init__</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">        <span class="built_in">print</span> ( <span class="string">&quot;name: %s&quot;</span> %( self.name) )</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getName</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Father &#x27;</span> + self.name</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>(<span class="params">Father</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getName</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Son &#x27;</span>+self.name</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    son=Son(<span class="string">&#x27;runoob&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span> ( son.getName() )</span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line">name: runoob</span><br><span class="line">Son runoob</span><br></pre></td></tr></table></figure>

<p>如果重写了**<strong>init</strong>** 时，实例化子类，就不会调用父类已经定义的 **<strong>init</strong>**，语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">        <span class="built_in">print</span> ( <span class="string">&quot;name: %s&quot;</span> %( self.name) )</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getName</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Father &#x27;</span> + self.name</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>(<span class="params">Father</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="built_in">print</span> ( <span class="string">&quot;hi&quot;</span> )</span><br><span class="line">        self.name =  name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getName</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Son &#x27;</span>+self.name</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    son=Son(<span class="string">&#x27;runoob&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span> ( son.getName() )</span><br><span class="line"><span class="comment">#输出结果：</span></span><br><span class="line">hi</span><br><span class="line">Son runoob</span><br></pre></td></tr></table></figure>

<p>若重写了<code>__init__</code>，还要继承父类的构造方法，可以使用<code>super</code>关键字。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">        <span class="built_in">print</span> ( <span class="string">&quot;name: %s&quot;</span> %( self.name))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getName</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Father &#x27;</span> + self.name</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>(<span class="params">Father</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Son, self).__init__(name)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;hi&quot;</span>)</span><br><span class="line">        self.name =  name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getName</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Son &#x27;</span>+self.name</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    son=Son(<span class="string">&#x27;runoob&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span> ( son.getName() )</span><br><span class="line">    </span><br><span class="line"><span class="comment">#输出结果如下：</span></span><br><span class="line">name: runoob</span><br><span class="line">hi</span><br><span class="line">Son runoob</span><br></pre></td></tr></table></figure>

<p>也可以直接调用父类的<code>__init__</code>类方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dad = Father(<span class="string">&#x27;luo&#x27;</span>)</span><br><span class="line">name: luo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dad.__init__()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#10&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    dad.__init__()</span><br><span class="line">TypeError: __init__() missing <span class="number">1</span> required positional argument: <span class="string">&#x27;name&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dad.__init__(<span class="string">&quot;WHALE&quot;</span>)</span><br><span class="line">name: WHALE</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dad.name</span><br><span class="line"><span class="string">&#x27;WHALE&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>__name__</code></p>
<p>一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用<code>__name__</code>属性来使该程序块仅在该模块自身运行时执行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># Filename: using_name.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;程序自身在运行&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;我来自另一模块&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#以下是程序运行结果</span></span><br><span class="line">$ python using_name.py			<span class="comment">#在模块自身运行时</span></span><br><span class="line">程序自身在运行</span><br><span class="line">$ python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> using_name			<span class="comment">#在模块被引用时</span></span><br><span class="line">我来自另一模块</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>注意：每个模块都有一个<code>__name__</code>属性，当其值是<code>__main__</code>时，表明该模块自身在运行，否则是被引入。</p>
</li>
<li></li>
</ol>
<h3 id="单下划线："><a href="#单下划线：" class="headerlink" title="单下划线：**_**"></a>单下划线：**_**</h3><p>有时候单个独立下划线是用作一个名字，来表示某个变量是临时的或无关紧要的。</p>
<p>例如，在下面的循环中，我们不需要访问正在运行的索引，我们可以使用”_”来表示它只是一个临时值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line"><span class="meta">... </span>   <span class="built_in">print</span>(<span class="string">&#x27;Hello, World.&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>你也可以在拆分(unpacking)表达式中将单个下划线用作”不关心的”变量，以忽略特定的值。 同样，这个含义只是”依照约定”，并不会在Python解释器中触发特殊的行为。 单个下划线仅仅是一个有效的变量名称，会有这个用途而已。</p>
<p>在下面的代码示例中，我将汽车元组拆分为单独的变量，但我只对颜色和里程值感兴趣。 但是，为了使拆分表达式成功运行，我需要将包含在元组中的所有值分配给变量。 在这种情况下，”_”作为占位符变量可以派上用场：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>car = (<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;auto&#x27;</span>, <span class="number">12</span>, <span class="number">3812.4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>color, _, _, mileage = car</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>color</span><br><span class="line"><span class="string">&#x27;red&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mileage</span><br><span class="line"><span class="number">3812.4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>除了用作临时变量之外，”_”是大多数Python REPL中的一个特殊变量，它表示由解释器评估的最近一个表达式的结果。</p>
<p>这样就很方便了，比如你可以在一个解释器会话中访问先前计算的结果，或者，你是在动态构建多个对象并与它们交互，无需事先给这些对象分配名字：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">20</span> + <span class="number">3</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_</span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(_)</span><br><span class="line"><span class="number">23</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>()</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_.append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_.append(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_.append(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>对于上面五种类型的下划线，<a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/python-5-underline.html">菜鸟教程的小结</a>可以很好的帮助我们：</p>
<p><img src="E:\JS练习\blog\Myblog\source\images\python下划线类型小结.jpg"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://justskim.github.io.git/2021/10/31/python3%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E8%AF%AD%E6%B3%95%E7%B3%96/" data-id="ckzcw3wzb0011roud9bt32kha" data-title="python3中的一些常见语法糖整理" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python3/" rel="tag">python3</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-linux的进程优先级与进程调度策略" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/10/23/linux%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%8E%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/" class="article-date">
  <time class="dt-published" datetime="2021-10-23T12:38:09.488Z" itemprop="datePublished">2021-10-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/10/23/linux%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%8E%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/">linux的进程优先级与进程调度策略</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="linux的进程优先级与进程调度策略"><a href="#linux的进程优先级与进程调度策略" class="headerlink" title="linux的进程优先级与进程调度策略"></a>linux的进程优先级与进程调度策略</h1><h2 id="linux中的进程调度策略"><a href="#linux中的进程调度策略" class="headerlink" title="linux中的进程调度策略"></a>linux中的进程调度策略</h2><p>FIFO，RR，OTHER</p>
<p>实时进程会抢占普通进程，FIFO会导致同优先级实时进程始终占用CPU，RR会保证同优先级实时进程按时间片轮流执行。</p>
<p>上面说的很通俗易懂，那么，两个同等优先级的FIFO实时进程，是不是谁先占据了cpu，另一个就只能等待它完成了让出CPU呢？</p>
<p>其实不尽然，即使是在单核cpu的linux系统中，FIFO实时进程也会被调度。</p>
<p>具体可见博客：</p>
<p>cnblogs.com/tongye/p/9575602.html</p>
<p>blog.csdn.net/qq_37451250/article/details/104807725</p>
<h2 id="C语言中的进程优先级设置"><a href="#C语言中的进程优先级设置" class="headerlink" title="C语言中的进程优先级设置"></a>C语言中的进程优先级设置</h2><p>创建实时进程与普通进程略有区别——在创建普通进程的基础上，将调度类从CFS（completely fair完全公平调度类）转向RT类（实时调度类型，包括RR和FIFO）</p>
<p>常见的几个进程优先级设置与取得函数（位于头文件sched.h中）：</p>
<p>sched_get_priority_max()  取得静态优先级的上限</p>
<p>sched_get_priority_min()  取得静态优先级的下限</p>
<p>sched_getparam()取得进程的调度参数</p>
<p>sched_setparam()设置进程的调度参数</p>
<p>sched_getscheduler()取得指定进程的调度类</p>
<p>sched_setscheduler()设置指定进程的调度类</p>
<blockquote>
<p>int sched_getscheduler(pid_t pid, int policy, const struct sched_param *param)</p>
<p>第一个参数是进程号（0表示本进程），第二个参数为调度类（SCHED_RR为2、SCHED_FIFO为1、SCHED_OTHER为0，三个之一） ，第三个参数是一个struct sched_param 类型的调度参数——其sched_priority成员可以指定优先级。</p>
</blockquote>
<p>sched_rr_get_interval()取得按RR算法调度的实时进程的时间片长度</p>
<p>sched_yield()进程主动让出处理器并将自己挂入等候调度队列的队尾</p>
<p>sched文件</p>
<p><strong>C语言system函数</strong></p>
<p>执行 dos(windows系统) 或 shell(Linux/Unix系统) 命令，参数字符串command为命令名。另，在windows系统下参数字符串不区分大小写。</p>
<p>说明：在windows系统中，system函数直接在控制台调用一个command命令。<br>在Linux/Unix系统中，system函数会调用fork函数产生子进程，由子进程来执行command命令，命令执行完后随即返回原调用的进程。</p>
<p>函数返回值<br>命令执行成功返回0，执行失败返回-1。</p>
<p><strong>C语言sprintf函数</strong></p>
<p>int sprintf( char *buffer, const char *format, [ argument] … )；</p>
<p>这个函数包含三个部分的参数：</p>
<p>buffer：char型指针，指向将要写入的字符串的缓冲区。format：格式化字符串。即可选参数的想要输入的数据类型。[argument]…：可选参数，可以是任何类型的数据。</p>
<p>这个函数就是把第三部分的数据，按照第二部分格式化字符的格式，把第三部分的数据进行”格式化“，然后在<strong>把格式化后的数据类型，存储到字符串</strong>的缓存区间里去。</p>
<p>通过查看/ proc /&lt; PID&gt; / sched中的调度统计信息(scheduling stats in <code>/proc/&lt;PID&gt;/sched</code>),您可以获得如下输出（仅限进程运行着的时候）</p>
<p>为了在进程退出后依然能看到这些调度统计信息，我们可以使用以上代码将其存储至本目录的sched-pid文件中</p>
<p>&gt; nr_switches：上下文切换次数.<br>&gt; nr_voluntary_switches：自愿切换的数量,即线程被阻塞,因此拾取另一个线程.<br>&gt; nr_involuntary_switches：调度程序将线程踢出,因为有另一个饥饿的线程已准备好运行.</p>
<h2 id="C语言中的进程调度函数"><a href="#C语言中的进程调度函数" class="headerlink" title="C语言中的进程调度函数"></a>C语言中的进程调度函数</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://justskim.github.io.git/2021/10/23/linux%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%8E%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/" data-id="ckzcw3wyn0001roud8rul6z97" data-title="linux的进程优先级与进程调度策略" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-在vmware中“mnthgfs”路径下共享文件夹的挂载" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/10/23/%E5%9C%A8vmware%E4%B8%AD%E2%80%9Cmnthgfs%E2%80%9D%E8%B7%AF%E5%BE%84%E4%B8%8B%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E6%8C%82%E8%BD%BD/" class="article-date">
  <time class="dt-published" datetime="2021-10-23T12:13:05.314Z" itemprop="datePublished">2021-10-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/10/23/%E5%9C%A8vmware%E4%B8%AD%E2%80%9Cmnthgfs%E2%80%9D%E8%B7%AF%E5%BE%84%E4%B8%8B%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E6%8C%82%E8%BD%BD/">在vmware中“/mnt/hgfs”路径下共享文件夹的挂载</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="在vmware中“-mnt-hgfs”路径下共享文件夹的挂载"><a href="#在vmware中“-mnt-hgfs”路径下共享文件夹的挂载" class="headerlink" title="在vmware中“/mnt/hgfs”路径下共享文件夹的挂载"></a>在vmware中“/mnt/hgfs”路径下共享文件夹的挂载</h1><p>在之前的博客中，我们已经讲过如何在vmware虚拟机中设置共享文件夹，mnt目录是挂接光驱、USB设备的目录，在其中进行文件操作需要有root权限。linux系统中一定会有/mnt目录，但其下不一定有hgfs目录，在我们成功安装完VMWare tools后会出现hgfs文件夹，但一些情况下hgfs文件夹中可能不存在我们之前在虚拟机中设置的共享文件夹名称，下面是解决办法</p>
<h2 id="mnt路径下有hgfs但却没有共享文件夹"><a href="#mnt路径下有hgfs但却没有共享文件夹" class="headerlink" title="/mnt路径下有hgfs但却没有共享文件夹"></a>/mnt路径下有hgfs但却没有共享文件夹</h2><p>先进入到root权限下，使用命令<code>vmware-hgfsclient</code>来查看当前有哪些共享的目录，如果未能成功安装VMWare tools则该命令会导致报错。</p>
<p>然后使用命令<code>mount -t vmhgfs .host:/你所设置的共享文件夹名称 /mnt/hgfs</code>来挂载共享文件夹即可。</p>
<p>以上设置后每次重新开机都要重复设置一次共享文件夹，我们使用在文件<code>/etc/fstab</code>中进行修改来设置开机后自动挂载：</p>
<p>在文件<code>/etc/fstab</code>中添加以下一行：<code>.host:/mnt/hgfs vmhgfs defaults 0 0</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://justskim.github.io.git/2021/10/23/%E5%9C%A8vmware%E4%B8%AD%E2%80%9Cmnthgfs%E2%80%9D%E8%B7%AF%E5%BE%84%E4%B8%8B%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E6%8C%82%E8%BD%BD/" data-id="ckzcw3wz5000groudcsyu3c0r" data-title="在vmware中“/mnt/hgfs”路径下共享文件夹的挂载" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ubuntu/" rel="tag">ubuntu</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vmware/" rel="tag">vmware</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag">虚拟机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-linux的权限与隐藏权限" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/27/linux%E7%9A%84%E6%9D%83%E9%99%90%E4%B8%8E%E9%9A%90%E8%97%8F%E6%9D%83%E9%99%90/" class="article-date">
  <time class="dt-published" datetime="2021-09-27T12:26:36.587Z" itemprop="datePublished">2021-09-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/27/linux%E7%9A%84%E6%9D%83%E9%99%90%E4%B8%8E%E9%9A%90%E8%97%8F%E6%9D%83%E9%99%90/">linux的权限与隐藏权限</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="linux的权限与隐藏权限"><a href="#linux的权限与隐藏权限" class="headerlink" title="linux的权限与隐藏权限"></a>linux的权限与隐藏权限</h1><h2 id="linux的权限"><a href="#linux的权限" class="headerlink" title="linux的权限"></a>linux的权限</h2><h3 id="linux中的文件类型"><a href="#linux中的文件类型" class="headerlink" title="linux中的文件类型"></a>linux中的文件类型</h3><p>　　linux一共有7种文件类型,分别如下:</p>
<p>​    　　 -：普通文件</p>
<p>​     　d：目录文件</p>
<p>​     　l： 软链接（类似Windows的快捷方式）</p>
<p>​    　　(<strong>下面四种是特殊文件)</strong></p>
<p>​     　b：块设备文件（例如硬盘、光驱等）</p>
<p>​    　　 p：管道文件</p>
<p>​     　c：字符设备文件（例如猫等串口设备）</p>
<p>​     　s：套接口文件/数据接口文件（例如启动一个MySql服务器时会产生一个mysql.sock文件）</p>
<h2 id="linux的隐藏权限"><a href="#linux的隐藏权限" class="headerlink" title="linux的隐藏权限"></a>linux的隐藏权限</h2><p>除了文件的读写,执行权限外,linux还有一种隐藏权限,设置隐藏权限可以防止一些其他用户的误操作或者恶意操作,当我们配置了<code>nginx</code>的放跨站攻击或其他安全措施后,相应的会在项目的根目录下生成一个隐藏文件<code>.user.ini</code>,当删除整个项目时会阻止操作完成.我们使用<code>ls</code>命令并使用<code>chmod chown</code>等命令设置了文件权限后会发现还是无法删除.这就是因为这个文件有隐藏的权限。</p>
<p>linux系统的隐藏权限总共有以下十三种类型：</p>
<ul>
<li><p>A：即Atime，告诉系统不要修改对这个文件的最后访问时间；</p>
</li>
<li><p>S：即Sync，一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘；</p>
</li>
<li><p>a：即Append Only，系统只允许在这个文件之后追加数据，不允许任何进程覆盖或截断这个文件。如果目录具有这个属性，系统将只允许在这个目录下建立和修改文件，而不允许删除任何文件；</p>
</li>
<li><p>b：不更新文件或目录的最后存取时间；</p>
</li>
<li><p>c：将文件或目录压缩后存放；</p>
</li>
<li><p>d：当dump程序执行时，该文件或目录不会被dump备份；</p>
</li>
<li><p>D:检查压缩文件中的错误；</p>
</li>
<li><p>i：即Immutable，系统不允许对这个文件进行任何的修改。如果目录具有这个属性，那么任何的进程只能修改目录之下的文件，不允许建立和删除文件；</p>
</li>
<li><p>s：彻底删除文件，不可恢复，因为是从磁盘上删除，然后用0填充文件所在区域；</p>
</li>
<li><p>u：当一个应用程序请求删除这个文件，系统会保留其数据块以便以后能够恢复删除这个文件，用来防止意外删除文件或目录；</p>
</li>
<li><p>t:文件系统支持尾部合并（tail-merging）；</p>
</li>
<li><p>X：可以直接访问压缩文件的内容 </p>
</li>
<li><p>e: 表示文件以ext4 extents存储的，ext4上新建文件的默认属性，<strong>不可用chattr修改</strong>。</p>
</li>
</ul>
<p>使用命令<code>chattr +权限类型</code>和<code>chattr -权限类型</code>可以为文件添加或删除隐藏权限</p>
<h2 id="chattr命令"><a href="#chattr命令" class="headerlink" title="chattr命令"></a>chattr命令</h2><p>提到文件权限的修改，必然绕不过这一命令，根据<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/874.html">C语言中文网</a>（这个网站怎么啥都有）：</p>
<blockquote>
<p>chattr 命令，专门用来修改文件或目录的隐藏属性，只有 root 用户可以使用。该命令的基本格式为：</p>
<p>[root@localhost ~]# chattr [+-=] [属性] 文件或目录名</p>
</blockquote>
<p>下面是常用chattr命令来授予/删除的一些属性：</p>
<table>
<thead>
<tr>
<th>属性选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>i</td>
<td>如果对文件设置 i 属性，那么不允许对文件进行删除、改名，也不能添加和修改数据； 如果对目录设置 i 属性，那么只能修改目录下文件中的数据，但不允许建立和删除文件；</td>
</tr>
<tr>
<td>a</td>
<td>如果对文件设置 a 属性，那么只能在文件中増加数据，但是不能删除和修改数据； 如果对目录设置 a 属性，那么只允许在目录中建立和修改文件，但是不允许删除文件；</td>
</tr>
<tr>
<td>u</td>
<td>设置此属性的文件或目录，在删除时，其内容会被保存，以保证后期能够恢复，常用来防止意外删除文件或目录。</td>
</tr>
<tr>
<td>s</td>
<td>和 u 相反，删除文件或目录时，会被彻底删除（直接从硬盘上删除，然后用 0 填充所占用的区域），不可恢复。</td>
</tr>
<tr>
<td>b</td>
<td>不更新文件或目录的最后存取时间。</td>
</tr>
<tr>
<td>c</td>
<td>将文件或目录压缩后存放。</td>
</tr>
<tr>
<td>d</td>
<td>将文件或目录排除在倾倒操作之外</td>
</tr>
<tr>
<td>S</td>
<td>即时更新文件或目录</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://justskim.github.io.git/2021/09/27/linux%E7%9A%84%E6%9D%83%E9%99%90%E4%B8%8E%E9%9A%90%E8%97%8F%E6%9D%83%E9%99%90/" data-id="ckzcw3wyj0000roud896acfe1" data-title="linux的权限与隐藏权限" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-在vmware中实现共享文件夹以及安装vmware-tools" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/27/%E5%9C%A8vmware%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85vmware-tools/" class="article-date">
  <time class="dt-published" datetime="2021-09-27T11:27:13.351Z" itemprop="datePublished">2021-09-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/27/%E5%9C%A8vmware%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85vmware-tools/">在vmware中实现共享文件夹以及安装vmware-tools</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="在vmware中实现共享文件夹以及安装vmware-tools"><a href="#在vmware中实现共享文件夹以及安装vmware-tools" class="headerlink" title="在vmware中实现共享文件夹以及安装vmware-tools"></a>在vmware中实现共享文件夹以及安装vmware-tools</h1><p>原因：想要设置共享文件夹，而ubuntu16.04版本系统中，只有文件夹mnt，其中没有文件夹hgfs，而按照网上教程操作，需要重新安装vmware-tools才能使得该选项可以点击，然而虚拟机菜单栏中，“重新安装vmware-tool”的选项为灰色不可点击</p>
<p>首先使用命令<code>su root</code>跳转至超级用户权限，</p>
<p>然后，使用命令<code>apt-get install open-vmware-tools</code>安装，</p>
<p>注意，完成之后，在文件夹<code>media</code>下面会有以下的文件</p>
<p><img src="E:\JS练习\blog\Myblog\source\images\media文件夹下的vmwareTools.png" alt="media文件夹下的vmwareTools"></p>
<p>我们如果在media文件夹中使用tar命令对 文件 进行解压缩，会发现出错，大量的报错语句：</p>
<p><code>tar: vmware-tools-distrib: Cannot mkdir: Read only file system</code></p>
<p>然后我们使用命令<code>su root</code>输入密码进入超级用户权限，再次尝试解压缩，依然出错！</p>
<p>原因在于<a target="_blank" rel="noopener" href="https://zhidao.baidu.com/question/367521394739288804.html">linux系统对我们的贴心</a>：</p>
<blockquote>
<p>我们知道<strong>root用户</strong>是linux执行<strong>权限最高</strong>的管理者用户，他可以进行任何的权限操作；<strong>然而</strong>我们的<strong>操作系统</strong>同样也考虑过这样的弊端，就是当我们使用者并不了解文件属性和重要性时会给予我们使用者提示；</p>
<p>  举个例子，当我们在linux下打开磁盘文件时，想要直接修改磁盘中的文件属性，一般会提示为只读文件，这时我们可以将其从磁盘中移动到本地目录下，这样就可以进行权限操作了；</p>
<p>  实例如图显示，我的操作是试图对DVD中的文件进行权限修改，这是不被允许的；</p>
</blockquote>
<p>如果我们在media文件夹目录下使用<code>lsattr</code>命令：可以发现：</p>
<p><img src=""></p>
<p>注意，<code>e</code>是linux文件的隐藏权限类型！！</p>
<p>在linux操作系统中，有这么几个特殊的文件夹：</p>
<blockquote>
<p>/mnt：一般是挂在镜像和硬盘一类的目录；/media:是挂在多媒体设备的目录，如默认情况下的光盘、优盘、硬盘等设备都挂在在此目录；/misc即各种其它杂七杂八东西</p>
<p>otp 是第三方软件的存放目录<br>selinux 是linux 下强制存取控制的实现 一般用来保护apache<br>srv 是存放系统提供服务站点的数据<br>media 是存放即插即用 设备的 挂载点。 比如USB 设备 自动在这个目录下创建一个目录</p>
<p>因为你没有对 文件所对应的内容进行操作 所以他是空的 </p>
</blockquote>
<p>在<a target="_blank" rel="noopener" href="https://www.howtogeek.com/117435/htg-explains-the-linux-directory-structure-explained/">How-To-Geek上对Linux系统的目录结构说明文档</a>中，关于media文件夹有这样的解释：</p>
<blockquote>
<h2 id="media-—-Removable-Media"><a href="#media-—-Removable-Media" class="headerlink" title="/media — Removable Media"></a>/media — Removable Media</h2><p>The /media directory contains subdirectories where removable media devices inserted into the computer are mounted. For example, when you insert a CD into your Linux system, a directory will automatically be created inside the /media directory. You can access the contents of the CD inside this directory.</p>
</blockquote>
<p>在我们使用apt-get下载了相关tar.gz格式的压缩文件后，这一篇<a target="_blank" rel="noopener" href="https://blog.csdn.net/a1219532602/article/details/110071982">博客</a>介绍了之后的步骤：</p>
<p>当然，作者也遇到了media文件夹中不能解压缩的问题，给出了下面的解答步骤：</p>
<p>于是，我们使用命令<code>cp VMwaretools.tar.gz /home/user/Desktop</code>将其拷贝一份至桌面进行解压缩</p>
<p><code>tar -zxvf VMwareTools.tar.gz</code></p>
<p>然后跳转到解压后的文件夹 <code>cd vmware-tools-distrib/</code></p>
<p>执行命令<code>sudo ./vmware-install.pl</code>。</p>
<p>完成，成功解压缩。</p>
<p>然后我们重新启动虚拟机，可以看到，/mnt文件夹下已经有了hgfs文件夹</p>
<p>在<a target="_blank" rel="noopener" href="https://www.linuxcool.com/">中文的一个方便网站上</a>，我们可以搜索到<strong>上面几个重要命令的讲解：</strong></p>
<ul>
<li><p><code>cp</code> </p>
<p>CoPy，功能为复制文件或目录，可以将多个文件复制到一个具体的文件名或一个已经存在的目录下，也可以同时复制多个文件到一个指定的目录中。</p>
<p><code>cp [参数] [文件] [路径]</code></p>
</li>
<li><p><code>tar</code></p>
<p>TARball，根据<a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-comm-tar.html">菜鸟教程中的描述</a>：</p>
<blockquote>
<p>tar 是用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件。</p>
</blockquote>
</li>
</ul>
<p>必要参数如下：<br>  <strong>A</strong>   新增压缩文件到已存在的压缩<br>  <strong>c</strong>    建立新的压缩文件<br>  <strong>d</strong>   记录文件的差别<br>  <strong>r</strong>    添加文件到已经压缩的文件<br>  <strong>u</strong>   添加改变了和现有的文件到已经存在的压缩文件<br>  <strong>x</strong>   从压缩的文件中提取文件<br>  <strong>t</strong>   显示压缩文件的内容<br>  <strong>z</strong>   支持<code>gzip</code>解压文件<br>  <strong>j</strong>    支持<code>bzip2</code>解压文件<br>  <strong>Z</strong>   支持compress解压文件<br>  <strong>v</strong>   显示操作过程<br>  <strong>l</strong>    文件系统边界设置<br>  <strong>k</strong>   保留原有文件不覆盖<br>  <strong>m</strong>  保留文件不被覆盖<br>  <strong>W</strong>  确认压缩文件的正确性</p>
<ul>
<li><p><code>cd</code></p>
<p>Change Directory，切换目录</p>
<p><code>cd [参数] [目录名]</code></p>
<p>一些特殊的目录表示：</p>
<p>“ <strong>~</strong> ”表示为<strong>用户目录</strong>的意思；</p>
<p>“ <strong>. <strong>”则是表示</strong>目前所在的目录</strong>；</p>
<p>“ <strong>..</strong> ”则表示<strong>当前目录位置的上一级目录</strong>。</p>
<p>常用参数</p>
<table>
<thead>
<tr>
<th>-P</th>
<th>如果切换的目标目录是一个符号链接，则直接切换到符号链接指向的目标目录</th>
</tr>
</thead>
<tbody><tr>
<td>-L</td>
<td>如果切换的目标目录是一个符号链接，则直接切换到符号链接名所在的目录</td>
</tr>
<tr>
<td>–</td>
<td>仅使用”-“选项时，当前目录将被切换到环境变量”OLDPWD”对应值的目录</td>
</tr>
<tr>
<td>~</td>
<td>切换至当前用户目录</td>
</tr>
<tr>
<td>..</td>
<td>切换至当前目录位置的上一级目录</td>
</tr>
</tbody></table>
</li>
<li><p><code>sudo</code></p>
<p>SuperUser DO</p>
<p>sudo 是一种权限管理机制，管理员可以授权于一些普通用户去执行一些 root 执行的操作，而不需要知道 root 的密码。</p>
<p>sudo 允许一个已授权用户以超级用户或者其它用户的角色运行一个命令。当然，能做什么不能做什么都是通过安全策略来指定的。sudo 支持插件架构的安全策略，并能把输入输出写入日志。第三方可以开发并发布自己的安全策略和输入输出日志插件，并让它们无缝的和 sudo 一起工作。默认的安全策略记录在 /etc/sudoers 文件中。而安全策略可能需要用户通过密码来验证他们自己。也就是在用户执行 sudo 命令时要求用户输入自己账号的密码。如果验证失败，sudo 命令将会退出。</p>
<p><strong>语法格式：</strong>sudo [参数]</p>
<p><strong>常用参数：</strong></p>
<table>
<thead>
<tr>
<th>-v</th>
<th>因为 sudo 在第一次执行时或是在 N分钟内没有执行（N 预设为五）会问密码，这个参数是重新做一次确认，如果超过N分钟，也会问密码</th>
</tr>
</thead>
<tbody><tr>
<td>-k</td>
<td>强迫使用者在下一次执行 sudo 时问密码（不论有没有超过 N 分钟）</td>
</tr>
<tr>
<td>-b</td>
<td>将要执行的指令放在背景执行</td>
</tr>
<tr>
<td>-p</td>
<td>prompt 可以更改问密码的提示语，其中 %u 会代换为使用者的帐号名称，%h 会显示主机名称</td>
</tr>
<tr>
<td>-s</td>
<td>执行环境变数中的SHELL 所指定的shell ，或是 /etc/passwd 里所指定的 shell</td>
</tr>
<tr>
<td>command</td>
<td>要以系统管理者身份（或以 -u 更改为其他人）执行的指令</td>
</tr>
</tbody></table>
</li>
</ul>
<p>例如我们要切换到root用户，需要使用命令<code>sudo su</code></p>
<h2 id="一个小插曲——如何在ubuntu中启用中英文输入法"><a href="#一个小插曲——如何在ubuntu中启用中英文输入法" class="headerlink" title="一个小插曲——如何在ubuntu中启用中英文输入法"></a>一个小插曲——如何在ubuntu中启用中英文输入法</h2><p>按照<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45797116/article/details/114260047">这一篇教程</a>安装搜狗输入法的linux版本，并进行相关配置。</p>
<p>当我们在linux桌面系统的终端或编辑器中启用输入的时候，只要记得右上角linux图标点击切换输入法即可。</p>
<p>当我们在Linux系统启用搜狗输入法时，记得用”shift”键切换中英文即可，对于大写的启用键与windows系统中一致。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://justskim.github.io.git/2021/09/27/%E5%9C%A8vmware%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85vmware-tools/" data-id="ckzcw3wz20009roudh9jlg4bz" data-title="在vmware中实现共享文件夹以及安装vmware-tools" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ubuntu/" rel="tag">ubuntu</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vmware/" rel="tag">vmware</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag">虚拟机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-在linux系统创建父子进程及相关操作" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/26/%E5%9C%A8linux%E7%B3%BB%E7%BB%9F%E5%88%9B%E5%BB%BA%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/" class="article-date">
  <time class="dt-published" datetime="2021-09-26T02:16:56.153Z" itemprop="datePublished">2021-09-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/26/%E5%9C%A8linux%E7%B3%BB%E7%BB%9F%E5%88%9B%E5%BB%BA%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/">在linux系统创建父子进程及相关操作</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="在linux系统创建父子进程及相关操作"><a href="#在linux系统创建父子进程及相关操作" class="headerlink" title="在linux系统创建父子进程及相关操作"></a>在linux系统创建父子进程及相关操作</h1><h2 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h2><p><code>fork</code>这一词，在英文中有两个意思：</p>
<ul>
<li>n. 叉(挖掘用的园艺工具); 餐叉; (道路、河流等的)分岔处; 岔路;</li>
<li>v. 分岔出分支，走岔路中的一条。</li>
</ul>
<p><em>fork</em>函数是基本上只在Linux环境中会使用到的C语言函数，在使用时需要调用<code>unistd.h</code>这个头文件，我们在Linux环境下举例讲解<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/586300fdb1ce">C语言的fork()函数</a>用法：</p>
<blockquote>
<p>一个进程，包括代码、数据和分配给进程的资源。fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。</p>
<p><strong>一个进程调用fork（）函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。</strong></p>
<p>由<strong>fork函数创建的新进程</strong>被称为<strong>子进程</strong>。fork函数<strong>被调用一次</strong>，但是<strong>返回两次</strong>。父进程返回的值是<strong>新进程的进程ID</strong>，而子进程返回的值是0。</p>
<h4 id="fork函数返回值的三种情况"><a href="#fork函数返回值的三种情况" class="headerlink" title="fork函数返回值的三种情况"></a>fork函数返回值的三种情况</h4><ul>
<li>返回<strong>子进程标识符，即PID</strong>给父进程（在父进程中，fork返回新创建子进程的进程ID）<ul>
<li>因为一个进程的子进程可能有多个，并且<strong>没有一个函数可以获得一个进程的所有子进程ID</strong>。</li>
</ul>
</li>
<li>返回0给子进程（在子进程中，fork返回值为0）<ul>
<li>一个进程只会有一个父进程，所以子进程总是可以调用<strong>getpid</strong>以获得<strong>当前进程Id</strong>以及调用<strong>getppid</strong>获得<strong>父进程Id</strong>.</li>
</ul>
</li>
<li>出现错误，返回负值<ul>
<li>当前进程数已经达到系统规定的上限，这时errno的值被设置为EAGAIN</li>
<li>系统内存不足，这时errno的值被设置为ENOMEM</li>
</ul>
</li>
</ul>
<p>创建新进程成功后，系统中出现两个基本完全相同的进程，这两个进程执行没有固定的先后顺序，哪个进程先执行要看系统的进程调度策略</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wangww631/article/details/78413815">更加形象的解释</a>：</p>
<blockquote>
<p>“ 其实就相当于<strong>链表</strong>，进程形成了链表，<strong>父进程的fork函数返回的值指向子进程的进程id</strong>, 因为<strong>子进程没有子进程</strong>，所以其<strong>fork函数返回的值为0</strong> .</p>
<pre><code>调用fork之后，数据、堆、栈有两份，代码仍然为一份但是这个代码段成为两个进程的共享代码段都从fork函数中返回。当父子进程有一个想要修改数据或者堆栈时，两个进程真正分裂。
</code></pre>
</blockquote>
<p>注意！子进程代码是<strong>从fork处开始执行</strong>的， 为什么不是从<code>#include</code>处开始复制代码的？这是因为fork是把 <strong>进程当前的情况拷贝一份</strong> ，执行fork时，进程已经执行完了int count=0;fork只拷贝下一个要执行的代码到新的进程。</p>
<h2 id="fork函数被调用一次，返回两次，详解"><a href="#fork函数被调用一次，返回两次，详解" class="headerlink" title="fork函数被调用一次，返回两次，详解"></a>fork函数被调用一次，返回两次，详解</h2><p>来自<a target="_blank" rel="noopener" href="https://blog.csdn.net/jason314/article/details/5640969">这篇博客的例子</a>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span>	<span class="comment">//引入pid_t类型的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">pid_t</span> fpid; <span class="comment">//fpid表示fork函数返回的值</span></span><br><span class="line">	<span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">	fpid=fork(); </span><br><span class="line">	<span class="keyword">if</span> (fpid &lt; <span class="number">0</span>) </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;error in fork!&quot;</span>); <span class="comment">//fork函数返回的第一种情况，为负数，错误处理</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (fpid == <span class="number">0</span>) &#123;		<span class="comment">//fork函数返回的第二种情况，在子进程中返回0</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;i am the child process, my process id is %d/n&quot;</span>,getpid()); </span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;					<span class="comment">//fork函数返回的第三种情况，在父进程中，fork返回新创建子进程的进程ID</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;i am the parent process, my process id is %d/n&quot;</span>,getpid());</span><br><span class="line">        <span class="comment">//这里因为已经在父进程中了，getpid()函数返回的是当前进程（elseif语句中进程的父进程）的进程ID</span></span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;统计结果是: %d/n&quot;</span>,count);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后运行的结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i am the child process, my process id is 5574</span><br><span class="line">统计结果是: 1</span><br><span class="line">i am the parent process, my process id is 5573</span><br><span class="line">统计结果是: 1</span><br></pre></td></tr></table></figure>

<p>借用一张图解释一下<strong>为什么同一个if else语句会执行两次，并且count的值为1而不是2</strong>：</p>
<p><img src="E:\JS练习\blog\Myblog\source\images\fork中的父子进程.jpg"></p>
<p>上面的代码都是位于语句<code>fpid=fork()</code>之后，进程1的变量为<code>count=0，fpid！=0（父进程）</code>。进程2的变量为<code>count=0，fpid=0（子进程）</code>，这两个进程的变量都是独立的，存在不同的地址中，不是共用的，这点要注意。可以说，我们就是通过<code>fpid</code>来识别和操作父子进程的。<br> 如果疑惑为什么不是从<code>#include</code>处开始复制代码的，这是因为fork是把进程当前的情况拷贝一份，执行fork时，进程已经执行完了<code>int count=0;</code>，正如我们上面所说的，<strong>子进程代码</strong>是<strong>从fork处开始执行</strong>的，fork只拷贝下一个要执行的代码到新的进程。</p>
<p>所以，其实执行的是两个if…else语句，输出的两个count也不是同一个。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;i son/pa ppid pid  fpid/n&quot;</span>);<span class="comment">//打印表头</span></span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">       <span class="keyword">pid_t</span> fpid=fork();</span><br><span class="line">       <span class="keyword">if</span>(fpid==<span class="number">0</span>)</span><br><span class="line">    	   <span class="built_in">printf</span>(<span class="string">&quot;%d child  %4d %4d %4d/n&quot;</span>,i,getppid(),getpid(),fpid);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">    	   <span class="built_in">printf</span>(<span class="string">&quot;%d parent %4d %4d %4d/n&quot;</span>,i,getppid(),getpid(),fpid);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">    i son/pa ppid pid  fpid</span></span><br><span class="line"><span class="comment">    0 parent 2043 3224 3225     这里是最开始的那个父进程id3224，它的ppid2043我们不用管</span></span><br><span class="line"><span class="comment">    0 child  3224 3225    0		子进程3225的ppid是父进程的pid</span></span><br><span class="line"><span class="comment">    1 parent 2043 3224 3226		仍然是父进程id3224，又用fork创建了一个子进程3226</span></span><br><span class="line"><span class="comment">    1 parent 3224 3225 3227		在这里fork返回了子进程3225创建的孙子进程3227</span></span><br><span class="line"><span class="comment">    1 child     1 3227    0</span></span><br><span class="line"><span class="comment">    1 child     1 3226    0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>从上面，我们可以看到，每次都是先执行父进程中的语句，再执行子进程中拷贝的代码语句，正如博主所说：</p>
<blockquote>
<ol>
<li>第一步：在父进程中，指令执行到for循环中，i=0，接着执行fork，fork执行完后，系统中出现两个进程，分别是p3224和p3225（后面我都用pxxxx表示进程id为xxxx的进程）。可以看到父进程p3224的父进程是p2043，子进程p3225的父进程正好是p3224。我们用一个链表来表示这个关系：<br> <code>p2043-&gt;p3224-&gt;p3225</code><br> 第一次fork后，p3224（父进程）的变量为i=0，fpid=3225（fork函数在父进程中返向子进程id）<br> p3225（子进程）的变量为i=0，fpid=0（fork函数在子进程中返回0），打印出结果：<br> 0 parent 2043 3224 3225<br> 0 child  3224 3225    0</li>
<li>第二步：假设父进程p3224先执行，当进入下一个循环时，i=1，接着执行fork，系统中又新增一个进程p3226，对于此时的父进程，p2043-&gt;p3224（当前进程）-&gt;p3226（被创建的子进程）。<br> 对于子进程p3225，执行完第一次循环后，i=1，接着执行fork，系统中新增一个进程p3227，对于此进程，p3224-&gt;p3225（当前进程）-&gt;p3227（被创建的子进程）。从输出可以看到p3225原来是p3224的子进程，现在变成p3227的父进程。父子是相对的，这个大家应该容易理解。只要当前进程执行了fork，该进程就变成了父进程了，就打印出了parent。<br> 所以打印出结果是：<br> 1 parent 2043 3224 3226<br> 1 parent 3224 3225 3227 </li>
<li>第三步：第二步创建了两个进程p3226，p3227，这两个进程执行完printf函数后就结束了，因为这两个进程无法进入第三次循环，无法fork，该执行return 0;了，其他进程也是如此。<br> 以下是p3226，p3227打印出的结果：<br> 1 child     1 3227    0<br> 1 child     1 3226    0</li>
<li> 细心的读者可能注意到p3226，p3227的父进程难道不该是p3224和p3225吗，怎么会是1呢？这里得讲到进程的创建和死亡的过程，在p3224和p3225执行完第二个循环后，main函数就该退出了，也即进程该死亡了，因为它已经做完所有事情了。p3224和p3225死亡后，p3226，p3227就没有父进程了，这在操作系统是不被允许的，所以p3226，p3227的父进程就被置为p1了，p1是永远不会死亡的，至于为什么，这里先不介绍。</li>
</ol>
</blockquote>
<p><img src="E:\JS练习\blog\Myblog\source\images\fork中的父子进程2.jpg" alt="fork中的父子进程进阶"></p>
<p>最后，用博主的这段打印祖孙三代关系的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">       <span class="keyword">pid_t</span> fpid=fork();</span><br><span class="line">       <span class="keyword">if</span>(fpid==<span class="number">0</span>)</span><br><span class="line">    	   <span class="built_in">printf</span>(<span class="string">&quot;son/n&quot;</span>);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">    	   <span class="built_in">printf</span>(<span class="string">&quot;father/n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    for        i=0         1           2</span></span><br><span class="line"><span class="comment">              father     father     father</span></span><br><span class="line"><span class="comment">                                        son</span></span><br><span class="line"><span class="comment">                            son       father</span></span><br><span class="line"><span class="comment">                                        son</span></span><br><span class="line"><span class="comment">               son       father     father</span></span><br><span class="line"><span class="comment">                                        son</span></span><br><span class="line"><span class="comment">                            son       father</span></span><br><span class="line"><span class="comment">                                        son</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="pid-t类型"><a href="#pid-t类型" class="headerlink" title="pid_t类型"></a>pid_t类型</h2><p>pid_t类型是Linux下的<strong>进程号类型</strong>，在Linux环境编程中用于定义进程ID，需要引入头文件<code>&lt;sys/types.h&gt;</code>，否则会报错：<code>error:&#39;pid_t&#39; was not declared in this  scope</code>。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/shanshu12/article/details/7896331">使用fork函数时，为什么使用pid_t而不用int</a>:</p>
<blockquote>
<p>pid_t是一个typedef定义类型，<br>sys/types.h中的定义:<br>typedef short       pid_t;     /* used for process ids */</p>
<p>pid_t就是一个short类型变量，实际表示的是内核中的进程表的索引</p>
<p>可以看到，头文件里也不过是个typedef而已.<br>使用pid_t而不使用int只是为了可移植性好一些.<br>因为在不同的平台上有可能这么定义：<br><code>typedef int pid_t</code><br>也有可能：<br><code>typedef long pid_t</code></p>
</blockquote>
<p>但是，在和fork函数配合使用时，由于进程很多时，fork函数返回的pid_t类型的子进程id，可能长度超过了int类型，需要用long int类型来存储，这时候就使用pid_t来存储子进程PID比较便于使用和移植。</p>
<h2 id="PID-PPID-PGID与SID"><a href="#PID-PPID-PGID与SID" class="headerlink" title="PID PPID PGID与SID"></a>PID PPID PGID与SID</h2><p>详见<a target="_blank" rel="noopener" href="https://blog.csdn.net/Justdoit123_/article/details/101347971">博客</a>，在Linux中，进程都拥有以下的ID</p>
<ul>
<li><strong>Process ID</strong>(<strong>PID</strong>，也称之为<strong>进程标识</strong>)<br>Linux中标识进程的一个数字，它的值是不确定的，是由系统分配的（但是有一个例外，启动阶段,kernel运行的第一个进程是init，它的PID是1，是所有进程的最原始的父进程），每个进程都有唯一PID，当进程退出运行之后，PID就会回收，可能之后创建的进程会分配这个PID</li>
<li><strong>Parent</strong> Process ID(<strong>P</strong>PID)<br>字面意思，父进程的PID</li>
<li>Process <strong>Group</strong> ID(P<strong>G</strong>ID)<br>PGID就是进程所属的Group的Leader的PID，如果PGID=PID，那么该进程是Group Leader</li>
<li><strong>Session</strong> ID(<strong>S</strong>ID)<br>和PGID非常相似，SID就是进程所属的Session Leader的PID，如果SID==PID，那么该进程是session leader</li>
</ul>
<blockquote>
<p>Session和Group都是管理多个进程的方式，同一个Group的进程属于同一个Session，一个Session里可以包含多个Group</p>
</blockquote>
<p>注意，父进程也有<code>ppid</code>（爸爸的爸爸叫爷爷(～￣▽￣)～ ），<code>ppid</code>为<code>1</code>的进程被称之为<strong>僵尸进程</strong>，这是因为<code>linux</code>下有3个特殊的进程，<code>idle</code>进程(<code>PID = 0</code>), <code>init</code>进程(<code>PID = 1</code>)和<code>kthreadd(PID = 2</code>)。</p>
<p>在<code>terminal</code>中使用默认的ps命令输出的信息值包括和当前终端会话相关的进程信息，自然看不到<code>id</code>很短的进程：</p>
<p><img src="E:\JS练习\blog\Myblog\source\images\默认ps命令.png" alt="使用ps命令"></p>
<p>我们可以使用命令<code>ps --help</code>获取帮助，然后使用命令<code>ps -A</code>或<code>ps -e</code>来获取全部进程（all process）<br>![查看全部进程](E:\JS练习\blog\Myblog\source\images\ps -A命令.png)</p>
<h2 id="getpid和getppid函数，与fork函数产生的pid"><a href="#getpid和getppid函数，与fork函数产生的pid" class="headerlink" title="getpid和getppid函数，与fork函数产生的pid"></a>getpid和getppid函数，与fork函数产生的pid</h2><p><code>getpid</code>返回当前进程标识（也就是<code>PID</code>），<code>getppid</code>返回当前进程的父进程标识，使用这两个函数需要引入头文件<code>&lt;unistd.h&gt;</code>。</p>
<blockquote>
<p>每个进程都有一个独特（互不相同）的进程标识符（<code>process ID</code>），可以通过<code>getpid()</code>函数获得，还有一个记录父进程<code>pid</code>的变量，可以通过<code>getppid()</code>函数获得变量的值。</p>
</blockquote>
<p>这两个函数<strong>在调用中都不能返回错误</strong>，注意，返回值的<code>pid_t</code>类型 能够放进 int类型中去，返回值被转为<code>long</code> 整型输出。</p>
<p>！！注意，我们常用到命令<code>pid_t pid = fork()</code>产生的<code>pid</code>根据所处分支是在子进程还是在父进程而具有不同的值，同时要注意，这个<code>pid</code>的值，是<code>getpid()</code>返回的进程id刚创建的子进程<code>id</code>（没有则为0），从祖宗关系上，是<code>getppid()</code>返回的id所属的进程的孙子进程的<code>id</code>，例如下面这一段代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fencha</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">    fencha(<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fencha</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid = fork;</span><br><span class="line">    <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">&quot;ERROR\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;num)</span><br><span class="line">            fencha(i+<span class="number">1</span>,num);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;现在在父进程中&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;由fork函数产生的pid是 %d,&quot;</span>,pid)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;用getpid函数获取的值为%d，用getppid函数获取的值为%d\n&quot;</span>,getpid(),getppid());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到代码结果如下，这是一个十层的子进程递归创建，祖宗总共十代：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意，在上面的代码中，我们使用了sleep()函数，这是为了确保在子进程代码运行的过程中，父进程不会执行完所有代码而被内核释放掉所有资源，如果我们不使用sleep函数，如下面的代码，会导致<strong>孤儿进程（没有父进程的进程，那么照顾他的重任就落到了init进程身上）</strong>的产生。</p>
<p>想想看，为什么我们的代码已经执行完毕，但是id为6666的进程依然可以在ps命令中被查询到，tty为一个问号?说明该进程不是通过tty/console启动，自然与终端terminal无关。</p>
<h3 id="孤儿进程与僵尸进程"><a href="#孤儿进程与僵尸进程" class="headerlink" title="孤儿进程与僵尸进程"></a>孤儿进程与僵尸进程</h3><p>这篇博客中提到了一个区别：</p>
<p><strong>孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</strong></p>
<p><strong>僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</strong></p>
<p>值得注意的是，照顾孤儿进程的进程id在不同版本的Linux系统中是不一样的，笔者所用的ubuntu16.04版本中由id为6666的进程负责收养孤儿进程。</p>
<p>虽然孤儿进程并没有危害，<strong>任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。</strong>这是每个 子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。  如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://justskim.github.io.git/2021/09/26/%E5%9C%A8linux%E7%B3%BB%E7%BB%9F%E5%88%9B%E5%BB%BA%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/" data-id="cku13vu0y0003bsudgz178u8s" data-title="在linux系统创建父子进程及相关操作" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c%E8%AF%AD%E8%A8%80/" rel="tag">c语言</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ubuntu/" rel="tag">ubuntu</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag">虚拟机</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BF%9B%E7%A8%8B/" rel="tag">进程</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Data-analysis/">Data analysis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Diary/">Diary</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Diary/life/">life</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Git/Github/">Github</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/Git%E6%8A%A5%E9%94%99%E5%A4%84%E7%90%86/">Git报错处理</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MarkDown/">MarkDown</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/MarkDown/typora%E7%9A%84%E7%89%B9%E6%AE%8A%E4%BD%BF%E7%94%A8/">typora的特殊使用</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mysql/">Mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Programming-languages-and-projects/">Programming languages and projects</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Programming-languages-and-projects/JavaScript/">JavaScript</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Programming-languages-and-projects/JavaScript/Nodejs/">Nodejs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Programming-languages-and-projects/JavaScript/Vue/">Vue</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Programming-languages-and-projects/JavaScript/web/">web</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Programming-languages-and-projects/Python3/">Python3</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Programming-languages-and-projects/Python3/PYQT5/">PYQT5</a></li></ul></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/anaconda/" rel="tag">anaconda</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/browser/" rel="tag">browser</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c%E8%AF%AD%E8%A8%80/" rel="tag">c语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/debug/" rel="tag">debug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ejs/" rel="tag">ejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/express/" rel="tag">express</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gui/" rel="tag">gui</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/llife/" rel="tag">llife</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/markdown/" rel="tag">markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nodejs/" rel="tag">nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/package/" rel="tag">package</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python3/" rel="tag">python3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/router/" rel="tag">router</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scipy/" rel="tag">scipy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/store/" rel="tag">store</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typora/" rel="tag">typora</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ubuntu/" rel="tag">ubuntu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vmware/" rel="tag">vmware</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue-cli/" rel="tag">vue-cli</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web/" rel="tag">web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E5%85%A8%E8%AF%81%E4%B9%A6/" rel="tag">安全证书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" rel="tag">数据分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/" rel="tag">数据存储</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag">虚拟机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%9B%E7%A8%8B/" rel="tag">进程</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/anaconda/" style="font-size: 10px;">anaconda</a> <a href="/tags/browser/" style="font-size: 10px;">browser</a> <a href="/tags/c%E8%AF%AD%E8%A8%80/" style="font-size: 11.43px;">c语言</a> <a href="/tags/debug/" style="font-size: 11.43px;">debug</a> <a href="/tags/ejs/" style="font-size: 10px;">ejs</a> <a href="/tags/express/" style="font-size: 10px;">express</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/gui/" style="font-size: 18.57px;">gui</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/http/" style="font-size: 11.43px;">http</a> <a href="/tags/linux/" style="font-size: 17.14px;">linux</a> <a href="/tags/llife/" style="font-size: 10px;">llife</a> <a href="/tags/markdown/" style="font-size: 11.43px;">markdown</a> <a href="/tags/mysql/" style="font-size: 11.43px;">mysql</a> <a href="/tags/nodejs/" style="font-size: 12.86px;">nodejs</a> <a href="/tags/package/" style="font-size: 11.43px;">package</a> <a href="/tags/python/" style="font-size: 11.43px;">python</a> <a href="/tags/python3/" style="font-size: 20px;">python3</a> <a href="/tags/router/" style="font-size: 10px;">router</a> <a href="/tags/scipy/" style="font-size: 11.43px;">scipy</a> <a href="/tags/store/" style="font-size: 10px;">store</a> <a href="/tags/typora/" style="font-size: 11.43px;">typora</a> <a href="/tags/ubuntu/" style="font-size: 15.71px;">ubuntu</a> <a href="/tags/vmware/" style="font-size: 14.29px;">vmware</a> <a href="/tags/vue/" style="font-size: 11.43px;">vue</a> <a href="/tags/vue-cli/" style="font-size: 11.43px;">vue-cli</a> <a href="/tags/web/" style="font-size: 10px;">web</a> <a href="/tags/webpack/" style="font-size: 10px;">webpack</a> <a href="/tags/%E5%AE%89%E5%85%A8%E8%AF%81%E4%B9%A6/" style="font-size: 10px;">安全证书</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" style="font-size: 11.43px;">数据分析</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/" style="font-size: 11.43px;">数据存储</a> <a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 15.71px;">虚拟机</a> <a href="/tags/%E8%BF%9B%E7%A8%8B/" style="font-size: 10px;">进程</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/02/08/win10%E4%B8%8A%E7%9A%84%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE%E4%B8%8E127.0.0.1/">win10上的代理服务器设置与127.0.0.1</a>
          </li>
        
          <li>
            <a href="/2021/11/16/%E5%9C%A8vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5/">在vmware虚拟机中进行网络连接</a>
          </li>
        
          <li>
            <a href="/2021/11/09/python3%E4%B8%AD%E7%9A%84%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4%E4%B8%8E%E7%8E%AF%E5%A2%83/">python3中的运行命令与环境</a>
          </li>
        
          <li>
            <a href="/2021/11/03/python3%E4%B8%AD%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/">python3中的生成器与迭代器</a>
          </li>
        
          <li>
            <a href="/2021/10/31/python3%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E8%AF%AD%E6%B3%95%E7%B3%96/">python3中的一些常见语法糖整理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 JustSkim<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>